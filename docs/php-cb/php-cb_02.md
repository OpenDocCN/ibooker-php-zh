# 第二章：运算符

虽然 第一章 介绍了 PHP 的基础构建模块——用于存储任意值的变量，但是这些构建模块如果没有某种粘合剂来将它们连接在一起将毫无用处。这个粘合剂就是 PHP 确立的 [*运算符*](https://oreil.ly/Vepfg) 集合。运算符是告诉 PHP 如何处理特定值的方式——具体来说是如何将一个或多个值转换为新的、离散的值。

在几乎所有情况下，PHP 中的运算符都由单个字符或重复使用该字符来表示。在少数情况下，运算符也可以用文字的英文单词来表示，这有助于消除运算符试图实现的功能的歧义。

本书并不试图覆盖 PHP 利用的每一个运算符；关于每个运算符的详尽解释，请参阅[PHP 手册本身](https://oreil.ly/YGWyE)。相反，接下来的几节将介绍一些最重要的逻辑、位和比较运算符，然后深入探讨更具体的问题、解决方案和示例。

## 逻辑运算符

*逻辑操作* 是 PHP 中创建真值表并定义基本的与/或/非分组条件的组成部分。表 2-1 枚举了 PHP 支持的所有基于字符的逻辑运算符。

表 2-1\. 逻辑运算符

| 表达式 | 运算符名称 | 结果 | 示例 |
| --- | --- | --- | --- |
| $x && $y | and | 如果 `$x` 和 `$y` 都为 `true`，则为 `true` | `true && true == true` |
| $x &#124;&#124; $y | or | 如果 `$x` 或 `$y` 有一个为 `true`，则为 `true` | `true &#124;&#124; false == true` |
| !$x | not | 如果 `$x` 为 `false`，则为 `true`（反之亦然） | `!true == false` |

逻辑运算符 `&&` 和 `||` 有其英文单词对应形式：分别是 `and` 和 `or`。语句 `($x and $y)` 在功能上等同于 `($x && $y)`。单词 `or` 同样可以用来替代 `||` 运算符，而不会改变表达式的功能。

单词 `xor` 也可以用来表示 PHP 中的特殊 *异或* 运算符，如果表达式中的两个值中有一个为 `true`，则结果为 `true`，但当两者都为 `true` 时结果为 `false`。不幸的是，逻辑异或操作在 PHP 中没有字符等效项。

## 位运算符

PHP 支持对整数进行特定位的操作，这一特性使得该语言非常灵活。支持位运算意味着 PHP 不仅仅局限于 Web 应用程序，而是可以轻松地在二进制文件和数据结构上进行操作！值得一提的是，这些运算符与 `and`、`or` 和 `xor` 在术语上看起来有些相似，因此将它们放在前面逻辑运算符的同一节中是合理的。

而逻辑运算符基于两个整数值之间的比较返回`true`或`false`，位运算符实际上对整数执行位运算，并返回提供的整数或整数的完整计算结果。关于这可以如何有用的具体示例，请跳转至配方 2.6。

表 2-2 展示了 PHP 中各种位运算符的功能，以及它们在简单整数上的快速示例。

表 2-2\. 位运算符

| 表达式 | 运算符名称 | 结果 | 示例 |
| --- | --- | --- | --- |
| `$x & $y` | 与 | 返回同时在`$x`和`$y`中设置的位 | `5 & 1 == 1` |
| `$x &#124; $y` | 或 | 返回在`$x`或`$y`中设置的位 | `4 &#124; 1 == 5` |
| `$x ^ $y` | 异或 | 返回仅在`$x`或`$y`中设置的位 | `5 ^ 3 == 6` |
| `~ $x` | 非 | 反转`$x`中被设置的位 | `~ 4 == -5` |
| `$x << $y` | 左移 | 将`$x`的位向左移动`$y`步 | `4 << 2 == 16` |
| `$x >> $y` | 右移 | 将`$x`的位向右移动`$y`步 | `4 >> 2 == 1` |

在 PHP 中，您可以拥有的最大整数取决于运行应用程序的处理器大小。在任何情况下，常量`PHP_INT_MAX`将告诉您整数可以有多大——在 32 位机器上为 2147483647，在 64 位机器上为 9223372036854775807。在这两种情况下，这个数字以二进制表示，长长的是比位大小少一位的 1。在 32 位机器上，2147483647 由 31 个 1 表示。前导位（默认为 0）用于标识整数的*符号*。如果位为`0`，整数为正数；如果位为`1`，整数为负数。

在任何机器上，数字 4 的二进制表示为`100`，左边有足够的 0 填充处理器的位大小。在 32 位系统上，这将是 29 个 0。要使整数为*负数*，您应该将其表示为 1 后跟 28 个 0，再跟`100`。

简单起见，考虑一个 16 位系统。整数 4 表示为`0000000000000100`。同样，负数 4 表示为`1000000000000100`。如果在 16 位系统中对正数 4 应用位非运算符(`~`)，所有的 0 将变成 1，反之亦然。这将把你的数字变成`1111111111111011`，在 16 位系统中表示为−5。

## 比较运算符

任何编程语言的核心是语言根据特定条件进行分支控制的能力。在 PHP 中，许多分支逻辑是通过比较两个或更多值来控制的。这是由 PHP 提供的[比较运算符](https://oreil.ly/QuPhV)，提供了用于构建复杂应用程序的大多数高级分支功能。

表 2-3 列出了被认为是最重要的 PHP 标量比较运算符。其他运算符（大于、小于和变体）在编程语言中有些标准，并且对本章中的任何配方都不是必需的。

表 2-3\. 比较运算符

| 表达式 | 操作 | 结果 |
| --- | --- | --- |
| `$x == $y` | 相等 | 如果两个值在强制转换为相同类型后相同则返回`true` |
| `$x === $y` | 相同 | 如果两个值相同且类型相同则返回`true` |
| `$x <=> $y` | 太空船 | 如果两个值相等则返回`0`，如果`$x`大则返回`1`，如果`$y`大则返回`-1` |

在处理对象时，相等性和身份运算符的工作方式略有不同。如果两个对象具有相同的内部结构（相同的属性和值）并且是相同类型（类），则认为它们相等（`==`）。仅当它们是对同一个类实例的引用时，才认为对象是相同的（`===`）。这些要求比比较标量值的要求更严格。

## 类型转换

虽然类型的名称在形式上不是运算符，但您可以使用它来将一个值明确转换为该类型。只需在值之前的括号中写入类型的名称，即可强制转换。示例 2-1 在使用该值之前将一个简单的整数值转换为各种其他类型。

##### 示例 2-1\. 将值转换为其他类型

```php
$value = 1;

$bool = (bool) $value;
$float = (float) $value;
$string = (string) $value;

var_dump([$bool, $float, $string]);

// array(3) {
//   [0]=>
//   bool(true)
//   [1]=>
//   float(1)
//   [2]=>
//   string(1) "1"
// }
```

PHP 支持以下类型转换：

`(整数)`

转换为`整数`

`(布尔)`

转换为`布尔`

`(浮点数)`

转换为`浮点数`

`(字符串)`

转换为`字符串`

`(数组)`

转换为`数组`

`(对象)`

转换为`对象`

也可以使用`(整数)`作为`(int)`的别名，`(布尔)`作为`(bool)`的别名，`(实数)`或`(双精度)`作为`(float)`的别名，`(二进制)`作为`(字符串)`的别名。这些别名将执行与前面列表中相同的类型转换，但由于它们不使用您要转换的类型的名称，因此不建议使用这种方法。

本章中的配方介绍了如何利用 PHP 最重要的比较和逻辑运算符。

# 2.1 使用三元运算符代替 if-else 块

## 问题

您希望在一行代码中提供一个二选一的分支条件，以将特定值分配给一个变量。

## 解决方案

使用*三元运算符*(`*a* ? *b* : *c*`)允许在一个语句中嵌套一个二选一条件和两个可能的分支值。以下示例展示了如何定义一个变量，其值来自`$_GET`超全局变量，并在为空时返回默认值：

```php
$username = isset($_GET['username']) ? $_GET['username'] : 'default';
```

## 讨论

三元表达式有三个参数，并从左到右进行评估，检查最左侧语句的*真值*（不考虑表达式中涉及的类型）并返回`true`时的下一个值，或者`false`时的最终值。您可以通过以下图示来可视化这种逻辑流程：

```php
$_value_ = (_expression to evaluate_) ? (if true) : (if false);
```

三元模式是在检查系统值或来自 Web 请求的参数时返回默认值的简单方法（这些存储在`$_GET`或`$_POST`超全局变量中）。它还是基于特定函数调用的页面模板中切换逻辑的强大方法。

以下示例假设一个 Web 应用程序，通过姓名欢迎已登录用户（通过调用`is_logged_in()`检查其认证状态）或者欢迎未经验证的访客。由于此示例直接编码到 Web 页面的 HTML 标记中，使用更长的`if`/`else`语句将不合适：

```php
<h1>Welcome, <?php echo is_logged_in() ? $_SESSION['user'] : 'Guest'; ?>!</h1>
```

如果正在检查的值既是*真值*（在强制转换为布尔值时评估为`true`）又是您默认希望的值，则可以简化三元操作。解决方案示例检查用户名是否已设置，并在这种情况下将该值分配给给定变量。由于非空字符串会评估为`true`，因此可以将解决方案缩短为以下形式：

```php
$username = $_GET['username'] ?: 'default';
```

当将一个三元缩短为简单的`*a* ?: *c*`格式时，PHP 将评估表达式以检查`*a*`是否为布尔值。如果为真，则 PHP 仅返回表达式本身。如果为假，则 PHP 返回替代值`*c*`。

###### 注意

PHP 类似于空值比较地比较真值，正如在第一章中所讨论的那样。已设置的字符串（非空或`null`）、非零整数和非空数组通常都被认为是真值，这意味着它们在布尔转换时会评估为`true`。您可以在[PHP 手册类型比较部分](https://oreil.ly/nXsr8)中了解更多关于类型混合和等价判定的信息。

三元运算符是一种高级的比较运算符，尽管它提供了简洁的代码，但有时会被过度使用，以至于创建的逻辑过于复杂难以理解。考虑嵌套一个三元操作在另一个中的示例 2-2。

##### 示例 2-2\. 嵌套三元表达式

```php
$val = isset($_GET['username']) ? $_GET['username'] : (isset($_GET['userid'])
       ? $_GET['user_id'] : null);
```

此示例应重写为一个简单的`if`/`else`语句，以提供更清晰的代码分支信息。代码*功能上*没有问题，但嵌套的三元操作可能难以阅读或理解，并且往往会在日后导致逻辑错误。前面的三元操作可以重写如示例 2-3 所示：

##### 示例 2-3\. 多个`if/else`语句

```php
if (isset($_GET['username'])) {
    $val = $_GET['username'];
} elseif (isset($_GET['userid'])) {
    $val = $_GET['userid'];
} else {
    $val = null;
}
```

尽管示例 2-3 比示例 2-2 更冗长，但你可以更轻松地跟踪逻辑分支的位置。代码也更易于维护，因为可以在必要时添加新的逻辑分支。向示例 2-2 添加另一个逻辑分支将进一步复杂化已经复杂的三元操作符，并使长期维护程序变得更加困难。

## 参见

文档关于[三元运算符](https://oreil.ly/Y5WCn)及其变体。

# 2.2 合并潜在的空值

## 问题

如果要仅在变量设置且不为`null`时为其分配特定值，否则使用静态默认值。

## 解决方案

使用空值合并运算符（`??`）如下，仅在设置并且不为`null`时使用第一个值：

```php
$username = $_GET['username'] ?? 'not logged in';
```

## 讨论

PHP 的空值合并运算符是 PHP 7.0 引入的新功能。它被称为*语法糖*，用于替换 PHP 的三元运算符简写形式 `?:`，详见配方 2.1。

###### 注意

*语法糖* 是指在代码中执行常见且冗长操作的简写。语言的开发人员引入这些功能是为了节省击键，并通过更简单、更简洁的语法呈现常见但经常重复的代码块。

下面两行代码在功能上是等效的，但三元形式在评估表达式未定义时将触发一个通知：

```php
$a = $b ?: $c;
$a = $b ?? $c;
```

尽管这两个前述示例在*功能上*相同，但在评估值（`$b`）未定义时，它们的行为有显著差异。使用空值合并运算符，一切都很完美。而使用三元简写形式，在执行过程中，PHP 会触发一个通知，表明在返回回退值之前该值未定义。

对于离散变量，这些运算符的不同功能并不完全明显，但当评估组件是一个索引数组时，潜在影响就显得更加明显了。假设，与离散变量不同，你正在尝试从超全局变量 `$_GET` 中提取一个元素，该变量保存请求参数。在下面的例子中，三元运算符和空值合并运算符都将返回回退值，但三元版本会抱怨未定义的索引：

```php
$username = $_GET['username'] ?? 'anonymous';
$username = $_GET['username'] ?: 'anonymous'; // Notice: undefined index ...
```

如果在执行过程中抑制了错误和通知，¹ 那么在这两种操作符选项之间就没有功能上的区别。然而，最佳实践是避免编写会触发错误或通知的代码，因为这些可能会在生产中意外引发警报，或者可能会填充系统日志，并使查找代码的真正问题更加困难。虽然简写的三元运算符非常有用，但空值合并运算符是专门用于这种操作的，几乎总是应该使用它。

## 参见

新操作符的公告，[当它首次添加到 PHP 7.0 中时](https://oreil.ly/6vmP_)。

# 2.3 比较相同值

## 问题

您想要比较两个相同类型的值以确保它们是相同的。

## 解决方案

使用三个等号来比较值，而不会动态转换它们的类型：

```php
if ($a === $b) {
    // ...
}
```

## 讨论

在 PHP 中，等号有三个功能。单个等号（`=`）用于*赋值*，即设置变量的值。两个等号（`==`）在表达式中用于确定两侧的值是否相等。表 2-4 展示了由于 PHP 在评估语句时将一个类型强制转换为另一个类型，因此某些值被视为相等。最后，三个等号（`===`）在表达式中用于确定两侧的值是否*完全相同*。

表 2-4\. PHP 中的值相等性

| 表达式 | 结果 | 解释 |
| --- | --- | --- |
| `0 == "a"` | `false` | （仅适用于 PHP 8.0 及以上）字符串`"a"`被转换为整数，这意味着它被转换为`0`。 |
| `"1" == "01"` | `true` | 表达式两侧都被转换为整数，`1 == 1`。 |
| `100 = "1e2`" | `true` | 表达式右侧被评估为`100`的指数形式，并转换为整数。 |

###### 注意

表 2-4 中的第一个示例在 PHP 版本低于 8.0 时评估为`true`。在这些早期版本中，比较字符串（或数值字符串）与数字会首先将字符串转换为数字（在本例中，将`"a"`转换为`0`）。PHP 8.0 中此行为已更改，现在只有数值字符串会被转换为数字，因此第一个表达式的结果现在是`false`。

PHP 在运行时动态转换类型的能力可能很有用，但在某些情况下，这并不是您希望发生的。布尔字面值`false`被一些方法返回以表示错误或失败，而整数`0`可能是函数的有效返回。考虑函数示例 2-4，它返回特定类别书籍的计数，或者如果连接到包含这些数据的数据库失败，则返回`false`。

##### 示例 2-4\. 计算数据库中的项或返回`false`

```php
function count_books_of_type($category)
{
    $sql = "SELECT COUNT(*) FROM books WHERE category = :category";

    try {
        $dbh = new PDO(DB_CONNECTION_STRING, DB_LOGIN, DB_PASS);
        $statement = $dbh->prepare($sql);

        $statement->execute(array(':category' => $category));
        return $statement->fetchColumn();
    } catch (PDOException $e) {
        return false;
    }
}
```

如果示例 2-4 中的一切按预期运行，那么代码将返回一个特定类别中书籍数量的整数计数。示例 2-5 可能利用此函数在网页上打印标题。

##### 示例 2-5\. 使用与数据库绑定函数的结果

```php
$books_found = count_books_of_type('fiction');

switch ($books_found) {
    case 0:
        echo 'No fiction books found';
        break;
    case 1:
        echo 'Found one fiction book';
        break;
    default:
        echo 'Found ' . $books_found . ' fiction books';
}
```

在内部，PHP 的`switch`语句使用宽松类型比较（我们的`==`操作符）。如果`count_books_of_type()`返回`false`而不是实际结果，此`switch`语句将打印出未找到虚构书籍，而不是报告错误。在这种特定用例中，这可能是可接受的行为——但是当您的应用程序需要反映`false`和`0`之间的实质性差异时，宽松相等比较是不够的。

PHP 允许使用*三个*等号（`===`）来检查评估中的两个值是否相同——即它们是相同的值和相同的类型。即使整数`5`和字符串`"5"`具有相同的值，评估`5 === "5"`将导致`false`，因为这两个值不是相同的类型。因此，虽然`0 == false`评估为`true`，`0 === false`将始终评估为`false`。

###### 警告

在处理对象时，确定两个值是否相同变得更加复杂，无论是使用自定义类定义还是 PHP 提供的类。对于两个对象`$obj1`和`$obj2`，只有当它们实际上是同一个类的*实例*时，它们才会被评估为相同。有关对象实例化和类的更多信息，请参阅第八章。

## 另请参阅

PHP 关于[比较运算符](https://oreil.ly/T6GXm)的文档。

# 2.4 使用宇宙飞船操作符排序值

## 问题

您想要提供一个自定义排序函数，以通过[PHP 的原生`usort()`](https://oreil.ly/xGbc9)对任意对象列表进行排序。

## 解决方案

假设您要按照对象列表的多个属性进行排序，可以使用 PHP 的宇宙飞船操作符（`<=>`）定义自定义排序函数，并将其作为回调提供给`usort()`。

考虑为您的应用程序中的人员提供以下类定义，允许只使用名字和姓氏创建记录：

```php
class Person {
    public $firstName;
    public $lastName;

    public function __construct($first, $last)
    {
        $this->firstName = $first;
        $this->lastName = $last;
    }
};
```

您可以使用此类创建人员列表，例如美国总统，并依次将每个人添加到您的列表中，就像示例 2-6 中所示。

##### 示例 2-6\. 向列表添加多个对象实例

```php
$presidents = [];

$presidents[] = new Person('George', 'Washington');
$presidents[] = new Person('John', 'Adams');
$presidents[] = new Person('Thomas', 'Jefferson');
// ...
$presidents[] = new Person('Barack', 'Obama');
$presidents[] = new Person('Donald', 'Trump');
$presidents[] = new Person('Joseph', 'Biden');
```

假设您想按姓氏首先，然后按名字排序数据，您可以利用宇宙飞船操作符来实现，如示例 2-7 所示。

##### 示例 2-7\. 使用宇宙飞船操作符对总统进行排序

```php
function presidential_sorter($left, $right)
{
    return [$left->lastName, $left->firstName]
        <=>
        [$right->lastName, $right->firstName];
}

usort($presidents, 'presidential_sorter');
```

调用`usort()`之前的结果是，`$presidents`数组将正确地原地排序并准备就绪。

## 讨论

宇宙飞船操作符是 PHP 7.0 的特殊添加，有助于确定其两侧值之间的关系：

+   如果第一个值小于第二个值，则表达式评估为`-1`。

+   如果第一个值大于第二个值，则表达式评估为`+1`。

+   如果两个值相同，则表达式评估为`0`。

###### 注意

类似于 PHP 的等号操作符，太空船操作符会尝试将比较中每个值的类型强制转换为相同类型。支持一个值为数字，另一个值为字符串，并获得有效结果是可能的。在使用这种特殊操作符进行类型强制转换时，需要注意风险。

太空船操作符最简单的用法是将简单类型相互比较，这使得对简单数组或原始值列表（如字符、整数、浮点数或日期）进行排序变得容易。如果使用`usort()`，则需要像下面这样的排序函数：

```php
function sorter($a, $b) {
    return ($a < $b) ? -1 : (($a > $b) ? 1 : 0);
}
```

太空船操作符通过完全用`return $a <=> $b`替换前面代码中的嵌套三元运算符的`return`语句，但不改变排序函数的功能。

更复杂的示例，如解决方案中用于基于自定义对象定义的多个属性进行排序，将需要相当冗长的排序函数定义。太空船操作符简化了比较逻辑，使开发人员能够在一行代码中指定复杂的逻辑。

## 参见

[PHP 太空船操作符的原始 RFC](https://oreil.ly/O1X8R)。

# 2.5 使用操作符抑制诊断错误

## 问题

您希望显式忽略或抑制应用程序中特定表达式触发的错误。

## 解决方案

在表达式前加上`@`操作符可临时将错误报告级别设置为 0，用于屏蔽与直接尝试打开丢失文件相关的错误，例如下面的示例：

```php
$fp = @fopen('file_that_does_not_exist.txt', 'r');
```

## 讨论

解决方案示例尝试打开不存在的文件*file_that_does_not_exist.txt*进行读取。在正常操作中，调用`fopen()`会因为文件不存在而返回`false`，同时为了诊断问题会发出 PHP 警告。在表达式前加上`@`操作符不会改变返回值，但会完全抑制发出的警告。

###### 警告

`@`操作符会抑制应用于其之后的代码行的错误报告。如果开发人员试图在`include`语句上抑制错误，他们将很容易隐藏由于包含的文件不存在（或访问控制不当）而导致的任何警告、通知或错误。抑制还会应用于包含文件内的所有代码行，这意味着包含代码中的任何错误（包括语法相关或其他）都将被忽略。因此，虽然`@include('some-file.php')`是完全有效的代码，但应避免在`include`语句上抑制错误！

这种特定的操作符在抑制文件访问操作中的错误或警告时非常有用（如示例中的解决方案）。在数组访问操作中抑制通知同样有用，比如下面的情况，其中请求中可能未设置特定的`GET`参数：

```php
$filename = @$_GET['filename'];
```

如果设置了请求的`filename`查询参数，则`$filename`变量将被设置为其值。否则，它将是字面量`null`。如果开发人员省略`@`操作符，则`$filename`的值仍将是`null`，但 PHP 将发出通知，指出数组中不存在`filename`索引。

自[PHP 8.0](https://oreil.ly/4Ec5B)起，此运算符将不再抑制 PHP 中的*致命*错误，否则会停止脚本执行。

## 参见

PHP 官方文档中关于[错误控制操作符](https://oreil.ly/bZkLY)的详细信息。

# 2.6 比较整数中的位

## 问题

您希望在应用程序中使用简单的标志来标识状态和行为，其中一个成员可能应用了多个标志。

## 解决方案

使用[位掩码](https://oreil.ly/aevr7)来指定可用的标志，并在后续标志上使用位操作符来确定哪些标志已设置。以下示例通过使用每个标志的整数二进制表示来定义四个离散标志，并将它们组合以指示*同时*设置了多个标志。然后使用 PHP 的位操作符来确定哪个标志被设置，并执行相应的条件逻辑分支：

```php
const FLAG_A = 0b0001; // 1
const FLAG_B = 0b0010; // 2
const FLAG_C = 0b0100; // 4
const FLAG_D = 0b1000; // 8

// Set a composite flag for an application
$application = FLAG_A | FLAG_B; // 0b0011 or 3

// Set a composite flag for a user
$user = FLAG_B | FLAG_C | FLAG_D; // 0b1110 or 14

// Switch based on the user's applied flags
if ($user & FLAG_B) {
    // ...
} else {
    // ...
}
```

## 讨论

位掩码通过将每个标志配置为常量整数的 2 的幂来构造。这样做的好处是在二进制表示中仅设置一个位，从而通过设置哪些位来识别组合标志。在解决方案示例中，每个标志都明确写成二进制数字，以说明哪些位被设置为（`1`），哪些位未设置为（`0`），在行尾还有同一个数字的整数表示。

我们例子中的`FLAG_B`是整数 2，其二进制表示为`0010`（第三位被设置）。同样，`FLAG_C`是整数 4，其二进制表示为`0100`（第二位被设置）。要指定*两个*标志都被设置，您将两者相加以设置第二位和第三位：`0110`或整数 6。

对于这个特定的例子，加法是一个容易记住的模型，但并不完全符合实际情况。要组合标志，您只需组合已设置的位，而不一定要将它们加在一起。将`FLAG_A`与其自身组合应该仅产生*仅有的* `FLAG_A`；将整数表示（1）与自身相加会完全改变标志的含义。

不要使用加法，而要使用位操作符*或*（`|`）和*与*（`&`）来同时组合位并筛选分配的标志。将两个标志组合在一起需要使用`|`运算符创建一个新的整数，其中包含要使用的任一标志中设置的位。请参考表 2-5 以创建`FLAG_A | FLAG_C`的组合。

表 2-5\. 使用位或组合的复合二进制标志

| 标志 | 二进制表示 | 整数表示 |
| --- | --- | --- |
| `FLAG_A` | `0001` | `1` |
| `FLAG_C` | `0100` | `4` |
| `FLAG_A &#124; FLAG_C` | `0101` | `5` |

然后需要使用`&`运算符比较复合标志与您的定义，它返回一个新数字，该数字在操作的两侧都设置了位。将标志与自身比较将始终返回 1，在条件检查中强制类型转换为`true`。比较具有任何相同位的两个值将返回一个大于 0 的值，这在条件检查中也将被强制类型转换为`true`。考虑在表 2-6 中评估`FLAG_A & FLAG_C`的简单情况。

表 2-6\. 使用按位*与*组合的复合二进制标志

| 标志 | 二进制表示 | 整数表示 |
| --- | --- | --- |
| `FLAG_A` | `0001` | `1` |
| `FLAG_C` | `0100` | `4` |
| `FLAG_A & FLAG_C` | `0000` | `0` |

您可以构建复合值然后将其与您的标志集进行比较，而不是将基元标志相互比较。以下示例演示了用于发布新闻文章的内容管理系统的基于角色的访问控制。用户可以查看文章、创建文章、编辑文章或删除文章；他们的访问级别由程序本身和授予其用户帐户的权限确定：

```php
const VIEW_ARTICLES   = 0b0001;
const CREATE_ARTICLES = 0b0010;
const EDIT_ARTICLES   = 0b0100;
const DELETE_ARTICLES = 0b1000;
```

典型的匿名访客将永远不会被登录，因此将被授予默认权限以查看内容。登录用户可能能够创建文章，但没有编辑权限的情况下不能编辑它们。同样，编辑人员可以审核和修改内容（或删除），但不能独立创建文章。最后，管理员可能被允许做任何事情。每个角色都是从前面的权限基元组合而成：

```php
const ROLE_ANONYMOUS = VIEW_ARTICLES;
const ROLE_AUTHOR    = VIEW_ARTICLES | CREATE_ARTICLES;
const ROLE_EDITOR    = VIEW_ARTICLES | EDIT_ARTICLES | DELETE_ARTICLES;
const ROLE_ADMIN     = VIEW_ARTICLES | CREATE_ARTICLES | EDIT_ARTICLES
                       | DELETE_ARTICLES;
```

一旦从基元权限定义了复合角色，应用程序就可以围绕检查用户的活动角色构建逻辑。虽然权限是使用`|`运算符组合在一起的，但`&`运算符将允许您基于这些标志进行切换，正如在示例 2-8 中定义的函数所示。

##### 示例 2-8\. 利用位掩码标志进行访问控制

```php
function get_article($article_id)
{
    $role = get_user_role();

    if ($role & VIEW_ARTICLES) {
        // ...
    } else {
        throw new UnauthorizedException();
    }
}

function create_article($content)
{
    $role = get_user_role();

    if ($role & CREATE_ARTICLES) {
        // ...
    } else {
        throw new UnauthorizedException();
    }
}

function edit_article($article_id, $content)
{
    $role = get_user_role();

    if ($role & EDIT_ARTICLES) {
        // ...
    } else {
        throw new UnauthorizedException();
    }
}

function delete_article($article_id)
{
    $role = get_user_role();

    if ($role & DELETE_ARTICLES) {
        // ...
    } else {
        throw new UnauthorizedException();
    }
}
```

位掩码是在任何语言中实现简单标志的强大方式。不过，如果计划增加所需标志的数量，请小心，因为每个新标志表示的是 2 的次方，这意味着所有标志的值会迅速增长。然而，位掩码在 PHP 应用程序和语言本身中广泛使用。PHP 的自身错误报告设置在第十二章中进一步讨论，利用位操作值来识别引擎本身使用的错误报告级别。

## 参见

PHP 文档关于[位运算符](https://oreil.ly/JmF85)。

¹ 长篇讨论错误处理和抑制错误、警告和通知在第十二章中进行。
