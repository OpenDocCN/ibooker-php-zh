- en: Chapter 16\. JavaScript Functions, Objects, and Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 16 章\. JavaScript 函数、对象和数组
- en: Just like PHP, JavaScript offers access to functions and objects. In fact, JavaScript
    is actually based on objects, because—as you’ve seen—it has to access the DOM,
    which makes every element of an HTML document available to manipulate as an object.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 PHP 一样，JavaScript 提供了访问函数和对象的方法。事实上，JavaScript 实际上是基于对象的，因为——正如你已经看到的——它必须访问
    DOM，这使得 HTML 文档的每个元素都可以作为一个对象进行操作。
- en: The usage and syntax are also quite similar to those of PHP, so you should feel
    right at home as I take you through using functions and objects in JavaScript,
    as well as through an in-depth exploration of array handling.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 使用和语法也与 PHP 非常相似，因此当我带你深入了解 JavaScript 中的函数和对象使用以及数组处理时，你应该会感到很自在。
- en: JavaScript Functions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 函数
- en: In addition to having access to dozens of built-in functions (or methods), such
    as `write`, which you have already seen being used in `document.write`, you can
    easily create your own functions. Whenever you have a relatively complex piece
    of code that is likely to be reused, you have a candidate for a function.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问数十个内置函数（或方法），如 `write`，你已经在 `document.write` 中看到它被使用，你还可以轻松创建自己的函数。每当你有一个可能会被重复使用的相对复杂的代码片段时，你就可以考虑创建一个函数。
- en: Defining a Function
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义函数
- en: 'The general syntax for a function is shown here:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的一般语法如下所示：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first line of the syntax indicates the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 语法的第一行指示以下内容：
- en: A definition starts with the word `function`.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义从 `function` 这个词开始。
- en: A name follows that must start with a letter or underscore, followed by any
    number of letters, digits, dollar signs, or underscores.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称必须以字母或下划线开头，后跟任意数量的字母、数字、美元符号或下划线。
- en: The parentheses are required.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号是必需的。
- en: One or more parameters, separated by commas, are optional (indicated by the
    square brackets, which are not part of the function syntax).
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选一个或多个用逗号分隔的参数（由方括号表示，不是函数语法的一部分）。
- en: 'Function names are case-sensitive, so all of the following strings refer to
    different functions: `getInput`, `GETINPUT`, and `getinput`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名区分大小写，因此以下所有字符串都指代不同的函数：`getInput`、`GETINPUT` 和 `getinput`。
- en: 'In JavaScript there is a general naming convention for functions: the first
    letter of each word in a name is capitalized, except for the very first letter,
    which is lowercase. Therefore, of the previous examples, `getInput` would be the
    preferred name used by most programmers. This convention is commonly referred
    to as *bumpyCaps*, *bumpyCase*, or (most frequently) *camelCase*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，函数有一个通用的命名约定：名称中每个单词的第一个字母大写，除了第一个字母外，其他字母都小写。因此，在前面的例子中，大多数程序员会选择使用
    `getInput` 作为首选名称。这种约定通常被称为 *bumpyCaps*、*bumpyCase* 或（最常见的）*camelCase*。
- en: The opening curly brace starts the statements that will execute when you call
    the function; a matching curly brace must close it. These statements may include
    one or more `return` statements, which force the function to cease execution and
    return to the calling code. If a value is attached to the `return` statement,
    the calling code can retrieve it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 大括号 `{` 开始定义函数调用时执行的语句；必须有相匹配的大括号 `}` 结束它。这些语句可能包括一个或多个 `return` 语句，它们强制函数停止执行并返回给调用代码。如果
    `return` 语句附带一个值，调用代码可以检索它。
- en: The `arguments` array
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`arguments` 数组'
- en: The `arguments` array is a member of every function. With it, you can determine
    the number of variables passed to a function and what they are. Take the example
    of a function called `displayItems`. [Example 16-1](#defining_a_function-id00087)
    shows one way of writing it.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments` 数组是每个函数的成员。借助它，你可以确定传递给函数的变量数量及其内容。以函数 `displayItems` 为例。[例子 16-1](#defining_a_function-id00087)
    展示了一种编写它的方式。'
- en: Example 16-1\. Defining a function
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 16-1\. 定义函数
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When you call up this script in your browser, it will display the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中调用这个脚本时，它将显示以下内容：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All of this is fine, but what if you wanted to pass more than five items to
    the function? Also, reusing the `document.write` call multiple times instead of
    employing a loop is wasteful programming. Luckily, the `arguments` array gives
    you the flexibility to handle a variable number of arguments. [Example 16-2](#modifying_the_function_to_use_the_argume)
    shows how you can use it to rewrite the previous example in a much more efficient
    manner.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都很好，但如果你想向函数传递超过五个项目会怎样？此外，多次重复使用`document.write`调用而不使用循环是一种浪费。幸运的是，`arguments`数组提供了灵活性，可以处理可变数量的参数。[示例 16-2](#modifying_the_function_to_use_the_argume)展示了如何以更高效的方式重写先前的示例。
- en: Example 16-2\. Modifying the function to use the `arguments` array
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-2\. 修改使用`arguments`数组的函数
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note the use of the `length` property, which you already encountered in the
    previous chapter, and also that I reference the array `displayItems.arguments`
    using the variable `j` as an offset into it. I also chose to keep the function
    short and sweet by not surrounding the contents of the `for` loop in curly braces,
    as it contains only a single statement. Remember that the loop must stop when
    `j` is one less than `length`, not equal to `length`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用了`length`属性，你已经在上一章中遇到过它，并且我使用变量`j`作为偏移量引用数组`displayItems.arguments`。我还选择通过不用花括号将`for`循环的内容包围起来来保持函数简短而简洁，因为它只包含一个语句。请记住，循环必须在`j`等于`length`之前停止，而不是等于`length`。
- en: Using this technique, you now have a function that can take as many (or as few)
    arguments as you like and act on each argument as you desire.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，你现在有一个函数，可以接受任意多（或少）的参数，并按照你的意愿对每个参数进行操作。
- en: Returning a Value
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回值
- en: Functions are not used just to display things. In fact, they are mostly used
    to perform calculations or data manipulations and then return a result. The function
    `fixNames` in [Example 16-3](#cleaning_up_a_full_name-id00089) uses the `arguments`
    array (discussed in the previous section) to take a series of strings passed to
    it and return them as a single string. The “fix” it performs is to convert every
    character in the arguments to lowercase except for the first character of each
    argument, which is set to a capital letter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不仅仅用于显示事物。事实上，它们主要用于进行计算或数据操作，然后返回结果。[示例 16-3](#cleaning_up_a_full_name-id00089)中的函数`fixNames`使用了`arguments`数组（在前一节中讨论过），接收传递给它的一系列字符串，并将它们返回为一个单一的字符串。它执行的“修复”操作是将每个参数中的每个字符转换为小写，除了每个参数的第一个字符，它设置为大写字母。
- en: Example 16-3\. Cleaning up a full name
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-3\. 清理完整名称
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When called with the parameters `the`, `DALLAS`, and `CowBoys`, for example,
    the function returns the string `The Dallas Cowboys`. Let’s walk through the function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当使用参数`the`、`DALLAS`和`CowBoys`调用时，该函数返回字符串`The Dallas Cowboys`。让我们来看看这个函数。
- en: It first initializes the temporary (and local) variable `s` to the empty string.
    Then a `for` loop iterates through each of the passed parameters, isolating the
    parameter’s first character using the `charAt` method and converting it to uppercase
    with the `toUpperCase` method. The various methods shown in this example are all
    built into JavaScript and available by default.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先将临时（和局部）变量`s`初始化为空字符串。然后，`for`循环遍历传递的每个参数，使用`charAt`方法隔离参数的第一个字符，并使用`toUpperCase`方法将其转换为大写。此示例中显示的各种方法都内置于JavaScript中，并默认可用。
- en: 'Then the `substr` method is used to fetch the rest of each string, which is
    converted to lowercase via the `toLowerCase` method. A fuller version of the `substr`
    method here would specify how many characters are part of the substring as a second
    argument:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`substr`方法获取每个字符串的其余部分，通过`toLowerCase`方法将其转换为小写。这里`substr`方法的更完整版本将指定作为第二个参数的子串的长度：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In other words, this `substr` method says, “Start with the character at position
    1 (the second character) and return the rest of the string (the length minus one).”
    As a nice touch, though, the `substr` method assumes that you want the rest of
    the string if you omit the second argument.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这个`substr`方法说，“从位置1（第二个字符）开始，并返回剩余的字符串（长度减一）。”尽管如此，`substr`方法会假定，如果你省略第二个参数，你希望返回剩余的字符串。
- en: After the whole argument is converted to our desired case, a space character
    is added to the end, and the result is appended to the temporary variable `s`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个参数转换为所需大小写之后，向末尾添加空格字符，并将结果追加到临时变量`s`。
- en: Finally, the `substr` method is used again to return the contents of the variable
    `s`, except for the final space—which is unwanted. We remove this by using `substr`
    to return the string up to, but not including, the final character.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，再次使用 `substr` 方法返回变量 `s` 的内容，除了最后一个不需要的空格。我们通过使用 `substr` 返回字符串直到最后一个字符之前来移除它。
- en: 'This example is particularly interesting in that it illustrates the use of
    multiple properties and methods in a single expression, for example:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子特别有趣，因为它展示了在单个表达式中使用多个属性和方法，例如：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You have to interpret the statement by mentally dividing it into parts at the
    periods. JavaScript evaluates these elements of the statement from left to right
    as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须在脑海中将该语句分成几个部分来解释。JavaScript 从左到右评估语句的这些元素如下：
- en: 'Start with the name of the function itself: `fixNames`.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数名称本身开始：`fixNames`。
- en: Extract element `j` from the array `arguments` representing `fixNames` arguments.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从代表 `fixNames` 参数的数组 `arguments` 中提取元素 `j`。
- en: Invoke `substr` with a parameter of `1` to the extracted element. This passes
    all but the first character to the next section of the expression.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `substr` 并使用参数 `1` 提取元素。这将除第一个字符外的所有内容传递给表达式的下一部分。
- en: Apply the method `toLowerCase` to the string that has been passed thus far.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对已传递的字符串应用 `toLowerCase` 方法。
- en: 'This practice is often referred to as *method chaining*. So, for example, if
    the string `mixedCASE` is passed to the example expression, it will go through
    the following transformations:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法通常被称为 *方法链*。例如，如果将字符串 `mixedCASE` 传递给示例表达式，它将经历以下转换：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In other words, `fixNames.arguments[j]` produces “mixedCASE”, then `substr(1)`
    takes “mixedCASE” and produces “ixedCASE”, and finally `toLowerCase()` takes “ixedCASE”
    and produces “ixedcase”.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，`fixNames.arguments[j]` 生成 “mixedCASE”，然后 `substr(1)` 获取 “mixedCASE” 并生成
    “ixedCASE”，最后 `toLowerCase()` 获取 “ixedCASE” 并生成 “ixedcase”。
- en: 'One final reminder: the `s` variable created inside the function is local and
    therefore cannot be accessed outside the function. By returning `s` in the `return`
    statement, we made its value available to the caller, which could store or use
    it any way it wanted. But `s` itself disappears at the end of the function. Although
    we could make a function operate on global variables (and sometimes that’s necessary),
    it’s much better to just return the values you want to preserve and let JavaScript
    clean up all the other variables used by the function.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后提醒一下：函数内部创建的 `s` 变量是局部的，因此无法在函数外部访问。通过在 `return` 语句中返回 `s`，我们使其值可以被调用者使用或存储。但是
    `s` 本身在函数结束时会消失。虽然我们可以让函数操作全局变量（有时是必要的），但最好的方法是只返回想要保留的值，并让 JavaScript 清理函数使用的所有其他变量。
- en: Returning an Array
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回一个数组
- en: In [Example 16-3](#cleaning_up_a_full_name-id00089), the function returned only
    one parameter—but what if you need to return multiple parameters? You can do this
    by returning an array, as in [Example 16-4](#returning_an_array_of_values).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 16-3](#cleaning_up_a_full_name-id00089) 中，该函数仅返回一个参数——但如果需要返回多个参数怎么办？您可以通过返回一个数组来实现，就像
    [示例 16-4](#returning_an_array_of_values) 中那样。
- en: Example 16-4\. Returning an array of values
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-4\. 返回一个值数组
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here the variable `words` is automatically defined as an array and populated
    with the returned result of a call to the function `fixNames`. Then a `for` loop
    iterates through the array and displays each member.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里变量 `words` 自动定义为数组，并用函数 `fixNames` 的返回结果填充。然后 `for` 循环迭代数组并显示每个成员。
- en: As for the `fixNames` function, it’s almost identical to [Example 16-3](#cleaning_up_a_full_name-id00089),
    except that the variable `s` is now an array; after each word has been processed,
    it is stored as an element of this array, which is returned by the `return` statement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 `fixNames` 函数，它与 [示例 16-3](#cleaning_up_a_full_name-id00089) 几乎完全相同，只是现在变量
    `s` 是一个数组；在处理每个单词后，它作为数组的一个元素存储，并通过 `return` 语句返回。
- en: 'This function enables the extraction of individual parameters from its returned
    values, like the following (the output from which is simply `The Cowboys`):'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许从其返回值中提取单个参数，例如下面的示例（其输出仅为 `The Cowboys`）：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: JavaScript Objects
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 对象
- en: A JavaScript object is a step up from a variable, which can contain only one
    value at a time. In contrast, objects can contain multiple values and even functions.
    An object groups data together with the functions needed to manipulate it.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript对象比变量更高级，变量一次只能包含一个值。相比之下，对象可以包含多个值，甚至函数。对象将数据与操作数据所需的函数组合在一起。
- en: Declaring a Class
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个类
- en: When creating a script to use objects, you need to design a composite of data
    and code called a *class*. Each new object based on this class is called an *instance*
    (or *occurrence*) of that class. As you’ve already seen, the data associated with
    an object is called its *properties*, while the functions it uses are called *methods*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建用于使用对象的脚本时，您需要设计称为*类*的数据和代码组合。基于此类的每个新对象称为该类的*实例*（或*发生*）。正如您已经看到的那样，与对象关联的数据称为其*属性*，而其使用的函数称为*方法*。
- en: Let’s look at how to declare the class for an object called `User` that will
    contain details about the current user. To create the class, just write a function
    named after the class. This function can accept arguments (I’ll show later how
    it’s invoked) and can create properties and methods for objects in that class.
    The function is called a *constructor*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何为称为`User`的对象声明类，该对象将包含有关当前用户的详细信息。要创建类，只需编写一个以类名命名的函数。此函数可以接受参数（稍后将展示如何调用它），并且可以为该类中的对象创建属性和方法。这个函数称为*构造函数*。
- en: '[Example 16-5](#declaring_the_user_class_and_its_method) shows a constructor
    for the class `User` with three properties: `forename`, `username`, and `password`.
    The class also defines the method `showUser`.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-5](#declaring_the_user_class_and_its_method) 显示了用于`User`类的构造函数，具有三个属性：`forename`、`username`和`password`。该类还定义了`showUser`方法。'
- en: Example 16-5\. Declaring the `User` class and its method
  id: totrans-63
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-5. 声明`User`类及其方法
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The function is different from other functions we’ve seen so far in several
    ways:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数在几个方面与我们迄今看到的其他函数不同：
- en: Each time the function is called, it creates a new object. Thus, you can call
    the same function over and over with different arguments to create users with
    different forenames, for example.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次调用函数时，它都会创建一个新对象。因此，您可以反复调用相同的函数并使用不同的参数来创建具有不同名字的用户，例如。
- en: The function refers to an object named `this`, which refers to the instance
    being created. As the example shows, the object uses the name `this` to set its
    own properties, which will be different from one `User` to another.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数引用一个名为`this`的对象，该对象引用正在创建的实例。如示例所示，对象使用名称`this`来设置自己的属性，这些属性将与另一个`User`不同。
- en: A new function named `showUser` is created within the function. The syntax shown
    here is new and rather complicated, but its purpose is to tie `showUser` to the
    `User` class. Thus, `showUser` comes into being as a method of the `User` class.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内创建了一个名为`showUser`的新函数。此处显示的语法是新的且相当复杂的，但其目的是将`showUser`与`User`类关联起来。因此，`showUser`作为`User`类的方法而存在。
- en: The naming convention I have used is to keep all properties in lowercase and
    to use at least one uppercase character in method names, following the camelCase
    convention mentioned earlier in the chapter.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用的命名约定是将所有属性保持为小写，并在方法名称中至少使用一个大写字符，遵循本章前面提到的驼峰命名约定。
- en: '[Example 16-5](#declaring_the_user_class_and_its_method) follows the recommended
    way to write a class constructor, which is to include methods in the constructor
    function. However, you can also refer to functions defined outside the constructor,
    as in [Example 16-6](#separately_defining_a_class_and_method).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-5](#declaring_the_user_class_and_its_method) 遵循编写类构造函数的推荐方式，即在构造函数中包含方法。但是，您还可以参考在构造函数外定义的函数，如[示例 16-6](#separately_defining_a_class_and_method)。'
- en: Example 16-6\. Separately defining a class and method
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-6. 分别定义类和方法
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I show you this form because you are certain to encounter it when perusing other
    programmers’ code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我向您展示这种形式，因为您在查看其他程序员的代码时一定会遇到它。
- en: Creating an Object
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'To create an instance of the class `User`, you can use a statement such as
    the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`User`类的实例，可以使用如下语句：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or you can create an empty object, like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以创建一个空对象，如下所示：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'and then populate it later, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后稍后再填充它，如下所示：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can also add new properties to an object, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以像这样向对象添加新属性：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can verify that adding such new properties works with the following statement:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以验证添加这种新属性是否有效，使用以下语句：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Accessing Objects
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问对象
- en: 'To access an object, you can refer to its properties, as in the following two
    unrelated example statements:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问对象，你可以引用其属性，如以下两个不相关的示例语句：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So, to access the `showUser` method of an object of class `User`, you would
    use the following syntax, in which the object `details` has already been created
    and populated with data:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要访问类`User`的对象的`showUser`方法，你将使用以下语法，其中对象`details`已经被创建并填充了数据：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Assuming the data supplied earlier, this code would display the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 假设之前提供的数据，这段代码将显示如下内容：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The prototype Keyword
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`prototype`关键字'
- en: 'The `prototype` keyword can save you a lot of memory. In the `User` class,
    every instance will contain the three properties and the method. Therefore, if
    you have one thousand of these objects in memory, the method `showUser` will also
    be replicated one thousand times. However, because the method is identical in
    every case, you can specify that new objects should refer to a single instance
    of the method instead of creating a copy of it. So, instead of using the following
    in a class constructor:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`prototype`关键字可以节省大量内存。在`User`类中，每个实例都包含三个属性和一个方法。因此，如果内存中有一千个这些对象，方法`showUser`也会被复制一千次。然而，因为方法在每种情况下都是相同的，你可以指定新对象应该引用方法的单个实例，而不是创建它的副本。因此，不要在类构造函数中使用以下内容：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'you could replace it with this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这个替换它：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[Example 16-7](#declaring_a_class_using_the_prototype_ke) shows what the new
    constructor would look like.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-7](#declaring_a_class_using_the_prototype_ke) 显示了新构造函数的样子。'
- en: Example 16-7\. Declaring a class using the `prototype` keyword for a method
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-7. 使用`prototype`关键字声明类的方法
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This works because all functions have a `prototype` property, designed to hold
    properties and methods that are not replicated in any objects created from a class.
    Instead, they are passed to its objects by reference.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为所有函数都有一个`prototype`属性，用于保存类中任何对象创建时不会复制的属性和方法。相反，它们通过引用传递给其对象。
- en: 'This means that you can add a `prototype` property or method at any time and
    all objects (even those already created) will inherit it, as the following statements
    illustrate:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以随时添加`prototype`属性或方法，并且所有对象（即使已经创建）都会继承它，如下面的语句所示：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The first statement adds the `prototype` property of `greeting` with a value
    of `Hello` to the class `User`. In the second line, the object `details`, which
    has already been created, correctly displays this new property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个语句将值为`Hello`的`greeting`属性添加到类`User`的`prototype`属性中。在第二行中，已经创建的对象`details`正确显示了这个新属性。
- en: 'You can also add to or modify methods in a class, as the following statements
    illustrate:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以添加或修改类中的方法，如下面的语句所示：
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You might add these lines to your script in a conditional statement (such as
    `if`), so they run if user activities cause you to decide you need a different
    `showUser` method. After these lines run, even if the object `details` has been
    created already, further calls to `details.showUser` will run the new function.
    The old definition of `showUser` has been erased.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在脚本中的条件语句（如`if`）中添加这些行，这样它们将在用户活动导致你需要不同的`showUser`方法时运行。这些行运行后，即使已经创建了对象`details`，对`details.showUser`的进一步调用也会运行新函数。旧的`showUser`定义已被擦除。
- en: Static methods and properties
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态方法和属性
- en: 'When reading about PHP objects, you learned that classes can have static properties
    and methods as well as properties and methods associated with a particular instance
    of a class. JavaScript also supports static properties and methods, which you
    can conveniently store and retrieve from the class’s `prototype`. Thus, the following
    statements set and read a static string from `User`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读关于 PHP 对象时，你学到了类不仅可以具有与类的特定实例相关联的静态属性和方法，还可以具有静态属性和方法。JavaScript 也支持静态属性和方法，你可以方便地从类的`prototype`中存储和检索它们。因此，以下语句设置并从`User`中读取静态字符串：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Extending JavaScript objects
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展 JavaScript 对象
- en: 'The `prototype` keyword even lets you add functionality to a built-in object.
    For example, suppose that you would like to add the ability to replace all spaces
    in a string with nonbreaking spaces in order to prevent it from wrapping around.
    You can do this by adding a prototype method to JavaScript’s default `String`
    object definition, like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`prototype`关键字甚至让你能够向内置对象添加功能。例如，假设你想要添加一个功能，将字符串中的所有空格替换为不换行空格以防止其换行。你可以通过向
    JavaScript 默认的`String`对象定义添加一个原型方法来实现这一点，就像这样：'
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here the `replace` method is used with a regular expression to find and replace
    all single spaces with the string `&nbsp;`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了`replace`方法和正则表达式来查找并替换所有单个空格为字符串`&nbsp;`。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you are not already familiar with regular expressions, they are a handy means
    of extracting information from or manipulating strings and are fully explained
    in [Chapter 17](ch17_split_000.xhtml#javascript_and_php_validation_and_error).
    Suffice it to say that for now, you can copy and paste the preceding examples
    and they will work as described, illustrating the power of extending JavaScript
    `String` objects.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还不熟悉正则表达式，它们是一种从字符串中提取信息或操作字符串的方便方法，并且在 [第 17 章](ch17_split_000.xhtml#javascript_and_php_validation_and_error)
    中有详细解释。总之，目前您可以复制并粘贴上述示例，并按描述的方式运行它们，展示了扩展 JavaScript `String` 对象的强大功能。
- en: 'If you then enter the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您输入以下命令：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'it will output the string `The&nbsp;quick&nbsp;brown&nbsp;fox`. Or here’s a
    method you can add that will trim leading and trailing spaces from a string (once
    again using a regular expression):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 它将输出字符串`The&nbsp;quick&nbsp;brown&nbsp;fox`。或者你可以添加一个方法，用来从字符串中删除前导和尾随空格（再次使用正则表达式）：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you issue the following statement, the output will be the string `Please
    trim me` (with the leading and trailing spaces removed):'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您发出以下语句，输出将是字符串`Please trim me`（删除了前导和尾随空格）：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If we break down the expression into its component parts, the two `/` characters
    mark the start and end of the expression, and the final `g` specifies a global
    search. Inside the expression, the `^\s+` part searches for one or more whitespace
    characters appearing at the start of the search string, while the `\s+$` part
    searches for one or more whitespace characters at the end of the search string.
    The `|` character in the middle acts to separate the alternatives.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将表达式分解为其组成部分，两个`/`字符标记了表达式的开始和结束，最后的`g`指定了全局搜索。在表达式内部，`^\s+`部分搜索出现在搜索字符串开头的一个或多个空白字符，而`\s+$`部分搜索出现在搜索字符串结尾的一个或多个空白字符。中间的`|`字符用于分隔替代项。
- en: The result is that when either of these expressions matches, the match is replaced
    with the empty string, thus returning a trimmed version of the string without
    any leading or trailing whitespace.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，当任何一个表达式匹配时，匹配项将被替换为空字符串，从而返回一个没有任何前导或尾随空白的修剪过的字符串版本。
- en: Warning
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'There is debate about whether extending objects is good or bad practice. Some
    programmers say that should an object later be extended to officially offer the
    functionality you have added, it could be implemented another way, or do something
    quite different to your extension, which could then cause a conflict. However,
    other programmers, such as the inventor of JavaScript, Brendan Eich, say that
    this is a perfectly acceptable practice. My take is to agree with the latter but
    in production code to choose extension names that are most unlikely to ever be
    officially used. So, for example, the `trim` extension could be renamed as `mytrim`,
    and the supporting code might more safely be written as the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 关于是否扩展对象是一种好还是坏的做法存在争议。一些程序员认为，如果稍后将对象扩展为正式提供您已添加的功能，可以以另一种方式实现，或者执行与您的扩展完全不同的操作，这可能会导致冲突。然而，其他程序员，如
    JavaScript 的发明者 Brendan Eich，认为这是完全可以接受的做法。我倾向于同意后者的观点，但在生产代码中选择最不可能被正式使用的扩展名称。例如，`trim`
    扩展可以重命名为 `mytrim`，支持代码可能更安全地编写如下：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: JavaScript Arrays
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 数组
- en: Array handling in JavaScript is very similar to PHP, although the syntax is
    a little different. Nevertheless, given all you have already learned about arrays,
    this section should be relatively straightforward for you.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 中的数组处理与 PHP 非常相似，尽管语法有些不同。尽管如此，鉴于您已经学到的关于数组的所有知识，这一部分对您来说应该相对简单。
- en: Numeric Arrays
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字数组
- en: 'To create a new array, use the following syntax:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新数组，请使用以下语法：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Or you can use the shorthand form, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以使用简写形式，如下所示：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Assigning element values
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分配元素值
- en: 'In PHP, you could add a new element to an array by simply assigning it without
    specifying the element offset, like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中，您可以通过简单地分配而不指定元素偏移来向数组添加新元素，如下所示：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But in JavaScript you use the `push` method to achieve the same thing, like
    this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但是在 JavaScript 中，您使用`push`方法来实现相同的操作，就像这样：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This allows you to keep adding items to an array without having to keep track
    of the number of items. When you need to know how many elements are in an array,
    you can use the `length` property, like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许您在不必跟踪项目数量的情况下继续向数组中添加项目。当您需要知道数组中有多少元素时，可以使用 `length` 属性，如下所示：
- en: '[PRE35]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Alternatively, if you wish to keep track of the element locations yourself
    and place them in specific locations, you can use syntax such as this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你希望自己跟踪元素的位置并将它们放在特定位置，可以使用以下语法：
- en: '[PRE36]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[Example 16-8](#creatingcomma_buildingcomma_and_printing) shows a simple script
    that creates an array, loads it with some values, and then displays them.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 16-8](#creatingcomma_buildingcomma_and_printing) 展示了创建数组、加载值和显示值的简单脚本。'
- en: Example 16-8\. Creating, building, and printing an array
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-8\. 创建、构建和打印一个数组
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output from this script is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出如下：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Assignment using the Array keyword
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `Array` 关键字赋值
- en: 'You can also create an array together with some initial elements by using the
    `Array` keyword, like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `Array` 关键字一起创建一个包含一些初始元素的数组，如下所示：
- en: '[PRE39]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There is nothing stopping you from adding more elements afterward as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么可以阻止您之后添加更多元素。
- en: You’ve now seen a couple of ways you can add items to an array, and one way
    of referencing them. JavaScript offers many more, which I’ll get to shortly—but
    first, we’ll look at another type of array.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经看到了可以向数组中添加项目的几种方式，以及引用它们的一种方式。JavaScript 提供了更多选项，我很快会介绍——但首先，我们将看看另一种类型的数组。
- en: Associative Arrays
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联数组
- en: An *associative array* is one in which the elements are referenced by name rather
    than by an integer offset. However, JavaScript doesn’t support such things. Instead,
    we can achieve the same result by creating an object with properties that will
    act the same way.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*关联数组* 是一种通过名称而不是整数偏移引用元素的数组。然而，JavaScript 不支持这样的事情。相反，我们可以通过创建具有相同功能的属性对象来实现相同的结果。'
- en: So, to create an “associative array,” define a block of elements within curly
    braces. For each element, place the key on the left and the contents on the right
    of a colon (`:`). [Example 16-9](#creating_and_displaying_an_associative_a) shows
    how you might create an associative array to hold the contents of the “balls”
    section of an online sports equipment retailer.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建一个“关联数组”，请在花括号内定义一个元素块。对于每个元素，将键放在冒号 (`:`) 的左侧，内容放在右侧。[示例 16-9](#creating_and_displaying_an_associative_a)
    展示了您可能创建一个关联数组来保存在线体育用品零售商“球”部分的内容。
- en: Example 16-9\. Creating and displaying an associative array
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-9\. 创建和显示一个关联数组
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: To verify that the array has been correctly created and populated, I have used
    another kind of `for` loop using the `in` keyword. This creates a new variable
    to use only within the array (`ball`, in this example) and iterates through all
    elements of the array to the right of the `in` keyword (`balls`, in this example).
    The loop acts on each element of `balls`, placing the key value into `ball`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证数组已经正确创建并填充，我使用了另一种使用 `for` 循环和 `in` 关键字的方式。这会创建一个新变量，仅在数组内部使用（在本例中是 `ball`），并迭代通过
    `in` 关键字右侧的数组所有元素（在本例中是 `balls`）。循环作用于 `balls` 的每个元素，将键值放入 `ball` 中。
- en: 'Using this key value stored in `ball`, you can also get the value of the current
    element of `balls`. The result of calling up the example script in a browser is
    as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用存储在 `ball` 中的键值，你还可以获取 `balls` 当前元素的值。在浏览器中调用示例脚本的结果如下：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To get a specific element of an associative array, you can specify a key explicitly,
    in the following manner (in this case, outputting the value `Soccer ball, 1`):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取关联数组的特定元素，可以明确指定键，如下所示（在这种情况下，输出值为 `Soccer ball, 1`）：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Multidimensional Arrays
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多维数组
- en: To create a multidimensional array in JavaScript, just place arrays inside other
    arrays. For example, to create an array to hold the details of a two-dimensional
    checkerboard (8 × 8 squares), you could use the code in [Example 16-10](#creating_a_multidimensional_nume-id00097).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 JavaScript 中创建一个多维数组，只需将数组放在其他数组中。例如，要创建一个包含二维棋盘（8 × 8 方格）详细信息的数组，您可以使用 [示例 16-10](#creating_a_multidimensional_nume-id00097)
    中的代码。
- en: Example 16-10\. Creating a multidimensional numeric array
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-10\. 创建一个多维数字数组
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, the lowercase letters represent black pieces, and the uppercase
    white. A pair of nested `for` loops walks through the array and displays its contents.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，小写字母代表黑色棋子，大写字母代表白色。一对嵌套的 `for` 循环遍历数组并显示其内容。
- en: 'The outer loop contains two statements, so curly braces enclose them. The inner
    loop then processes each square in a row, outputting the character at location
    `[j][k]`, followed by a space (to square up the printout). This loop contains
    a single statement, so curly braces are not required to enclose it. The `<pre>`
    and `</pre>` tags ensure that the output displays correctly, like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 外部循环包含两个语句，因此使用大括号将它们括起来。然后内部循环处理每一行中的每个方块，输出位置`[j][k]`处的字符，后跟一个空格（使输出对齐）。由于此循环只包含一个语句，因此不需要使用大括号将其括起来。使用`<pre>`和`</pre>`标签确保输出正确显示，如下所示：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also directly access any element within this array by using square
    brackets:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接使用方括号访问数组中的任何元素：
- en: '[PRE45]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This statement outputs the uppercase letter `O`, the eighth element down and
    the third along—remember that array indexes start at 0, not 1.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此语句输出大写字母`O`，从第八个元素开始，沿着第三个元素的位置—请记住数组索引从0开始，而不是1。
- en: Using Array Methods
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数组方法
- en: Given the power of arrays, JavaScript comes ready-made with a number of methods
    for manipulating them and their data. Here is a selection of the most useful ones.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于数组的强大功能，JavaScript内置了多种用于操作数组及其数据的方法。以下是其中几个最有用的方法。
- en: some
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: some
- en: 'When you need to know whether at least one array element matches a certain
    criterion, you can use the `some` function, which will test all the elements and
    automatically stop and return the required value as soon as one matches. This
    saves you from having to write your own code to perform such searches, like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要知道是否至少有一个数组元素与特定条件匹配时，可以使用`some`函数。该函数会测试所有元素，并在找到匹配的元素后自动停止并返回所需的值。这样可以避免编写自己的代码来执行此类搜索，如下所示：
- en: '[PRE46]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: indexOf
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: indexOf
- en: 'To find out where an element can be found in an array, you can call the `indexOf`
    function on the array, which will return the offset of the located element (starting
    from 0), or `-1` if it is not found. For example, the following gives `offset`
    the value `2`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要找出数组中元素的位置，可以在数组上调用`indexOf`函数，该函数将返回所定位元素的偏移量（从0开始），如果未找到则返回`-1`。例如，以下代码将`offset`赋值为`2`：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: concat
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: concat
- en: 'The `concat` method concatenates two arrays, or a series of values within an
    array. For example, the following code outputs `Banana,Grape,Carrot,Cabbage`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`concat`方法用于连接两个数组或数组内的一系列值。例如，以下代码输出`Banana,Grape,Carrot,Cabbage`：'
- en: '[PRE48]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can specify multiple arrays as arguments, in which case `concat` adds all
    their elements in the order that the arrays are specified.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将多个数组指定为参数，此时`concat`方法会按照数组指定的顺序添加所有元素。
- en: 'Here’s another way to use `concat`. This time, plain values are concatenated
    with the array `pets`, which outputs `Cat,Dog,Fish,Rabbit,Hamster`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一种使用`concat`的方法。此时，普通值与数组`pets`进行了连接，输出为`Cat,Dog,Fish,Rabbit,Hamster`：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: forEach
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: forEach
- en: The `forEach` method in JavaScript is another way of achieving functionality
    similar to the PHP `foreach` keyword. To use it, you pass it the name of a function,
    which will be called for each element within the array. [Example 16-11](#using_the_foreach_method)
    shows how.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript中的`forEach`方法是实现类似于PHP `foreach`关键字功能的另一种方式。要使用它，只需传递一个函数名，该函数将针对数组中的每个元素进行调用。[示例 16-11](#using_the_foreach_method)展示了如何使用它。
- en: Example 16-11\. Using the `forEach` method
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-11\. 使用`forEach`方法
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this case, the function passed to `forEach` is called `output`. It takes
    three parameters: the `element`, its `index`, and the `array`. These can be used
    as required by your function. This example displays just the `element` and `index`
    values using the function `document.write`.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，传递给`forEach`的函数称为`output`。它接受三个参数：`element`，其`index`，以及`array`。这些参数可以根据函数的需要使用。以下示例仅使用`document.write`函数显示`element`和`index`的值。
- en: 'Once an array has been populated, the method is called like this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数组被填充，就可以像这样调用方法：
- en: '[PRE51]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This is the output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出结果：
- en: '[PRE52]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: join
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: join
- en: With the `join` method, you can convert all the values in an array to strings
    and then join them together into one large string, placing an optional separator
    between them. [Example 16-12](#using_the_join_method) shows three ways of using
    this method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`join`方法，你可以将数组中的所有值转换为字符串，然后将它们连接成一个大字符串，在它们之间可以放置一个可选的分隔符。[示例 16-12](#using_the_join_method)展示了三种使用此方法的方式。
- en: Example 16-12\. Using the `join` method
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-12\. 使用`join`方法
- en: '[PRE53]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Without a parameter, `join` uses a comma to separate the elements; otherwise,
    the string passed to `join` is inserted between each element. The output of [Example 16-12](#using_the_join_method)
    looks like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有参数，`join`将使用逗号来分隔元素；否则，将插入到`join`中的字符串在每个元素之间插入。[示例 16-12](#using_the_join_method)的输出如下所示：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: push and pop
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: push和pop
- en: You already saw how the `push` method can be used to insert a value into an
    array. The inverse method is `pop`. It deletes the most recently inserted element
    from an array and returns it. [Example 16-13](#using_the_push_and_pop_methods)
    shows an example of its use.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到`push`方法如何用于向数组中插入值。其逆方法是`pop`。它从数组中删除最近插入的元素并返回它。[示例 16-13](#using_the_push_and_pop_methods)展示了其使用示例。
- en: Example 16-13\. Using the `push` and `pop` methods
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-13\. 使用`push`和`pop`方法
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The three main statements of this script are shown in bold type. First, the
    script creates an array called `sports` with three elements and then `push`es
    a fourth element into the array. After that, it `pop`s that element back off.
    In the process, the various current values are displayed via `document.write`.
    The script outputs the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的三个主要语句显示为粗体。首先，脚本创建了一个名为`sports`的数组，其中包含三个元素，然后向数组中`push`了第四个元素。随后，它将该元素`pop`出来。在此过程中，通过`document.write`显示了各种当前值。脚本输出如下：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `push` and `pop` functions are useful in situations where you need to divert
    from some activity to do another, and then return. For example, let’s suppose
    you want to put off some activities until later, while you get on with something
    more important now. This often happens in real life when we’re going through “to-do”
    lists, so let’s emulate that in code, with tasks number 2 and 5 in a list of six
    items being granted priority status, as in [Example 16-14](#using_push_and_pop_inside_and_outside_of).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`push`和`pop`函数在需要中断某些活动进行其他活动然后返回的情况下非常有用。例如，假设您想要将一些活动推迟到稍后，同时现在进行更重要的事情。这在我们处理“待办”清单时经常发生，所以让我们在代码中模拟这种情况，将六个项目列表中的第2和第5项赋予优先状态，如[示例 16-14](#using_push_and_pop_inside_and_outside_of)所示。'
- en: Example 16-14\. Using `push` and `pop` inside and outside of a loop
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-14\. 在循环内外使用`push`和`pop`
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Of course, nothing is actually getting processed here, just text being output
    to the browser, but you get the idea. The output from this example is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里实际上没有进行任何处理，只是将文本输出到浏览器，但您可以理解这个想法。此示例的输出如下：
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Using reverse
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用reverse
- en: The `reverse` method simply reverses the order of all elements in an array.
    [Example 16-15](#using_the_reverse_method) shows this in action.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse`方法简单地颠倒数组中所有元素的顺序。[示例 16-15](#using_the_reverse_method)展示了其工作原理。'
- en: Example 16-15\. Using the `reverse` method
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-15\. 使用`reverse`方法
- en: '[PRE59]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The original array is modified, and the output from this script is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数组被修改，此脚本的输出如下：
- en: '[PRE60]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: sort
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 排序
- en: With the `sort` method, you can place all the elements of an array in alphabetical
    order, depending on the parameters used. [Example 16-16](#using_the_sort_method)
    shows four types of sort.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sort`方法，您可以根据使用的参数将数组的所有元素按字母顺序排列。[示例 16-16](#using_the_sort_method)展示了四种排序类型。
- en: Example 16-16\. Using the `sort` method
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 16-16\. 使用`sort`方法
- en: '[PRE61]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first of the four example sections uses the default `sort` method to perform
    an *alphabetical sort*, while the second uses the default `sort` and then applies
    the `reverse` method to get a *reverse alphabetical sort*.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 四个示例部分中的第一个使用默认的`sort`方法执行*字母排序*，而第二个则使用默认的`sort`，然后应用`reverse`方法来获得*反向字母排序*。
- en: The third and fourth sections are a little more complicated; they use a function
    to compare the relationships between `a` and `b`. The function doesn’t have a
    name, because it’s used only in the sort. You have already seen the function named
    `function` used to create an anonymous function; we used it to define a method
    in a class (the `showUser` method).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第三和第四部分稍微复杂一些；它们使用一个函数来比较`a`和`b`之间的关系。该函数没有名称，因为它仅在排序中使用。您已经看到了名为`function`的函数用于创建匿名函数；我们用它来定义类中的方法（`showUser`方法）。
- en: Here, `function` creates an anonymous function meeting the needs of the `sort`
    method. If the function returns a value greater than zero, the sort assumes that
    `b` comes before `a`. If the function returns a value less than zero, the sort
    assumes that `a` comes before `b`. The sort runs this function across all the
    values in the array to determine their order. (Of course, if `a` and `b` have
    the same value, the function returns zero and it doesn’t matter which value is
    first.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`function` 创建了一个满足 `sort` 方法需求的匿名函数。如果函数返回大于零的值，则排序假定 `b` 在 `a` 之前。如果函数返回小于零的值，则排序假定
    `a` 在 `b` 之前。排序通过在数组的所有值上运行此函数来确定它们的顺序。（当然，如果 `a` 和 `b` 的值相同，函数返回零，先后顺序无关紧要。）
- en: By manipulating the value returned (`a – b` in contrast to `b - a`), the third
    and fourth sections of [Example 16-16](#using_the_sort_method) choose between
    an *ascending numerical sort* and a *descending numerical sort*.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过操作返回的值（`a - b` 与 `b - a` 相比），[示例 16-16](#using_the_sort_method) 的第三和第四部分选择
    *升序数值排序* 和 *降序数值排序*。
- en: And, believe it or not, this represents the end of your introduction to JavaScript.
    You should now have a core knowledge of the three main technologies covered in
    this book. The next chapter will look at some advanced techniques used across
    these technologies, such as pattern matching and input validation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这标志着你对 JavaScript 的介绍结束了。现在你应该掌握本书涵盖的三种主要技术的核心知识。下一章将讨论一些跨这些技术使用的高级技术，如模式匹配和输入验证。
- en: Questions
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Are JavaScript functions and variable names case-sensitive or case-insensitive?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 函数和变量名区分大小写吗？
- en: How can you write a function that accepts and processes an unlimited number
    of parameters?
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何编写一个接受和处理无限数量参数的函数？
- en: Name a way to return multiple values from a function.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出一个从函数返回多个值的方法。
- en: When you’re defining a class, what keyword do you use to refer to the current
    object?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在定义类时，用于引用当前对象的关键字是什么？
- en: Do all the methods of a class have to be defined within the class definition?
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类的所有方法是否都必须在类定义内部定义？
- en: What keyword is used to create an object?
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于创建对象的关键字是什么？
- en: How can you make a property or method available to all objects in a class without
    replicating the property or method within the object?
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使类中的所有对象都可以访问一个属性或方法，而无需在对象内部复制该属性或方法？
- en: How can you create a multidimensional array?
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建一个多维数组？
- en: What syntax is used to create an associative array?
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于创建关联数组的语法是什么？
- en: Write a statement to sort an array of numbers in descending numerical order.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个语句以按降序对数字数组进行排序。
- en: See [“Chapter 16 Answers”](app01_split_015.xhtml#chapter_16_answers) in the
    [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions) for the
    answers to these questions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[“第 16 章答案”](app01_split_015.xhtml#chapter_16_answers) 中的 [附录 A](app01_split_000.xhtml#solutions_to_the_chapter_questions)
    获取这些问题的答案。
