- en: Chapter 10\. Requests, Responses, and Middleware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章\. 请求、响应和中间件
- en: We’ve already talked a bit about the Illuminate `Request` object. In [Chapter 3](ch03.html#routing),
    for example, you saw how you can typehint it in constructors to get an instance
    or use the `request()` helper to retrieve it, and in [Chapter 7](ch07.html#collecting_and_handling_user_data)
    we looked at how you can use it to get information about the user’s input.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经谈论过Illuminate `Request`对象了。例如，在[第3章](ch03.html#routing)中，您看到如何在构造函数中使用类型提示来获取实例或使用`request()`助手来检索它，在[第7章](ch07.html#collecting_and_handling_user_data)中我们讨论了如何使用它来获取关于用户输入的信息。
- en: In this chapter, you’ll learn more about what the `Request` object is, how it’s
    generated, what it represents, and what part it plays in your application’s lifecycle.
    We’ll also talk about the `Response` object and Laravel’s implementation of the
    middleware pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将了解更多关于`Request`对象的信息，它是如何生成的，代表什么以及它在应用程序生命周期中扮演的角色。我们还将讨论`Response`对象以及Laravel对中间件模式的实现。
- en: Laravel’s Request Lifecycle
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel的请求生命周期
- en: Every request coming into a Laravel application, whether generated by an HTTP
    request or a command-line interaction, is immediately converted into an Illuminate
    `Request` object, which then crosses many layers and ends up being parsed by the
    application itself. The application then generates an Illuminate `Response` object,
    which is sent back out across those layers and finally returned to the end user.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进入Laravel应用程序的请求，无论是由HTTP请求还是命令行交互生成的，都会立即转换为Illuminate `Request`对象，然后跨越许多层并最终被应用程序本身解析。然后应用程序生成一个Illuminate
    `Response`对象，该对象通过这些层级返回并最终返回给最终用户。
- en: This request/response lifecycle is illustrated in [Figure 10-1](#FIG1001). Let’s
    take a look at what it takes to make each of these steps happen, from the first
    line of code to the last.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此请求/响应生命周期见图[10-1](#FIG1001)。让我们看看如何实现每一个步骤，从第一行代码到最后。
- en: '![lur3 1001](assets/lur3_1001.png)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![lur3 1001](assets/lur3_1001.png)'
- en: Figure 10-1\. Request/response lifecycle
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图10-1\. 请求/响应生命周期
- en: Bootstrapping the Application
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导应用程序
- en: Every Laravel application has some form of configuration set up at the web server
    level, in an Apache *.htaccess* file or an Nginx configuration setting or something
    similar, that captures every web request regardless of URL and routes it to *public/index.php*
    in the Laravel application directory.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Laravel应用程序都在Web服务器级别设置了某种形式的配置，在Apache的*.htaccess*文件或Nginx配置设置或类似的地方捕获每个Web请求，无论URL如何，并将其路由到Laravel应用程序目录中的*public/index.php*。
- en: '*index.php* doesn’t actually have that much code in it. It has three primary
    functions.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*index.php*实际上并没有那么多代码。它有三个主要功能。'
- en: First, it loads Composer’s autoload file, which registers all of the Composer-loaded
    dependencies.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它加载Composer的自动加载文件，注册所有由Composer加载的依赖项。
- en: Next, it kicks off Laravel’s bootstrap, creating the application container (you’ll
    learn more about the container in [Chapter 11](ch11.html#the_container)) and registering
    a few core services (including the kernel, which we’ll talk about in just a bit).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，它启动Laravel的引导过程，创建应用程序容器（您将在[第11章](ch11.html#the_container)中了解更多关于容器的信息），并注册一些核心服务（包括内核，我们马上会谈到）。
- en: Finally, it creates an instance of the kernel, creates a request representing
    the current user’s web request, and passes the request to the kernel to handle.
    The kernel responds with an Illuminate `Response` object, which *index.php* returns
    to the end user. Then, the kernel terminates the page request.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，它创建内核的一个实例，创建代表当前用户Web请求的请求，并将请求传递给内核进行处理。内核响应一个Illuminate `Response`对象，*index.php*将其返回给最终用户。然后，内核终止页面请求。
- en: The kernel is the core router of every Laravel application, responsible for
    taking in a user request, processing it through middleware, handling exceptions
    and passing it to the page router, and then returning the final response. Actually,
    there are two kernels, but only one is used for each page request. One of the
    routers handles web requests (the HTTP kernel), and the other handles console,
    cron, and Artisan requests (the console kernel). Each has a `handle()` method
    that’s responsible for taking in an Illuminate `Request` object and returning
    an Illuminate `Response` object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 内核是每个 Laravel 应用程序的核心路由器，负责接收用户请求，通过中间件处理它，处理异常并将其传递给页面路由器，然后返回最终响应。实际上，有两个内核，但每个页面请求只使用一个。一个路由器处理
    Web 请求（HTTP 内核），另一个处理控制台、定时任务和 Artisan 请求（控制台内核）。每个都有一个`handle()`方法，负责接收 Illuminate
    `Request`对象并返回 Illuminate `Response`对象。
- en: The kernel runs all of the bootstraps that need to run before every request,
    including determining which environment the current request is running in (staging,
    local, production, etc.) and running all of the service providers. The HTTP kernel
    additionally defines the list of middleware that will wrap each request, including
    the core middleware responsible for sessions and CSRF protection.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 内核运行所有在每个请求之前需要运行的引导，包括确定当前请求运行的环境（测试、本地、生产等），以及运行所有服务提供商。HTTP 内核还定义了将包装每个请求的中间件列表，包括负责会话和
    CSRF 保护的核心中间件。
- en: Service Providers
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务提供商
- en: Although there’s a bit of procedural code in these bootstraps, almost all of
    Laravel’s bootstrap code is separated into something Laravel calls *service providers*.
    A service provider is a class that encapsulates logic that various parts of your
    application need to run to bootstrap their core functionality.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些引导中有一些过程性代码，几乎所有 Laravel 的引导代码都被分离到 Laravel 称为*服务提供商*的东西中。服务提供商是一个类，封装了各个应用程序部分需要运行的逻辑，以引导它们的核心功能。
- en: For example, there’s an `AuthServiceProvider` that bootstraps all of the registrations
    necessary for Laravel’s authentication system and a `RouteServiceProvider` that
    bootstraps the routing system.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个`AuthServiceProvider`，它引导所有 Laravel 认证系统所需的注册，并且有一个`RouteServiceProvider`，它引导路由系统。
- en: 'The concept of service providers can be a little hard to understand at first,
    so think about it this way: many components of your application have bootstrap
    code that needs to run when the application initializes. Service providers are
    a tool for grouping that bootstrap code into related classes. If you have any
    code that needs to run *in preparation* for your application code to work, it’s
    a strong candidate for a service provider.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供商的概念一开始可能有点难以理解，所以可以这样考虑：你的应用程序中的许多组件都有引导代码，需要在应用程序初始化时运行。服务提供商是将这些引导代码分组到相关类中的工具。如果你有任何需要在应用程序代码正常工作之前运行的代码，它就是服务提供商的一个强力候选者。
- en: For example, if you ever find that the feature you’re working on requires some
    classes registered in the container (you’ll learn more about this in [Chapter 11](ch11.html#the_container)),
    you would create a service provider just for that piece of functionality. You
    might have a `GitHubServiceProvider` or a `MailerServiceProvider`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你发现你正在开发的功能需要在容器中注册一些类（你将在[第11章](ch11.html#the_container)中了解更多），你会为该功能创建一个专门的服务提供商。你可能会有一个`GitHubServiceProvider`或`MailerServiceProvider`。
- en: 'Service providers have two important methods: `boot()` and `register()`. There’s
    also a `DeferrableProvider` interface that you might choose to use. Here’s how
    they work.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供商有两个重要的方法：`boot()` 和 `register()`。还有一个你可能选择使用的`DeferrableProvider`接口。这里是它们的工作原理。
- en: First, all of the service providers’ `register()` methods are called. This is
    where you’ll want to bind classes and aliases to the container. You don’t want
    to do anything in `register()` that relies on the entire application being bootstrapped.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 其次会调用所有服务提供商的`boot()`方法。现在你可以在这里做任何其他引导，比如绑定事件监听器或定义路由——任何依赖于整个 Laravel 应用程序已经引导的东西。
- en: Second, all of the service providers’ `boot()` methods are called. You can now
    do any other bootstrapping here, like binding event listeners or defining routes—​anything
    that may rely on the entire Laravel application having been bootstrapped.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 首先会调用所有服务提供商的`register()`方法。在这里，你可以将类和别名绑定到容器中。不要在`register()`中做任何依赖于整个应用程序已经引导的事情。
- en: If your service provider is only going to register bindings in the container
    (i.e., teach the container how to resolve a given class or interface), but not
    perform any other bootstrapping, you can “defer” its registrations, which means
    they won’t run unless one of their bindings is explicitly requested from the container.
    This can speed up your application’s average time to bootstrap.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的服务提供者只会在容器中注册绑定（即教会容器如何解析给定的类或接口），而不执行任何其他引导操作，你可以“延迟”它们的注册，这意味着它们不会运行，除非显式从容器请求它们的绑定。这可以加快应用程序的平均引导时间。
- en: If you want to defer your service provider’s registrations, first implement
    the `Illuminate\Contracts\Support\DeferrableProvider` interface; then, give the
    service provider a `provides()` method that returns a list of bindings the provider
    provides, as shown in [Example 10-1](#EX1001).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想延迟你的服务提供者的注册，首先要实现 `Illuminate\Contracts\Support\DeferrableProvider` 接口；然后，给服务提供者一个
    `provides()` 方法，返回该提供者提供的绑定列表，如[示例 10-1](#EX1001)所示。
- en: Example 10-1\. Deferring the registration of a service provider
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-1\. 延迟服务提供者的注册
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: More Uses for Service Providers
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务提供者的更多用途
- en: Service providers also have a suite of methods and configuration options that
    can provide advanced functionality to the end user when the provider is published
    as part of a Composer package. Take a look at the service provider definition
    in the [Laravel source](https://oreil.ly/uHhap) to learn more about how this can
    work.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供者还有一套方法和配置选项，可以在作为 Composer 包的一部分发布时为最终用户提供高级功能。查看[Laravel 源](https://oreil.ly/uHhap)中的服务提供者定义，了解更多信息。
- en: Now that we’ve covered the application bootstrap, let’s take a look at the `Request`
    object, the most important output of the bootstrap.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了应用程序引导，让我们来看看 `Request` 对象，这是引导过程中最重要的输出。
- en: The Request Object
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求对象
- en: The `Illuminate\Http\Request` class is a Laravel-specific extension of Symfony’s
    `HttpFoundation``\Request` class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Illuminate\Http\Request` 类是 Laravel 特有的 Symfony `HttpFoundation` 的扩展。'
- en: Symfony HttpFoundation
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Symfony HttpFoundation
- en: Symfony’s `HttpFoundation` suite of classes powers almost every PHP framework
    in existence at this point; this is the most popular and powerful set of abstractions
    available in PHP for representing HTTP requests, responses, headers, cookies,
    and more.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony 的 `HttpFoundation` 类组件几乎支持目前所有的 PHP 框架；这是 PHP 中表示 HTTP 请求、响应、头部、Cookie
    等的最流行和强大的抽象集合。
- en: The `Request` object is intended to represent every relevant piece of information
    you might care to know about a user’s HTTP request.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request` 对象旨在表示你可能关心的用户 HTTP 请求的每个相关信息。'
- en: In native PHP code, you might find yourself looking to `$_SERVER`, `$_GET`,
    `$_POST`, and other combinations of globals and processing logic to get information
    about the current user’s request. What files has the user uploaded? What’s their
    IP address? What fields did they post? All of this is sprinkled around the language—​and
    your code—​in a way that’s hard to understand and harder to mock.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在原生 PHP 代码中，你可能会发现自己查看 `$_SERVER`、`$_GET`、`$_POST` 等全局变量和处理逻辑的组合，以获取关于当前用户请求的信息。用户上传了哪些文件？他们的
    IP 地址是什么？他们提交了哪些字段？所有这些信息都分散在语言和代码中，这使得理解起来困难，而模拟起来更加困难。
- en: Symfony’s `Request` object instead collects all of the information necessary
    to represent a single HTTP request into a single object, and then tacks on convenience
    methods to make it easy to get useful information from it. The Illuminate `Request`
    object adds even more convenience methods to get information about the request
    it’s representing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Symfony 的 `Request` 对象将所有表示单个 HTTP 请求所需的信息集成到一个对象中，并添加了便捷方法来轻松获取有用的信息。Illuminate
    的 `Request` 对象增加了更多便捷方法，用于获取它所代表的请求的信息。
- en: Capturing a Request
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获请求
- en: 'You’ll very likely never need to do this in a Laravel app, but if you ever
    need to capture your own Illuminate `Request` object directly from PHP’s globals,
    you can use the `capture()` method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Laravel 应用中，你几乎不太可能需要这样做，但如果你需要直接从 PHP 的全局变量中捕获自己的 Illuminate `Request` 对象，你可以使用
    `capture()` 方法：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Getting a Request Object in Laravel
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Laravel 中获取请求对象
- en: Laravel creates an internal `Request` object for each request, and there are
    a few ways you can get access to it.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 为每个请求创建一个内部的 `Request` 对象，你可以通过几种方式来访问它。
- en: First—and again, we’ll cover this more in [Chapter 11](ch11.html#the_container)—you
    can typehint the class in any constructor or method that’s resolved by the container.
    That means you can typehint it in a controller method or a service provider, as
    seen in [Example 10-2](#EX1002).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先—再次强调，我们将在[第11章](ch11.html#the_container)中更详细地介绍—您可以在任何由容器解析的构造函数或方法中对类进行类型提示。这意味着您可以在控制器方法或服务提供程序中进行类型提示，就像在[示例10-2](#EX1002)中看到的那样。
- en: Example 10-2\. Typehinting in a container-resolved method to receive a `Request`
    object
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例10-2\. 在容器解析的方法中对类进行类型提示以接收`Request`对象
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, you can use the `request()` global helper, which allows you
    to call methods on it (e.g., `request()->input()`) and also allows you to call
    it on its own to get an instance of `$request`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`request()`全局助手，允许您在其上调用方法（例如，`request()->input()`），也允许您单独调用它以获取`$request`的实例：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, you can use the `app()` global method to get an instance of `Request`.
    You can pass either the fully qualified class name or the shortcut `request`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`app()`全局方法来获取`Request`的实例。您可以传递完全限定的类名或简写`request`：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Getting Basic Information About a Request
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取请求的基本信息
- en: Now that you know how to get an instance of `Request`, what can you do with
    it? The primary purpose of the `Request` object is to represent the current HTTP
    request, so the primary functionality the `Request` class offers is to make it
    easy to get useful information about the current request.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何获取`Request`的实例了，您可以做些什么呢？`Request`对象的主要目的是表示当前的HTTP请求，因此`Request`类提供的主要功能是轻松获取有关当前请求的有用信息。
- en: I’ve categorized the methods described here, but note that there’s certainly
    overlap between the categories, and the categories are a bit arbitrary—​for example,
    query parameters could just as easily be in “User and request state” as they are
    in “Basic user input.” Hopefully these categories will make it easy for you to
    learn what’s available, and then you can throw away the categories.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将这里描述的方法分类，但请注意分类之间肯定存在重叠，并且分类有点随意—例如，查询参数可以与“用户和请求状态”一样轻松地出现在“基本用户输入”中。希望这些分类能让您轻松了解可用内容，然后您可以丢弃这些分类。
- en: Also, be aware that there are many more methods available on the `Request` object;
    these are just the most commonly used methods.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`Request`对象上还有许多其他可用的方法；这些只是最常用的方法。
- en: Basic user input
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本用户输入
- en: 'The basic user input methods make it simple to get information that the users
    themselves explicitly provide—​likely through submitting a form or an Ajax component.
    When I reference “user-provided input” here, I’m talking about input from query
    strings (`GET`), form submissions (`POST`), or JSON. The basic user input methods
    include the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用户输入方法使得获取用户显式提供的信息变得简单—通常通过提交表单或Ajax组件。在这里提到“用户提供的输入”时，我指的是来自查询字符串（`GET`）、表单提交（`POST`）或JSON的输入。基本用户输入方法包括以下内容：
- en: '`all()`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()`'
- en: Returns an array of all user-provided input.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有用户提供的输入的数组。
- en: '`input(*fieldName*)`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`input(*fieldName*)`'
- en: Returns the value of a single user-provided input field.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 返回单个用户提供的输入字段的值。
- en: '`only(*fieldName*|[*array,of,field,names*])`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`only(*fieldName*|[*array,of,field,names*])`'
- en: Returns an array of all user-provided input for the specified field name(s).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定字段名（们）的所有用户提供的输入的数组。
- en: '`except(*fieldName*|[*array,of,field,names*])`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`except(*fieldName*|[*array,of,field,names*])`'
- en: Returns an array of all user-provided input except for the specified field name(s).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 返回除指定字段名（们）外的所有用户提供的输入的数组。
- en: '`exists(*fieldName*)`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`exists(*fieldName*)`'
- en: Returns a Boolean indicating whether the field exists in the input. `has()`
    is an alias. Executes the given callback when the field exists in the input.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个布尔值，指示输入中是否存在指定字段。`has()`是其别名。在输入中存在指定字段时执行给定的回调。
- en: '`filled(*fieldName*)`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`filled(*fieldName*)`'
- en: Returns a Boolean indicating whether the field exists in the input and is not
    empty (that is, has a value).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个布尔值，指示输入中是否存在指定字段并且不为空（即具有值）。
- en: '`whenFilled()`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`whenFilled()`'
- en: Executes the given callback when the field exists in the input and is not empty
    (that is, has a value).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入中存在指定字段并且不为空（即具有值）时执行给定的回调。
- en: '`json()`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`json()`'
- en: Returns a `ParameterBag` if the page had JSON sent to it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果页面收到了JSON，则返回一个`ParameterBag`。
- en: '`boolean(*fieldName*)`'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean(*fieldName*)`'
- en: Returns value from the input as a Boolean. Converts strings and integers to
    appropriate booleans (using `FILTER_VALIDATE_BOOLEAN`). If the key is not present
    in the request, returns `false`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入的值作为布尔值返回。将字符串和整数转换为适当的布尔值（使用 `FILTER_VALIDATE_BOOLEAN`）。如果请求中不存在键，则返回 `false`。
- en: '`json(*keyName*)`'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`json(*keyName*)`'
- en: Returns the value of the given key from the JSON sent to the page.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 返回从发送到页面的 JSON 中给定键的值。
- en: '[Example 10-3](#EX1003) gives a few quick examples of how to use the user-provided
    information methods from a request.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 10-3](#EX1003) 提供了如何使用请求中提供的用户信息方法的几个快速示例。'
- en: Example 10-3\. Getting basic user-provided information from the request
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-3\. 从请求获取基本用户提供的信息
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: User and request state
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户和请求状态
- en: 'The user and request state methods include input that wasn’t explicitly provided
    by the user through a form:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 用户和请求状态方法包括通过表单未显式提供的输入：
- en: '`method()`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`method()`'
- en: Returns the method (`GET`, `POST`, `PATCH`, etc.) used to access this route.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 返回用于访问此路由的方法（`GET`、`POST`、`PATCH` 等）。
- en: '`path()`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`path()`'
- en: Returns the path (without the domain) used to access this page; for example,
    `'http://www.myapp.com/abc/def'` would return `'abc/def'`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 返回用于访问此页面的路径（不包括域名）；例如，`'http://www.myapp.com/abc/def'` 将返回 `'abc/def'`。
- en: '`url()`'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`url()`'
- en: Returns the URL (with the domain) used to access this page; for example, `'abc'`
    would return `'http://www.myapp.com/abc'`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 返回用于访问此页面的带域名的 URL；例如，`'abc'` 将返回 `'http://www.myapp.com/abc'`。
- en: '`is()`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`is()`'
- en: Returns a Boolean indicating whether or not the current page request fuzzy-matches
    a provided string (e.g., `/a/b/c` would be matched by `$request->is('*b*')`, where
    `*` stands for any characters); uses a custom regex parser found in `Str::is()`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 返回布尔值，指示当前页面请求是否与提供的字符串模糊匹配（例如，`/a/b/c` 将被 `$request->is('*b*')` 匹配，其中 `*` 表示任意字符）；使用在
    `Str::is()` 中找到的自定义正则表达式解析器。
- en: '`ip()`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`ip()`'
- en: Returns the user’s IP address.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回用户的 IP 地址。
- en: '`header()`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`header()`'
- en: Returns an array of headers (e.g., `['accept-language' => ['⁠e⁠n⁠-⁠U⁠S⁠,⁠e⁠n⁠;​q⁠=⁠0⁠.⁠8⁠']]`),
    or, if passed a header name as a parameter, returns just that header.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 返回标题数组（例如 `['accept-language' => ['⁠e⁠n⁠-⁠U⁠S⁠,⁠e⁠n⁠;​q⁠=⁠0⁠.⁠8⁠']]`），或者如果作为参数传递了标题名称，则只返回该标题。
- en: '`server()`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`server()`'
- en: Returns an array of the variables traditionally stored in `$_SERVER` (e.g.,
    `REMOTE_ADDR`), or, if passed a `$_SERVER` variable name, returns just that value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 返回传统存储在 `$_SERVER` 中的变量数组（例如 `REMOTE_ADDR`），或者如果传递了 `$_SERVER` 变量名称，则只返回该值。
- en: '`secure()`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`secure()`'
- en: Returns a Boolean indicating whether this page was loaded using HTTPS.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指示此页面是否使用 HTTPS 加载的布尔值。
- en: '`pjax()`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`pjax()`'
- en: Returns a Boolean indicating whether this page request was loaded using Pjax.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指示此页面请求是否使用了 Pjax 加载的布尔值。
- en: '`wantsJson()`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`wantsJson()`'
- en: Returns a Boolean indicating whether this request has any `/json` content types
    in its `Accept` headers.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指示此请求的 `Accept` 头中是否有任何 `/json` 内容类型的布尔值。
- en: '`isJson()`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`isJson()`'
- en: Returns a Boolean indicating whether this page request has any `/json` content
    types in its `Content-Type` header.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指示此页面请求的 `Content-Type` 头中是否有任何 `/json` 内容类型的布尔值。
- en: '`accepts()`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`accepts()`'
- en: Returns a Boolean indicating whether this page request accepts a given content
    type.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指示此页面请求是否接受给定内容类型的布尔值。
- en: Files
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件
- en: 'So far, all of the input we’ve covered is either explicit (retrieved by methods
    like `all()`, `input()`, etc.) or defined by the browser or referring site (retrieved
    by methods like `pjax()`). File inputs are similar to explicit user input, but
    they’re handled much differently:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论的所有输入都是显式的（通过诸如 `all()`、`input()` 等方法检索），或者由浏览器或引用站点定义（通过诸如 `pjax()`
    等方法检索）。文件输入类似于显式用户输入，但处理方式有很大不同：
- en: '`file()`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`file()`'
- en: Returns an array of all uploaded files, or, if a key is passed (the file upload
    field name), returns just the one file.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有已上传文件的数组，或者如果传递了键（文件上传字段名称），则仅返回一个文件。
- en: '`allFiles()`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`allFiles()`'
- en: Returns an array of all uploaded files; useful as opposed to `file()` because
    of clearer naming.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有已上传文件的数组；与 `file()` 相比，命名更清晰，非常有用。
- en: '`hasFile()`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasFile()`'
- en: Returns a Boolean indicating whether a file was uploaded at the specified key.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 返回指定键是否上传了文件的布尔值。
- en: Every file that’s uploaded will be an instance of `Symfony\Component\HttpFoundation\File\UploadedFile`,
    which provides a suite of tools for validating, processing, and storing uploaded
    files.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个上传的文件都将是 `Symfony\Component\HttpFoundation\File\UploadedFile` 的实例，提供一套工具来验证、处理和存储上传的文件。
- en: Take a look at [Chapter 14](ch14.html#storage_and_retrieval) for more examples
    of how to handle uploaded files.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看 [Chapter 14](ch14.html#storage_and_retrieval) 获取有关如何处理上传文件的更多示例。
- en: Persistence
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 持久性
- en: 'The request can also provide functionality for interacting with the session.
    Most session functionality lives elsewhere, but there are a few methods that are
    particularly relevant to the current page request:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请求还可以提供与会话交互的功能。大多数会话功能存放在其他位置，但有几个方法对当前页面请求特别相关：
- en: '`flash()`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash()`'
- en: Flashes the current request’s user input to the session to be retrieved later,
    which means it’s saved to the session but disappears after the next request.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前请求的用户输入闪存到会话中以供稍后检索，这意味着它保存到会话中，但在下一个请求后消失。
- en: '`flashOnly()`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`flashOnly()`'
- en: Flashes the current request’s user input for any keys in the provided array.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为提供的数组中的任何键闪存当前请求的用户输入。
- en: '`flashExcept()`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`flashExcept()`'
- en: Flashes the current request’s user input, except for any keys in the provided
    array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存当前请求的用户输入，除了提供的数组中的任何键。
- en: '`old()`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`old()`'
- en: Returns an array of all previously flashed user input, or, if passed a key,
    returns the value for that key if it was previously flashed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有先前闪存的用户输入的数组，或者如果传递了键，则返回先前闪存的该键的值。
- en: '`flush()`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`flush()`'
- en: Wipes all previously flashed user input.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 清除所有先前闪存的用户输入。
- en: '`cookie()`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`cookie()`'
- en: Retrieves all cookies from the request, or, if a key is provided, retrieves
    just that cookie.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从请求中检索所有 cookie，或者如果提供了键，则仅检索该 cookie。
- en: '`hasCookie()`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasCookie()`'
- en: Returns a Boolean indicating whether the request has a cookie for the given
    key.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个布尔值，指示请求是否具有给定键的 cookie。
- en: The `flash*()` and `old()` methods are used for storing user input and retrieving
    it later, often after the input is validated and rejected.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`flash*()` 和 `old()` 方法用于存储用户输入，并在稍后检索它，通常在输入经过验证并被拒绝后。'
- en: The Response Object
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 响应对象
- en: Similar to the `Request` object, there’s an Illuminate `Response` object that
    represents the response your application is sending to the end user, complete
    with headers, cookies, content, and anything else used for sending the end user’s
    browser instructions on rendering a page.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `Request` 对象，还有一个 Illuminate `Response` 对象，表示您的应用程序发送给最终用户的响应，包括标头、cookie、内容和用于发送最终用户浏览器的页面渲染指令的任何其他内容。
- en: 'Just like `Request`, the `Illuminate\Http\Response` class extends a Symfony
    class: `Symfony\Component\HttpFoundation\Response`. This is a base class with
    a series of properties and methods that makes it possible to represent and render
    a response; Illuminate’s `Response` class decorates it with a few helpful shortcuts.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `Request` 一样，`Illuminate\Http\Response` 类扩展了 Symfony 类：`Symfony\Component\HttpFoundation\Response`。这是一个基类，具有一系列属性和方法，使得表示和呈现响应成为可能；Illuminate
    的 `Response` 类通过一些有用的快捷方式对其进行装饰。
- en: Using and Creating Response Objects in Controllers
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在控制器中使用和创建响应对象
- en: Before we talk about how you can customize your `Response` objects, let’s step
    back and see how we most commonly work with `Response` objects.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论如何自定义您的 `Response` 对象之前，让我们退后一步，看看我们最常用的 `Response` 对象的工作方式。
- en: In the end, any `Response` object returned from a route definition will be converted
    into an HTTP response. It may define specific headers or specific content, set
    cookies, or whatever else, but eventually it will be converted into a response
    your users’ browsers can parse.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，从路由定义返回的任何 `Response` 对象都将转换为 HTTP 响应。它可以定义特定的标头或特定的内容，设置 cookie 或其他任何内容，但最终它将转换为用户浏览器可以解析的响应。
- en: Let’s take a look at the simplest possible response, in [Example 10-4](#EX1004).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下最简单的响应，例如 [Example 10-4](#EX1004)。
- en: Example 10-4\. Simplest possible HTTP response
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-4\. 最简单的可能的 HTTP 响应
- en: '[PRE7]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We create a response, give it some core data, and then return it. We can also
    customize the HTTP status, headers, cookies, and more, like in [Example 10-5](#EX1005).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个响应，为其提供一些核心数据，然后返回它。我们还可以自定义 HTTP 状态、标头、cookie 等等，例如 [Example 10-5](#EX1005)。
- en: Example 10-5\. Simple HTTP response with customized status and headers
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-5\. 具有自定义状态和标头的简单 HTTP 响应
- en: '[PRE8]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Setting headers
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置标头
- en: We define a header on a response by using the `header()` fluent method, like
    in [Example 10-5](#EX1005). The first parameter is the header name, and the second
    is the header value.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `header()` 流畅方法在响应上定义一个标头，例如在 [Example 10-5](#EX1005)。第一个参数是标头名称，第二个是标头值。
- en: Adding cookies
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 cookie
- en: We can also set cookies directly on the `Response` object if we’d like. We’ll
    cover Laravel’s cookie handling a bit more in [Chapter 14](ch14.html#storage_and_retrieval),
    but take a look at [Example 10-6](#EX1006) for a simple use case for attaching
    cookies to a response.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要的话，我们还可以直接在`Response`对象上设置Cookie。我们将在[第 14 章](ch14.html#storage_and_retrieval)更详细地讨论Laravel的Cookie处理，但你可以查看[示例 10-6](#EX1006)了解如何将Cookie附加到响应中的简单用例。
- en: Example 10-6\. Attaching a cookie to a response
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-6\. 将Cookie附加到响应
- en: '[PRE9]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Specialized Response Types
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专用响应类型
- en: There are also a few special response types for views, downloads, files, and
    JSON. Each is a predefined macro that makes it easy to reuse particular templates
    for headers or content structure.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些专门用于视图、下载、文件和JSON的特殊响应类型。每种都是预定义的宏，可以轻松重用特定的头部或内容结构模板。
- en: View responses
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看响应
- en: In [Chapter 3](ch03.html#routing), I used the global `view()` helper to show
    how to return a template—​for example, `view('*view.name.here*')` or something
    similar. But if you need to customize the headers, HTTP status, or anything else
    when returning a view, you can use the `view()` response type as shown in [Example 10-7](#EX1007).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](ch03.html#routing)中，我使用全局的`view()`助手展示如何返回模板，例如`view('*view.name.here*')`或类似的内容。但如果在返回视图时需要自定义头部、HTTP状态或其他内容，可以使用`view()`响应类型，如[示例 10-7](#EX1007)所示。
- en: Example 10-7\. Using the `view()` response type
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-7\. 使用`view()`响应类型
- en: '[PRE10]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Download responses
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下载响应
- en: Sometimes you want your application to force the user’s browser to download
    a file, whether you’re creating the file in Laravel or serving it from a database
    or a protected location. The `download()` response type makes this simple.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望应用程序强制用户的浏览器下载一个文件，无论是在Laravel中创建文件还是从数据库或受保护的位置提供文件。使用`download()`响应类型可以轻松实现这一点。
- en: The required first parameter is the path for the file you want the browser to
    download. If it’s a generated file, you’ll need to save it somewhere temporarily.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的第一个参数是要浏览器下载的文件路径。如果是生成的文件，你需要将其暂时保存在某个地方。
- en: The optional second parameter is the filename for the downloaded file (e.g.,
    *export.csv*). If you don’t pass a string here, the name will be generated automatically.
    The optional third parameter allows you to pass an array of headers. [Example 10-8](#EX1008)
    illustrates the use of the `download()` response type.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的第二个参数是下载文件的文件名（例如，*export.csv*）。如果你不在这里传递一个字符串，文件名将会自动生成。可选的第三个参数允许你传递一个头部数组。[示例 10-8](#EX1008)展示了使用`download()`响应类型的例子。
- en: Example 10-8\. Using the `download()` response type
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-8\. 使用`download()`响应类型
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you wish to delete the original file from the disk after returning a download
    response, you can chain the `deleteFileAfterSend()` method after the `download()`
    method:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望在返回下载响应后从磁盘删除原始文件，可以在`download()`方法后链式调用`deleteFileAfterSend()`方法：
- en: '[PRE12]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: File responses
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文件响应
- en: The file response is similar to the download response, except it allows the
    browser to display the file instead of forcing a download. This is most common
    with images and PDFs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 文件响应类似于下载响应，不同之处在于它允许浏览器显示文件而不是强制下载。这在处理图片和PDF文件时最常见。
- en: The required first parameter is the filename, and the optional second parameter
    can be an array of headers (see [Example 10-9](#EX1009)).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 必需的第一个参数是文件名，可选的第二个参数可以是头部数组（参见[示例 10-9](#EX1009)）。
- en: Example 10-9\. Using the `file()` response type
  id: totrans-168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-9\. 使用`file()`响应类型
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: JSON responses
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON响应
- en: JSON responses are so common that, even though they’re not really particularly
    complex to program, there’s a custom response for them as well.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: JSON响应非常常见，尽管编程起来并不是特别复杂，但也有一个定制的响应类型。
- en: JSON responses convert the passed data to JSON (with `json_encode()`) and set
    the `Content-Type` to `application/json`. You can also optionally use the `setCallback()`
    method to create a JSONP response instead of JSON, as seen in [Example 10-10](#EX1011).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: JSON响应将传递的数据转换为JSON（使用`json_encode()`），并将`Content-Type`设置为`application/json`。你还可以选择使用`setCallback()`方法创建一个JSONP响应而不是JSON，如[示例 10-10](#EX1011)所示。
- en: Example 10-10\. Using the `json()` response type
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-10\. 使用`json()`响应类型
- en: '[PRE14]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Redirect responses
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重定向响应
- en: Redirects aren’t commonly called on the `response()` helper, so they’re a bit
    different from the other custom response types we’ve discussed already, but they’re
    still just another sort of response. Redirects, returned from a Laravel route,
    send the user a redirect (often a 301) to another page or back to the previous
    page.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向不常在`response()`辅助函数中调用，因此它们与我们已经讨论过的其他自定义响应类型有所不同，但它们仍然只是另一种响应。从Laravel路由返回的重定向会向用户发送一个重定向（通常是301），将其导向另一个页面或返回到上一页。
- en: You technically *can* call a redirect from `response()`, as in `return response()``->redirectTo('/')`.
    But, more commonly, you’ll use the redirect-specific global helpers.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你技术上*可以*从`response()`中调用重定向，例如`return response()->redirectTo('/')`。但更常见的做法是使用专门的全局辅助函数。
- en: There is a global `redirect()` function that can be used to create redirect
    responses and a global `back()` function that is a shortcut to `redirect()->back()`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个全局的`redirect()`函数，用于创建重定向响应，还有一个全局的`back()`函数，是`redirect()->back()`的快捷方式。
- en: Just like most global helpers, the `redirect()` global function can either be
    passed parameters or be used to get an instance of its class that you then chain
    method calls onto. If you don’t chain, but just pass parameters, `redirect()`
    performs the same as `redirect()->to()`; it takes a string and redirects to that
    string URL. [Example 10-11](#EX10011) shows some examples of its use.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像大多数全局辅助函数一样，`redirect()`全局函数可以传递参数，也可以用来获取其类的实例，然后链式调用方法。如果不链式调用，而只是传递参数，`redirect()`的行为与`redirect()->to()`相同；它接受一个字符串并重定向到该字符串的URL。[示例 10-11](#EX10011)展示了其使用示例。
- en: Example 10-11\. Examples of using the `redirect()` global helper
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-11\. 使用`redirect()`全局辅助函数的示例
- en: '[PRE15]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can also redirect “back” to the previous page, which is especially useful
    when handling and validating user input. [Example 10-12](#EX1012) shows a common
    pattern in validation contexts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理和验证用户输入时，你也可以“返回”到上一页，这在验证上下文中特别有用。[示例 10-12](#EX1012)展示了验证上下文中的常见模式。
- en: Example 10-12\. Redirect back with input
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-12\. 带有输入的回跳重定向
- en: '[PRE16]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally, you can redirect and flash data to the session at the same time. This
    is common with error and success messages, like in [Example 10-13](#EX1013).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以同时重定向并向会话闪存数据。这在处理错误和成功消息时很常见，例如[示例 10-13](#EX1013)。
- en: Example 10-13\. Redirect with flashed data
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-13\. 带有闪存数据的重定向
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Custom response macros
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义响应宏
- en: You can also create your own custom response types using *macros*. This allows
    you to define a series of modifications to make to the response and its provided
    content.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用*宏*创建自己的自定义响应类型。这允许你定义要对响应及其提供的内容进行的一系列修改。
- en: Let’s re-create the `json()` custom response type, just to see how it works.
    As always, you should probably create a custom service provider for these sorts
    of bindings, but for now we’ll just put it in `AppServiceProvider`, as seen in
    [Example 10-14](#EX1014).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新创建`json()`自定义响应类型，只是为了看看它是如何工作的。如常，你应该为这类绑定创建一个自定义服务提供者，但现在我们暂时将其放在`AppServiceProvider`中，如[示例 10-14](#EX1014)所示。
- en: Example 10-14\. Creating a custom response macro
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-14\. 创建一个自定义响应宏
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we can use it just like we would use the predefined `json()` macro:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像使用预定义的`json()`宏一样使用它：
- en: '[PRE19]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will return a response with the body of that array encoded for JSON, with
    the JSON-appropriate `Content-Type` header.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个带有数组主体的JSON编码响应，带有适当的JSON类型的`Content-Type`头。
- en: The responsable interface
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负责任接口
- en: If you’d like to customize how you’re sending responses and a macro doesn’t
    offer enough space or enough organization, or if you want any of your objects
    to be capable of being returned as a “response” with their own logic of how to
    be displayed, the `Responsable` interface is for you.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自定义如何发送响应，而宏提供的空间或组织不够，或者你希望你的对象能够根据自己的显示逻辑作为“响应”返回，那么`Responsable`接口适合你。
- en: The `Responsable` interface, `Illuminate\Contracts\Support\Responsable`, dictates
    that its implementors must have a `toResponse()` method. This needs to return
    an Illuminate `Response` object. [Example 10-15](#EX1022) illustrates how to create
    a `Responsable` object.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Responsable`接口，`Illuminate\Contracts\Support\Responsable`，规定其实现类必须有一个`toResponse()`方法。这需要返回一个Illuminate
    `Response`对象。[示例 10-15](#EX1022)说明了如何创建一个`Responsable`对象。'
- en: Example 10-15\. Creating a simple `Responsable` object
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-15\. 创建一个简单的`Responsable`对象
- en: '[PRE20]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we can use it just like our custom macro:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以像使用我们自定义的宏一样使用它：
- en: '[PRE21]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This probably looks like a lot of work relative to the response macros we covered
    earlier. But the `Responsable` interface really shines when you’re working with
    more complicated controller manipulations. One common example is to use it to
    create view models (or view objects), like in [Example 10-16](#EX1023).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于之前介绍的响应宏，这可能看起来需要做很多工作。但是在处理更复杂的控制器操作时，`Responsable`接口真正发挥作用。一个常见的例子是使用它来创建视图模型（或视图对象），就像在[示例 10-16](#EX1023)中。
- en: Example 10-16\. Using `Responsable` to create a view object
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-16\. 使用`Responsable`创建视图对象
- en: '[PRE22]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It starts to make a little bit more sense in this context—move your complex
    view preparation into a dedicated, *testable* object, and keep your controllers
    clean. Here’s a controller that uses that `Responsable` object:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将复杂的视图准备工作移到一个专用的、*可测试*的对象中，并保持控制器的简洁，这开始变得更有意义。以下是使用那个`Responsable`对象的控制器：
- en: '[PRE23]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Laravel and Middleware
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel和中间件
- en: Take a look back at [Figure 10-1](#FIG1001), at the start of this chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下[图 10-1](#FIG1001)，这是本章的开头。
- en: We’ve covered the requests and responses, but we haven’t actually looked into
    what middleware are. You may already be familiar with middleware, which aren’t
    unique to Laravel, but rather a widely used architecture pattern.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了请求和响应，但实际上还没有深入了解中间件是什么。您可能已经熟悉中间件，这不是Laravel独有的，而是一种广泛使用的架构模式。
- en: An Introduction to Middleware
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件简介
- en: The idea of middleware is that there is a series of layers wrapping around your
    application, like a multilayer cake or an onion.^([1](ch10.html#id1407)) Just
    as shown in [Figure 10-1](#FIG1001), every request passes through every middleware
    layer on its way into the application, and then the resulting response passes
    back through the middleware layers on its way out to the end user.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的概念是，有一系列层包裹在您的应用程序周围，就像一个多层蛋糕或洋葱[^1]一样。正如[图 10-1](#FIG1001)所示，每个请求在进入应用程序时都会经过每个中间件层，然后生成的响应在发送给最终用户之前也会经过中间件层。
- en: Middleware are most often considered separate from your application logic, and
    usually are constructed in a way that should theoretically be applicable to any
    application, not just the one you’re working on at the moment.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件通常被视为与应用程序逻辑分离的部分，并且通常设计为理论上适用于任何应用程序，而不仅限于您目前正在开发的应用程序。
- en: 'A middleware can inspect a request and decorate it or reject it, based on what
    it finds. That means middleware are great for something like rate limiting: they
    can inspect the IP address, check how many times it’s accessed this resource in
    the last minute, and send back a 429 (Too Many Requests) status if a threshold
    is passed.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件可以检查请求并根据其内容装饰或拒绝它。这意味着中间件非常适合像速率限制这样的用例：它们可以检查IP地址，查看在最后一分钟内访问此资源的次数，并在超过阈值时返回状态码429（请求过多）。
- en: Because middleware also get access to the response on its way out of the application,
    it’s great for decorating responses. For example, Laravel uses a middleware to
    add all of the queued cookies from a given request/response cycle to the response
    right before it is sent to the end user.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因为中间件也可以在应用程序发送响应时访问响应，所以非常适合装饰响应。例如，Laravel使用中间件将给定请求/响应周期中排队的所有cookie添加到响应中，然后再发送给最终用户。
- en: But some of the most powerful uses of middleware come from the fact that they
    can be nearly the *first* and the *last* thing to interact with the request/response
    cycle. That makes middleware perfect for something like enabling sessions—​PHP
    needs you to open the session very early and close it very late, and middleware
    are also great for this.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但中间件最强大的用途之一来自于它们几乎可以是请求/响应周期中*第一*和*最后*的交互对象。这使得中间件非常适合像启用会话这样的功能——PHP需要您尽早打开会话并在很晚时候关闭会话，而中间件也非常适合这种用途。
- en: Creating Custom Middleware
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义中间件
- en: Let’s imagine we want to have a middleware that rejects every request that uses
    the `DELETE` HTTP method and also sends a cookie back for every request.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望有一个中间件，它拒绝使用`DELETE` HTTP方法的每个请求，并在每个请求返回时发送一个cookie。
- en: 'There’s an Artisan command to create custom middleware. Let’s try it out:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个Artisan命令用于创建自定义中间件。让我们试试看：
- en: '[PRE24]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can now open up the file at *app/Http/Middleware/BanDeleteMethod.php*. The
    default contents are shown in [Example 10-17](#EX1015).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以打开*app/Http/Middleware/BanDeleteMethod.php*文件。默认内容如示例 10-17所示。
- en: Example 10-17\. Default middleware contents
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-17\. 默认中间件内容
- en: '[PRE25]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How this `handle()` method represents the processing of both the incoming request
    *and* the outgoing response is the most difficult thing to understand about middleware,
    so let’s walk through it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `handle()` 方法如何表示处理传入请求 *和* 传出响应是最难理解的中间件方面，所以让我们逐步来看一下。
- en: Understanding middleware’s handle() method
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解中间件的 `handle()` 方法
- en: First, remember that middleware are layered, one on top of another, and then
    finally on top of the app. The first middleware that’s registered gets *first*
    access to a request when it comes in, then that request is passed to every other
    middleware in turn, then to the app. Then the resulting response is passed outward
    through the middleware, and finally the first middleware gets *last* access to
    the response when it goes out.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，要记住中间件是层层叠加的，最后叠加在应用程序之上。注册的第一个中间件在请求进入时最先访问，然后请求依次传递给每个其他中间件，然后到达应用程序。然后通过中间件传递生成的响应，最后第一个中间件在响应输出时再次访问。
- en: Let’s imagine we’ve registered `BanDeleteMethod` as the first middleware to
    run. That means the `$request` coming into it is the raw request, unadulterated
    by any other middleware. Now what?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已将 `BanDeleteMethod` 注册为第一个运行的中间件。这意味着进入它的 `$request` 是原始请求，没有任何其他中间件的篡改。现在呢？
- en: Passing that request to `$next()` means handing it off to the rest of the middleware.
    The `$next()` closure just takes that `$request` and passes it to the `handle()`
    method of the next middleware in the stack. It then gets passed on down the line
    until there are no more middleware to hand it to, and it finally ends up at the
    application.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将该请求传递给 `$next()` 意味着将其传递给其余的中间件。`$next()` 闭包只是将该 `$request` 传递给堆栈中下一个中间件的 `handle()`
    方法。然后它会一直传递到没有更多中间件可传递时，并最终到达应用程序。
- en: Next, how does the response come out? This is where it might be hard to follow.
    The application returns a response, which is passed back up the chain of middleware—​because
    each middleware returns its response. So, within that same `handle()` method,
    the middleware can decorate a `$request` and pass it to the `$next()` closure,
    and can then choose to do something with the output it receives before finally
    returning that output to the end user. Let’s look at some pseudocode to make this
    clearer ([Example 10-18](#EX1016)).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，响应是如何出来的？这可能比较难理解。应用程序返回一个响应，它通过中间件链返回上来——因为每个中间件都返回它的响应。因此，在同一个 `handle()`
    方法中，中间件可以修饰 `$request` 并将其传递给 `$next()` 闭包，然后可以选择在最终将该输出返回给最终用户之前对接收到的输出做一些处理。让我们看一些伪代码来澄清这一点（参见
    [Example 10-18](#EX1016)）。
- en: Example 10-18\. Pseudocode explaining the middleware call process
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-18\. 解释中间件调用过程的伪代码
- en: '[PRE26]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, let’s make the middleware do what we actually promised ([Example 10-19](#EX1017)).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们确保中间件实现我们实际承诺的功能（参见 [Example 10-19](#EX1017)）。
- en: Example 10-19\. Sample middleware banning the `DELETE` method
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-19\. 禁止 `DELETE` 方法的示例中间件
- en: '[PRE27]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Binding Middleware
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定中间件
- en: 'We’re not quite done yet. We need to register this middleware in one of two
    ways: globally or for specific routes.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。我们需要以两种方式之一注册此中间件：全局注册或特定路由注册。
- en: Global middleware are applied to every route; route middleware are applied on
    a route-by-route basis.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 全局中间件适用于每个路由；路由中间件则逐个路由应用。
- en: Binding global middleware
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定全局中间件
- en: Both bindings happen in *app/Http/Kernel.php*. To add a middleware as global,
    add its class name to the `$middleware` property, as in [Example 10-20](#EX1018).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种绑定都发生在 *app/Http/Kernel.php* 中。要将中间件作为全局添加，只需将其类名添加到 `$middleware` 属性中，如
    [Example 10-20](#EX1018) 所示。
- en: Example 10-20\. Binding global middleware
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-20\. 绑定全局中间件
- en: '[PRE28]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Binding route middleware
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定路由中间件
- en: Middleware intended for specific routes can be added as route middleware or
    as part of a middleware group. Let’s start with the former.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 用于特定路由的中间件可以作为路由中间件或作为中间件组的一部分添加。让我们从前者开始。
- en: Route middleware are added to the `$middlewareAliases` array in *app/Http/Kernel.php*.
    It’s similar to adding them to `$middleware`, except we have to give each one
    a key that will be used when applying this middleware to a particular route, as
    seen in [Example 10-21](#EX1019).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 路由中间件被添加到 *app/Http/Kernel.php* 的 `$middlewareAliases` 数组中。这类似于将它们添加到 `$middleware`，但我们必须为每一个中间件指定一个键，当将此中间件应用于特定路由时使用，正如在
    [Example 10-21](#EX1019) 中所见。
- en: Example 10-21\. Binding route middleware
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-21\. 绑定路由中间件
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We can now use this middleware in our route definitions, like in [Example 10-22](#EX1020).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在路由定义中使用这个中间件，就像在 [Example 10-22](#EX1020) 中所示。
- en: Example 10-22\. Applying route middleware in route definitions
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-22\. 在路由定义中应用路由中间件
- en: '[PRE30]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Using middleware groups
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用中间件组
- en: Middleware groups are essentially prepackaged bundles of middleware that make
    sense to be together in specific contexts.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件组本质上是在特定上下文中一起合理存在的预打包中间件束。
- en: Middleware Groups in Routes Files
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由文件中的中间件组
- en: Every route in *routes/web.php* is in the `web` middleware group. This *routes/web.php*
    file is specific for web routes and the *routes/api.php* file for API routes.
    If you want to add routes in other groups, read on.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '*routes/web.php* 中的每个路由都位于`web`中间件组中。 *routes/web.php* 文件专门用于web路由，而*routes/api.php*
    文件则用于API路由。如果您想要在其他组中添加路由，请继续阅读。'
- en: 'Out of the box, there are two groups: `web` and `api`. The `web` group has
    all the middleware that will be useful on almost every Laravel page request, including
    middleware for cookies, sessions, and CSRF protection. `api` has none of those—​it
    has a throttling middleware and a route model binding middleware, and that’s it.
    These are all defined in *app/Http/Kernel.php*.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 开箱即用，有两个组：`web`和`api`。 `web`组包含几乎每个Laravel页面请求都有用的所有中间件，包括用于cookies、sessions和CSRF保护的中间件。
    `api`组则没有这些——它包含一个节流中间件和一个路由模型绑定中间件，就这些。这些都在*app/Http/Kernel.php*中定义。
- en: 'You can apply middleware groups to routes just like you apply route middleware
    to routes, with the `middleware()` fluent method:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像向路由应用路由中间件一样，使用`middleware()`流畅方法向路由应用中间件组：
- en: '[PRE31]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: You can also create your own middleware groups and add and remove route middleware
    to and from preexisting middleware groups. It works just like adding route middleware
    normally, but you’re instead adding them to keyed groups in the `$middlewareGroups`
    array.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建自己的中间件组，并向预定义的中间件组添加和移除路由中间件。它的工作方式与通常添加路由中间件相同，但您是将它们添加到`$middlewareGroups`数组中的键组中。
- en: You might be wondering how these middleware groups match up with the two default
    route files. Unsurprisingly, the *routes/web.php* file is wrapped with the `web`
    middleware group, and the *routes/api.php* file is wrapped with the `api` middleware
    group.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道这些中间件组与两个默认路由文件的对应关系。毫不奇怪，*routes/web.php* 文件使用`web`中间件组包裹，而*routes/api.php*
    文件使用`api`中间件组包裹。
- en: The *routes/** files are loaded in the `RouteServiceProvider`. Take a look at
    the `map()` method there ([Example 10-23](#EX1021)) and you’ll find a `mapWebRoutes()`
    method and a `mapApiRoutes()` method, each of which loads its respective files
    already wrapped in the appropriate middleware group.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*routes/** 文件在`RouteServiceProvider`中加载。看一下那里的`map()`方法（[示例 10-23](#EX1021)），您会发现`mapWebRoutes()`方法和`mapApiRoutes()`方法，每个方法都已将其各自的文件加载并已包裹在适当的中间件组中。'
- en: Example 10-23\. Default route service provider
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-23\. 默认路由服务提供者
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see in [Example 10-23](#EX1021), we’re using the router to load a
    route group with the `web` middleware group, and another under the `api` middleware
    group.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在[示例 10-23](#EX1021)中使用路由器加载了一个路由组，其中包括`web`中间件组和`api`中间件组下的另一个路由组。
- en: Passing Parameters to Middleware
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将参数传递给中间件
- en: 'It’s not common, but there are times when you need to pass parameters to a
    route middleware. For example, you might have an authentication middleware that
    will act differently depending on whether you’re guarding for the `member` user
    type or the `owner` user type:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不常见，但有时您需要向路由中间件传递参数。例如，您可能有一个身份验证中间件，根据您是保护`member`用户类型还是`owner`用户类型而采取不同的操作：
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To make this work, you’ll need to add one or more parameters to the middleware’s
    `handle()` method and update that method’s logic accordingly, as shown in [Example 10-24](#EX10a).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此工作正常，您需要向中间件的`handle()`方法添加一个或多个参数，并相应地更新该方法的逻辑，如[示例 10-24](#EX10a)所示。
- en: Example 10-24\. Defining a route middleware that accepts parameters
  id: totrans-267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-24\. 定义接受参数的路由中间件
- en: '[PRE34]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Note that you can also add more than one parameter to the `handle()` method
    and pass multiple parameters to the route definition by separating them with commas:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还可以向`handle()`方法添加多个参数，并通过用逗号分隔它们将多个参数传递给路由定义：
- en: '[PRE35]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Default Middleware
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认中间件
- en: Laravel comes with quite a few middleware out of the box. Let’s take a look
    at each.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel默认提供了相当多的中间件。让我们一起来看看每个中间件。
- en: Maintenance Mode
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护模式
- en: Often we need to take our applications offline temporarily to perform some form
    of maintenance. Laravel offers tooling for this feature, called “Maintenance Mode,”
    and there’s a middleware that checks every response to see if the app is in that
    mode.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要临时将应用程序下线以执行某种形式的维护。Laravel 提供了名为“维护模式”的功能，并有一个中间件在每个响应中检查应用程序是否处于该模式下。
- en: 'You can enable maintenance mode for your app with the `down` Artisan command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `down` Artisan 命令为您的应用程序启用维护模式：
- en: '[PRE36]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`refresh`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`refresh`'
- en: Sends a header with the response to refresh the browser after the specified
    number of seconds.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 发送一个带有响应的头部，以指定秒数后刷新浏览器。
- en: '`retry`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry`'
- en: Sets the Retry-After header, with the specified number of seconds. Browsers
    usually ignore this header.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `Retry-After` 头部，带有指定的秒数。浏览器通常会忽略此头部。
- en: '`secret`'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`secret`'
- en: Sets a password to allow some users to bypass the maintenance mode. To bypass
    the maintenance mode navigate to your app URL followed by the secret you set (e.g.,
    *app.url/long-password*). This will redirect you to the */* app URL, while setting
    a bypass cookie on your browser, allowing you to access the application normally
    even while it’s in maintenance mode.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个密码，允许某些用户绕过维护模式。要绕过维护模式，请导航到您的应用程序 URL，后面跟着您设置的秘密（例如 *app.url/long-password*）。这将重定向您到
    */* 应用程序 URL，并在您的浏览器上设置一个绕过 cookie，允许您在应用程序处于维护模式时正常访问。
- en: 'To disable maintenance mode, use the `up` Artisan command:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用维护模式，请使用 `up` Artisan 命令：
- en: '[PRE37]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Rate Limiting
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速率限制
- en: 'If you need to limit users such that they can access any given route(s) only
    a certain number of times in a given time frame (called *rate limiting*, and most
    common with APIs), there’s an out-of-the-box middleware for that: `throttle`.
    [Example 10-25](#EX41.5) demonstrates its use, using the “api” `RateLimiter` preset
    Laravel ships with.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要限制用户在特定时间内只能访问某些路由的次数（称为*速率限制*，在API中最常见），那么 Laravel 提供了一个即用即有的中间件：`throttle`。[示例 10-25](#EX41.5)
    展示了它的使用，使用 Laravel 提供的“api” `RateLimiter` 预设。
- en: Example 10-25\. Applying the rate limiting middleware to a route
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-25\. 将速率限制中间件应用于路由
- en: '[PRE38]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can define as many custom `RateLimiter` configurations as you need; look
    at the `configureRateLimiting()` method of the `RouteServiceProvider` for the
    default `api` configuration, and also to create your own.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以定义尽可能多的自定义 `RateLimiter` 配置，查看 `RouteServiceProvider` 的 `configureRateLimiting()`
    方法以获取默认的 `api` 配置，也可以创建您自己的配置。
- en: As you can see in [Example 10-26](#EX1025), the default `api` configuration
    limits requests to 60 per minute, segmented by either the authenticated ID or,
    if the user is not logged in, the IP address.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 [示例 10-26](#EX1025) 中看到的，默认的 `api` 配置限制每分钟请求 60 次，分段为经过身份验证的 ID 或（如果用户未登录）IP
    地址。
- en: Example 10-26\. Default rate limiter definition
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-26\. 默认速率限制器定义
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can also customize the response that’s sent if the rate limit is hit, specify
    different rate limits based on user or application or request conditions, or even
    specify a stack of rate limiters that are applied in sequence. Take a look at
    [the rate limiting docs](https://oreil.ly/dEy4V) to learn more.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以自定义当速率限制达到时发送的响应，根据用户或应用程序或请求条件指定不同的速率限制，甚至指定一个依次应用的速率限制器堆栈。查看[速率限制文档](https://oreil.ly/dEy4V)以获取更多信息。
- en: Trusted Proxies
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 受信任的代理
- en: If you use any Laravel tools to generate URLs within the app, you’ll notice
    that Laravel detects whether the current request was via HTTP or HTTPS and generates
    links using the appropriate protocol.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用任何 Laravel 工具在应用程序内生成 URL，您会注意到 Laravel 检测当前请求是否通过 HTTP 或 HTTPS，并使用适当的协议生成链接。
- en: However, this doesn’t always work when you have a proxy (e.g., a load balancer
    or other web-based proxy) in front of your app. Many proxies send nonstandard
    headers like `X_FORWARDED_PORT` and `X_FORWARDED_PROTO` to your app, and expect
    your app to “trust” those, interpret them, and use them as a part of the process
    of interpreting the HTTP request. To make Laravel correctly treat proxied HTTPS
    calls like secure calls, and in order for Laravel to process other headers from
    proxied requests, you need to define how it should do so.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您的应用程序前面有代理（例如负载均衡器或其他基于Web的代理）时，这并不总是有效。许多代理会发送非标准的头部，如 `X_FORWARDED_PORT`
    和 `X_FORWARDED_PROTO` 到您的应用程序，并希望您的应用程序“信任”这些头部，解释它们，并将它们作为解释 HTTP 请求的一部分使用。为了使
    Laravel 正确地将代理的 HTTPS 调用视为安全调用，并且为了让 Laravel 处理来自代理请求的其他头部，您需要定义它应该如何处理。
- en: You likely don’t want to allow just *any* proxy to send traffic to your app;
    rather, you want to lock your app to only trust certain proxies, and even from
    those proxies you may only want to trust certain forwarded headers.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能不希望允许*任何*代理发送流量到您的应用程序；相反，您希望将您的应用程序锁定为仅信任特定代理，并且即使从这些代理中，您可能也只想信任某些转发头部。
- en: Laravel includes the [TrustedProxy package](https://oreil.ly/wYcDc), which makes
    it possible for you to mark certain sources of traffic as “trusted,” and also
    mark which forwarded headers you want to trust from those sources and how to map
    them to normal headers.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 包含了[TrustedProxy 包](https://oreil.ly/wYcDc)，它使您能够将某些流量源标记为“可信”，并标记您希望从这些源信任的转发头，并指定如何将它们映射到普通头部。
- en: To configure which proxies your app will trust, you can edit the `App\Http``\Middleware``\TrustProxies`
    middleware and add the IP address for your load balancer or proxy to the `$proxies`
    array, as shown in [Example 10-27](#EX10b).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置您的应用程序将信任哪些代理，您可以编辑 `App\Http\Middleware\TrustProxies` 中间件，并将负载均衡器或代理的 IP
    地址添加到 `$proxies` 数组中，如[示例 10-27](#EX10b)所示。
- en: Example 10-27\. Configuring the `TrustProxies` middleware
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 10-27\. 配置 `TrustProxies` 中间件
- en: '[PRE40]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, the `$headers` array defaults to trusting all forwarded headers
    from the trusted proxies; if you want to customize this list, take a look at the
    [Symfony docs on trusting proxies](https://oreil.ly/ur3bg).
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`$headers` 数组默认信任来自可信代理的所有转发头部；如果您想自定义此列表，请查看[Symfony 关于信任代理的文档](https://oreil.ly/ur3bg)。
- en: CORS
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CORS
- en: Hopefully you’ve never had a run in with CORS (cross-origin resource sharing).
    It’s one of those things that we hope always *just works*, and when it doesn’t,
    it’s painful.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您从未遇到 CORS（跨源资源共享）的问题。这是我们希望始终*正常运行*的事情之一，当它不起作用时，会令人痛苦。
- en: Laravel’s built-in CORS middleware runs by default and can be configured in
    *config/cors.php*. Its default configuration is reasonable for most apps, but
    in its config file you can exclude routes from CORS protection, modify the HTTP
    methods it operates on, and configure how it interacts with CORS headers.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的内置 CORS 中间件默认运行，并可以在*config/cors.php*中配置。它的默认配置对大多数应用程序都是合理的，但在其配置文件中，您可以排除
    CORS 保护的路由，修改它操作的 HTTP 方法，并配置它如何与 CORS 头部交互。
- en: Testing
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Outside of the context of you as a developer using requests, responses, and
    middleware in your own testing, Laravel itself actually uses each quite a bit.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您作为开发人员在自己的测试中使用请求、响应和中间件的上下文之外，Laravel 本身实际上也大量使用它们。
- en: 'When you’re doing application testing with calls like `$this->get(''/'')`,
    you’re instructing Laravel’s application testing framework to generate request
    objects that represent the interactions you’re describing. Then those request
    objects are passed to your application, as if they were actual visits. That’s
    why the application tests are so accurate: your application doesn’t actually “know”
    that it’s not a real user that’s interacting with it.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 当您像`$this->get('/')`这样使用应用程序测试调用时，您正在指示 Laravel 的应用程序测试框架生成代表您所描述交互的请求对象。然后，这些请求对象被传递给您的应用程序，就好像它们是实际访问一样。这就是为什么应用程序测试如此准确：您的应用程序实际上并不“知道”它正在与一个真实用户交互。
- en: In this context, many of the assertions you’re making—​say, `assertResponseOk()`—are
    assertions against the response object generated by the application testing framework.
    The `assertResponseOk()` method just looks at the response object and asserts
    that its `isOk()` method returns `true`—which is just checking that its status
    code is 200. In the end, *everything* in application testing is acting as if this
    were a real page request.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您进行的许多断言—比如`assertResponseOk()`—都是针对应用程序测试框架生成的响应对象的断言。`assertResponseOk()`
    方法只是查看响应对象，并断言其`isOk()` 方法返回`true`—这只是检查其状态码是否为 200。最终，在应用程序测试中，*一切*都像这是一个真实的页面请求一样运作。
- en: 'Find yourself in a context where you need a request to work with in your tests?
    You can always pull one from the container with `$request = request()`. Or you
    could create your own—the constructor parameters for the `Request` class, all
    optional, are as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 发现自己需要在测试中使用一个请求的上下文？您可以随时从容器中获取一个，使用 `$request = request()`。或者您可以自己创建一个—`Request`
    类的构造函数参数，所有参数都是可选的，如下所示：
- en: '[PRE41]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If you’re really interested in an example, check out the method Symfony uses
    to create a new `Request` from the globals PHP provides: `Symfony\Component\HttpFoundation\Request@createFromGlobals()`.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的对一个例子感兴趣，请查看 Symfony 用于从 PHP 提供的全局变量创建新 `Request` 的方法：`Symfony\Component\HttpFoundation\Request@createFromGlobals()`。
- en: '`Response` objects are even simpler to create manually, if you need to. Here
    are the (optional) parameters:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 对象如果需要手动创建，甚至更加简单。以下是（可选的）参数：'
- en: '[PRE42]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Finally, if you need to disable your middleware during an application test,
    import the `WithoutMiddleware` trait into that test. You can also use the `$this``->``withoutMiddleware()`
    method to disable middleware just for a single test method.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果在应用程序测试期间需要禁用中间件，请在该测试中导入 `WithoutMiddleware` 特性。你还可以使用 `$this->withoutMiddleware()`
    方法仅在单个测试方法中禁用中间件。
- en: TL;DR
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TL;DR
- en: Every request coming into a Laravel application is converted into an Illuminate
    `Request` object, which then passes through all the middleware and is processed
    by the application. The application generates a `Response` object, which is then
    passed back through all of the middleware (in reverse order) and returned to the
    end user.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 每个进入 Laravel 应用程序的请求都会转换为 Illuminate `Request` 对象，然后通过所有中间件并由应用程序处理。应用程序生成一个
    `Response` 对象，然后通过所有中间件（以相反的顺序）返回给最终用户。
- en: '`Request` and `Response` objects are responsible for encapsulating and representing
    every relevant piece of information about the incoming user request and the outgoing
    server response.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request` 和 `Response` 对象负责封装和表示关于传入用户请求和传出服务器响应的每一个相关信息。'
- en: Service providers gather together related behavior for binding and registering
    classes for use by the application.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 服务提供者汇集了绑定和注册类以供应用程序使用的相关行为。
- en: Middleware wrap the application and can reject or decorate any request and response.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件包裹应用程序，可以拒绝或装饰任何请求和响应。
- en: ^([1](ch10.html#id1407-marker)) Or an [ogre](https://oreil.ly/HQ1zL).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch10.html#id1407-marker)) 或者一个 [ogre](https://oreil.ly/HQ1zL)。
