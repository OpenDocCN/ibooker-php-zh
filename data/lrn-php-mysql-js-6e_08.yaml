- en: Chapter 5\. PHP Functions and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章 PHP 函数和对象
- en: The basic requirements of any programming language include somewhere to store
    data, a means of directing program flow, and a few bits and pieces such as expression
    evaluation, file management, and text output. PHP has all these, plus tools like
    `else` and `elseif` to make life easier. But even with all these in your toolkit,
    programming can be clumsy and tedious, especially if you have to rewrite portions
    of very similar code each time you need them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的基本要求包括存储数据的地方，指导程序流的方法，以及一些细节，如表达式评估、文件管理和文本输出。PHP 具备所有这些功能，还有像 `else`
    和 `elseif` 这样的工具，使生活更轻松。但即使在你的工具包中拥有所有这些，编程仍然可能笨拙和乏味，特别是在每次需要它们时必须重新编写非常相似的代码片段时。
- en: That’s where functions and objects come in. As you might guess, a *function*
    is a set of statements that performs a particular function and—optionally—returns
    a value. You can pull out a section of code that you have used more than once,
    place it into a function, and call the function by name when you want the code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和对象应运而生。正如你可能猜到的那样，*函数*是执行特定功能的一组语句，还可以选择性地返回一个值。当你需要使用多次的一段代码时，你可以将其放入一个函数中，并在需要时通过函数名调用该函数。
- en: 'Functions have many advantages over contiguous, inline code. For example, they:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 函数比连续的内联代码有很多优势。例如：
- en: Involve less typing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少输入量
- en: Reduce syntax and other programming errors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少语法和其他编程错误
- en: Decrease the loading time of program files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少程序文件的加载时间
- en: Decrease execution time, because each function is compiled only once, no matter
    how often you call it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少执行时间，因为每个函数只编译一次，无论调用多少次
- en: Accept arguments and can therefore be used for general as well as specific cases
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受参数，因此可以用于一般以及特定的情况
- en: Objects take this concept a step further. An *object* incorporates one or more
    functions, and the data they use, into a single structure called a *class*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对象进一步推进了这个概念。*对象*将一个或多个函数及其使用的数据合并到一个称为*类*的单一结构中。
- en: In this chapter, you’ll learn all about using functions, from defining and calling
    them to passing arguments back and forth. With that knowledge under your belt,
    you’ll start creating functions and using them in your own objects (where they
    will be referred to as *methods*).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用函数，从定义和调用到来回传递参数。掌握这些知识后，你将开始创建函数，并在自己的对象中使用它们（在这里它们被称为*方法*）。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is now highly unusual (and definitely not recommended) to use any version
    of PHP lower than 5.4\. Therefore, this chapter assumes that this release is the
    bare minimum version you will be working with. Generally I would recommend version
    5.6, or the new version 7.0 or 7.1 (there is no version 6). You can select any
    of these from the AMPPS control panel, as described in [Chapter 2](ch02.xhtml#setting_up_a_development_server).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用低于 PHP 5.4 的任何版本已经非常不常见（而且绝对不推荐）。因此，本章假设您将使用此版本作为最低版本。一般建议使用版本 5.6，或者新版本
    7.0 或 7.1（没有版本 6）。您可以从 AMPPS 控制面板中选择其中任何一个，如[第 2 章](ch02.xhtml#setting_up_a_development_server)所述。
- en: PHP Functions
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP 函数
- en: 'PHP comes with hundreds of ready-made, built-in functions, making it a very
    rich language. To use a function, call it by name. For example, you can see the
    `date` function in action here:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了数百个内置函数，使其成为一个非常丰富的语言。要使用函数，只需通过名称调用它。例如，你可以在这里看到 `date` 函数的运行效果：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The parentheses tell PHP that you’re referring to a function. Otherwise, it
    thinks you’re referring to a constant or variable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 括号告诉 PHP 你正在引用一个函数。否则，它会认为你在引用一个常量或变量。
- en: 'Functions can take any number of arguments, including zero. For example, `phpinfo`,
    as shown next, displays lots of information about the current installation of
    PHP and requires no argument:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以接受任意数量的参数，包括零个。例如，如下所示的 `phpinfo` 显示有关当前 PHP 安装的大量信息，并且不需要参数：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result of calling this function can be seen in [Figure 5-1](#phpinfo).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 调用该函数的结果可以在[图 5-1](#phpinfo)中看到。
- en: '![](Images/pmj6_0501.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pmj6_0501.png)'
- en: Figure 5-1\. The output of PHP’s built-in `phpinfo` function
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. PHP 内置函数 `phpinfo` 的输出
- en: Warning
  id: totrans-22
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `phpinfo` function is extremely useful for obtaining information about your
    current PHP installation, but that information could also be very useful to potential
    hackers. Therefore, never leave a call to this function in any web-ready code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`phpinfo` 函数非常有用，可以获取有关当前 PHP 安装的信息，但这些信息对潜在的黑客也可能非常有用。因此，在任何 Web 可用的代码中绝不要留下对此函数的调用。'
- en: Some of the built-in functions that use one or more arguments appear in [Example 5-1](#three_string_functions).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使用一个或多个参数的内置函数出现在[示例 5-1](https://example.org/three_string_functions)中。
- en: Example 5-1\. Three string functions
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 三个字符串函数
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This example uses three string functions to output the following text:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例使用三个字符串函数输出以下文本：
- en: '**`Hello world. Hip Hip HOORAY!`**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Hello world. Hip Hip HOORAY!`**'
- en: As you can see, the `strrev` function reversed the order of characters in the
    string, `str_repeat` repeated the string `"Hip "` twice (as required by the second
    argument), and `strtoupper` converted `"hooray!"` to uppercase.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`strrev`函数颠倒了字符串中字符的顺序，`str_repeat`重复了字符串`"Hip "`两次（根据第二个参数的要求），而`strtoupper`将`"hooray!"`转换为大写。
- en: Defining a Function
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个函数
- en: 'The general syntax for a function is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的一般语法如下：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first line of the syntax indicates the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 语法的第一行指示如下：
- en: A definition starts with the word `function`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义以`function`开头。
- en: A name follows, which must start with a letter or underscore, followed by any
    number of letters, numbers, or underscores.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称紧随其后，必须以字母或下划线开头，后跟任意数量的字母、数字或下划线。
- en: The parentheses are required.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 括号是必需的。
- en: One or more parameters, separated by commas, are optional (as indicated by the
    square brackets).
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个用逗号分隔的参数是可选的（如方括号所示）。
- en: 'Function names are case-insensitive, so all of the following strings can refer
    to the `print` function: `PRINT`, `Print`, and `PrInT`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名称不区分大小写，所以以下所有字符串都可以引用`print`函数：`PRINT`、`Print`和`PrInT`。
- en: The opening curly brace starts the statements that will execute when you call
    the function; a matching curly brace must close it. These statements may include
    one or more `return` statements, which force the function to cease execution and
    return to the calling code. If a value is attached to the `return` statement,
    the calling code can retrieve it, as we’ll see next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 开放大括号开始执行调用函数时会执行的语句；匹配的大括号必须结束它。这些语句可以包括一个或多个`return`语句，它们会强制函数停止执行并返回到调用代码。如果`return`语句附有值，调用代码可以检索它，我们将在接下来看到。
- en: Returning a Value
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回一个值
- en: Let’s take a look at a simple function to convert a person’s full name to lowercase
    and then capitalize the first letter of each part of the name.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个简单的函数，将一个人的全名转换为小写，然后将每个部分的第一个字母大写。
- en: 'We’ve already seen an example of PHP’s built-in `strtoupper` function in [Example 5-1](#three_string_functions).
    For our current function, we’ll use its counterpart, `strtolower`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[示例 5-1](https://example.org/three_string_functions)中看到了PHP内置的`strtoupper`函数的示例。对于我们当前的函数，我们将使用它的对应函数，`strtolower`：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of this experiment is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此实验的输出如下：
- en: '**`any # of letters and punctuation you want`**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**`any # of letters and punctuation you want`**'
- en: 'We don’t want names all lowercase, though; we want the first letter of each
    part of the sentence capitalized. (We’re not going to deal with subtle cases such
    as Mary-Ann or Jo-En-Lai for this example.) Luckily, PHP also provides a `ucfirst`
    function that sets the first character of a string to uppercase:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们不希望名字全部小写；我们希望将句子中每个部分的第一个字母大写。（对于这个示例，我们不打算处理Mary-Ann或Jo-En-Lai等细微情况。）幸运的是，PHP还提供了一个`ucfirst`函数，可以将字符串的第一个字符设为大写：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '**`    Any # of letters and punctuation you want`**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    Any # of letters and punctuation you want`**'
- en: 'Now we can do our first bit of program design: to get a word with its initial
    letter capitalized, we call `strtolower` on the string first and then `ucfirst`.
    The way to do this is to nest a call to `strtolower` within `ucfirst`. Let’s see
    why, because it’s important to understand the order in which code is evaluated.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进行第一步程序设计：将单词首字母大写，我们先调用`strtolower`函数将字符串转为小写，然后再调用`ucfirst`。这样做的方法是在`ucfirst`中嵌套调用`strtolower`。让我们看看为什么，因为理解代码评估顺序很重要。
- en: 'Say you make a simple call to the `print` function:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你简单调用`print`函数：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The expression `5-8` is evaluated first, and the output is `–3`. (As you saw
    in the previous chapter, PHP converts the result to a string in order to display
    it.) If the expression contains a function, that function is evaluated first as
    well:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`5-8`首先被评估，输出是`–3`。（如前一章所示，PHP将结果转换为字符串以便显示。）如果表达式包含一个函数，那么该函数也将首先被评估：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'PHP is doing several things in executing that short statement:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: PHP在执行这个简短语句时做了几件事情：
- en: Evaluate `5-8` to produce `–3`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估`5-8`以生成`–3`。
- en: Use the `abs` function to turn `–3` into `3`.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`abs`函数将`–3`转换为`3`。
- en: Convert the result to a string and output it using the `print` function.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将结果转换为字符串并使用`print`函数输出它。
- en: 'It all works because PHP evaluates each element from the inside out. The same
    procedure is in operation when we call the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都有效是因为PHP从内到外评估每个元素。当我们调用以下内容时，同样的过程正在进行：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'PHP passes our string to `strtolower` and then to `ucfirst`, producing (as
    we’ve already seen when we played with the functions separately):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: PHP将我们的字符串传递给`strtolower`，然后传递给`ucfirst`，生成的结果如我们分别使用这些函数时所见：
- en: '**`    Any # of letters and punctuation you want`**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    任意数量的字母和标点符号`**'
- en: Now let’s define a function (shown in [Example 5-2](#cleaning_up_a_full_name))
    that takes three names and makes each one lowercase, with an initial capital letter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们定义一个函数（显示在[示例 5-2](#cleaning_up_a_full_name)中），该函数接受三个名称并将每个名称转换为小写，并以大写字母开头。
- en: Example 5-2\. Cleaning up a full name
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. 清理完整姓名
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You may well find yourself writing this type of code, because users often leave
    their Caps Lock key on, accidentally insert capital letters in the wrong places,
    and even forget capitals altogether. The output from this example is shown here:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会发现自己写这种类型的代码，因为用户经常不小心将Caps Lock键保持打开状态，错误地插入大写字母，甚至完全忘记大写。此示例的输出如下所示：
- en: '**  `William Henry Gates`**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**  `William Henry Gates`**'
- en: Returning an Array
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回一个数组
- en: We just saw a function returning a single value. There are also ways of getting
    multiple values from a function.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到一个函数返回单个值。还有从函数中获取多个值的方法。
- en: The first method is to return them within an array. As you saw in [Chapter 3](ch03.xhtml#introduction_to_php),
    an array is like a bunch of variables stuck together in a row. [Example 5-3](#returning_multiple_values_in_an_array)
    shows how you can use an array to return function values.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是在一个数组中返回它们。正如你在[第 3 章](ch03.xhtml#introduction_to_php)中看到的那样，数组就像一排粘在一起的变量。[示例 5-3](#returning_multiple_values_in_an_array)展示了如何使用数组返回函数值。
- en: Example 5-3\. Returning multiple values in an array
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. 在数组中返回多个值
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method has the benefit of keeping all three names separate, rather than
    concatenating them into a single string, so you can refer to any user simply by
    first or last name without having to extract either name from the returned string.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的好处是保持所有三个名称分开，而不是将它们连接成一个字符串，因此你可以仅仅通过名字或姓氏来引用任何用户，而不必从返回的字符串中提取任何一个名称。
- en: Passing Arguments by Reference
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按引用传递参数
- en: In PHP versions prior to 5.3, you used to be able to preface a variable with
    the `&` symbol at the time of calling a function (for example, `increment(&$myvar);`)
    to tell the parser to pass a reference to the variable, not the variable’s value.
    This granted a function access to the variable (allowing different values to be
    written back to it).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 5.3之前的版本中，你可以在调用函数时用`&`符号作为变量的前缀（例如，`increment(&$myvar);`）告诉解析器传递变量的引用，而不是变量的值。这使函数可以访问变量（允许将不同的值写回到它）。
- en: Caution
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Call-time pass-by-reference was deprecated in PHP 5.3 and removed in PHP 5.4\.
    You should therefore not use this feature other than on legacy websites, and even
    there it is recommended you rewrite code that passes by reference, because it
    will halt with a fatal error on newer versions of PHP.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 5.3中弃用了调用时传递引用，而在PHP 5.4中移除了这个特性。因此，除了在旧版网站上，你不应该使用这个特性，即使在那里也建议重新编写传递引用的代码，因为在较新版本的PHP上会产生致命错误。
- en: However, *within* a function definition, you may continue to access arguments
    by reference. This concept can be hard to get your head around, so let’s go back
    to the matchbox metaphor from [Chapter 3](ch03.xhtml#introduction_to_php).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在函数定义内部，你仍然可以通过引用访问参数。这个概念可能很难理解，所以让我们回到[第 3 章](ch03.xhtml#introduction_to_php)中的火柴盒比喻。
- en: Imagine that instead of taking a piece of paper out of a matchbox, reading it,
    copying what’s on it onto another piece of paper, putting the original back, and
    passing the copy to a function (phew!) you could simply attach a piece of thread
    to the original piece of paper and pass one end of it to the function (see [Figure 5-2](#imagining_a_reference_as_a_thread_attach)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，不是从火柴盒里拿出一张纸，读取它，将上面的内容复制到另一张纸上，把原始的放回去，然后将复印件传递给一个函数（呼！），你可以简单地将一根线连接到原始的纸上，并将其一端传递给函数（参见[图 5-2](#imagining_a_reference_as_a_thread_attach)）。
- en: '![Imagining a reference as a thread attached to a variable](Images/pmj6_0502.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![将引用想象成连接到变量的线程](Images/pmj6_0502.png)'
- en: Figure 5-2\. Imagining a reference as a thread attached to a variable
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 想象一个参考作为附加到变量的线索
- en: Now the function can follow the thread to find the data to be accessed. This
    prevents all the overhead of creating a copy of the variable just for the function’s
    use. What’s more, the function can now modify the variable’s value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数可以跟随线索找到要访问的数据。这样可以避免为函数使用的变量创建副本的所有开销。更重要的是，函数现在可以修改变量的值。
- en: This means you can rewrite [Example 5-3](#returning_multiple_values_in_an_array)
    to pass references to all the parameters, and then the function can modify these
    directly (see [Example 5-4](#returning_values_from_a_function_by_refe)).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以重写 [示例 5-3](#returning_multiple_values_in_an_array)，将所有参数的引用传递，然后函数可以直接修改这些参数（参见
    [示例 5-4](#returning_values_from_a_function_by_refe)）。
- en: Example 5-4\. Passing values to a function by reference
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. 通过引用将值传递给函数
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Rather than passing strings directly to the function, you first assign them
    to variables and print them out to see their “before” values. Then you call the
    function as before, but within the function definition you place an `&` symbol
    in front of each parameter to be passed by reference.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与其直接将字符串传递给函数，不如先将它们分配给变量并打印出它们的“before”值。然后像以前一样调用函数，但在函数定义内部，您在每个参数前面放置一个
    `&` 符号以按引用传递。
- en: Now the variables `$n1`, `$n2`, and `$n3` are attached to “threads” that lead
    to the values of `$a1`, `$a2`, and `$a3`. In other words, there is one group of
    values, but two sets of variable names are allowed to access them.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量 `$n1`、`$n2` 和 `$n3` 都附加到通向 `$a1`、`$a2` 和 `$a3` 值的“线索”。换句话说，有一个值组，但允许两组变量名访问它们。
- en: 'Therefore, the function `fix_names` only has to assign new values to `$n1`,
    `$n2`, and `$n3` to update the values of `$a1`, `$a2`, and `$a3`. The output from
    this code is:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数 `fix_names` 只需要为 `$n1`、`$n2` 和 `$n3` 分配新值即可更新 `$a1`、`$a2` 和 `$a3` 的值。此代码的输出是：
- en: '**`    WILLIAM henry gatES William Henry Gates`**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    威廉·亨利·盖茨·威廉·亨利·盖茨`**'
- en: As you see, both of the `echo` statements use only the values of `$a1`, `$a2`,
    and `$a3`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，`echo` 语句只使用了 `$a1`、`$a2` 和 `$a3` 的值。
- en: Returning Global Variables
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回全局变量
- en: The better way to give a function access to an externally created variable that
    is not passed as an argument is by declaring it to have global access from within
    the function. The `global` keyword followed by the variable name gives every part
    of your code full access to it (see [Example 5-5](#returning_values_in_global_variables)).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 给函数访问外部创建的不作为参数传递的变量更好的方法是通过在函数内部声明具有全局访问权限。在变量名后面跟着 `global` 关键字可以让代码的每个部分都完全访问它（参见
    [示例 5-5](#returning_values_in_global_variables)）。
- en: Example 5-5\. Returning values in global variables
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 在全局变量中返回值
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now you don’t have to pass parameters to the function, and it doesn’t have to
    accept them. Once declared, these variables retain global access and are available
    to the rest of your program, including its functions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您不必将参数传递给函数，函数也不必接受它们。一旦声明，这些变量保留全局访问权限，并且可以在程序的其余部分（包括其函数）中使用。
- en: Recap of Variable Scope
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域回顾
- en: 'A quick reminder of what you know from [Chapter 3](ch03.xhtml#introduction_to_php):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾从 [第三章](ch03.xhtml#introduction_to_php) 中所知的内容：
- en: '*Local variables* are accessible just from the part of your code where you
    define them. If they’re outside of a function, they can be accessed by all code
    outside of functions, classes, and so on. If a variable is inside a function,
    only that function can access the variable, and its value is lost when the function
    returns.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*局部变量* 只能从定义它们的代码部分访问。如果它们在函数外部，则可以被所有函数外部的代码访问，包括类等。如果一个变量在函数内部，只有该函数可以访问该变量，并且当函数返回时其值会丢失。'
- en: '*Global variables* are accessible from all parts of your code, whether within
    or outside of functions.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*全局变量* 可以从代码的所有部分访问，无论是在函数内部还是外部。'
- en: '*Static variables* are accessible only within the function that declared them
    but retain their value over multiple calls.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*静态变量* 只能在声明它们的函数内部访问，但在多次调用之间保留它们的值。'
- en: Including and Requiring Files
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含和需要文件
- en: As you progress in your use of PHP programming, you are likely to start building
    a library of functions that you think you will need again. You’ll also probably
    start using libraries created by other programmers.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在您使用 PHP 编程时，您可能会开始构建您认为将来会再次使用的函数库。您还可能开始使用其他程序员创建的库。
- en: 'There’s no need to copy and paste these functions into your code. You can save
    them in separate files and use commands to pull them in. There are two commands
    to perform this action: `include` and `require`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要将这些函数复制粘贴到你的代码中。你可以将它们保存在单独的文件中，并使用命令将它们拉入。有两个命令可以执行此操作：`include` 和 `require`。
- en: The include Statement
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: include 语句
- en: Using `include`, you can tell PHP to fetch a particular file and load all its
    contents. It’s as if you pasted the included file into the current file at the
    insertion point. [Example 5-6](#including_a_php_file) shows how you would include
    a file called *library.php*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `include`，你可以告诉 PHP 获取一个特定文件并加载其所有内容。就好像你把包含的文件粘贴到当前文件的插入点一样。[示例 5-6](#including_a_php_file)
    展示了如何包含一个名为 *library.php* 的文件。
- en: Example 5-6\. Including a PHP file
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. 包含一个 PHP 文件
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using include_once
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 include_once
- en: Each time you issue the `include` directive, it includes the requested file
    again, even if you’ve already inserted it. For instance, suppose that *library.php*
    contains a lot of useful functions, so you include it in your file, but you also
    include another library that includes *library.php*. Through nesting, you’ve inadvertently
    included *library.php* twice. This will produce error messages, because you’re
    trying to define the same constant or function multiple times. So, you should
    use `include_once` instead (see [Example 5-7](#including_a_php_file_only_once)).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用 `include` 指令，即使已经插入过，也会再次包含请求的文件。例如，假设 *library.php* 包含许多有用的函数，你将它包含在你的文件中，但你还包含了另一个包含
    *library.php* 的库。通过嵌套，你无意中包含了 *library.php* 两次。这将产生错误消息，因为你尝试多次定义相同的常量或函数。所以，你应该使用
    `include_once` 替代（参见 [示例 5-7](#including_a_php_file_only_once)）。
- en: Example 5-7\. Including a PHP file only once
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-7\. 仅包含一次 PHP 文件
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then, any further attempts to include the same file (with `include` or `include_once`)
    will be ignored. To determine whether the requested file has already been executed,
    the absolute filepath is matched after all relative paths are resolved (to their
    absolute paths) and the file is found in your `include` path.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，任何进一步尝试包含同一文件（使用 `include` 或 `include_once`）都将被忽略。要确定请求的文件是否已执行，需要在解析所有相对路径（到它们的绝对路径）并在你的
    `include` 路径中找到文件后，匹配绝对文件路径。
- en: Note
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In general, it’s probably best to stick with `include_once` and ignore the basic
    `include` statement. That way, you will never have the problem of files being
    included multiple times.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，最好坚持使用 `include_once`，忽略基本的 `include` 语句。这样，你就永远不会遇到多次包含文件的问题。
- en: Using require and require_once
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 require 和 require_once
- en: A potential problem with `include` and `include_once` is that PHP will only
    *attempt* to include the requested file. Program execution continues even if the
    file is not found.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 和 `include_once` 的一个潜在问题是，PHP 只会 *尝试* 包含请求的文件。即使找不到文件，程序执行也会继续。'
- en: When it is absolutely essential to include a file, `require` it. For the same
    reasons I gave for using `include_once`, I recommend that you generally stick
    with `require_once` whenever you need to `require` a file (see [Example 5-8](#requiring_a_php_file_only_once)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当绝对需要包含文件时，使用 `require`。出于同样的原因，我建议你在需要 `require` 文件时通常坚持使用 `require_once`（参见
    [示例 5-8](#requiring_a_php_file_only_once)）。
- en: Example 5-8\. Requiring a PHP file only once
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-8\. 仅需要一次引入 PHP 文件
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: PHP Version Compatibility
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP 版本兼容性
- en: PHP is in an ongoing process of development, and there are multiple versions.
    If you need to check whether a particular function is available to your code,
    you can use the `function_exists` function, which checks all predefined and user-created
    functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 正在持续开发中，有多个版本。如果需要检查特定函数是否可用于你的代码，可以使用 `function_exists` 函数，该函数检查所有预定义和用户创建的函数。
- en: '[Example 5-9](#checking_for_a_functionapostrophes_exist) checks for `array_combine`,
    a function specific to only some versions of PHP.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-9](#checking_for_a_functionapostrophes_exist) 检查 `array_combine`，这是仅适用于某些
    PHP 版本的特定函数。'
- en: Example 5-9\. Checking for a function’s existence
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-9\. 检查函数是否存在
- en: '[PRE18]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Using code such as this, you can take advantage of features in newer versions
    of PHP and yet still have your code run on earlier versions where the newer features
    are unavailable, as long as you replicate any features that are missing. Your
    functions may be slower than the built-in ones, but at least your code will be
    much more portable.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的代码，你可以利用新版本 PHP 的功能，同时使你的代码在旧版本上运行，只要你复制了任何缺失的功能。你的函数可能比内置函数慢，但至少你的代码将更加可移植。
- en: 'You can also use the `phpversion` function to determine which version of PHP
    your code is running on. The returned result will be similar to the following,
    depending on the version:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`phpversion`函数来确定你的代码运行在哪个版本的PHP上。返回的结果将类似于以下内容，具体取决于版本：
- en: '**  8.0.0**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**  8.0.0**'
- en: PHP Objects
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP对象
- en: In much the same way that functions represent a huge increase in programming
    power over the early days of computing, where sometimes the best program navigation
    available was a very basic `GOTO` or `GOSUB` statement, *object-oriented programming*
    (OOP) takes the use of functions in a different direction.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就像函数代表着编程力量在计算机早期时代的巨大增长一样，在那些时代，有时候最好的程序导航只是一个非常基本的`GOTO`或`GOSUB`语句一样，*面向对象编程*（OOP）将函数的使用带入了不同的方向。
- en: Once you get the hang of condensing reusable bits of code into functions, it’s
    not that great a leap to consider bundling the functions and their data into objects.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了将可重用的代码片段压缩成函数的技巧，将这些函数及其数据打包成对象就不是那么大的飞跃了。
- en: Let’s take a social networking site that has many parts. One handles all user
    functions—that is, code to enable new users to sign up and existing users to modify
    their details. In standard PHP, you might create a few functions to handle this
    and embed some calls to the MySQL database to keep track of all the users.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个有很多部分的社交网络站点为例。其中一个部分处理所有用户功能——也就是说，用于启用新用户注册和现有用户修改其详细信息的代码。在标准的PHP中，你可能会创建一些函数来处理这些，并嵌入一些调用MySQL数据库的代码来跟踪所有用户。
- en: To create an object to represent the current user, you could create a class,
    perhaps called `User`, that would contain all the code required for handling users
    and all the variables needed for manipulating the data within the class. Then,
    whenever you need to manipulate a user’s data, you could simply create a new object
    with the `User` class.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个表示当前用户的对象，你可以创建一个类，也许叫做`User`，其中包含处理用户所需的所有代码以及操作类内部数据所需的所有变量。然后，每当需要操作用户数据时，你可以简单地使用`User`类创建一个新对象。
- en: You could treat this new object as if it were the actual user. For example,
    you could pass the object a name, password, and email address; ask it whether
    such a user already exists; and, if not, have it create a new user with those
    attributes. You could even have an instant messaging object, or one for managing
    whether two users are friends.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个新对象视为实际的用户。例如，你可以向对象传递姓名、密码和电子邮件地址；询问它是否已存在这样一个用户；如果不存在，让它使用这些属性创建一个新用户。你甚至可以有一个即时消息对象，或者用于管理两个用户是否是朋友的对象。
- en: Terminology
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语
- en: When creating a program to use objects, you need to design a composite of data
    and code called a *class*. Each new object based on this class is called an *instance*
    (or *occurrence*) of that class.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个使用对象的程序时，你需要设计一个称为*类*的数据和代码的复合体。基于这个类创建的每个新对象称为该类的*实例*（或*发生*）。
- en: The data associated with an object is called its *properties*; the functions
    it uses are called *methods*. In defining a class, you supply the names of its
    properties and the code for its methods. See [Figure 5-3](#jukebox_a_great_example_of_a_self-cont)
    for a jukebox metaphor for an object. Think of the CDs that it holds in the carousel
    as its properties; the method of playing them is to press buttons on the front
    panel. There is also a slot for inserting coins (the method used to activate the
    object) and a laser disc reader (the method used to retrieve the music, or properties,
    from the CDs).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象相关联的数据称为其*属性*；它所使用的函数称为*方法*。在定义一个类时，你提供其属性的名称和方法的代码。参见[图5-3](#jukebox_a_great_example_of_a_self-cont)关于一个对象的自动唱机比喻。想象一下它在旋转碟盘中保存的CD，就像是它的属性；播放它们的方法是在前面板上按按钮。还有一个插入硬币的槽口（用于激活对象的方法），以及一个激光唱片阅读器（用于从CD中检索音乐或属性的方法）。
- en: '![A jukebox: a great example of a self-contained object](Images/pmj6_0503.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![一个自包含对象的绝佳例子：自动唱机](Images/pmj6_0503.png)'
- en: 'Figure 5-3\. A jukebox: a great example of a self-contained object'
  id: totrans-140
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-3\. 一个自包含对象的绝佳例子：自动唱机
- en: When you’re creating objects, it is best to use *encapsulation*, or writing
    a class in such a way that only its methods can be used to manipulate its properties.
    In other words, you deny outside code direct access to its data. The methods you
    supply are known as the object’s *interface*.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建对象时，最好使用*封装*，或者以这样一种方式编写类，即只有其方法才能用于操作其属性。换句话说，你拒绝外部代码直接访问其数据。你提供的方法被称为对象的*接口*。
- en: 'This approach makes debugging easy: you have to fix faulty code only within
    a class. Additionally, when you want to upgrade a program, if you have used proper
    encapsulation and maintained the same interface, you can simply develop new replacement
    classes, debug them fully, and then swap them in for the old ones. If they don’t
    work, you can swap the old ones back in to immediately fix the problem before
    further debugging the new classes.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使得调试变得容易：你只需修复类内的错误代码。 另外，当你想要升级程序时，如果使用了适当的封装并保持了相同的接口，你只需开发新的替代类，彻底调试它们，然后替换旧类。
    如果它们不起作用，你可以重新替换旧类，立即修复问题，然后进一步调试新类。
- en: Once you have created a class, you may find that you need another class that
    is similar to it but not quite the same. The quick and easy thing to do is to
    define a new class using *inheritance*. When you do this, your new class has all
    the properties of the one it has inherited from. The original class is now called
    the *parent* (or occasionally the *superclass*), and the new one is the *subclass*
    (or *derived* class).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个类，你可能会发现你需要另一个类，它与之类似但不完全相同。 最快最简单的方法是使用*继承*定义一个新类。 当你这样做时，你的新类拥有从它继承的所有属性。
    原始类现在称为*父类*（或偶尔是*超类*），而新类则是*子类*（或*派生类*）。
- en: In our jukebox example, if you invent a new jukebox that can play a video along
    with the music, you can inherit all the properties and methods from the original
    jukebox superclass and add some new properties (videos) and new methods (a movie
    player).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的点唱机示例中，如果你发明了一个新的点唱机，它可以同时播放视频和音乐，你可以继承原始点唱机超类的所有属性和方法，并添加一些新属性（视频）和新方法（电影播放器）。
- en: An excellent benefit of this system is that if you improve the speed or any
    other aspect of the superclass, its subclasses will receive the same benefit. On
    the other hand, any change made to the parent/superclass could break the subclass.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统的一个显著优点是，如果你提高了超类的速度或任何其他方面，其子类将获得同样的好处。 另一方面，对父/超类进行的任何更改可能会破坏子类。
- en: Declaring a Class
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明类
- en: Before you can use an object, you must define a class with the `class` keyword.
    Class definitions contain the class name (which is case-sensitive), its properties,
    and its methods. [Example 5-10](#declaring_a_class_and_examining_an_objec) defines
    the class `User` with two properties, which are `$name` and `$password` (indicated
    by the `public` keyword—see [“Property and Method Scope”](#property_and_method_scope_in_php_5)).
    It also creates a new instance (called `$object`) of this class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以使用对象之前，你必须用`class`关键字定义一个类。 类定义包含类名（区分大小写），其属性和其方法。 [示例 5-10](#declaring_a_class_and_examining_an_objec)
    定义了`User`类，具有两个属性`$name`和`$password`（由`public`关键字指示—参见[“属性和方法范围”](#property_and_method_scope_in_php_5)）。
    它还创建了这个类的新实例（称为`$object`）。
- en: Example 5-10\. Declaring a class and examining an object
  id: totrans-148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-10\. 声明一个类并检查一个对象
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here I have also used an invaluable function called `print_r`. It asks PHP
    to display information about a variable in human-readable form. (The `_r` stands
    for *human-readable*.) In the case of the new object `$object`, it displays the
    following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我还使用了一个称为`print_r`的宝贵函数。 它要求PHP以人类可读的形式显示关于变量的信息。 （`_r`代表*人类可读*。） 在新对象`$object`的情况下，它显示如下内容：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'However, a browser compresses all the whitespace, so the output in a browser
    is slightly harder to read:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，浏览器会压缩所有空白字符，因此在浏览器中输出稍微难以阅读：
- en: '**`    User Object ( [name] => [password] => )`**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    用户对象（[name] => [password] => ）`**'
- en: In any case, the output says that `$object` is a user-defined object that has
    the properties `name` and `password`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，输出显示`$object`是一个具有属性`name`和`password`的用户定义对象。
- en: Creating an Object
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'To create an object with a specified class, use the `new` keyword, like this:
    `$object = new Class`. Here are a couple of ways in which we could do this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个具有指定类的对象，请使用`new`关键字，如此：`$object = new Class`。 这里有几种我们可以这样做的方式：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: On the first line, we simply assign an object to the `User` class. In the second,
    we pass arguments to the call.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们只是将一个对象分配给`User`类。 在第二行，我们向调用传递参数。
- en: A class may require or prohibit arguments; it may also allow arguments without
    explicitly requiring them.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可能需要或禁止参数； 它也可能允许不明确需要的参数。
- en: Accessing Objects
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问对象
- en: Let’s add a few lines to [Example 5-10](#declaring_a_class_and_examining_an_objec)
    and check the results. [Example 5-11](#creating_and_interacting_with_an_object)
    extends the previous code by setting object properties and calling a method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加几行到[示例 5-10](#declaring_a_class_and_examining_an_objec)，并检查结果。[示例 5-11](#creating_and_interacting_with_an_object)通过设置对象属性并调用方法扩展了先前的代码。
- en: Example 5-11\. Creating and interacting with an object
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-11\. 创建并与对象交互
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, the syntax for accessing an object’s property is *`$object->property`*.
    Likewise, you call a method like this: *`$object->method()`*.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，访问对象属性的语法是*`$object->property`*。同样，调用方法的方式是这样的：*`$object->method()`*。
- en: You should note that the example `property` and `method` do not have `$` signs
    in front of them. If you were to preface them with `$` signs, the code would not
    work, as it would try to reference the value inside a variable. For example, the
    expression `$object->$property` would attempt to look up the value assigned to
    a variable named `$property` (let’s say that value is the string `brown`) and
    then attempt to reference the property `$object->brown`. If `$property` is undefined,
    an attempt to reference `$object->NULL` would occur and cause an error.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意到，示例中的`property`和`method`并没有在它们前面加上`$`符号。如果您在它们前面加上`$`符号，代码将无法工作，因为它会尝试引用变量中的值。例如，表达式`$object->$property`会尝试查找分配给名为`$property`的变量的值（假设该值是字符串`brown`），然后尝试引用属性`$object->brown`。如果`$property`未定义，则会尝试引用`$object->NULL`并导致错误。
- en: 'When looked at using a browser’s View Source facility, the output from [Example 5-11](#creating_and_interacting_with_an_object)
    is as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器的查看源代码工具查看[示例 5-11](#creating_and_interacting_with_an_object)的输出如下：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Again, `print_r` shows its utility by providing the contents of `$object` before
    and after property assignment. From now on, I’ll omit `print_r` statements, but
    if you are working along with this book on your development server, you can put
    some in to see exactly what is happening.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`print_r`通过在属性分配之前和之后提供`$object`的内容来展示其实用性。从现在开始，我将省略`print_r`语句，但是如果您在开发服务器上跟随本书工作，可以添加一些语句以准确了解发生了什么。
- en: You can also see that the code in the method `save_user` was executed via the
    call to that method. It printed the string reminding us to create some code.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以看到，在方法`save_user`中的代码通过调用该方法而执行。它打印了一个提醒我们创建一些代码的字符串。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can place functions and class definitions anywhere in your code, before
    or after statements that use them. Generally, though, it is considered good practice
    to place them toward the end of a file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将函数和类定义放置在代码的任何位置，无论是在使用它们的语句之前还是之后。不过，通常认为将它们放置在文件的末尾是一种良好的实践。
- en: Cloning Objects
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 克隆对象
- en: Once you have created an object, it is passed by reference when you pass it
    as a parameter. In the matchbox metaphor, this is like keeping several threads
    attached to an object stored in a matchbox so that you can follow any attached
    thread to access it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了对象，在将其作为参数传递时，它将按引用传递。用火柴盒的比喻来说，这就像将几根线固定在一个放在火柴盒中的对象上，这样您就可以跟随任何附加的线来访问它。
- en: In other words, making object assignments does not copy objects in their entirety.
    You’ll see how this works in [Example 5-12](#copying_an_objectquestion_mark),
    where we define a very simple `User` class with no methods and only the property
    `name`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，对象分配并不复制对象的整体内容。您将在[示例 5-12](#copying_an_objectquestion_mark)中看到这是如何工作的，我们定义了一个非常简单的`User`类，没有方法，只有属性`name`。
- en: Example 5-12\. Copying an object
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-12\. 复制对象
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we first create the object `$object1` and assign the value `Alice` to
    the `name` property. Then we create `$object2`, assigning it the value of `$object1`,
    and assign the value `Amy` just to the `name` property of `$object2`—or so we
    might think. But this code outputs the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们首先创建对象`$object1`并将值`Alice`分配给`name`属性。然后，我们创建`$object2`，将其赋值为`$object1`的值，并仅将`Amy`赋值给`$object2`的`name`属性——或者我们可能会这样认为。但是，此代码输出如下：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What has happened? Both `$object1` and `$object2` refer to the *same* object,
    so changing the `name` property of `$object2` to `Amy` also sets that property
    for `$object1`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 发生了什么？`$object1`和`$object2`都指向*同一个*对象，因此将`$object2`的`name`属性更改为`Amy`也会为`$object1`设置该属性。
- en: To avoid this confusion, you can use the `clone` operator, which creates a new
    instance of the class and copies the property values from the original instance
    to the new instance. [Example 5-13](#cloning_an_object) illustrates this usage.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免混淆，可以使用`clone`操作符，它创建类的新实例，并从原始实例复制属性值到新实例中。[示例 5-13](#cloning_an_object)展示了这种用法。
- en: Example 5-13\. Cloning an object
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-13\. 克隆对象
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Voilà! The output from this code is what we initially wanted:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 瞧！这段代码的输出正是我们最初想要的：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Constructors
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: When creating a new object, you can pass a list of arguments to the class being
    called. These are passed to a special method within the class, called the *constructor*,
    which initializes various properties.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新对象时，你可以向被调用的类传递一系列参数。这些参数传递给类中的一个特殊方法，称为*构造方法*，它初始化各种属性。
- en: To do this you use the function name `__construct` (that is, `construct` preceded
    by two underscore characters), as in [Example 5-14](#creating_a_constructor_method).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你使用函数名`__construct`（即，`construct`前面加上两个下划线字符），就像在[示例 5-14](#creating_a_constructor_method)中一样。
- en: Example 5-14\. Creating a constructor method
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-14\. 创建构造方法
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Destructors
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 析构函数
- en: You also have the ability to create *destructor* methods. This ability is useful
    when code has made the last reference to an object or when a script reaches the
    end. [Example 5-15](#creating_a_destructor_method) shows how to create a destructor
    method. The destructor can do clean-up such as releasing a connection to a database
    or some other resource that you reserved within the class. Because you reserved
    the resource within the class, you have to release it here, or it will stick around
    indefinitely. Many system-wide problems are caused by programs reserving resources
    and forgetting to release them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以创建*析构*方法。当代码已经引用了一个对象或脚本达到结尾时，这个功能非常有用。[示例 5-15](#creating_a_destructor_method)展示了如何创建析构方法。析构函数可以进行清理工作，例如释放数据库连接或类中保留的其他资源。因为你在类中保留了资源，所以必须在这里释放它，否则它将无限期存在。许多系统-wide问题是由程序保留资源并忘记释放它们引起的。
- en: Example 5-15\. Creating a destructor method
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-15\. 创建析构方法
- en: '[PRE29]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Writing Methods
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写方法
- en: As you have seen, declaring a method is similar to declaring a function, but
    there are a few differences. For example, method names beginning with a double
    underscore (`__`) are reserved (for example, for `__construct` and `__destruct`),
    and you should not create any of this form.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，声明方法类似于声明函数，但有一些区别。例如，以双下划线 (`__`) 开头的方法名是保留的（例如，`__construct` 和 `__destruct`），你不应该创建这种形式的任何方法。
- en: You also have access to a special variable called `$this`, which can be used
    to access the current object’s properties. To see how it works, take a look at
    [Example 5-16](#using_the_variable_dollarthis_in_a_metho), which contains a different
    method from the `User` class definition called `get_password`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以访问一个特殊的变量称为`$this`，它可以用来访问当前对象的属性。要了解它是如何工作的，请看[示例 5-16](#using_the_variable_dollarthis_in_a_metho)，其中包含了`User`类定义中不同的方法`get_password`。
- en: Example 5-16\. Using the variable `$this` in a method
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-16\. 在方法中使用变量`$this`
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`get_password` uses the `$this` variable to access the current object and then
    return the value of that object’s `password` property. Note how the preceding
    `$` of the property `$password` is omitted when we use the `->` operator. Leaving
    the `$` in place is a typical error you may run into, particularly when you first
    use this feature.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_password`使用`$this`变量来访问当前对象，然后返回该对象的`password`属性的值。请注意，当我们使用`->`操作符时，前面的`$`符号在`$password`属性中被省略了。在首次使用此功能时，保留`$`可能是一个典型的错误。'
- en: 'Here’s how you would use the class defined in [Example 5-16](#using_the_variable_dollarthis_in_a_metho):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用在[示例 5-16](#using_the_variable_dollarthis_in_a_metho)中定义的类：
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This code prints the password `secret`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印出密码`secret`。
- en: Declaring Properties
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明属性
- en: It is not necessary to explicitly declare properties within classes, as they
    can be implicitly defined when first used. To illustrate this, in [Example 5-17](#defining_a_property_implicitly)
    the class `User` has no properties and no methods but is legal code.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中显式声明属性并不是必需的，因为它们可以在首次使用时隐式定义。为了说明这一点，在[示例 5-17](#defining_a_property_implicitly)中，`User`类没有属性和方法，但是这是合法的代码。
- en: Example 5-17\. Defining a property implicitly
  id: totrans-205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-17\. 隐式定义属性
- en: '[PRE32]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code correctly outputs the string `Alice` without a problem, because PHP
    implicitly declares the property `$object1->name` for you. But this kind of programming
    can lead to bugs that are infuriatingly difficult to discover, because `name`
    was declared from outside the class.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码正确输出字符串`Alice`，没有问题，因为PHP会隐式地为你声明属性`$object1->name`。但这种编程方式可能会导致极难发现的错误，因为`name`是从类外部声明的。
- en: To help yourself and anyone else who will maintain your code, I advise that
    you get into the habit of always declaring your properties explicitly within classes.
    You’ll be glad you did.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助自己和任何将来维护你代码的人，我建议你养成在类内部始终显式声明属性的习惯。你会为此感到高兴的。
- en: Also, when you declare a property within a class, you may assign a default value
    to it. The value you use must be a constant and not the result of a function or
    expression. [Example 5-18](#valid_and_invalid_property_declarations) shows a few
    valid and invalid assignments.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你在类内声明一个属性时，你可以为其分配一个默认值。你使用的值必须是一个常量，而不是函数或表达式的结果。[示例 5-18](#valid_and_invalid_property_declarations)展示了一些有效和无效的赋值。
- en: Example 5-18\. Valid and invalid property declarations
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-18\. 有效和无效的属性声明
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Declaring Constants
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明常量
- en: In the same way that you can create a global constant with the `define` function,
    you can define constants inside classes. The generally accepted practice is to
    use uppercase letters to make them stand out, as in [Example 5-19](#defining_constants_within_a_class).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用`define`函数创建全局常量一样，你也可以在类内部定义常量。普遍接受的做法是使用大写字母以突出它们的重要性，如[示例 5-19](#defining_constants_within_a_class)所示。
- en: Example 5-19\. Defining constants within a class
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-19\. 在类内定义常量
- en: '[PRE34]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You can reference constants directly, using the `self` keyword and double colon
    operator. Note that this code calls the class directly, using the double colon
    operator at line 1, without creating an instance of it first. As you would expect,
    the value printed when you run this code is `1`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接引用常量，使用`self`关键字和双冒号操作符。请注意，此代码在第1行直接调用类，而不是先创建实例。运行此代码时打印的值将是`1`。
- en: Remember that once you define a constant, you can’t change it.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，一旦定义了常量，就不能更改它。
- en: Property and Method Scope
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性和方法的作用域
- en: 'PHP provides three keywords for controlling the scope of properties and methods
    (*members*):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了三个关键字来控制属性和方法（*成员*）的作用域：
- en: <dfn class="keep-together">`public`</dfn>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`public`</dfn>
- en: Public members can be referenced anywhere, including by other classes and instances
    of the object. This is the default when variables are declared with the `var`
    or `public` keywords, or when a variable is implicitly declared the first time
    it is used. The keywords `var` and `public` are interchangeable because, although
    deprecated, `var` is retained for compatibility with previous versions of PHP.
    Methods are assumed to be `public` by default.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 公共成员可以在任何地方引用，包括其他类和对象的实例。这是使用`var`或`public`关键字声明变量时的默认值，或者在第一次使用变量时隐式声明的默认值。`var`和`public`关键字是可互换的，因为尽管`var`已被弃用，但为了与PHP的旧版本兼容，它仍然保留。方法默认被假定为`public`。
- en: <dfn class="keep-together">`protected`</dfn>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`protected`</dfn>
- en: These members can be referenced only by the object’s class methods and those
    of any subclasses.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员只能通过对象的类方法及其任何子类的方法引用。
- en: <dfn class="keep-together">`private`</dfn>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`private`</dfn>
- en: These members can be referenced only by methods within the same class—not by
    subclasses.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这些成员只能通过同一类内的方法引用，而不能通过子类引用。
- en: 'Here’s how to decide which you need to use:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何决定使用哪个：
- en: Use `public` when outside code *should* access this member and extending classes
    *should* also inherit it.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当外部代码*应该*访问此成员且扩展类也*应该*继承它时，请使用`public`。
- en: Use `protected` when outside code *should not* access this member but extending
    classes *should* inherit it.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当外部代码*不应该*访问此成员但扩展类*应该*继承它时，请使用`protected`。
- en: Use `private` when outside code *should not* access this member and extending
    classes also *should not* inherit it.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当外部代码*不应该*访问此成员且扩展类也*不应该*继承它时，请使用`private`。
- en: '[Example 5-20](#changing_property_and_method_scope) illustrates the use of
    these keywords.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-20](#changing_property_and_method_scope)说明了这些关键字的使用。'
- en: Example 5-20\. Changing property and method scope
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-20\. 改变属性和方法的作用域
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Static Methods
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态方法
- en: You can define a method as `static`, which means that it is called on a class,
    not on an object. A static method has no access to any object properties and is
    created and accessed as in [Example 5-21](#creating_and_accessing_a_static_method).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将方法定义为`static`，这意味着它是在类上调用而不是在对象上调用。静态方法无法访问任何对象属性，并且如在[示例 5-21](#creating_and_accessing_a_static_method)中所示创建和访问。
- en: Example 5-21\. Creating and accessing a static method
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-21\. 创建和访问静态方法
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note how we call the class itself, along with the static method, using a double
    colon (also known as the *scope resolution* operator), not `->`. Static functions
    are useful for performing actions relating to the class itself but not to specific
    instances of the class. You can see another example of a static method in [Example 5-19](#defining_constants_within_a_class).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何使用双冒号（也称为*作用域解析*运算符）而不是`->`来调用类本身以及静态方法。静态函数用于执行与类本身相关的操作，而不是特定类的实例。您可以在[示例 5-19](#defining_constants_within_a_class)中看到另一个静态方法的示例。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you try to access `$this->property`, or other object properties from within
    a static function, you will receive an error message.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试从静态函数内部访问`$this->property`或其他对象属性，将收到错误消息。
- en: Static Properties
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态属性
- en: Most data and methods apply to instances of a class. For example, in a `User`
    class, you want to do such things as set a particular user’s password or check
    when the user has been registered. These facts and operations apply separately
    to each user and therefore use instance-specific properties and methods.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据和方法适用于类的实例。例如，在`User`类中，您希望执行设置特定用户密码或检查用户注册时间等操作。这些事实和操作分别适用于每个用户，因此使用实例特定的属性和方法。
- en: But occasionally you’ll want to maintain data about a whole class. For instance,
    to report how many users are registered, you will store a variable that applies
    to the whole `User` class. PHP provides static properties and methods for such
    data.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 但偶尔您可能需要维护关于整个类的数据。例如，要报告注册用户的数量，您将存储一个适用于整个`User`类的变量。PHP提供了用于此类数据的静态属性和方法。
- en: As shown briefly in [Example 5-21](#creating_and_accessing_a_static_method),
    declaring members of a class `static` makes them accessible without an instantiation
    of the class. A property declared `static` cannot be directly accessed within
    an instance of a class, but a static method can.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如[示例 5-21](#creating_and_accessing_a_static_method)中简要显示的那样，声明类成员为`static`使它们可以在不实例化类的情况下访问。声明为`static`的属性无法在类的实例内直接访问，但静态方法可以。
- en: '[Example 5-22](#defining_a_class_with_a_static_property) defines a class called
    `Test` with a static property and a public method.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-22](#defining_a_class_with_a_static_property)定义了一个名为`Test`的类，其中包含一个静态属性和一个公共方法。'
- en: Example 5-22\. Defining a class with a static property
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-22\. 定义具有静态属性的类
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When you run this code, it returns the following output:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码时，将返回以下输出：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This example shows that the property `$static_property` could be directly referenced
    from the class itself via the double colon operator in Test A. Also, Test B could
    obtain its value by calling the `get_sp` method of the object `$temp`, created
    from class `Test`. But Test C failed, because the static property `$static_property`
    was not accessible to the object `$temp`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例显示，通过 Test A 中的双冒号运算符，可以直接从类本身引用属性`$static_property`。另外，Test B 可以通过从类`Test`创建的对象`$temp`调用`get_sp`方法来获取其值。但是，Test
    C 失败了，因为对象`$temp`无法访问静态属性`$static_property`。
- en: Note how the method `get_sp` accesses `$static_property` using the keyword `self`.
    This is how a static property or constant can be directly accessed within a class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注意方法`get_sp`如何使用关键字`self`访问`$static_property`。这是在类内部直接访问静态属性或常量的方式。
- en: Inheritance
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'Once you have written a class, you can derive subclasses from it. This can
    save lots of painstaking code rewriting: you can take a class similar to the one
    you need to write, extend it to a subclass, and just modify the parts that are
    different. You achieve this using the `extends` keyword.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 定义类后，可以从中派生子类。这可以节省大量费力的代码重写：您可以取一个与您需要编写的类类似的类，将其扩展为子类，并仅修改不同的部分。您可以使用`extends`关键字来实现这一点。
- en: In [Example 5-23](#inheriting_and_extending_a_class), the class `Subscriber`
    is declared a subclass of `User` by means of the `extends` keyword.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 5-23](#inheriting_and_extending_a_class)中，类`Subscriber`通过`extends`关键字声明为`User`的子类。
- en: Example 5-23\. Inheriting and extending a class
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-23\. 继承和扩展类
- en: '[PRE39]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The original `User` class has two properties, `$name` and `$password`, and
    a method to save the current user to the database. `Subscriber` extends this class
    by adding an additional two properties, `$phone` and `$email`, and includes a
    method of displaying the properties of the current object using the variable `$this`,
    which refers to the current values of the object being accessed. The output from
    this code is as follows:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 原始`User`类具有两个属性，`$name`和`$password`，以及一个将当前用户保存到数据库的方法。 `Subscriber`通过添加另外两个属性`$phone`和`$email`来扩展此类，并包括使用变量`$this`显示当前对象属性的方法，该变量引用正在访问的对象的当前值。
    此代码的输出如下：
- en: '**`    Name:  Fred     Pass:  pword     Phone: 012 345 6789     Email: fred@bloggs.com`**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    名称:  弗雷德     密码:  密码     电话: 012 345 6789     电子邮件: fred@bloggs.com`**'
- en: The parent keyword
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 父关键字
- en: If you write a method in a subclass with the same name as one in its parent
    class, its statements will override those of the parent class. Sometimes this
    is not the behavior you want, and you need to access the parent’s method. To do
    this, you can use the `parent` operator, as in [Example 5-24](#overriding_a_method_and_using_the_parent).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在子类中编写与父类中同名的方法，其语句将覆盖父类的语句。 有时这不是您想要的行为，您需要访问父方法。 为此，可以使用`parent`运算符，如[示例 5-24](#overriding_a_method_and_using_the_parent)。
- en: Example 5-24\. Overriding a method and using the `parent` operator
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-24\. 覆盖方法并使用`parent`运算符
- en: '[PRE40]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code creates a class called `Dad` and a subclass called `Son` that inherits
    its properties and methods and then overrides the method `test`. Therefore, when
    line 2 calls the method `test`, the new method is executed. The only way to execute
    the overridden `test` method in the `Dad` class is to use the `parent` operator,
    as shown in function `test2` of class `Son`. The code outputs the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码创建了一个名为`Dad`的类和一个名为`Son`的子类，后者继承了其属性和方法，然后覆盖了方法`test`。 因此，当第2行调用方法`test`时，将执行新方法。
    要执行`Dad`类中重写的`test`方法的唯一方法是使用`parent`运算符，如`Son`类的`test2`函数所示。 代码输出如下：
- en: '`**    [Class Son] I am Luke**`'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`**    [类儿子] 我是卢克**`'
- en: '`**    [Class Dad] I am your Father**`'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`**    [类爸爸] 我是你的父亲**`'
- en: 'If you wish to ensure that your code calls a method from the current class,
    you can use the `self` keyword, like this:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望确保您的代码调用当前类的方法，可以使用`self`关键字，如下所示：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Subclass constructors
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子类构造函数
- en: When you extend a class and declare your own constructor, you should be aware
    that PHP will not automatically call the constructor method of the parent class.
    If you want to be certain that all initialization code is executed, subclasses
    should always call the parent constructors, as in [Example 5-25](#calling_the_parent_class_constructor).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当您扩展一个类并声明自己的构造函数时，应该意识到PHP不会自动调用父类的构造函数。 如果希望确保执行所有初始化代码，子类应始终调用父类构造函数，如[示例 5-25](#calling_the_parent_class_constructor)。
- en: Example 5-25\. Calling the parent class constructor
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-25\. 调用父类构造函数
- en: '[PRE42]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This example takes advantage of inheritance in the typical manner. The `Wildcat`
    class has created the property `$fur`, which we’d like to reuse, so we create
    the `Tiger` class to inherit `$fur` and additionally create another property,
    `$stripes`. To verify that both constructors have been called, the program outputs
    the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例以典型方式利用继承。 `Wildcat`类创建了属性`$fur`，我们希望重用该属性，因此我们创建了`Tiger`类来继承`$fur`并额外创建了另一个属性`$stripes`。
    为了验证已调用两个构造函数，程序输出如下：
- en: '**`    Tigers have...     Fur: TRUE     Stripes: TRUE`**'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    老虎有...     毛皮: TRUE     条纹: TRUE`**'
- en: Final methods
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最终方法
- en: When you wish to prevent a subclass from overriding a superclass method, you
    can use the `final` keyword. [Example 5-26](#creating_a_final_method) shows how.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 当你希望防止子类覆盖超类方法时，可以使用`final`关键字。 [示例 5-26](#creating_a_final_method) 演示了如何使用。
- en: Example 5-26\. Creating a `final` method
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-26\. 创建一个`final`方法
- en: '[PRE43]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you have digested the contents of this chapter, you should have a strong
    feel for what PHP can do for you. You should be able to use functions with ease
    and, if you wish, write object-oriented code. In [Chapter 6](ch06.xhtml#php_arrays),
    we’ll finish off our initial exploration of PHP by looking at the workings of
    PHP arrays.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您消化了本章的内容，您应该对PHP能为您做什么有很强的感觉。 您应该能够轻松使用函数，并且如果希望，编写面向对象的代码。 在[第6章](ch06.xhtml#php_arrays)中，我们将通过查看PHP数组的工作方式来完成我们对PHP的初步探索。
- en: Questions
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the main benefit of using a function?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用函数的主要好处是什么？
- en: How many values can a function return?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数可以返回多少个值？
- en: What is the difference between accessing a variable by name and by reference?
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过名称和引用访问变量之间有什么区别？
- en: What is the meaning of *scope* in PHP?
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*作用域*在 PHP 中的含义是什么？'
- en: How can you incorporate one PHP file within another?
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在一个 PHP 文件中引用另一个？
- en: How is an object different from a function?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象与函数有何不同？
- en: How do you create a new object in PHP?
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 PHP 中创建一个新对象？
- en: What syntax would you use to create a subclass from an existing one?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用什么语法可以从现有类创建一个子类？
- en: How can you cause an object to be initialized when you create it?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在创建对象时使其初始化？
- en: Why is it a good idea to explicitly declare properties within a class?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 明确在类中声明属性是个好主意的原因是什么？
- en: See [“Chapter 5 Answers”](app01_split_004.xhtml#chapter_5_answers) in the [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions)
    for the answers to these questions.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[“第 5 章答案”](app01_split_004.xhtml#chapter_5_answers)，可以找到这些问题的答案。
