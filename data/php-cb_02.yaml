- en: Chapter 2\. Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. 运算符
- en: While [Chapter 1](ch01.html#chapter_variables) introduced the foundational building
    blocks of PHP—variables to store arbitrary values—these building blocks are useless
    without some kind of glue to hold them together. This glue is the set of [*operators*](https://oreil.ly/Vepfg)
    established by PHP. Operators are the way you tell PHP what to do with certain
    values—specifically how to change one or more values into a new, discrete value.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [第一章](ch01.html#chapter_variables) 介绍了 PHP 的基础构建模块——用于存储任意值的变量，但是这些构建模块如果没有某种粘合剂来将它们连接在一起将毫无用处。这个粘合剂就是
    PHP 确立的 [*运算符*](https://oreil.ly/Vepfg) 集合。运算符是告诉 PHP 如何处理特定值的方式——具体来说是如何将一个或多个值转换为新的、离散的值。
- en: In almost every case, an operator in PHP is represented by a single character
    or by repeated uses of that same character. In a handful of cases, operators can
    also be represented by literal English words, which helps disambiguate what the
    operator is trying to accomplish.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，PHP 中的运算符都由单个字符或重复使用该字符来表示。在少数情况下，运算符也可以用文字的英文单词来表示，这有助于消除运算符试图实现的功能的歧义。
- en: This book does not attempt to cover every operator leveraged by PHP; for exhaustive
    explanations of each, refer to the [PHP Manual itself](https://oreil.ly/YGWyE).
    Instead, the following few sections cover some of the most important logical,
    bitwise, and comparison operators before diving into more concrete problems, solutions,
    and examples.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不试图覆盖 PHP 利用的每一个运算符；关于每个运算符的详尽解释，请参阅[PHP 手册本身](https://oreil.ly/YGWyE)。相反，接下来的几节将介绍一些最重要的逻辑、位和比较运算符，然后深入探讨更具体的问题、解决方案和示例。
- en: Logical Operators
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: '*Logical operations* are the components of PHP that create truth tables and
    define basic and/or/not grouping criteria. [Table 2-1](#table_logical_operators)
    enumerates all of the character-based logical operators supported by PHP.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*逻辑操作* 是 PHP 中创建真值表并定义基本的与/或/非分组条件的组成部分。[表 2-1](#table_logical_operators) 枚举了
    PHP 支持的所有基于字符的逻辑运算符。'
- en: Table 2-1\. Logical operators
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. 逻辑运算符
- en: '| Expression | Operator name | Result | Example |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 运算符名称 | 结果 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| $x && $y | and | `true` if both `$x` and `$y` are `true` | `true && true
    == true` |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| $x && $y | and | 如果 `$x` 和 `$y` 都为 `true`，则为 `true` | `true && true == true`
    |'
- en: '| $x &#124;&#124; $y | or | `true` if either `$x` or `$y` is `true` | `true
    &#124;&#124; false == true` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| $x &#124;&#124; $y | or | 如果 `$x` 或 `$y` 有一个为 `true`，则为 `true` | `true &#124;&#124;
    false == true` |'
- en: '| !$x | not | `true` if `$x` is `false` (and vice versa) | `!true == false`
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| !$x | not | 如果 `$x` 为 `false`，则为 `true`（反之亦然） | `!true == false` |'
- en: 'The logical operators `&&` and `||` have English word counterparts: `and` and
    `or`, respectively. The statement `($x and $y)` is functionally equivalent to
    `($x && $y)`. The word `or` can likewise be used in place of the `||` operator
    without changing the functionality of the expression.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符 `&&` 和 `||` 有其英文单词对应形式：分别是 `and` 和 `or`。语句 `($x and $y)` 在功能上等同于 `($x
    && $y)`。单词 `or` 同样可以用来替代 `||` 运算符，而不会改变表达式的功能。
- en: The word `xor` can also be used to represent a special *exclusive or* operator
    in PHP that evaluates to `true` if one of the two values in the expression is
    `true`, but not when both are `true`. Unfortunately, the logical XOR operation
    has no character equivalent in PHP.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单词 `xor` 也可以用来表示 PHP 中的特殊 *异或* 运算符，如果表达式中的两个值中有一个为 `true`，则结果为 `true`，但当两者都为
    `true` 时结果为 `false`。不幸的是，逻辑异或操作在 PHP 中没有字符等效项。
- en: Bitwise Operators
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算符
- en: PHP supports operations against specific bits in an integer, a feature that
    makes the language quite versatile. Supporting bitwise operations means PHP is
    not limited to web applications but can operate on binary files and data structures
    with ease! It’s worth mentioning these operators in the same section as the preceding
    logical operators as they appear somewhat similar in terms of terminology with
    `and`, `or`, and `xor`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 支持对整数进行特定位的操作，这一特性使得该语言非常灵活。支持位运算意味着 PHP 不仅仅局限于 Web 应用程序，而是可以轻松地在二进制文件和数据结构上进行操作！值得一提的是，这些运算符与
    `and`、`or` 和 `xor` 在术语上看起来有些相似，因此将它们放在前面逻辑运算符的同一节中是合理的。
- en: Whereas logical operators return `true` or `false` based on the comparison between
    two whole values, bitwise operators actually perform bitwise arithmetic on integers
    and return the result of that full calculation over the integer or integers provided.
    For a specific example of how this can be useful, skip ahead to [Recipe 2.6](#bitwise_arithmetic).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 而逻辑运算符基于两个整数值之间的比较返回`true`或`false`，位运算符实际上对整数执行位运算，并返回提供的整数或整数的完整计算结果。关于这可以如何有用的具体示例，请跳转至[配方2.6](#bitwise_arithmetic)。
- en: '[Table 2-2](#table_bitwise_operators) illustrates the various bitwise operators
    in PHP, what they do, and a quick example of how they work on simple integers.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-2](#table_bitwise_operators)展示了PHP中各种位运算符的功能，以及它们在简单整数上的快速示例。'
- en: Table 2-2\. Bitwise operators
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-2\. 位运算符
- en: '| Expression | Operator name | Result | Example |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 运算符名称 | 结果 | 示例 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `$x & $y` | and | Returns bits set in both `$x` and `$y` | `5 & 1 == 1` |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `$x & $y` | 与 | 返回同时在`$x`和`$y`中设置的位 | `5 & 1 == 1` |'
- en: '| `$x &#124; $y` | or | Returns bits set in either `$x` or `$y` | `4 &#124;
    1 == 5` |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `$x &#124; $y` | 或 | 返回在`$x`或`$y`中设置的位 | `4 &#124; 1 == 5` |'
- en: '| `$x ^ $y` | xor | Returns bits set in only `$x` or `$y` | `5 ^ 3 == 6` |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `$x ^ $y` | 异或 | 返回仅在`$x`或`$y`中设置的位 | `5 ^ 3 == 6` |'
- en: '| `~ $x` | not | Inverts bits that are set in `$x` | `~ 4 == -5` |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `~ $x` | 非 | 反转`$x`中被设置的位 | `~ 4 == -5` |'
- en: '| `$x << $y` | shift left | Shift the bits of `$x` to the left by `$y` steps
    | `4 << 2 == 16` |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `$x << $y` | 左移 | 将`$x`的位向左移动`$y`步 | `4 << 2 == 16` |'
- en: '| `$x >> $y` | shift right | Shift the bits of `$x` to the right by `$y` steps
    | `4 >> 2 == 1` |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `$x >> $y` | 右移 | 将`$x`的位向右移动`$y`步 | `4 >> 2 == 1` |'
- en: In PHP, the largest integer you can have depends on the size of the processor
    running the application. In any case, the constant `PHP_INT_MAX` will tell you
    how large integers can be—2147483647 on 32-bit machines and 9223372036854775807
    on 64-bit machines. In both cases, this number is represented, in binary, as a
    long string of 1s equal in length to one less than the bit size. On a 32-bit machine,
    2147483647 is represented by 31 1s. The leading bit (a `0` by default) is used
    to identify the *sign* of the integer. If the bit is `0`, the integer is positive;
    if the bit is `1`, the integer is negative.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，您可以拥有的最大整数取决于运行应用程序的处理器大小。在任何情况下，常量`PHP_INT_MAX`将告诉您整数可以有多大——在32位机器上为2147483647，在64位机器上为9223372036854775807。在这两种情况下，这个数字以二进制表示，长长的是比位大小少一位的1。在32位机器上，2147483647由31个1表示。前导位（默认为0）用于标识整数的*符号*。如果位为`0`，整数为正数；如果位为`1`，整数为负数。
- en: On any machine, the number 4 is represented in binary as `100`, with enough
    0s to the left of the most significant digit to fill the bit size of the processor.
    On a 32-bit system, this would be 29 0s. To make the integer *negative*, you would
    represent it instead as a 1 followed by 28 0s followed by `100`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何机器上，数字4的二进制表示为`100`，左边有足够的0填充处理器的位大小。在32位系统上，这将是29个0。要使整数为*负数*，您应该将其表示为1后跟28个0，再跟`100`。
- en: For simplicity, consider a 16-bit system. The integer 4 would be represented
    as `0000000000000100`. Likewise, a negative 4 would be represented as `100000000​0000100`.
    If you were to apply the bitwise *not* operator (`~`) on a positive 4 in a 16-bit
    system, all of the 0s would become 1s and vice versa. This would turn your number
    into `1111111111111011`, which on a 16-bit system is −5.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简单起见，考虑一个16位系统。整数4表示为`0000000000000100`。同样，负数4表示为`1000000000000100`。如果在16位系统中对正数4应用位非运算符(`~`)，所有的0将变成1，反之亦然。这将把你的数字变成`1111111111111011`，在16位系统中表示为−5。
- en: Comparison Operators
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: The core of any programming language is the level of control that language has
    to branch based on specific conditions. In PHP, much of this branching logic is
    controlled by comparing two or more values with one another. It is the set of
    [comparison operators provided by PHP](https://oreil.ly/QuPhV), provide most of
    the advanced branching functionality used to build complex applications.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言的核心是语言根据特定条件进行分支控制的能力。在PHP中，许多分支逻辑是通过比较两个或更多值来控制的。这是由PHP提供的[比较运算符](https://oreil.ly/QuPhV)，提供了用于构建复杂应用程序的大多数高级分支功能。
- en: '[Table 2-3](#table_comparison_operators) lists the scalar comparison operators
    considered to be the most vital to understand PHP. The other operators (greater
    than, less than, and variants) are somewhat standard among programming languages
    and are not necessary to any of the recipes in this chapter.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-3](#table_comparison_operators)列出了被认为是最重要的PHP标量比较运算符。其他运算符（大于、小于和变体）在编程语言中有些标准，并且对本章中的任何配方都不是必需的。'
- en: Table 2-3\. Comparison operators
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-3\. 比较运算符
- en: '| Expression | Operation | Result |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 操作 | 结果 |'
- en: '| --- | --- | --- |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `$x == $y` | Equal | Returns `true` if both values are the same after coercing
    into the same type |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `$x == $y` | 相等 | 如果两个值在强制转换为相同类型后相同则返回`true` |'
- en: '| `$x === $y` | Identical | Returns `true` if both values are the same *and*
    are of the same type |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `$x === $y` | 相同 | 如果两个值相同且类型相同则返回`true` |'
- en: '| `$x <=> $y` | Spaceship | Returns `0` is both values are equal, `1` if `$x`
    is greater, or `-1` if `$y` is greater |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `$x <=> $y` | 太空船 | 如果两个值相等则返回`0`，如果`$x`大则返回`1`，如果`$y`大则返回`-1` |'
- en: When dealing with objects, the equality and identity operators work somewhat
    differently. Two objects are considered equal (`==`) if they have the same internal
    structure (same attributes and values) and are of the same type (class). Objects
    are considered identical (`===`) if and only if they are references to the same
    instance of a class. These are stricter requirements than those for comparing
    scalar values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理对象时，相等性和身份运算符的工作方式略有不同。如果两个对象具有相同的内部结构（相同的属性和值）并且是相同类型（类），则认为它们相等（`==`）。仅当它们是对同一个类实例的引用时，才认为对象是相同的（`===`）。这些要求比比较标量值的要求更严格。
- en: Type Casting
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: While the name of a type is not formally an operator, you can use it to explicitly
    cast a value as that type. Simply write the name of the type within parentheses
    before the value to force a conversion. [Example 2-1](#type_juggling) converts
    a simple integer value to various other types prior to using the value.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然类型的名称在形式上不是运算符，但您可以使用它来将一个值明确转换为该类型。只需在值之前的括号中写入类型的名称，即可强制转换。[示例 2-1](#type_juggling)在使用该值之前将一个简单的整数值转换为各种其他类型。
- en: Example 2-1\. Casting values as other types
  id: totrans-42
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-1\. 将值转换为其他类型
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'PHP supports the following type casts:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: PHP支持以下类型转换：
- en: '`(int)`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`(整数)`'
- en: Cast to `int`
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为`整数`
- en: '`(bool)`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`(布尔)`'
- en: Cast to `bool`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为`布尔`
- en: '`(float)`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`(浮点数)`'
- en: Cast to `float`
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为`浮点数`
- en: '`(string)`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`(字符串)`'
- en: Cast to `string`
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为`字符串`
- en: '`(array)`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`(数组)`'
- en: Cast to `array`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为`数组`
- en: '`(object)`'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`(对象)`'
- en: Cast to `object`
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为`对象`
- en: It’s also possible to use `(integer)` as an alias of `(int)`, `(boolean)` as
    an alias of `(bool)`, `(real)` or `(double)` as aliases of `(float)`, and `(binary)`
    as an alias of `(string)`. These aliases will make the same type casts as in the
    preceding list, but given that they don’t use the name of the type to which you’re
    casting, this approach is not recommended.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`(整数)`作为`(int)`的别名，`(布尔)`作为`(bool)`的别名，`(实数)`或`(双精度)`作为`(float)`的别名，`(二进制)`作为`(字符串)`的别名。这些别名将执行与前面列表中相同的类型转换，但由于它们不使用您要转换的类型的名称，因此不建议使用这种方法。
- en: The recipes in this chapter introduce ways to leverage PHP’s most important
    comparison and logical operators.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的配方介绍了如何利用PHP最重要的比较和逻辑运算符。
- en: 2.1 Using a Ternary Operator Instead of an If-Else Block
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.1 使用三元运算符代替if-else块
- en: Problem
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to provide an either-or branching condition to assign a specific value
    to a variable in a single line of code.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在一行代码中提供一个二选一的分支条件，以将特定值分配给一个变量。
- en: Solution
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Using a *ternary operator* (`*a* ? *b* : *c*`) allows nesting an either-or
    condition and both possible branched values in a single statement. The following
    example shows how to define a variable with a value from the `$_GET` superglobal
    and fall back on a default if it is empty:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '使用*三元运算符*(`*a* ? *b* : *c*`)允许在一个语句中嵌套一个二选一条件和两个可能的分支值。以下示例展示了如何定义一个变量，其值来自`$_GET`超全局变量，并在为空时返回默认值：'
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Discussion
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A ternary expression has three arguments and is evaluated from left to right,
    checking the *truthiness* of the leftmost statement (whether it evaluates to `true`
    regardless of the types involved in the expression) and returning the next value
    if `true` or the final value if `false`. You can visualize this logical flow with
    the following illustration:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 三元表达式有三个参数，并从左到右进行评估，检查最左侧语句的*真值*（不考虑表达式中涉及的类型）并返回`true`时的下一个值，或者`false`时的最终值。您可以通过以下图示来可视化这种逻辑流程：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The ternary pattern is a simple way to return a default value when checking
    either system values or even parameters from a web request (those stored in the
    `$_GET` or `$_POST` superglobals). It is also a powerful way to switch logic in
    page templates based on the return of a particular function call.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 三元模式是在检查系统值或来自Web请求的参数时返回默认值的简单方法（这些存储在`$_GET`或`$_POST`超全局变量中）。它还是基于特定函数调用的页面模板中切换逻辑的强大方法。
- en: 'The following example assumes a web application that welcomes logged-in users
    by name (checking their authentication state with a call to `is_logged_in()`)
    or welcomes a guest if the user has yet to authenticate. As this example is coded
    directly into the HTML markup of a web page, using a longer `if`/`else` statement
    would be inappropriate:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例假设一个Web应用程序，通过姓名欢迎已登录用户（通过调用`is_logged_in()`检查其认证状态）或者欢迎未经验证的访客。由于此示例直接编码到Web页面的HTML标记中，使用更长的`if`/`else`语句将不合适：
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Ternary operations can also be simplified if the value being checked is both
    *truthy* (evaluates to `true` when coerced into a Boolean value) and is the value
    you want by default. The Solution example checks that a username is set *and*
    assigns that value to a given variable if so. Since non-empty strings evaluate
    to `true`, you can shorten the solution to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在检查的值既是*真值*（在强制转换为布尔值时评估为`true`）又是您默认希望的值，则可以简化三元操作。解决方案示例检查用户名是否已设置，并在这种情况下将该值分配给给定变量。由于非空字符串会评估为`true`，因此可以将解决方案缩短为以下形式：
- en: '[PRE4]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When a ternary is shortened from its `*a* ? *b* : *c*` format to a simple `*a*
    ?: *c*`, PHP will evaluate the expression to check `*a*` as if it were a Boolean
    value. If it’s true, PHP merely returns the expression itself. If it’s false,
    PHP returns the fallback value `*c*` instead.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '当将一个三元缩短为简单的`*a* ?: *c*`格式时，PHP将评估表达式以检查`*a*`是否为布尔值。如果为真，则PHP仅返回表达式本身。如果为假，则PHP返回替代值`*c*`。'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: PHP compares truthiness similarly to the way it compares emptiness, as discussed
    in [Chapter 1](ch01.html#chapter_variables). Strings that are set (not empty or
    `null`), integers that are nonzero, and arrays that are non-empty are all generally
    considered truthy, which is to say they evaluate to `true` when cast as a Boolean.
    You can read more about the ways types are intermixed and considered equivalent
    in [the PHP Manual section on type comparisons](https://oreil.ly/nXsr8).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: PHP类似于空值比较地比较真值，正如在[第1章](ch01.html#chapter_variables)中所讨论的那样。已设置的字符串（非空或`null`）、非零整数和非空数组通常都被认为是真值，这意味着它们在布尔转换时会评估为`true`。您可以在[PHP手册类型比较部分](https://oreil.ly/nXsr8)中了解更多关于类型混合和等价判定的信息。
- en: The ternary operator is an advanced form of comparison operator that, while
    it provides for concise code, can sometimes be overused to create logic that is
    too difficult to follow. Consider [Example 2-2](#nested_ternary), which nests
    one ternary operation within another.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符是一种高级的比较运算符，尽管它提供了简洁的代码，但有时会被过度使用，以至于创建的逻辑过于复杂难以理解。考虑嵌套一个三元操作在另一个中的[示例2-2](#nested_ternary)。
- en: Example 2-2\. Nested ternary expression
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-2\. 嵌套三元表达式
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This example should be rewritten as a simple `if`/`else` statement instead
    to provide more clarity as to how the code branches. Nothing is *functionally*
    wrong with the code, but nested ternaries can be difficult to read or reason about
    and often lead to logic errors down the road. The preceding ternary could be rewritten
    as shown in [Example 2-3](#multiple_if_else):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例应重写为一个简单的`if`/`else`语句，以提供更清晰的代码分支信息。代码*功能上*没有问题，但嵌套的三元操作可能难以阅读或理解，并且往往会在日后导致逻辑错误。前面的三元操作可以重写如[示例2-3](#multiple_if_else)所示：
- en: Example 2-3\. Multiple `if/else` statements
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例2-3\. 多个`if/else`语句
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While [Example 2-3](#multiple_if_else) is more verbose than [Example 2-2](#nested_ternary),
    you can more easily track where the logic needs to branch. The code is also more
    maintainable, as new branching logic can be added where necessary. Adding another
    logical branch to [Example 2-2](#nested_ternary) would further complicate the
    already complex ternary and make the program even harder to maintain in the long
    run.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管[示例 2-3](#multiple_if_else)比[示例 2-2](#nested_ternary)更冗长，但你可以更轻松地跟踪逻辑分支的位置。代码也更易于维护，因为可以在必要时添加新的逻辑分支。向[示例
    2-2](#nested_ternary)添加另一个逻辑分支将进一步复杂化已经复杂的三元操作符，并使长期维护程序变得更加困难。
- en: See Also
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on the [ternary operator](https://oreil.ly/Y5WCn) and its variations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 文档关于[三元运算符](https://oreil.ly/Y5WCn)及其变体。
- en: 2.2 Coalescing Potentially Null Values
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.2 合并潜在的空值
- en: Problem
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to assign a specific value to a variable only if it’s set and not `null`
    and otherwise use a static default value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要仅在变量设置且不为`null`时为其分配特定值，否则使用静态默认值。
- en: Solution
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Using a null-coalescing operator (`??`) as follows will use the first value
    only if it is set and not `null`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用空值合并运算符（`??`）如下，仅在设置并且不为`null`时使用第一个值：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP’s null-coalescing operator is a newer feature introduced in PHP 7.0\. It’s
    been referred to as *syntactic sugar* to replace the shorthand version of PHP’s
    ternary operator, `?:`, discussed in [Recipe 2.1](#ternary_operator).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的空值合并运算符是PHP 7.0引入的新功能。它被称为*语法糖*，用于替换PHP的三元运算符简写形式 `?:`，详见[配方 2.1](#ternary_operator)。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*Syntactic sugar* is shorthand for performing a common yet verbose operation
    in code. The developers of languages introduce such features to save keystrokes
    and render routine, oft-repeated blocks of code via simpler and more concise syntax.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*语法糖* 是指在代码中执行常见且冗长操作的简写。语言的开发人员引入这些功能是为了节省击键，并通过更简单、更简洁的语法呈现常见但经常重复的代码块。'
- en: 'Both of the following lines of code are functionally equivalent, but the ternary
    form will trigger a notice if the expression being evaluated is undefined:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面两行代码在功能上是等效的，但三元形式在评估表达式未定义时将触发一个通知：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While these preceding two examples are *functionally* identical, a notable difference
    in their behavior occurs if the value being evaluated (`$b`) is not defined. With
    the null-coalescing operator, everything is golden. With the ternary shorthand,
    PHP will trigger a notice during execution that the value is undefined before
    returning the fallback value.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两个前述示例在*功能上*相同，但在评估值（`$b`）未定义时，它们的行为有显著差异。使用空值合并运算符，一切都很完美。而使用三元简写形式，在执行过程中，PHP会触发一个通知，表明在返回回退值之前该值未定义。
- en: 'With discrete variables, the differing functionality of these operators isn’t
    entirely obvious, but when the evaluated component is, perhaps, an indexed array,
    the potential impact becomes more apparent. Assume that, instead of a discrete
    variable, you are trying to extract an element from the superglobal `$_GET` variable
    that holds request parameters. In the following example, both the ternary and
    the null-coalescing operators will return the fallback value, but the ternary
    version will complain about an undefined index:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于离散变量，这些运算符的不同功能并不完全明显，但当评估组件是一个索引数组时，潜在影响就显得更加明显了。假设，与离散变量不同，你正在尝试从超全局变量 `$_GET`
    中提取一个元素，该变量保存请求参数。在下面的例子中，三元运算符和空值合并运算符都将返回回退值，但三元版本会抱怨未定义的索引：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If errors and notices are suppressed during execution,^([1](ch02.html#idm45875191836944))
    there is no functional difference between either operator option. It is, however,
    best practice to avoid writing code that triggers errors or notices, as these
    can accidentally raise alerts in production or potentially fill system logs and
    make it more difficult to find legitimate issues with your code. While the shorthand
    ternary operator is remarkably useful, the null-coalescing operator is purpose-built
    for this kind of operation and should nearly always be used instead.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行过程中抑制了错误和通知，^([1](ch02.html#idm45875191836944)) 那么在这两种操作符选项之间就没有功能上的区别。然而，最佳实践是避免编写会触发错误或通知的代码，因为这些可能会在生产中意外引发警报，或者可能会填充系统日志，并使查找代码的真正问题更加困难。虽然简写的三元运算符非常有用，但空值合并运算符是专门用于这种操作的，几乎总是应该使用它。
- en: See Also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The announcement of the new operator [when it was first added to PHP 7.0](https://oreil.ly/6vmP_).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 新操作符的公告，[当它首次添加到PHP 7.0中时](https://oreil.ly/6vmP_)。
- en: 2.3 Comparing Identical Values
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.3 比较相同值
- en: Problem
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to compare two values of the same type to ensure that they’re identical.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要比较两个相同类型的值以确保它们是相同的。
- en: Solution
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use three equals signs to compare values without dynamically casting their
    types:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三个等号来比较值，而不会动态转换它们的类型：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In PHP, the equals sign has three functions. A single equals sign (`=`) is used
    for *assignment*, which is setting the value of a variable. Two equals signs (`==`)
    are used in an expression to determine whether the values on either side are equal.
    [Table 2-4](#table_equality) shows how certain values are considered equal because
    PHP coerces one type into another while evaluating the statement. Finally, three
    equals signs (`===`) are used in an expression to determine whether the values
    on either side are *identical*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，等号有三个功能。单个等号（`=`）用于*赋值*，即设置变量的值。两个等号（`==`）在表达式中用于确定两侧的值是否相等。[表 2-4](#table_equality)展示了由于PHP在评估语句时将一个类型强制转换为另一个类型，因此某些值被视为相等。最后，三个等号（`===`）在表达式中用于确定两侧的值是否*完全相同*。
- en: Table 2-4\. Value equality in PHP
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-4\. PHP中的值相等性
- en: '| Expression | Result | Explanation |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 表达式 | 结果 | 解释 |'
- en: '| --- | --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `0 == "a"` | `false` | (Only for PHP 8.0 and above) The string `"a"` is cast
    as an integer, which means it’s cast to `0`. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `0 == "a"` | `false` | （仅适用于PHP 8.0及以上）字符串`"a"`被转换为整数，这意味着它被转换为`0`。 |'
- en: '| `"1" == "01"` | `true` | Both sides of the expression are cast to integers,
    and `1 == 1`. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `"1" == "01"` | `true` | 表达式两侧都被转换为整数，`1 == 1`。 |'
- en: '| `100 = "1e2`" | `true` | The right side of the expression is evaluated as
    an exponential representation of `100` and cast as an integer. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `100 = "1e2`" | `true` | 表达式右侧被评估为`100`的指数形式，并转换为整数。 |'
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The first example in [Table 2-4](#table_equality) evaluates as `true` in PHP
    versions below 8.0\. In those earlier versions, comparing the equality of a string
    (or numeric string) to a number would convert the string first to a number (in
    this case, converting `"a"` to `0`). This behavior changed in PHP 8.0 such that
    only numeric strings are cast to numbers, so the result of that first expression
    is now `false`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 2-4](#table_equality)中的第一个示例在PHP版本低于8.0时评估为`true`。在这些早期版本中，比较字符串（或数值字符串）与数字会首先将字符串转换为数字（在本例中，将`"a"`转换为`0`）。PHP
    8.0中此行为已更改，现在只有数值字符串会被转换为数字，因此第一个表达式的结果现在是`false`。'
- en: PHP’s ability to dynamically convert between types at runtime can be useful,
    but in some cases it is not what you want to have happen at all. The Boolean literal
    `false` is returned by some methods to represent an error or failure, while an
    integer `0` might be a valid return of a function. Consider the function in [Example 2-4](#count_books_of_type)
    that returns a count of books of a specific category, or `false` if a connection
    to the database holding that data fails.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PHP在运行时动态转换类型的能力可能很有用，但在某些情况下，这并不是您希望发生的。布尔字面值`false`被一些方法返回以表示错误或失败，而整数`0`可能是函数的有效返回。考虑函数[示例 2-4](#count_books_of_type)，它返回特定类别书籍的计数，或者如果连接到包含这些数据的数据库失败，则返回`false`。
- en: Example 2-4\. Count items in a database or return `false`
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-4\. 计算数据库中的项或返回`false`
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If everything in [Example 2-4](#count_books_of_type) runs as expected, the code
    will then return an integer count of the number of books in a particular category.
    [Example 2-5](#print_query_results_to_headline) might leverage this function to
    print a headline on a web page.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果[示例 2-4](#count_books_of_type)中的一切按预期运行，那么代码将返回一个特定类别中书籍数量的整数计数。[示例 2-5](#print_query_results_to_headline)可能利用此函数在网页上打印标题。
- en: Example 2-5\. Using the results of a database-bound function
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-5\. 使用与数据库绑定函数的结果
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Internally, PHP’s `switch` statement is using a loose type comparison (our `==`
    operator). If `count_books_of_type()` returns `false` instead of an actual result,
    this `switch` statement will print out that no fiction books were found rather
    than reporting an error. In this particular use case, that might be acceptable
    behavior—but when your application needs to reflect a material difference between
    `false` and `0`, loose equality comparisons are inadequate.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，PHP的`switch`语句使用宽松类型比较（我们的`==`操作符）。如果`count_books_of_type()`返回`false`而不是实际结果，此`switch`语句将打印出未找到虚构书籍，而不是报告错误。在这种特定用例中，这可能是可接受的行为——但是当您的应用程序需要反映`false`和`0`之间的实质性差异时，宽松相等比较是不够的。
- en: Instead, PHP permits the use of *three* equals signs (`===`) to check whether
    both values under evaluation are identical—that is, they are both the same value
    and the same type. Even though the integer `5` and the string `"5"` have the same
    value, evaluating `5 === "5"` will result in `false` because the two values are
    not the same type. Thus, while `0 == false` evaluates to `true`, `0 === false`
    will always evaluate to `false`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: PHP允许使用*三个*等号（`===`）来检查评估中的两个值是否相同——即它们是相同的值和相同的类型。即使整数`5`和字符串`"5"`具有相同的值，评估`5
    === "5"`将导致`false`，因为这两个值不是相同的类型。因此，虽然`0 == false`评估为`true`，`0 === false`将始终评估为`false`。
- en: Warning
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Determining whether two values are identical becomes more complicated when dealing
    with objects, either defined with custom classes or PHP-provided ones. In the
    case of two objects, `$obj1` and `$obj2`, they will only evaluate as identical
    if they are actually the same *instance* of a class. For more on object instantiation
    and classes, see [Chapter 8](ch08.html#chapter_classes).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理对象时，确定两个值是否相同变得更加复杂，无论是使用自定义类定义还是PHP提供的类。对于两个对象`$obj1`和`$obj2`，只有当它们实际上是同一个类的*实例*时，它们才会被评估为相同。有关对象实例化和类的更多信息，请参阅[第8章](ch08.html#chapter_classes)。
- en: See Also
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: PHP documentation on [comparison operators](https://oreil.ly/T6GXm).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: PHP关于[比较运算符](https://oreil.ly/T6GXm)的文档。
- en: 2.4 Using the Spaceship Operator to Sort Values
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.4 使用宇宙飞船操作符排序值
- en: Problem
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to provide a custom ordering function to sort an arbitrary list of
    objects by using [PHP’s native `usort()`](https://oreil.ly/xGbc9).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要提供一个自定义排序函数，以通过[PHP的原生`usort()`](https://oreil.ly/xGbc9)对任意对象列表进行排序。
- en: Solution
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Assuming you want to sort by multiple properties of the list of objects, use
    PHP’s spaceship operator (`<=>`) to define a custom sorting function and supply
    that as the callback to `usort()`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您要按照对象列表的多个属性进行排序，可以使用PHP的宇宙飞船操作符（`<=>`）定义自定义排序函数，并将其作为回调提供给`usort()`。
- en: 'Consider the following class definition for a person in your application that
    allows creating records with just first and last names:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑为您的应用程序中的人员提供以下类定义，允许只使用名字和姓氏创建记录：
- en: '[PRE13]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can then create a list of people, perhaps US presidents, using this class
    and adding each person to your list in turn, as in [Example 2-6](#adding_presidents_to_list).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用此类创建人员列表，例如美国总统，并依次将每个人添加到您的列表中，就像[示例 2-6](#adding_presidents_to_list)中所示。
- en: Example 2-6\. Adding multiple object instances to a list
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-6\. 向列表添加多个对象实例
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The spaceship operator can then be leveraged to identify how to sort this data,
    assuming you want to order by last name first, then by first name, as shown in
    [Example 2-7](#sorting_with_spaceship).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想按姓氏首先，然后按名字排序数据，您可以利用宇宙飞船操作符来实现，如[示例 2-7](#sorting_with_spaceship)所示。
- en: Example 2-7\. Sorting presidents with the spaceship operator
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-7\. 使用宇宙飞船操作符对总统进行排序
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The result of the preceding call to `usort()` is that the `$presidents` array
    will be properly sorted in place and ready for use.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`usort()`之前的结果是，`$presidents`数组将正确地原地排序并准备就绪。
- en: Discussion
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The spaceship operator is a special addition as of PHP 7.0 that helps identify
    the relationship between the values on either side of it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 宇宙飞船操作符是PHP 7.0的特殊添加，有助于确定其两侧值之间的关系：
- en: If the first value is less than the second, the expression evaluates to `-1`.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个值小于第二个值，则表达式评估为`-1`。
- en: If the first value is greater than the second, the expression evaluates to `+1`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第一个值大于第二个值，则表达式评估为`+1`。
- en: If both values are the same, the expression evaluates to `0`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两个值相同，则表达式评估为`0`。
- en: Note
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Like PHP’s equality operator, the spaceship operator will attempt to coerce
    the types of each value in the comparison to be the same. It is possible to support
    a number for one value and a string for the other and get a valid result. Use
    type coercion with special operators like this at your own risk.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于PHP的等号操作符，太空船操作符会尝试将比较中每个值的类型强制转换为相同类型。支持一个值为数字，另一个值为字符串，并获得有效结果是可能的。在使用这种特殊操作符进行类型强制转换时，需要注意风险。
- en: 'The simplest use of the spaceship operator compares simple types with one another,
    making it easy to order a simple array or list of primitive values (like characters,
    integers, floating-point numbers, or dates). This simple case, if using `usort()`,
    would require a sorting function like the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 太空船操作符最简单的用法是将简单类型相互比较，这使得对简单数组或原始值列表（如字符、整数、浮点数或日期）进行排序变得容易。如果使用`usort()`，则需要像下面这样的排序函数：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The spaceship operator simplifies the nested ternary in the preceding code by
    replacing the `return` statement entirely with `return $a <=> $b`, but without
    modifying the functionality of the sorting function at all.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 太空船操作符通过完全用`return $a <=> $b`替换前面代码中的嵌套三元运算符的`return`语句，但不改变排序函数的功能。
- en: More complex examples, like that used in the Solution to sort based on multiple
    properties of a custom object definition, would necessitate rather verbose sorting
    function definitions. The spaceship operator simplifies comparison logic, empowering
    developers to specify otherwise complex logic in a single, easy-to-read line.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的示例，如解决方案中用于基于自定义对象定义的多个属性进行排序，将需要相当冗长的排序函数定义。太空船操作符简化了比较逻辑，使开发人员能够在一行代码中指定复杂的逻辑。
- en: See Also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The [original RFC for PHP’s spaceship operator](https://oreil.ly/O1X8R).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[PHP太空船操作符的原始RFC](https://oreil.ly/O1X8R)。'
- en: 2.5 Suppressing Diagnostic Errors with an Operator
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.5 使用操作符抑制诊断错误
- en: Problem
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to explicitly ignore or suppress errors triggered by a specific expression
    in your application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望显式忽略或抑制应用程序中特定表达式触发的错误。
- en: Solution
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Prefix the expression with the `@` operator to temporarily set the error reporting
    level to 0 for that line of code. This might help suppress errors related to missing
    files when attempting to open them directly, as in the following example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式前加上`@`操作符可临时将错误报告级别设置为0，用于屏蔽与直接尝试打开丢失文件相关的错误，例如下面的示例：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Discussion
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The Solution example attempts to open the file *file_that_does_not_exist.txt*
    for reading. In normal operations, a call to `fopen()` would return `false` because
    the file does not exist *and* emit a PHP warning for the purposes of diagnosing
    the issue. Prefixing the expression with the `@` operator doesn’t change the return
    value at all, but it suppresses the emitted warning entirely.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例尝试打开不存在的文件*file_that_does_not_exist.txt*进行读取。在正常操作中，调用`fopen()`会因为文件不存在而返回`false`，同时为了诊断问题会发出PHP警告。在表达式前加上`@`操作符不会改变返回值，但会完全抑制发出的警告。
- en: Warning
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `@` operator suppresses error reporting for the line to which it is applied.
    If a developer attempts to suppress errors on an `include` statement, they will
    very easily hide any warnings, notices, or errors caused by the included file
    not existing (or having improper access controls). The suppression will *also*
    apply to all lines of code within the included file, meaning any errors (syntax-related
    or otherwise) in the included code will be ignored. Thus, while `@include('some-file.php')`
    is perfectly valid code, suppressing errors on `include` statements should be
    avoided!
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`@`操作符会抑制应用于其之后的代码行的错误报告。如果开发人员试图在`include`语句上抑制错误，他们将很容易隐藏由于包含的文件不存在（或访问控制不当）而导致的任何警告、通知或错误。抑制还会应用于包含文件内的所有代码行，这意味着包含代码中的任何错误（包括语法相关或其他）都将被忽略。因此，虽然`@include(''some-file.php'')`是完全有效的代码，但应避免在`include`语句上抑制错误！'
- en: 'This particular operator is useful when suppressing errors or warnings on file
    access operations (as in the Solution example). It’s also useful in suppressing
    notices in array-access operations, as in the following, where a specific `GET`
    parameter might not be set in a request:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这种特定的操作符在抑制文件访问操作中的错误或警告时非常有用（如示例中的解决方案）。在数组访问操作中抑制通知同样有用，比如下面的情况，其中请求中可能未设置特定的`GET`参数：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `$filename` variable will be set to the value of the request’s `filename`
    query parameter if it’s set. Otherwise, it will be a literal `null`. If a developer
    were to omit the `@` operator, the value of `$filename` would still be `null`,
    but PHP would emit a notice that the index of `filename` does not exist in the
    array.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了请求的`filename`查询参数，则`$filename`变量将被设置为其值。否则，它将是字面量`null`。如果开发人员省略`@`操作符，则`$filename`的值仍将是`null`，但PHP将发出通知，指出数组中不存在`filename`索引。
- en: As of [PHP 8.0](https://oreil.ly/4Ec5B), this operator will no longer suppress
    *fatal* errors in PHP that otherwise halt script execution.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 自[PHP 8.0](https://oreil.ly/4Ec5B)起，此运算符将不再抑制PHP中的*致命*错误，否则会停止脚本执行。
- en: See Also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Official PHP documentation on [error control operators](https://oreil.ly/bZkLY).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: PHP官方文档中关于[错误控制操作符](https://oreil.ly/bZkLY)的详细信息。
- en: 2.6 Comparing Bits Within Integers
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2.6 比较整数中的位
- en: Problem
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use simple flags to identify state and behavior in your application,
    where one member might have multiple flags applied.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在应用程序中使用简单的标志来标识状态和行为，其中一个成员可能应用了多个标志。
- en: Solution
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use a [bitmask](https://oreil.ly/aevr7) to specify which flags are available
    and bitwise operators on the subsequent flags to identify which are set. The following
    example defines four discrete flags by using a binary notation of the integer
    each represents and combines them to indicate *multiple* flags being set at once.
    PHP’s bitwise operators are then used to identify which flag is set and which
    branch of conditional logic should be executed:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[位掩码](https://oreil.ly/aevr7)来指定可用的标志，并在后续标志上使用位操作符来确定哪些标志已设置。以下示例通过使用每个标志的整数二进制表示来定义四个离散标志，并将它们组合以指示*同时*设置了多个标志。然后使用PHP的位操作符来确定哪个标志被设置，并执行相应的条件逻辑分支：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Discussion
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A bitmask is structured by configuring each flag to be a constant integer power
    of 2\. This has the benefit of only setting a single bit in the binary representation
    of the number such that composite flags are then identified by which bits are
    set. In the Solution example, each flag is written explicitly as a binary number
    to illustrate which bits are set (`1`) versus unset (`0`), with the integer representation
    of the same number in a comment at the end of the line.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 位掩码通过将每个标志配置为常量整数的2的幂来构造。这样做的好处是在二进制表示中仅设置一个位，从而通过设置哪些位来识别组合标志。在解决方案示例中，每个标志都明确写成二进制数字，以说明哪些位被设置为（`1`），哪些位未设置为（`0`），在行尾还有同一个数字的整数表示。
- en: 'Our example’s `FLAG_B` is the integer 2, which is represented in binary as
    `0010` (the third bit is set). Likewise, `FLAG_C` is the integer 4 with a binary
    representation of `0100` (the second bit is set). To specify that *both* flags
    are set, you add the two together to set both the second and third bits: `0110`
    or the integer 6.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们例子中的`FLAG_B`是整数2，其二进制表示为`0010`（第三位被设置）。同样，`FLAG_C`是整数4，其二进制表示为`0100`（第二位被设置）。要指定*两个*标志都被设置，您将两者相加以设置第二位和第三位：`0110`或整数6。
- en: For this specific example, addition is an easy model to keep in mind, but it’s
    not exactly what is going on. To combine flags, you merely want to combine the
    bits that are set, not necessarily add them together. Combining `FLAG_A` with
    itself should result in *only* `FLAG_A`; adding the integer representation (1)
    to itself would change the meaning of the flag entirely.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的例子，加法是一个容易记住的模型，但并不完全符合实际情况。要组合标志，您只需组合已设置的位，而不一定要将它们加在一起。将`FLAG_A`与其自身组合应该仅产生*仅有的*
    `FLAG_A`；将整数表示（1）与自身相加会完全改变标志的含义。
- en: Rather than addition, use the bitwise operations *or* (`|`) and *and* (`&`)
    to both combine bits and filter on assigned flags. Combining two flags together
    requires using the `|` operator to create a new integer with bits that are set
    in *either* of the flags being used. Consider [Table 2-5](#composite_binary_flags_or)
    to create a composite of `FLAG_A | FLAG_C`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用加法，而要使用位操作符*或*（`|`）和*与*（`&`）来同时组合位并筛选分配的标志。将两个标志组合在一起需要使用`|`运算符创建一个新的整数，其中包含要使用的任一标志中设置的位。请参考[表 2-5](#composite_binary_flags_or)以创建`FLAG_A
    | FLAG_C`的组合。
- en: Table 2-5\. Composite binary flags with bitwise *or*
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-5\. 使用位或组合的复合二进制标志
- en: '| Flag | Binary representation | Integer representation |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 二进制表示 | 整数表示 |'
- en: '| --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `FLAG_A` | `0001` | `1` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `FLAG_A` | `0001` | `1` |'
- en: '| `FLAG_C` | `0100` | `4` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `FLAG_C` | `0100` | `4` |'
- en: '| `FLAG_A &#124; FLAG_C` | `0101` | `5` |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `FLAG_A &#124; FLAG_C` | `0101` | `5` |'
- en: Comparing composite flags against your definitions then requires the `&` operator,
    which returns a new number that has bits set on *both* sides of the operation.
    Comparing a flag to itself will always return 1, which is type cast to `true`
    in conditional checks. Comparing two values that have any of the same bits set
    will return a value *greater* than 0, which is type cast to `true`. Consider the
    simple case of evaluating where `FLAG_A & FLAG_C` in [Table 2-6](#composite_binary_flags_and).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后需要使用`&`运算符比较复合标志与您的定义，它返回一个新数字，该数字在操作的两侧都设置了位。将标志与自身比较将始终返回1，在条件检查中强制类型转换为`true`。比较具有任何相同位的两个值将返回一个大于0的值，这在条件检查中也将被强制类型转换为`true`。考虑在[表
    2-6](#composite_binary_flags_and)中评估`FLAG_A & FLAG_C`的简单情况。
- en: Table 2-6\. Composite binary flags with bitwise *and*
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-6\. 使用按位*与*组合的复合二进制标志
- en: '| Flag | Binary representation | Integer representation |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| 标志 | 二进制表示 | 整数表示 |'
- en: '| --- | --- | --- |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `FLAG_A` | `0001` | `1` |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `FLAG_A` | `0001` | `1` |'
- en: '| `FLAG_C` | `0100` | `4` |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `FLAG_C` | `0100` | `4` |'
- en: '| `FLAG_A & FLAG_C` | `0000` | `0` |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `FLAG_A & FLAG_C` | `0000` | `0` |'
- en: 'Instead of comparing primitive flags against one another, you can and should
    build composite values and then compare them to your sets of flags. The following
    example visualizes the role-based access controls of a content management system
    for publishing news articles. Users can view articles, create articles, edit articles,
    or delete articles; their level of access is determined by the program itself
    and the permissions granted to their user account:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以构建复合值然后将其与您的标志集进行比较，而不是将基元标志相互比较。以下示例演示了用于发布新闻文章的内容管理系统的基于角色的访问控制。用户可以查看文章、创建文章、编辑文章或删除文章；他们的访问级别由程序本身和授予其用户帐户的权限确定：
- en: '[PRE20]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A typical, anonymous visitor will never be logged in and will then be granted
    a default permission of being able to view content. Logged-in users might be able
    to create articles but not edit them without an editor’s permission. Likewise,
    editors can review and modify content (or delete it) but cannot independently
    create articles. Finally, administrators might be allowed to do everything. Each
    of the roles is composited from the preceding permission primitives as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的匿名访客将永远不会被登录，因此将被授予默认权限以查看内容。登录用户可能能够创建文章，但没有编辑权限的情况下不能编辑它们。同样，编辑人员可以审核和修改内容（或删除），但不能独立创建文章。最后，管理员可能被允许做任何事情。每个角色都是从前面的权限基元组合而成：
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once composite roles are defined from primitive permissions, the application
    can structure logic around checking the user’s active role. While permissions
    were composited together with the `|` operator, the `&` operator will allow you
    to switch based on these flags, as demonstrated by the functions defined in [Example 2-8](#leveraging_bitmask_flags).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从基元权限定义了复合角色，应用程序就可以围绕检查用户的活动角色构建逻辑。虽然权限是使用`|`运算符组合在一起的，但`&`运算符将允许您基于这些标志进行切换，正如在[示例
    2-8](#leveraging_bitmask_flags)中定义的函数所示。
- en: Example 2-8\. Leveraging bitmask flags for access control
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2-8\. 利用位掩码标志进行访问控制
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Bitmasks are a powerful way to implement simple flags in any language. Take
    caution, though, if the number of flags needed is ever planned to increase, because
    each new flag represents an additional power of 2, meaning the value of all flags
    grows rapidly in size. However, bitmasks are commonly used in both PHP applications
    and by the language itself. PHP’s own error reporting setting, discussed further
    in [Chapter 12](ch12.html#chapter_errors), leverages bitwise values to identify
    the level of error reporting used by the engine itself.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 位掩码是在任何语言中实现简单标志的强大方式。不过，如果计划增加所需标志的数量，请小心，因为每个新标志表示的是2的次方，这意味着所有标志的值会迅速增长。然而，位掩码在
    PHP 应用程序和语言本身中广泛使用。PHP 的自身错误报告设置在[第12章](ch12.html#chapter_errors)中进一步讨论，利用位操作值来识别引擎本身使用的错误报告级别。
- en: See Also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [bitwise operators](https://oreil.ly/JmF85).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 文档关于[位运算符](https://oreil.ly/JmF85)。
- en: ^([1](ch02.html#idm45875191836944-marker)) Error handling and suppressing errors,
    warnings, and notices are discussed at length in [Chapter 12](ch12.html#chapter_errors).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.html#idm45875191836944-marker)) 长篇讨论错误处理和抑制错误、警告和通知在[第12章](ch12.html#chapter_errors)中进行。
