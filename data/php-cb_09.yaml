- en: Chapter 9\. Security and Encryption
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章。安全和加密
- en: PHP is a remarkably easy-to-use language because of the forgiving nature of
    the runtime. Even when you make a mistake, PHP will try to infer what you *meant*
    to do and, often, keep executing your program just fine. Unfortunately, this strength
    is also seen by some developers as a key weakness. By being forgiving, PHP allows
    for a sheer amount of “bad” code to continue functioning as if it were correct.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 是一个非常易于使用的语言，因为它的运行时宽容性。即使你犯了一个错误，PHP 也会尝试推断你*想要*做什么，并且通常会继续正常执行你的程序。不幸的是，这种特性也被一些开发者视为一个关键弱点。由于宽容性，PHP
    允许大量“坏”代码继续像正确代码一样运行。
- en: Worse still, much of this “bad” code finds its way into tutorials, leading developers
    to copy and paste it into their own projects and perpetuate the cycle. This forgiving
    runtime and long history of PHP have led to the perception that PHP itself is
    insecure. In reality, it’s easy to use *any* programming language insecurely.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，许多这样的“坏”代码出现在教程中，导致开发者将其复制粘贴到自己的项目中，并延续这一循环。PHP 的这种宽容的运行时和悠久历史使得人们普遍认为
    PHP 本身不安全。事实上，*任何*编程语言都可能被不安全地使用。
- en: Natively, PHP supports the ability to quickly and easily filter malicious input
    and sanitize user data. In a web context, this utility is critical to keeping
    user information safe from malicious inputs or attacks. PHP also exposes well-defined
    functions for both securely hashing and securely validating passwords during authentication.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 本地支持快速、简便地过滤恶意输入和清理用户数据的能力。在 Web 环境中，这种实用性对于保护用户信息免受恶意输入或攻击至关重要。PHP 还提供了明确定义的函数，用于在认证过程中安全地哈希和验证密码。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: PHP’s default password hashing and validation functions both leverage secure
    hashing algorithms and constant-time, secure implementations. This protects your
    application against niche attacks like those using timing information in an attempt
    to extract information. Attempting to implement hashing (or validation) yourself
    would likely expose your application to risks for which PHP has already accounted.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的默认密码哈希和验证函数都利用了安全的哈希算法和常数时间的安全实现。这保护了你的应用免受使用时间信息来尝试提取信息等特定攻击的影响。试图自己实现哈希（或验证）可能会使你的应用程序面临
    PHP 已经考虑过的风险。
- en: The language also makes cryptography—for both encryption and signatures—simple
    for developers. Native, high-level interfaces protect you from the kinds of mistakes
    easily made elsewhere.^([1](ch09.html#idm45875152082528)) In fact, PHP is one
    of the *easiest* languages in which developers can leverage strong, modern cryptography
    without relying on a third-party extension or implementation!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 还为开发者简化了加密（包括加密和签名）的过程。本地的高级接口保护你免受在其他地方容易犯的错误的影响。^([1](ch09.html#idm45875152082528))
    事实上，PHP 是其中一个*最简单*的语言，开发者可以在其中利用强大、现代的加密，而无需依赖第三方扩展或实现！
- en: Legacy Encryption
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧版加密
- en: Earlier versions of PHP shipped with an extension called [mcrypt](https://oreil.ly/I7stH).
    This extension exposed the lower-level mcrypt library, allowing developers to
    easily leverage a variety of block ciphers and hash algorithms. It was removed
    in PHP 7.2 in favor of the newer sodium extension, but it can still be manually
    installed via the PHP Extension Community Library (PECL).^([2](ch09.html#idm45875152074560))
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的早期版本附带一个名为 [mcrypt](https://oreil.ly/I7stH) 的扩展。这个扩展暴露了底层的 mcrypt 库，允许开发者轻松利用各种分组密码和哈希算法。在
    PHP 7.2 中，为了更加现代化，这个扩展被移除，并推荐使用更新的 sodium 扩展，但你仍然可以通过 PHP 扩展社区库（PECL）手动安装它。^([2](ch09.html#idm45875152074560))
- en: Warning
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While still available, the mcrypt library has not been updated in over a decade
    and should not be used in new projects. For any new encryption needs, use either
    PHP’s bindings against OpenSSL or the native sodium extension.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 mcrypt 库仍然可用，但在过去十多年里没有更新，不应在新项目中使用。对于任何新的加密需求，请使用 PHP 对 OpenSSL 的绑定或本地的
    sodium 扩展。
- en: PHP also supports direct use of the OpenSSL library [through an extension](https://oreil.ly/cYNB2).
    This is helpful when building a system that must interoperate with legacy cryptographic
    libraries. However, the extension does not expose the full-feature offering of
    OpenSSL to PHP; it would be useful to review the [functions](https://oreil.ly/Y8xEK)
    and features exposed to identify whether PHP’s implementation would be useful
    to your application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PHP还支持通过[扩展](https://oreil.ly/cYNB2)直接使用OpenSSL库。在构建必须与旧的加密库进行互操作的系统时，这非常有用。但是，该扩展未将OpenSSL的全部功能提供给PHP；有必要查看所暴露的[函数](https://oreil.ly/Y8xEK)和特性，以确定PHP的实现是否对您的应用程序有用。
- en: In any case, the newer sodium interfaces support a wide range of cryptographic
    operations in PHP and should be preferred over either OpenSSL or mcrypt.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，较新的钠接口支持PHP中广泛的加密操作，应优先于OpenSSL或mcrypt。
- en: Sodium
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于钠及其暴露的接口唯一的问题是缺乏简洁性。每个函数都以`sodium_`为前缀，每个常量都以`SODIUM_`为前缀。在函数和常量名称中的高度描述性使得理解代码发生的事情变得容易。但是，这也导致了极长且潜在分散注意力的函数名称，例如`sodium_​crypto_​sign_​keypair_​from_​secretkey_​and_​publickey()`。
- en: PHP formally added the [sodium](https://oreil.ly/gH1Va) extension (also known
    as *Libsodium*) as a core extension in version 7.2, released in late 2017.^([3](ch09.html#idm45875152063760))
    This library supports high-level abstractions for encryption, cryptographic signatures,
    password hashing, and more. It is itself an open source fork of an earlier project,
    the [Networking and Cryptography Library (NaCl)](https://nacl.cr.yp.to) by Daniel
    J. Bernstein.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: PHP在2017年末发布的7.2版本中正式添加了[sodium](https://oreil.ly/gH1Va)扩展（也称为*Libsodium*）。该库支持高级抽象的加密、密码签名、密码哈希等功能。它本身是早期项目[Networking
    and Cryptography Library (NaCl)](https://nacl.cr.yp.to)的开源分支，由Daniel J. Bernstein创建。
- en: Both projects add easy-to-use, high-speed tools for developers who need to work
    with encryption. The opinionated nature of their exposed interfaces aims to make
    cryptography *safe* and proactively avoid the pitfalls presented by other low-level
    tools. Shipping with well-defined opinionated interfaces helps developers make
    the right choices about algorithm implementations and defaults because those very
    choices (and potential mistakes) are entirely abstracted away and presented in
    safe, straightforward functions for everyday use.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个项目为需要处理加密的开发者添加了易于使用、高速的工具。它们暴露的接口具有明确的倾向性，旨在使密码学*安全*，并主动避免其他低级工具可能带来的问题。随着明确定义的倾向性接口，开发者可以在算法实现和默认选择方面做出正确的选择，因为这些选择（和潜在的错误）完全被抽象化，并以安全、简单的功能呈现供日常使用。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The only problem with sodium and its exposed interfaces is a lack of brevity.
    Every function is prefixed with `sodium_`, and every constant with `SODIUM_`.
    The high level of descriptiveness in both function and constant names makes it
    easy to understand what is happening in code. However, this also leads to incredibly
    long and potentially distracting function names, like `sodium_​crypto_​sign_​keypair_​from_​secretkey_​and_​publickey()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 钠
- en: While sodium is bundled as a core extension for PHP, it also exposes bindings
    for [several other languages](https://oreil.ly/L9JPp) as well. It is fully interoperable
    with everything from .NET to Go to Java to Python.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然钠作为PHP的核心扩展捆绑在一起，它还为[几种其他语言](https://oreil.ly/L9JPp)提供了绑定。它与从.NET到Go再到Java到Python的所有内容都是完全可互操作的。
- en: Unlike many other cryptographic libraries, sodium focuses primarily on *authenticated*
    encryption. Every piece of data is automatically paired with an authentication
    tag that the library can later use to validate the integrity of the underlying
    plaintext. If this tag is missing or invalid, the library throws an error to alert
    the developer that the associated plaintext is unreliable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他加密库不同，钠主要专注于*认证*加密。每个数据片段都自动与身份验证标签配对，该库随后可以使用它来验证底层明文的完整性。如果此标签丢失或无效，库将抛出错误，以警示开发者关联的明文不可靠。
- en: This use of authentication isn’t unique—the Galois/Counter Mode (GCM) of the
    Advanced Encryption Standard (AES) does effectively the same thing. However, other
    libraries often leave authentication and validation of an authentication tag as
    an exercise for the developer. There are a number of tutorials, books, and Stack
    Overflow discussions that point to a proper implementation of AES but omit the
    validation of the GCM tag affixed to a message! The sodium extension abstracts
    both authentication and validation away and provides a clear, concise implementation,
    as illustrated in [Example 9-1](#symmetric_crypto_intro).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此身份验证的使用并非独特——高级加密标准（AES）的Galois/Counter Mode (GCM) 实际上做了同样的事情。然而，其他库通常将身份验证和验证认证标签作为开发者的练习留给了开发者。有许多教程、书籍和Stack
    Overflow讨论指出了AES的正确实现，但忽略了附加到消息上的GCM标签的验证！钠扩展将身份验证和验证抽象化，并提供了清晰、简洁的实现，正如[示例 9-1](#symmetric_crypto_intro)中所示。
- en: Example 9-1\. Authenticated encryption and decryption in sodium
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-1\. 钠中的身份验证加密和解密
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO1-1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO1-1)'
- en: Encryption algorithms are deterministic—the same input will always produce the
    same output. To ensure that encrypting the same data with the same key returns
    *different* outputs, you need to use a sufficiently random *nonce* (number used
    once) to initialize the algorithm each time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 加密算法是确定性的——相同的输入总是产生相同的输出。为了确保使用相同密钥加密相同数据返回*不同*输出，您需要每次使用足够随机的*nonce*来初始化算法。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO1-2)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO1-2)'
- en: For symmetric encryption, you leverage a single, shared key used to both encrypt
    and decrypt data. While the key in this example is random, you would likely store
    this encryption key somewhere outside the application for safekeeping.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对称加密中，您利用单个共享密钥来加密和解密数据。在本例中，密钥是随机的，但您可能会将此加密密钥存储在应用程序之外的某个地方以供安全保存。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO1-3)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO1-3)'
- en: Encrypting is incredibly straightforward. Sodium chooses the algorithm and cipher
    mode for you—all you provide is the message, the random nonce, and the symmetric
    key. The underlying library does the rest!
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 加密非常简单。钠选择算法和密码模式，您只需提供消息、随机的一次性数（nonce）和对称密钥即可。底层库会处理其余部分！
- en: '[![4](assets/4.png)](#co_security_and_encryption_CO1-4)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_security_and_encryption_CO1-4)'
- en: When exporting the encrypted value (either to send to another party or to store
    on disk), you need to keep track of both the random nonce and the subsequent ciphertext.
    The nonce itself is not secret, so storing it in plaintext alongside the encrypted
    value is safe (and encouraged). Converting the raw bytes from binary to hexadecimal
    is an effective way to prepare data for an API request or to store in a database
    field.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在导出加密值（无论是发送给另一方还是存储在磁盘上），您需要跟踪随机nonce和随后的密文。nonce本身不是秘密，因此将其与加密值一起以明文形式存储是安全的（并且是鼓励的）。将二进制的原始字节转换为十六进制是准备数据进行API请求或存储在数据库字段中的有效方式。
- en: '[![5](assets/5.png)](#co_security_and_encryption_CO1-5)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_security_and_encryption_CO1-5)'
- en: Since the output of encryption is encoded in hexadecimal, you must first decode
    things back to raw bytes and then separate the nonce and ciphertext components
    before proceeding with decryption.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加密输出是十六进制编码的，因此必须先将其解码为原始字节，然后在进行解密之前分离nonce和密文组件。
- en: '[![6](assets/6.png)](#co_security_and_encryption_CO1-6)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_security_and_encryption_CO1-6)'
- en: To extract the plaintext value back out of an encrypted field, provide the ciphertext
    with its associated nonce and the original encryption key. The library pulls the
    plaintext bytes back out and returns them to you.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要从加密字段中提取回原文值，需要提供带有其关联nonce和原始加密密钥的密文。库会将原文字节重新提取出来并返回给您。
- en: '[![7](assets/7.png)](#co_security_and_encryption_CO1-7)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_security_and_encryption_CO1-7)'
- en: Internally, the encryption library also adds (and validates) an authentication
    tag on every encrypted message. If the authentication tag fails to validate during
    decryption, sodium will return a literal `false` rather than the original plaintext.
    This is a sign to you that the message has been tampered with (either intentionally
    or accidentally) and should not be trusted.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，加密库还在每条加密消息上添加（并验证）认证标签。如果在解密过程中认证标签验证失败，sodium将返回一个字面量`false`而不是原始明文。这表明消息已被篡改（无论是有意还是无意），不可信。
- en: Sodium also introduces an efficient means to handle public-key cryptography.
    In this paradigm, encryption uses one key (a known or publicly exposed key), while
    decryption uses an entirely different key known only to the recipient of the message.
    This two-part key system is ideal when exchanging data between two separate parties
    over a potentially untrusted medium (like exchanging banking information between
    a user and their bank over the public internet). In fact, the HTTPS connections
    used for most websites on the modern internet leverage public-key cryptography
    under the hood within the browser.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Sodium还引入了一个有效的方式来处理公钥密码学。在这种范式中，加密使用一个密钥（已知或公开的密钥），而解密则使用仅为消息接收者所知的完全不同的密钥。在通过可能不受信任的介质（如通过公共互联网交换用户与其银行之间的银行信息）之间交换数据时，这种两部分密钥系统非常理想。事实上，现代互联网上大多数网站使用的HTTPS连接在浏览器内部也利用公钥密码学。
- en: 'In legacy systems like RSA, you need to keep track of relatively large cryptographic
    keys in order to exchange information safely. In 2022, the minimum recommended
    key size for RSA was 3,072 bits; in many situations, developers will default to
    4,096 bits to retain the keys’ safety against future computing enhancements. Juggling
    keys of this size can be difficult in some situations. In addition, traditional
    RSA can only encrypt 256 bytes of data. If you want to encrypt a larger message,
    you are forced to do the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在RSA等传统系统中，为了安全地交换信息，您需要跟踪相对较大的加密密钥。在2022年，RSA的最小推荐密钥大小为3072位；在许多情况下，开发人员将默认为4096位，以保证密钥对未来计算增强的安全性。在某些情况下，处理这么大的密钥可能会很困难。此外，传统的RSA只能加密256字节的数据。如果要加密更大的消息，则需要执行以下操作：
- en: Create a 256-bit random key.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个256位的随机密钥。
- en: Use that 256-bit key to *symmetrically* encrypt a message.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用那个256位密钥对消息进行*对称*加密。
- en: Use RSA to encrypt the symmetric key.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用RSA加密对称密钥。
- en: Share both the encrypted message and the encrypted key that protects it.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分享加密消息和保护其的加密密钥。
- en: This is a workable solution, but the steps involved can easily become complicated
    and introduce unnecessary complexity for a development team building a project
    that *just happens* to include encryption. Thankfully, sodium fixes this almost
    entirely!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可行的解决方案，但所涉及的步骤很容易变得复杂，并为构建*包含加密*项目的开发团队引入不必要的复杂性。幸运的是，sodium几乎完全解决了这个问题！
- en: Sodium’s public-key interfaces leverage elliptic-curve cryptography (ECC) rather
    than RSA. RSA uses prime numbers and exponentiation to create the known (public)
    and unknown (private) components of the two-key system used for encryption. ECC
    instead uses the geometry and particular forms of arithmetic against a well-defined
    elliptic curve. Whereas RSA’s public and private components are numbers used for
    exponentiation, ECC’s public and private components are literal *x* and *y* coordinates
    on a geometric curve.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Sodium的公钥接口利用椭圆曲线密码学（ECC）而不是RSA。 RSA使用素数和指数运算来创建用于加密的已知（公共）和未知（私有）组件的双密钥系统。
    ECC则利用几何和特定形式的算术对定义明确的椭圆曲线进行操作。而RSA的公共和私有组件是用于指数运算的数字，ECC的公共和私有组件是几何曲线上的字面上的*x*和*y*坐标。
- en: With ECC, a 256-bit key has [strength equivalent to that of a 3,072-bit RSA
    key](https://oreil.ly/o2kne). Further, sodium’s choice of cryptographic primitives
    means that its keys are just numbers (rather than *x* and *y* coordinates as with
    most other ECC implementations)—a 256-bit ECC key for sodium is simply a 32-byte
    integer!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ECC，256位密钥具有与3072位RSA密钥等效的[强度](https://oreil.ly/o2kne)。此外，sodium选择的加密原语意味着其密钥只是数字（而不是大多数其他ECC实现的*x*和*y*坐标）—sodium的256位ECC密钥只是一个32字节的整数！
- en: In addition, sodium entirely abstracts the “create a random symmetric key and
    separately encrypt it” workflow from developers, making asymmetric encryption
    just as simple in PHP as [Example 9-1](#symmetric_crypto_intro) demonstrated for
    symmetric encryption. [Example 9-2](#asymmetric_crypto_intro) illustrates exactly
    how this form of encryption works, along with the key exchange required between
    participants.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，钠完全将“创建一个随机对称密钥并单独加密它”的工作流抽象出来，使得 PHP 中的非对称加密与对称加密一样简单，正如 [示例 9-1](#symmetric_crypto_intro)
    对对称加密所示范的那样。[示例 9-2](#asymmetric_crypto_intro) 明确展示了这种加密形式的工作方式，以及参与者之间所需的密钥交换。
- en: Example 9-2\. Asymmetric encryption and decryption in sodium
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-2\. 钠中的非对称加密与解密
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO2-1)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO2-1)'
- en: In practice, both parties would generate their public/private key pairs locally
    and distribute their public keys directly. The `sodium_crypto_box_keypair()` function
    creates a random key pair each time so, conceivably, you would only need to do
    this once, so long as the secret key remains private.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，双方都会在本地生成其公共/私有密钥对，并直接分发其公共密钥。`sodium_crypto_box_keypair()` 函数每次都创建一个随机密钥对，因此理论上，只需执行一次，只要保证私钥保持私密即可。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO2-2)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO2-2)'
- en: Both the public and secret components of the key pair can be extracted separately.
    This makes it easy to extract and communicate only the public key to a third party
    but also makes the secret key separately available for use in the later key-exchange
    operation.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥对的公共和私有组件可以分别提取。这使得仅向第三方提取和传输公钥变得容易，同时也使得私钥分别可用于后续的密钥交换操作。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO2-3)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO2-3)'
- en: As with symmetric encryption, you need a random nonce for each asymmetric encryption
    operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与对称加密一样，每次非对称加密操作都需要一个随机 nonce。
- en: '[![4](assets/4.png)](#co_security_and_encryption_CO2-4)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_security_and_encryption_CO2-4)'
- en: Alice’s public key was potentially distributed via a direct communication channel
    or is otherwise already known.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Alice 的公钥可以通过直接的通信渠道分发，或者已经被知晓。
- en: '[![5](assets/5.png)](#co_security_and_encryption_CO2-5)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_security_and_encryption_CO2-5)'
- en: The key exchange here isn’t being used to agree upon a new key; it’s merely
    combining Bob’s secret key with Alice’s public key to prepare for Bob to encrypt
    a message that can only be read by Alice.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的密钥交换并非用于协商新密钥；它只是简单地将 Bob 的私钥与 Alice 的公钥结合，以便 Bob 加密一条只能由 Alice 读取的消息。
- en: '[![6](assets/6.png)](#co_security_and_encryption_CO2-6)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_security_and_encryption_CO2-6)'
- en: Again, sodium chooses the algorithms and cipher modes involved. All you need
    to do is provide the data, random nonce, and keys, and the library does the rest.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，钠选择所涉及的算法和密码模式。你只需要提供数据、随机 nonce 和密钥，库就会完成其余的工作。
- en: '[![7](assets/7.png)](#co_security_and_encryption_CO2-7)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_security_and_encryption_CO2-7)'
- en: When sending the message, it’s useful to concatenate the nonce and ciphertext,
    then encode the raw bytes as something more readily sent over an HTTP channel.
    Hexadecimal is a common choice, but Base64 encoding is equally valid.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息时，将 nonce 和密文连接在一起，然后将原始字节编码为更易于通过 HTTP 渠道发送的内容。十六进制是常见选择，但 Base64 编码同样有效。
- en: '[![8](assets/8.png)](#co_security_and_encryption_CO2-8)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_security_and_encryption_CO2-8)'
- en: On the receiving end, Alice needs to combine her own secret key with Bob’s public
    key in order to decrypt a message that could have only been encrypted by Bob.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收端，Alice 需要将自己的私钥与 Bob 的公钥结合起来，以解密只能由 Bob 加密的消息。
- en: '[![9](assets/9.png)](#co_security_and_encryption_CO2-9)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_security_and_encryption_CO2-9)'
- en: Extracting the plaintext is as straightforward as encryption was in step 6!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 提取明文就像步骤 6 中的加密一样简单！
- en: '[![10](assets/10.png)](#co_security_and_encryption_CO2-10)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_security_and_encryption_CO2-10)'
- en: As with symmetric encryption, this operation is authenticated. If the encryption
    fails for any reason (e.g., Bob’s public key was invalid) or the authentication
    tag fails to validate, sodium returns a literal `false` to indicate the untrustworthiness
    of the message.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与对称加密一样，此操作也是经过认证的。如果由于任何原因（例如，Bob 的公钥无效）导致加密失败，或者认证标签无法验证，钠会返回一个字面上的 `false`，表明消息不可信任。
- en: Randomness
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机性
- en: In the world of encryption, leveraging a proper source of randomness is critical
    to protecting any sort of data. Older tutorials heavily reference PHP’s [`mt_rand()`](https://oreil.ly/HeBSd)
    function, which is a pseudorandom number generator based on the Mersenne Twister
    algorithm.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密领域中，利用适当的随机源对保护任何类型的数据至关重要。较旧的教程大量引用了基于Mersenne Twister算法的PHP的[`mt_rand()`](https://oreil.ly/HeBSd)函数，这是一个伪随机数生成器。
- en: Unfortunately, while the output of this function appears random to a casual
    observer, it is not a cryptographically safe source of randomness. Instead, leverage
    PHP’s [`random_bytes()`](https://oreil.ly/_eYh6) and [`random_int()`](https://oreil.ly/YWQs8)
    functions for anything critical. Both of these functions leverage the cryptographically
    secure source of randomness built into your local operating system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，尽管此函数的输出对于偶然观察者似乎是随机的，但它不是密码学上安全的随机源。相反，对于关键任务，请使用PHP的[`random_bytes()`](https://oreil.ly/_eYh6)和[`random_int()`](https://oreil.ly/YWQs8)函数。这两个函数利用了您本地操作系统中内置的密码学安全随机源。
- en: Warning
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: A *cryptographically secure pseudorandom number generator* (CSPRNG) is one with
    an output that is indistinguishable from random noise. Algorithms like the Mersenne
    Twister are “random enough” to fool a human into thinking they’re safe. In reality,
    they’re easy for a computer to predict or even crack, given a series of previous
    outputs. If an attacker can reliably predict the output of your random number
    generator, they can conceivably decrypt anything you try to protect based on that
    generator!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码学安全伪随机数生成器*（CSPRNG）的输出与随机噪声无法区分。像Mersenne Twister这样的算法足以愚弄人类认为它们是安全的。但实际上，它们对计算机来说很容易预测甚至破解，只要给定一系列先前的输出。如果攻击者能够可靠地预测您的随机数生成器的输出，他们理论上可以解密基于该生成器的任何您试图保护的内容！'
- en: The following recipes cover some of the most important security- and encryption-related
    concepts in PHP. You’ll learn about input validation, proper password storage,
    and the use of PHP’s sodium interface.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例涵盖了PHP中一些最重要的安全和加密相关概念。您将学习有关输入验证、适当的密码存储以及使用PHP的钠接口的内容。
- en: 9.1 Filtering, Validating, and Sanitizing User Input
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.1 过滤、验证和清理用户输入
- en: Problem
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to validate a specific value provided by an otherwise untrusted user
    prior to using it elsewhere in your application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在将其用于应用程序中的其他地方之前验证来自不受信任用户的特定值。
- en: Solution
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `filter_var()` function to validate that the value matches a specific
    expectation, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`filter_var()`函数验证值是否符合特定期望，如下所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Discussion
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP’s filtering extension empowers you to either validate that data matches
    a specific format or type or sanitize any data that fails that validation. The
    subtle difference between the two options—validation versus sanitization—is that
    sanitization removes invalid characters from a value, whereas validation explicitly
    returns `false` if the final, sanitized input is not of a valid type.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的过滤扩展使您能够验证数据是否符合特定格式或类型，或者对未通过验证的数据进行清理。两种选项之间的微妙差别在于，清理会从值中删除无效字符，而验证会明确返回`false`，如果最终的清理后输入不是有效类型。
- en: In the Solution example, untrusted user input is explicitly validated as a valid
    email address. [Example 9-3](#filter_validate_email) demonstrates the behavior
    of this form of validation across multiple potential inputs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案示例中，明确验证了不受信任的用户输入是否为有效的电子邮件地址。 [示例 9-3](#filter_validate_email)演示了此形式验证在多个潜在输入中的行为。
- en: Example 9-3\. Testing email validation
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-3\. 测试电子邮件验证
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO3-1)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO3-1)'
- en: Returns `blah@example.com`
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`blah@example.com`
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO3-2)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO3-2)'
- en: Returns `false`
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`false`
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO3-3)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO3-3)'
- en: Returns `false`
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`false`
- en: The alternative to the preceding example is to *sanitize* user input such that
    invalid characters are stripped from the entry. The result of this sanitization
    is guaranteed to match a specific character set, but there is no guarantee that
    the result is a valid input. For example, [Example 9-4](#filter_sanitize_email)
    properly sanitizes every possible input string even though two results are invalid
    email addresses.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与前述示例的替代方法是对用户输入进行*清理*，以便从条目中去除无效字符。这种清理的结果保证与特定字符集匹配，但不能保证结果是有效输入。例如，[示例 9-4](#filter_sanitize_email)即使两个结果均为无效电子邮件地址，也会正确地清理每个可能的输入字符串。
- en: Example 9-4\. Testing email sanitization
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-4\. 测试电子邮件清理
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO4-1)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO4-1)'
- en: Returns `blah@example.com`
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `blah@example.com`
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO4-2)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO4-2)'
- en: Returns `1234`
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `1234`
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO4-3)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO4-3)'
- en: Returns `1234@example.comtest`
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `1234@example.comtest`
- en: Whether you want to sanitize or validate your input data depends highly on what
    you intend to use the resulting data for. If you merely want to keep invalid characters
    out of a data storage engine, sanitization might be the right approach. If you
    want to ensure that data is both within the expected character set *and* a valid
    entry, data validation is a safer tool.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您希望对输入数据进行的操作，您可能需要对其进行清理或验证。如果您只是希望在数据存储引擎中保持无效字符之外的数据，那么清理可能是正确的方法。如果您希望确保数据既在预期的字符集范围内，*又*是有效的条目，则数据验证是更安全的工具。
- en: Both approaches are supported equally well by `filter_var()` based on various
    types of filters in PHP. Specifically, PHP supports validation filters (enumerated
    in [Table 9-1](#filter_type_validation)), sanitization filters (enumerated in
    [Table 9-2](#filter_type_sanitization)), and filters falling under neither category
    (see [Table 9-3](#filter_type_misc)). The `filter_var()` function also supports
    an optional third parameter for flags that enable more granular control of the
    overall output of a filter operation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 PHP 中各种类型的过滤器，`filter_var()` 同样支持这两种方法。具体而言，PHP 支持验证过滤器（见[表 9-1](#filter_type_validation)）、清理过滤器（见[表 9-2](#filter_type_sanitization)）以及不属于这两类的过滤器（见[表 9-3](#filter_type_misc)）。`filter_var()`
    函数还支持第三个可选参数，用于启用更精细的控制，以控制过滤操作的整体输出。
- en: Table 9-1\. Validation filters supported by PHP
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-1\. PHP 支持的验证过滤器
- en: '| ID | Options | Flags | Description |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| ID | 选项 | 标志 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `FILTER_​VALI⁠DATE_​BOOLEAN` | `default` | `FILTER_NULL_ON_FAILURE` | Returns
    `true` for truthy values (`1`, `true`, `on`, and `yes`), `false` otherwise |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​VALI⁠DATE_​BOOLEAN` | `default` | `FILTER_NULL_ON_FAILURE` | 对真值（`1`、`true`、`on`
    和 `yes`）返回 `true`，否则返回 `false`'
- en: '| `FILTER_​VALI⁠DATE_​DOMAIN` | `default` | `FILTER_FLAG_HOSTNAME`, `FIL⁠TER_NULL_ON_FAILURE`
    | Validates whether domain name lengths are valid against various RFCs |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​VALI⁠DATE_​DOMAIN` | `default` | `FILTER_FLAG_HOSTNAME`, `FIL⁠TER_NULL_ON_FAILURE`
    | 根据各种 RFC 验证域名长度是否有效 |'
- en: '| `FILTER_​VALI⁠DATE_​EMAIL` | `default` | `FILTER_FLAG_EMAIL_UNICODE`, `FIL⁠TER_​NULL_ON_FAILURE`
    | Validates an email address against the syntax documented in [RFC 822](https://oreil.ly/iHPaR)
    |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​VALI⁠DATE_​EMAIL` | `default` | `FILTER_FLAG_EMAIL_UNICODE`, `FIL⁠TER_​NULL_ON_FAILURE`
    | 根据[RFC 822](https://oreil.ly/iHPaR)的语法验证电子邮件地址 |'
- en: '| `FILTER_​VALI⁠DATE_​FLOAT` | `default`, `decimal`, `min_range`, `max_range`
    | `FIL⁠TER_​FLAG_ALLOW_THOUSANDS`, `FILTER_NULL_ON_FAILURE` | Validates value
    as a float, optionally from a specified range, and converts to that type on success
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​VALI⁠DATE_​FLOAT` | `default`, `decimal`, `min_range`, `max_range`
    | `FIL⁠TER_​FLAG_ALLOW_THOUSANDS`, `FILTER_NULL_ON_FAILURE` | 验证值是否为浮点数，可选地从指定范围内验证，并在成功时转换为该类型
    |'
- en: '| `FILTER_​VALI⁠DATE_​INT` | `default`, `max_range`, `min_range` | `FILTER_FLAG_ALLOW_OCTAL`,
    `FIL⁠TER_FLAG_ALLOW_HEX`, `FIL⁠TER_NULL_ON_FAILURE` | Validates value as an integer,
    optionally from a specified range, and converts to that type on success |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​VALI⁠DATE_​INT` | `default`, `max_range`, `min_range` | `FILTER_FLAG_ALLOW_OCTAL`,
    `FIL⁠TER_FLAG_ALLOW_HEX`, `FIL⁠TER_NULL_ON_FAILURE` | 验证值是否为整数，可选地从指定范围内验证，并在成功时转换为该类型
    |'
- en: '| `FILTER_​VALI⁠DATE_​IP` | `default` | `FILTER_FLAG_IPV4`, `FILTER_FLAG_IPV6`,
    `FIL⁠TER_FLAG_NO_PRIV_RANGE`, `FIL⁠TER_FLAG_NO_RES_RANGE`, `FIL⁠TER_NULL_ON_FAILURE`
    | Validates value as an IP address |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​VALI⁠DATE_​IP` | `default` | `FILTER_FLAG_IPV4`, `FILTER_FLAG_IPV6`,
    `FIL⁠TER_FLAG_NO_PRIV_RANGE`, `FIL⁠TER_FLAG_NO_RES_RANGE`, `FIL⁠TER_NULL_ON_FAILURE`
    | 验证值是否为 IP 地址 |'
- en: '| `FILTER_​VALI⁠DATE_​MAC` | `default` | `FILTER_NULL_ON_FAILURE` | Validates
    value as a MAC address |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​VALI⁠DATE_​MAC` | `default` | `FILTER_NULL_ON_FAILURE` | 将值验证为MAC地址
    |'
- en: '| `FILTER_​VALI⁠DATE_​REGEXP` | `default`, `regexp` | `FILTER_NULL_ON_FAILURE`
    | Validates value against a Perl-compatible regular expression |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​VALI⁠DATE_​REGEXP` | `default`，`regexp` | `FILTER_NULL_ON_FAILURE`
    | 根据Perl兼容的正则表达式验证值 |'
- en: '| `FILTER_​VALI⁠DATE_​URL` | `default` | `FILTER_FLAG_SCHEME_REQUIRED`, `FIL⁠TER_FLAG_HOST_REQUIRED`,
    `FIL⁠TER_FLAG_PATH_REQUIRED`, `FIL⁠TER_FLAG_QUERY_REQUIRED`, `FIL⁠TER_NULL_ON_FAILURE`
    | Validates as a URL according to [RFC 2396](https://oreil.ly/KiLd3) |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​VALI⁠DATE_​URL` | `default` | `FILTER_FLAG_SCHEME_REQUIRED`，`FIL⁠TER_FLAG_HOST_REQUIRED`，`FIL⁠TER_FLAG_PATH_REQUIRED`，`FIL⁠TER_FLAG_QUERY_REQUIRED`，`FIL⁠TER_NULL_ON_FAILURE`
    | 根据[RFC 2396](https://oreil.ly/KiLd3)验证为URL |'
- en: Table 9-2\. Sanitization filters supported by PHP
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-2\. PHP支持的净化过滤器
- en: '| ID | Flags | Description |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| ID | 标志 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `FILTER_​SANI⁠TIZE_EMAIL` |  | Removes all characters except letters, digits,
    and + ! # $ % & '' * + - = ? ^ _ ` { \ &#124; } ~ @ . [ ]  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​SANI⁠TIZE_EMAIL` |  | 移除除了字母、数字和+ ! # $ % & '' * + - = ? ^ _ ` {
    \ &#124; } ~ @ . [ ] 之外的所有字符 |'
- en: '| `FILTER_​SANI⁠TIZE_​ENCODED` | `FILTER_FLAG_STRIP_LOW`, `FIL⁠TER_FLAG_STRIP_HIGH`,
    `FIL⁠TER_FLAG_STRIP_BACKTICK`, `FIL⁠TER_FLAG_ENCODE_HIGH`, `FIL⁠TER_FLAG_ENCODE_LOW`
    | URL-encodes string, optionally stripping or encoding special characters |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​SANI⁠TIZE_​ENCODED` | `FILTER_FLAG_STRIP_LOW`，`FIL⁠TER_FLAG_STRIP_HIGH`，`FIL⁠TER_FLAG_STRIP_BACKTICK`，`FIL⁠TER_FLAG_ENCODE_HIGH`，`FIL⁠TER_FLAG_ENCODE_LOW`
    | 对字符串进行URL编码，可选择剥离或编码特殊字符 |'
- en: '| `FILTER_​SANI⁠TIZE_ADD_SLASHES` |  | Applies `addslashes()` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​SANI⁠TIZE_ADD_SLASHES` |  | 应用 `addslashes()` |'
- en: '| `FILTER_​SANI⁠TIZE_​NUM⁠BER_FLOAT` | `FILTER_FLAG_ALLOW_FRACTION`, `FILTER_FLAG_ALLOW_THOUSANDS`,
    `FILTER_FLAG_ALLOW_SCIENTIFIC` | Removes all characters except digits, plus and
    minus signs, and optionally periods, commas, and uppercase and lowercase *E*s
    |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​SANI⁠TIZE_​NUM⁠BER_FLOAT` | `FILTER_FLAG_ALLOW_FRACTION`，`FILTER_FLAG_ALLOW_THOUSANDS`，`FILTER_FLAG_ALLOW_SCIENTIFIC`
    | 移除除了数字、加号和减号以及可选的句点、逗号和大写和小写 *E* 之外的所有字符 |'
- en: '| `FILTER_​SANI⁠TIZE_​NUM⁠BER_INT` |  | Removes all characters except digits
    and plus and minus signs |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​SANI⁠TIZE_​NUM⁠BER_INT` |  | 移除除了数字、加号和减号之外的所有字符 |'
- en: '| `FILTER_​SANI⁠TIZE_​SPE⁠CIAL_CHARS` | `FILTER_FLAG_STRIP_LOW`, `FIL⁠TER_FLAG_STRIP_HIGH`,
    `FIL⁠TER_FLAG_STRIP_BACKTICK`, `FIL⁠TER_FLAG_ENCODE_HIGH` | HTML-encodes `'' "
    < > &` and characters with ASCII values less than 32, optionally strips or encodes
    other special characters |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​SANI⁠TIZE_​SPE⁠CIAL_CHARS` | `FILTER_FLAG_STRIP_LOW`，`FIL⁠TER_FLAG_STRIP_HIGH`，`FIL⁠TER_FLAG_STRIP_BACKTICK`，`FIL⁠TER_FLAG_ENCODE_HIGH`
    | HTML编码 `'' " < > &` 和ASCII值低于32的字符，可选择剥离或编码其他特殊字符 |'
- en: '| `FILTER_​SANI⁠TIZE_FULL_​SPECIAL_CHARS` | `FILTER_FLAG_NO_ENCODE_QUOTES`
    | Equivalent to calling `htmlspecialchars()` with `ENT_QUOTES` set |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​SANI⁠TIZE_FULL_​SPECIAL_CHARS` | `FILTER_FLAG_NO_ENCODE_QUOTES`
    | 等同于使用设置了 `ENT_QUOTES` 的 `htmlspecialchars()` |'
- en: '| `FILTER_​SANI⁠TIZE_URL` |  | Removes all characters except those valid in
    URLs |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_​SANI⁠TIZE_URL` |  | 移除除了在URL中有效的字符之外的所有字符 |'
- en: Table 9-3\. Miscellaneous filters supported by PHP
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-3\. PHP支持的杂项过滤器
- en: '| ID | Options | Flags | Description |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| ID | 选项 | 标志 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `FILTER_CALLBACK` | `callable` function or method | All flags are ignored.
    | Calls a user-defined function to filter data |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `FILTER_CALLBACK` | `callable` 函数或方法 | 所有标志被忽略。 | 调用用户定义的函数来过滤数据 |'
- en: The validation filters also accept an array of options at runtime. This gives
    you the ability to code specific ranges (for numeric checks) and even fallback
    default values should a particular user input not pass validation.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 验证过滤器还接受运行时的选项数组。这使您能够编写特定范围（用于数字检查）甚至是特定用户输入未通过验证时的默认值。
- en: For example, say you are building a shopping cart that allows the user to specify
    the number of items they want to purchase. Clearly, this must be a value greater
    than zero and less than the total inventory you have available. An approach like
    that illustrated in [Example 9-5](#filter_validate_default) will force the value
    to be an integer between certain bounds or the value will fall back to 1\. In
    this way, a user cannot accidentally order more items than you have, a negative
    number of items, a partial number of items, or some non-numeric amount.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您正在构建一个允许用户指定他们想购买的商品数量的购物车。显然，这必须是大于零且小于您所拥有的总库存的值。像[示例 9-5](#filter_validate_default)中所示的方法将强制该值为介于某些边界之间的整数，否则该值将回退到1。通过这种方式，用户无法意外地订购超过库存、负数商品、部分商品或某些非数值数量。
- en: Example 9-5\. Validating an integer value with bounds and a default
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-5\. 验证带有界限和默认值的整数值
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO5-1)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO5-1)'
- en: The quantity checks out and returns `12`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 数量核对并返回 `12`。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO5-2)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO5-2)'
- en: Negative integers fail to validate, so this returns the default of `1`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 负整数验证失败，因此返回默认值 `1`。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO5-3)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO5-3)'
- en: The input is above the max range, so this returns the default of `1`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输入超出最大范围，因此返回默认值 `1`。
- en: '[![4](assets/4.png)](#co_security_and_encryption_CO5-4)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_security_and_encryption_CO5-4)'
- en: Non-numeric inputs will always return the default of `1`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 非数字输入将始终返回默认值 `1`。
- en: See Also
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on PHP’s [data filtering extension](https://oreil.ly/UX_Hs).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的[数据过滤扩展的文档](https://oreil.ly/UX_Hs)。
- en: 9.2 Keeping Sensitive Credentials Out of Application Code
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.2 将敏感凭据从应用程序代码中排除
- en: Problem
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your application needs to leverage a password or API key, and you want to avoid
    having that sensitive credential written in code or committed to version control.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序需要利用密码或API密钥，并且希望避免将敏感凭据写入代码或提交到版本控制。
- en: Solution
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Store the credential in an environment variable exposed by the server running
    the application. Then reference that environment variable in code. For example:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将凭据存储在运行应用程序的服务器暴露的环境变量中。然后在代码中引用该环境变量。例如：
- en: '[PRE6]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A common mistake made in many developers’ early careers is to hardcode credentials
    for sensitive systems into constants or other places in application code. While
    this makes those credentials readily available to application logic, it also introduces
    severe risk to your application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者在早期职业生涯中常犯的一个错误是将敏感系统的凭据硬编码到常量或应用程序代码的其他位置。虽然这样可以让这些凭据容易被应用逻辑访问，但也会严重增加应用程序的风险。
- en: You could accidentally use production credentials from a development account.
    An attacker might find credentials indexed in an accidentally public repository.
    An employee might abuse their knowledge of credentials beyond their intended use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会意外地从开发账户中使用生产凭据。攻击者可能会在意外公开的代码库中找到索引的凭据。员工可能会滥用他们对凭据的知识，超出预期的使用范围。
- en: In production, the best credentials are those unknown to and untouched by humans.
    It’s a good idea to keep those credentials only in the production environment
    and use *separate accounts* for development and testing. Leveraging environment
    variables within your code makes your application flexible enough to run anywhere,
    as it uses not hardcoded credentials but those bound to the environment itself.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，最好的凭据是那些未知且未被人为操作的。最好将这些凭据仅保留在生产环境中，并为开发和测试使用*单独的账户*。在代码中利用环境变量使得应用程序足够灵活，能够在任何地方运行，因为它使用的是环境本身而不是硬编码的凭据。
- en: Warning
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: PHP’s built-in information system, `phpinfo()`, will automatically enumerate
    all environment variables for debugging purposes. Once you begin leveraging the
    system environment to house sensitive credentials, take extra care to avoid using
    detailed diagnostic tools like `phpinfo()` in publicly accessible parts of your
    application!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: PHP内置的信息系统 `phpinfo()` 将自动列举所有环境变量，用于调试目的。一旦开始利用系统环境存放敏感凭据，请特别注意避免在应用程序的公开可访问部分使用诸如
    `phpinfo()` 这样详细的诊断工具！
- en: 'The method of *populating* environment variables will differ from one system
    to another. In Apache-powered systems, you can set environment variables by using
    the `SetEnv` keyword within the `<VirtualHost>` directive as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*填充*环境变量的方法会因系统而异。在使用Apache的系统中，可以通过在 `<VirtualHost>` 指令内使用 `SetEnv` 关键字来设置环境变量，如下所示：'
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In NGINX-powered systems, you can set environment variables for PHP only if
    it’s running as a FastCGI process. Similar to Apache’s `SetEnv`, this is done
    with a keyword within a `location` directive in the NGINX configuration as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在由NGINX驱动的系统中，只有在PHP作为FastCGI进程运行时，才能设置环境变量。类似于Apache的 `SetEnv`，这可以通过在NGINX配置的
    `location` 指令内使用关键字来完成，如下所示：
- en: '[PRE8]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Separately, Docker-powered systems set environment variables in either their
    Compose files (for Docker Swarm) or the system deployment configuration (for Kubernetes).
    In all of these situations, you are defining a credential within the environment
    itself rather than within your application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 驱动的系统分别在其 Compose 文件（用于 Docker Swarm）或系统部署配置（用于 Kubernetes）中设置环境变量。在所有这些情况下，您都是在环境本身而不是应用程序内部定义凭据。
- en: An additional option is to use [PHP dotenv](https://oreil.ly/a4TQp).^([4](ch09.html#idm45875151024592))
    This third-party package allows you to define your environment configuration in
    a flat file named *.env* and it automatically populates both environment variables
    and the `$_SERVER` superglobal. The biggest advantage of this approach is that
    dotfiles (files prefixed with a `.`) are easy to exclude from version control
    and are typically hidden on a server to begin with. You can use a *.env* locally
    to define development credentials and keep a separate *.env* on the server to
    define production credentials.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用 [PHP dotenv](https://oreil.ly/a4TQp)^([4](ch09.html#idm45875151024592))。这个第三方包允许您在名为
    *.env* 的平面文件中定义您的环境配置，并自动填充环境变量和 `$_SERVER` 超全局数组。这种方法的最大优势在于 dotfiles（以 `.` 开头的文件）很容易从版本控制中排除，并且通常在服务器上是隐藏的。您可以在本地使用一个
    *.env* 文件来定义开发凭据，并在服务器上保留一个单独的 *.env* 文件来定义生产凭据。
- en: In both cases, you never have to directly manage an Apache or NGINX configuration
    file at all!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，您都无需直接管理任何 Apache 或 NGINX 配置文件！
- en: 'A *.env* file defining the database credentials used in the Solution example
    would look something like the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *.env* 文件定义的数据库凭据，用于解决方案示例，看起来类似以下内容：
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In your application code, you would then load the library dependency and invoke
    its loader as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序代码中，您可以加载库依赖项并按如下方式调用其加载器：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once the library is loaded, you can leverage `getenv()` to reference the environment
    variables wherever you need access.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了库，您可以利用 `getenv()` 在需要访问环境变量的任何地方引用它们。
- en: See Also
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on [`getenv()`](https://oreil.ly/t6ncZ).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[`getenv()`文档](https://oreil.ly/t6ncZ)。'
- en: 9.3 Hashing and Validating Passwords
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.3 哈希和验证密码
- en: Problem
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to authenticate users leveraging passwords only they know and prevent
    your application from storing sensitive data.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望仅通过用户知道的密码进行身份验证，并防止您的应用程序存储敏感数据。
- en: Solution
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `password_hash()` to store secure hashes of passwords:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `password_hash()` 来存储密码的安全哈希：
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use `password_verify()` to verify that a plaintext password produces a given,
    stored hash as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `password_verify()` 来验证一个明文密码是否产生了给定的存储哈希，如下所示：
- en: '[PRE12]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Discussion
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Storing passwords in plaintext is always a bad idea. If your application or
    data store is ever breached, those plaintext passwords can and will be abused
    by attackers. To keep your users safe and protect them from potential abuse in
    the case of a breach, you must always hash those passwords when storing them in
    your database.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 存储明文密码始终是一个坏主意。如果您的应用程序或数据存储曾被入侵过，那些明文密码将会被攻击者滥用。为了保护用户安全并在遭遇入侵时防止滥用，您必须始终在存储密码时对其进行哈希处理。
- en: Conveniently, PHP ships with a native function to do just that—`password_hash()`.
    This function takes a plaintext password and automatically generates a deterministic
    but seemingly random hash from that data. Rather than storing the plaintext password,
    you store this hash. Later, when the user chooses to log into your application,
    you can compare the plaintext password against the stored hash (using a safe comparison
    function like `hash_equals()`) and assert whether they match.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，PHP 集成了一个原生功能来实现这一点——`password_hash()`。此函数接受明文密码，并自动从该数据生成一个确定性但看似随机的哈希。与其存储明文密码，您存储这个哈希。稍后，当用户选择登录您的应用程序时，您可以比较明文密码与存储的哈希（使用像
    `hash_equals()` 这样的安全比较函数），并断言它们是否匹配。
- en: PHP generally supports three hashing algorithms, enumerated in [Table 9-4](#password_hashing_algorithms).
    At the time of this writing, the default algorithm is bcrypt (which is based on
    the Blowfish cipher), but you can choose a particular algorithm at runtime by
    passing a second parameter into `password_hash()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 通常支持三种哈希算法，在[表 9-4](#password_hashing_algorithms)中列举。在撰写本文时，默认算法是 bcrypt（基于
    Blowfish 密码），但您可以通过向 `password_hash()` 传递第二个参数来在运行时选择特定的算法。
- en: Table 9-4\. Password hashing algorithms
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 表 9-4\. 密码哈希算法
- en: '| Constant | Description |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PASSWORD_DEFAULT` | Use the default bcrypt algorithm. The default algorithm
    could change in a future release. |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `PASSWORD_DEFAULT` | 使用默认的bcrypt算法。默认算法可能会在将来的版本中更改。 |'
- en: '| `PASSWORD_BCRYPT` | Use the `CRYPT_BLOWFISH` algorithm. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `PASSWORD_BCRYPT` | 使用`CRYPT_BLOWFISH`算法。 |'
- en: '| `PASSWORD_ARGON2I` | Use the Argon2i hashing algorithm. (Only available if
    PHP has been compiled with Argon2 support.) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `PASSWORD_ARGON2I` | 使用Argon2i散列算法。（仅在PHP已编译为支持Argon2时可用。） |'
- en: '| `PASSWORD_ARGON2ID` | Use the Argon2id hashing algorithm. (Only available
    if PHP has been compiled with Argon2 support.) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `PASSWORD_ARGON2ID` | 使用Argon2id散列算法。（仅在PHP已编译为支持Argon2时可用。） |'
- en: Each hashing algorithm supports a set of options that can determine the difficulty
    of calculating a hash on the server. The default (or bcrypt) algorithm supports
    an integer “cost” factor—the higher the number, the more computationally expensive
    the operation will be. The Argon2 family of algorithms supports two cost factors—one
    for the memory cost and one for the amount of time it will take to compute a hash.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每个散列算法支持一组选项，这些选项可以确定服务器上计算散列的难度。默认（或bcrypt）算法支持一个整数“成本”因子——数字越高，操作的计算成本就越高。Argon2系列算法支持两个成本因子——一个用于内存成本，另一个用于计算散列所需的时间量。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Increasing the cost for computing a hash is a means of protecting the application
    from brute-force authentication attacks. If it takes 1 second to calculate a hash,
    it will take *at least* 1 second for a legitimate party to authenticate (this
    is trivial). However, an attacker can attempt to authenticate *at most* once per
    second. This renders brute-force attacks relatively costly both in terms of time
    and computing capacity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 增加计算散列成本是一种保护应用程序免受暴力破解身份验证攻击的手段。如果计算一个散列需要1秒钟，那么合法用户进行身份验证将至少需要1秒钟（这很简单）。但是，攻击者每秒最多只能尝试进行一次身份验证。这使得暴力破解攻击在时间和计算能力上都相对昂贵。
- en: When you first build your application, it is a good idea to test the server
    environment that will run it and set your cost factors appropriately. Identifying
    cost factors requires testing the performance of `password_hash()` on the live
    environment, as demonstrated in [Example 9-6](#password_hash_cost_test). This
    script will test the hashing performance of the system with increasingly large
    cost factors and identify a cost factor that achieves the desired time target.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在首次构建应用程序时，建议测试将运行该应用程序的服务器环境，并适当设置成本因子。识别成本因子需要在现场环境中测试`password_hash()`的性能，正如在[示例9-6](#password_hash_cost_test)中所演示的。该脚本将测试系统使用越来越大的成本因子时的散列性能，并确定达到期望时间目标的成本因子。
- en: Example 9-6\. Testing the cost factors for `password_hash()`
  id: totrans-193
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-6。测试`password_hash()`的成本因子
- en: '[PRE13]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output of `password_hash()` is intended to be fully forward compatible.
    Rather than merely generate a hash, the function will also internally generate
    a salt to make the hash unique. Then the function returns a string representing
    the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`password_hash()`的输出旨在完全向前兼容。该函数不仅生成散列，还会内部生成一个盐以使散列唯一化。然后该函数返回表示以下内容的字符串：'
- en: The algorithm used
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用的算法
- en: The cost factors or options
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成本因子或选项
- en: The generated random salt
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的随机盐
- en: The resulting hash
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成的散列
- en: '[Figure 9-1](#password_hash_output) shows an example of this string output.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9-1](#password_hash_output)显示了此字符串输出的示例。'
- en: Note
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A unique, random salt is generated internally by PHP every time you call `password_hash()`.
    This has the effect of producing distinct hashes for identical plaintext passwords.
    In this way, hashed values can’t be used to identify which accounts are using
    the same passwords.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: PHP在每次调用`password_hash()`时会内部生成一个唯一的随机盐。这样做的效果是，对于相同的明文密码，产生不同的散列。通过这种方式，散列值不能用于识别哪些帐户使用相同的密码。
- en: '![Illustration of the output of +password_hash()+](assets/phpc_0901.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![Illustration of the output of +password_hash()+](assets/phpc_0901.png)'
- en: Figure 9-1\. Example output of `password_hash()`
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图9-1。`password_hash()`的输出示例
- en: The advantage of encoding all of this information into the output of `pass⁠word_​hash()`
    is that you don’t need to maintain this data in the application. At a future date,
    you might change the hashing algorithm or modify the cost factors used for hashing.
    By encoding the settings originally used to generate a hash, PHP can reliably
    re-create a hash for comparison.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些信息编码到`pass⁠word_​hash()`的输出中的优势在于，您无需在应用程序中维护这些数据。在将来的某个日期，您可能会更改散列算法或修改用于散列的成本因素。通过编码最初用于生成散列的设置，PHP可以可靠地重新创建用于比较的散列。
- en: When a user logs in, they provide only their plaintext password. The application
    needs to recompute a hash of this password and compare the newly computed value
    with the one stored in the database. Given that the information you need to calculate
    a hash is stored alongside the hash, this becomes relatively straightforward.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录时，他们只提供明文密码。应用程序需要重新计算此密码的哈希值，并将新计算的值与存储在数据库中的值进行比较。鉴于需要计算哈希的信息存储在哈希旁边，这变得相对简单。
- en: Rather than implement the comparison yourself, though, you can leverage PHP’s
    `password_verify()` function that does all this in a safe and secure way.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是自己实现比较，您可以利用PHP的`password_verify()`函数以安全可靠的方式完成所有操作。
- en: See Also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on [`password_hash()`](https://oreil.ly/gZwBC) and [`password_​verify()`](https://oreil.ly/gf3O9).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有关[`password_hash()`](https://oreil.ly/gZwBC)和[`password_​verify()`](https://oreil.ly/gf3O9)的文档。
- en: 9.4 Encrypting and Decrypting Data
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.4 加密和解密数据
- en: Problem
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to protect sensitive data leveraging encryption and reliably decrypt
    that information at a later time.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用加密保护敏感数据，并能够在稍后可靠地解密这些信息。
- en: Solution
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use sodium’s `sodium_crypto_secretbox()` to encrypt the data with a known symmetric
    (aka shared) key, as shown in [Example 9-7](#sodium_symmetric_solution_example).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 使用sodium的`sodium_crypto_secretbox()`来使用已知的对称（也称为共享）密钥加密数据，如示例 9-7中所示。
- en: Example 9-7\. Sodium symmetric encryption example
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-7。Sodium对称加密示例
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO6-1)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO6-1)'
- en: The key must be a random value of length `SODIUM_CRYPTO_SECRETBOX_KEYBYTES`
    (32 bytes). If you are creating a new, random string, you can leverage `sodium_crypto_secretbox_keygen()`
    to create one. Just be sure to store it somewhere so you can decrypt the message
    later.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥必须是长度为`SODIUM_CRYPTO_SECRETBOX_KEYBYTES`（32字节）的随机值。如果您正在创建一个新的随机字符串，可以使用`sodium_crypto_secretbox_keygen()`来创建一个。只需确保将其存储在某个地方，以便稍后解密消息。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO6-2)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO6-2)'
- en: Every encryption operation should use a unique, random nonce. PHP’s `ran⁠dom_​bytes()`
    can reliably create one of the appropriate length by using built-in constants.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加密操作都应使用唯一的、随机的一次性数字。PHP的`ran⁠dom_​bytes()`可以可靠地创建适当长度的随机数，使用内置常量。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO6-3)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO6-3)'
- en: The encryption operation leverages both the random nonce and the fixed secret
    key to protect the message and returns raw bytes as a result.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 加密操作利用随机一次性数字和固定的秘密密钥来保护消息，并作为结果返回原始字节。
- en: '[![4](assets/4.png)](#co_security_and_encryption_CO6-4)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_security_and_encryption_CO6-4)'
- en: Often you want to exchange encrypted information over a network protocol, so
    encoding the raw bytes as hexadecimal can make it more portable. You’ll also need
    the nonce to decrypt the exchanged data, so you store it alongside the ciphertext.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 通常希望通过网络协议交换加密信息，因此将原始字节编码为十六进制可以使其更易于移植。您还需要一次性数字来解密交换的数据，因此将其存储在密文旁边。
- en: When you need to decrypt the data, use `sodium_crypto_secretbox_open()` to both
    extract and validate the data, as shown in [Example 9-8](#sodium_symmetric_decryption).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要解密数据时，使用`sodium_crypto_secretbox_open()`来提取和验证数据，如示例 9-8中所示。
- en: Example 9-8\. Sodium symmetric decryption
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-8。Sodium对称解密
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO7-1)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO7-1)'
- en: Use the same key for decryption that you used for encryption.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用解密时所用的相同密钥，该密钥用于加密。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO7-2)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO7-2)'
- en: The resulting ciphertext from [Example 9-7](#sodium_symmetric_solution_example)
    is reused here and is extracted from a hexadecimal-encoded string.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从[示例 9-7](#sodium_symmetric_solution_example)得到的结果密文在此处被重复使用，并且从十六进制编码的字符串中提取。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO7-3)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO7-3)'
- en: Because you concatenated the ciphertext and nonce, you must split the two components
    apart for use with `sodium_crypto_secretbox_open()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因为您将密文和一次性数字串联在一起，所以必须将这两个组件分开以便与`sodium_crypto_secretbox_open()`一起使用。
- en: '[![4](assets/4.png)](#co_security_and_encryption_CO7-4)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_security_and_encryption_CO7-4)'
- en: This entire encryption/decryption operation is authenticated. If anything changed
    in the underlying data, the authentication step will fail and the function will
    return a literal `false` to flag the manipulation. If it returns anything else,
    the decryption succeeded and you can trust the output!
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 整个加密/解密操作都是经过验证的。如果底层数据发生任何变化，验证步骤将失败，并且函数会返回字面值`false`来标记篡改。如果返回其他内容，则解密成功，您可以信任输出！
- en: Discussion
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `secretbox` family of functions exposed by sodium implements authenticated
    encryption/decryption by using a fixed symmetric key. Every time you encrypt a
    message, you should do so with a random nonce to fully protect the privacy of
    the encrypted message.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 由sodium公开的`secretbox`函数系列通过使用固定的对称密钥实现了经过验证的加密/解密。每次加密消息时，都应该使用一个随机的随机数来完全保护加密消息的隐私。
- en: Warning
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The nonce used in encryption itself isn’t a secret or sensitive value. However,
    you should take care never to reuse a nonce with the same symmetric encryption
    key. Nonces are “numbers used once” and are intended to add randomness to the
    encryption algorithm such that the same value encrypted twice with the same key
    can produce different ciphertexts. Reusing a nonce with a specific key compromises
    the security of the data you’re aiming to protect.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在加密中使用的随机数（nonce）本身不是秘密或敏感值。然而，您应该注意，永远不要在相同的对称加密密钥下重复使用随机数。随机数是“一次性使用”的数字，旨在为加密算法增加随机性，使得使用相同密钥加密两次的相同值可以产生不同的密文。重复使用随机数会损害您希望保护的数据的安全性。
- en: The symmetry here is that the same key is used both to encrypt and decrypt a
    message. This is most valuable when the same system is responsible for both operations—for
    example, when a PHP application needs to encrypt data to be stored in a database
    and then decrypt that data when reading it back out.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的对称性在于同一个密钥用于加密和解密消息。当同一个系统负责这两个操作时，这是最有价值的——例如，当PHP应用程序需要加密要存储在数据库中的数据，然后在读取时解密该数据。
- en: The encryption leverages the [XSalsa20 stream cipher](https://oreil.ly/DSUAQ)
    to protect data. This cipher uses a 32-byte (256-bit) key and a 24-byte (192-bit)
    nonce. None of this information is necessary for developers to keep track of,
    though, as it’s safely abstracted behind the `secretbox` functions and constants.
    Rather than keep track of key sizes and encryption modes, you merely need to create
    or *open* a box with the matched key and nonce for the message.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 加密利用[XSalsa20流密码](https://oreil.ly/DSUAQ)来保护数据。这种密码使用32字节（256位）密钥和24字节（192位）随机数。尽管开发者不必关心这些信息，因为它们被安全地抽象在`secretbox`函数和常量后面。与跟踪密钥大小和加密模式不同，您只需使用匹配的密钥和消息随机数来创建或*打开*一个盒子。
- en: Another advantage of this approach is authentication. Every encryption operation
    will also generate a message authentication tag leveraging the [Poly1305 algorithm](https://oreil.ly/tSgmq).
    Upon decryption, sodium will validate that the authentication tag matches the
    protected data. If there is not a match, it’s possible that the message was either
    accidentally corrupted or intentionally manipulated. In either case, the ciphertext
    is unreliable (as would be any decrypted plaintext), and the open function will
    return a Boolean `false`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的另一个优点是身份验证。每个加密操作也将生成一个消息身份验证标签，利用[Poly1305算法](https://oreil.ly/tSgmq)。解密时，sodium将验证身份验证标签是否与受保护数据匹配。如果不匹配，可能是消息意外损坏或有意篡改。在任何一种情况下，密文都是不可靠的（解密后的明文也是如此），并且open函数将返回一个布尔值`false`。
- en: Asymmetric encryption
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非对称加密
- en: Symmetric encryption is easiest when the same party is both encrypting and decrypting
    data. In many modern tech environments, these parties might be independent and
    communicating over less-than-trustworthy media. This necessitates a different
    form of encryption, as the two parties cannot directly share a symmetric encryption
    key. Instead, each can create pairs of public and private keys and leverage key
    exchange to agree upon an encryption key.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当同一个方负责加密和解密数据时，对称加密最为简单。在许多现代技术环境中，这些参与方可能是独立的，并通过不太可信的媒体进行通信。这需要一种不同形式的加密，因为两个参与方不能直接共享对称加密密钥。相反，每个参与方可以创建公钥和私钥对，并利用密钥交换协议来就加密密钥达成一致。
- en: 'Key exchange is a complicated topic. Luckily, sodium exposes simple interfaces
    for performing the operation in PHP. In the examples that follow, two parties
    will do the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥交换是一个复杂的话题。幸运的是，sodium为在PHP中执行此操作提供了简单的接口。在接下来的示例中，两个参与方将执行以下操作：
- en: Create public/private key pairs
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建公钥/私钥对
- en: Exchange their public keys directly
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接交换他们的公钥
- en: Use these asymmetric keys to agree upon a symmetric key
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用这些非对称密钥达成对称密钥协议
- en: Exchange encrypted data
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 交换加密数据
- en: '[Example 9-9](#asymmetric_key_creation) illustrates how each party will create
    their own public/private key pairs. Though the code example is in a single block,
    each party would create their keys independently and only ever exchange their
    public keys with one another.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-9](#asymmetric_key_creation)说明了每一方如何创建自己的公钥/私钥对。尽管代码示例是一个单独的块，但每一方都会独立创建他们的密钥，并且只与对方交换他们的公钥。'
- en: Example 9-9\. Asymmetric key creation
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-9\. 非对称密钥创建
- en: '[PRE16]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO8-1)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO8-1)'
- en: Alice creates a key pair and extracts her public and private key from it separately.
    She shares her public key with Beth.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: Alice创建一个密钥对，并从中分别提取她的公钥和私钥。她与Beth分享她的公钥。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO8-2)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO8-2)'
- en: Alice keeps her private key secret. This is the key she will use to encrypt
    data *for* Beth and decrypt data *from* her. Similarly, Alice would use her private
    key to encrypt data for anyone else who has shared their public key with her.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Alice保持她的私钥保密。这是她用来为Beth加密数据和从她那里解密数据的密钥。类似地，Alice将使用她的私钥为任何与她分享其公钥的人加密数据。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO8-3)'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO8-3)'
- en: Beth independently does the same thing as Alice and shares her own public key.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Beth像Alice一样独立执行相同的操作，并分享她自己的公钥。
- en: Once Alice and Beth have shared their public keys, they are free to communicate
    privately. The `cryptobox` family of functions in sodium leverages these asymmetric
    keys to compute a symmetric key that can be used for confidential communication.
    This symmetric key is not exposed directly to either party, but allows the parties
    to easily communicate with one another.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Alice和Beth分享了他们的公钥，他们就可以自由地进行私密通信。sodium中的`cryptobox`函数族利用这些非对称密钥计算可以用于机密通信的对称密钥。这个对称密钥不会直接暴露给任何一方，但允许双方轻松地进行通信。
- en: Note that anything Alice encrypts for Beth can *only* be decrypted by Beth.
    Even Alice cannot decrypt these messages, as she does not have Beth’s private
    key! [Example 9-10](#asymmetric_encryption_simple_message) illustrates how Alice
    can encrypt a simple message leveraging both her own private key and Beth’s advertised
    public key.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Alice为Beth加密的任何内容只能被Beth解密。即使是Alice也无法解密这些消息，因为她没有Beth的私钥！[示例 9-10](#asymmetric_encryption_simple_message)说明了Alice如何利用她自己的私钥和Beth公开的公钥加密简单消息。
- en: Example 9-10\. Asymmetric encryption
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-10\. 非对称加密
- en: '[PRE17]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO9-1)'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO9-1)'
- en: The encryption key used here is actually a key pair composed of information
    from both Alice’s and Beth’s individual key pairs.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的加密密钥实际上是由Alice和Beth各自密钥对的信息组成的。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO9-2)'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO9-2)'
- en: As with symmetric encryption, you leverage a nonce in order to introduce randomness
    into the encrypted output.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与对称加密类似，您可以利用一次性密码本引入加密输出的随机性。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO9-3)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO9-3)'
- en: You concatenate the random nonce and the encrypted ciphertext so Alice can send
    both to Beth at the same time.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您将随机nonce和加密的密文串联起来，以便Alice可以同时将两者发送给Beth。
- en: The key pairs involved are points on an elliptic curve, specifically Curve25519\.
    The initial operation sodium uses for asymmetric encryption is a *key exchange*
    between two of these points to define a fixed but secret number. This operation
    uses the [X25519 key exchange algorithm](https://oreil.ly/OAqeF) and produces
    a number based on Alice’s private key and Beth’s public key.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的关键对是椭圆曲线上的点，具体来说是Curve25519。sodium用于非对称加密的初始操作是两个这些点之间的*密钥交换*，以定义一个固定但保密的数字。这个操作使用[X25519密钥交换算法](https://oreil.ly/OAqeF)，并基于Alice的私钥和Beth的公钥生成一个数字。
- en: That number is then used as a key with the XSalsa20 stream cipher (the same
    one used for symmetric encryption) to encrypt the message. As with symmetric encryption
    discussed for the `secret box` family of functions, a `cryptobox` will leverage
    a Poly1305 message authentication tag to protect the message against tampering
    or corruption.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将该数字用作 XSalsa20 流密码（与对称加密使用的相同）的密钥，以加密消息。类似于对称加密中讨论的 `secret box` 函数族，`cryptobox`
    将利用 Poly1305 消息认证标签保护消息，以防篡改或损坏。
- en: At this point, Beth, by leveraging her own private key, Alice’s public key,
    and the message nonce, can reproduce all of these steps on her own to decrypt
    the message. She performs a similar X25519 key exchange to derive the same shared
    key and then uses that for decryption.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Beth 利用她自己的私钥、Alice 的公钥和消息的 nonce，可以独立地重现所有这些步骤来解密消息。她执行类似的 X25519 密钥交换以推导相同的共享密钥，然后用于解密。
- en: Thankfully, sodium abstracts the key exchange and derivation for us, making
    asymmetric decryption relatively straightforward. See [Example 9-11](#asymmetric_decryption).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，sodium 为我们抽象了密钥交换和推导，使得非对称解密相对简单。参见 [Example 9-11](#asymmetric_decryption)。
- en: Example 9-11\. Asymmetric decryption
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-11\. 非对称解密
- en: '[PRE18]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO10-1)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO10-1)'
- en: Similar to the `secretbox` operation, you first extract the nonce and ciphertext
    from the hexadecimal-encoded payload provided by Alice.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `secretbox` 操作，你首先从 Alice 提供的十六进制编码的负载中提取 nonce 和密文。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO10-2)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO10-2)'
- en: Beth uses her own private key along with Alice’s public key to create a key
    pair appropriate for decrypting the message.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Beth 使用她自己的私钥以及 Alice 的公钥来创建一个适合解密消息的密钥对。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO10-3)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO10-3)'
- en: The key exchange and decryption operations are abstracted away with a simple
    “open” interface to read the message.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥交换和解密操作被简化为一个简单的“打开”接口来读取消息。
- en: '[![4](assets/4.png)](#co_security_and_encryption_CO10-4)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_security_and_encryption_CO10-4)'
- en: As with symmetric encryption, sodium’s asymmetric interfaces will validate the
    Poly1305 authentication tag on the message before decrypting and returning the
    plaintext.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 与对称加密一样，sodium 的非对称接口在解密和返回明文之前会验证消息的 Poly1305 认证标签。
- en: Either mechanism—symmetric or asymmetric encryption—is well supported and cleanly
    abstracted by sodium’s functional interfaces. This helps avoid errors commonly
    encountered when implementing older mechanisms (like AES or RSA). Libsodium (the
    C-level library powering the sodium extension) is widely supported in other languages
    as well, providing solid interoperability between PHP, Ruby, Python, JavaScript,
    and even lower-level languages like C and Go.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 不管是对称还是非对称加密机制，sodium 的功能接口都得到了很好的支持和清晰的抽象。这有助于避免在实现旧的机制（如 AES 或 RSA）时常见的错误。Libsodium（支持
    sodium 扩展的 C 级库）在其他语言中也得到了广泛支持，提供了 PHP、Ruby、Python、JavaScript 甚至低级语言如 C 和 Go 之间的稳固互操作性。
- en: See Also
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on [`sodium_​crypto_​secretbox()`](https://oreil.ly/3IZZM), [`sodium_​crypto_​secret⁠box_​open()`](https://oreil.ly/qNDqx),
    [`sodium_​crypto_​box()`](https://oreil.ly/-apZN), and [`sodium_crypto_box_open()`](https://oreil.ly/5lT_D).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 [`sodium_​crypto_​secretbox()`](https://oreil.ly/3IZZM)、[`sodium_​crypto_​secret⁠box_​open()`](https://oreil.ly/qNDqx)、[`sodium_​crypto_​box()`](https://oreil.ly/-apZN)
    和 [`sodium_crypto_box_open()`](https://oreil.ly/5lT_D) 的文档。
- en: 9.5 Storing Encrypted Data in a File
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.5 将加密数据存储在文件中
- en: Problem
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to encrypt (or decrypt) a file that is too large to fit in memory.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望加密（或解密）一个太大而无法装入内存的文件。
- en: Solution
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the *push* streaming interfaces exposed by sodium to encrypt one chunk of
    the file at a time, as shown in [Example 9-12](#libsodium_stream_encrypt).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 sodium 提供的 *push* 流接口，逐块加密文件，如 [Example 9-12](#libsodium_stream_encrypt)
    中所示。
- en: Example 9-12\. Sodium stream encryption
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-12\. Sodium 流加密
- en: '[PRE19]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO11-1)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO11-1)'
- en: Initializing the stream operation yields two values—a header and the current
    state of the stream. The header itself contains a random nonce and is required
    in order to decrypt anything encrypted with the stream.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化流操作会产生两个值——一个头部和流的当前状态。头部本身包含一个随机 nonce，并且在解密任何使用该流加密的内容时是必需的。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO11-2)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO11-2)'
- en: Open both the input and output files as binary streams. Working with files is
    one of the few times you want to emit raw bytes rather than leverage hexadecimal
    or Base64 encoding to wrap an encrypted output.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 将输入和输出文件都作为二进制流打开。在处理文件时，唯一不使用十六进制或Base64编码来封装加密输出的情况之一是。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO11-3)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO11-3)'
- en: To ensure that you can decrypt the file, first store the fixed-length header
    for later retrieval.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保您可以解密文件，首先存储固定长度的头部以供稍后检索。
- en: '[![4](assets/4.png)](#co_security_and_encryption_CO11-4)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_security_and_encryption_CO11-4)'
- en: Before you begin iterating over chunks of bytes in the file, you need to determine
    how large the input file really is.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始迭代文件字节块之前，您需要确定输入文件的实际大小。
- en: '[![5](assets/5.png)](#co_security_and_encryption_CO11-5)'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_security_and_encryption_CO11-5)'
- en: As with other sodium operations, the stream encryption cipher is built atop
    Poly1305 authentication tags (which are 17 bytes in length). As a result, you
    read 17 bytes less than the standard 4,096-byte block, so the output will be a
    total of 4,081 bytes written to the file.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他钠操作一样，流加密密码建立在Poly1305认证标签之上（长度为17字节）。因此，您读取比标准的4,096字节块少17字节，因此输出将是写入文件的总计4,081字节。
- en: '[![6](assets/6.png)](#co_security_and_encryption_CO11-6)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_security_and_encryption_CO11-6)'
- en: The sodium API encrypts the plaintext and automatically updates the state variable
    (`$state` is passed by reference and updated in place).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 钠API加密明文并自动更新状态变量（`$state`通过引用传递并在原地更新）。
- en: '[![7](assets/7.png)](#co_security_and_encryption_CO11-7)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_security_and_encryption_CO11-7)'
- en: After you’re done with encryption, explicitly zero out the memory of the state
    variable. PHP’s garbage collector will clean up the references, but you want to
    ensure that no coding errors elsewhere in the system can inadvertently leak this
    value.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 加密完成后，显式清空状态变量的内存。PHP的垃圾回收器会清理引用，但您需要确保系统中的其他编码错误不会无意中泄漏此值。
- en: '[![8](assets/8.png)](#co_security_and_encryption_CO11-8)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_security_and_encryption_CO11-8)'
- en: Finally, close the file handles since the encryption is complete.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于加密完成，关闭文件句柄。
- en: To decrypt the file, use sodium’s *pull* streaming interfaces, as shown in [Example 9-13](#sodium_stream_decryption).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密文件，请使用钠的*pull*流接口，如[示例 9-13](#sodium_stream_decryption)所示。
- en: Example 9-13\. Sodium stream decryption
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-13\. 钠流解密
- en: '[PRE20]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO12-1)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO12-1)'
- en: Before you can begin decryption, you must explicitly retrieve the header value
    from the file you encrypted in the first place.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始解密之前，您必须显式从您首次加密的文件中检索头部值。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO12-2)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO12-2)'
- en: Armed with the encryption header and key, you can initialize the stream state
    as desired.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有加密头部和密钥后，您可以按需初始化流状态。
- en: '[![3](assets/3.png)](#co_security_and_encryption_CO12-3)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_security_and_encryption_CO12-3)'
- en: Keep in mind that the file is prefixed with a header, so you skip those bytes
    and then pull chunks of 4,096 bytes at a time. This will include 4,079 bytes of
    ciphertext and 17 bytes of authentication tag.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住文件以头部为前缀，因此您需要跳过这些字节，然后每次提取4,096字节的块。这将包括4,079字节的密文和17字节的认证标签。
- en: '[![4](assets/4.png)](#co_security_and_encryption_CO12-4)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_security_and_encryption_CO12-4)'
- en: The actual stream decryption operation returns a tuple of the plaintext and
    an optional status tag (e.g., to identify that a key needs to be rotated).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的流解密操作返回明文的元组和一个可选的状态标签（例如，用于标识需要旋转密钥的情况）。
- en: '[![5](assets/5.png)](#co_security_and_encryption_CO12-5)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_security_and_encryption_CO12-5)'
- en: If the authentication tag on the encrypted message fails to validate, however,
    this function will return `false` to indicate the authentication failure. Should
    this occur, halt decryption immediately.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加密消息上的认证标签未能验证通过，此函数将返回`false`表示认证失败。如果发生这种情况，请立即停止解密。
- en: '[![6](assets/6.png)](#co_security_and_encryption_CO12-6)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_security_and_encryption_CO12-6)'
- en: Again, once the operation is complete, you should zero out the memory storing
    the stream state, as well as close out the file handles.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 操作完成后，应该清零存储流状态的内存，并关闭文件句柄。
- en: Discussion
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The stream cipher interfaces exposed by sodium are not actual streams to PHP.^([5](ch09.html#idm45875149639856))
    Specifically, they are stream *ciphers* that work like block ciphers with an internal
    counter. XChaCha20 is the cipher used by the `sodium_crypto_secret⁠stream_​xcha⁠cha​20​poly1305_*()`
    family of functions leveraged to push data into and pull data from an encrypted
    stream in this recipe. The implementation in PHP explicitly breaks a long message
    (a file) into a series of related messages. Each of these messages is encrypted
    with the underlying cipher and tagged individually but in a specific order.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Sodium暴露给PHP的流密码接口并不是实际的流。^([5](ch09.html#idm45875149639856)) 具体来说，它们是像块密码一样工作的流*密码*，具有内部计数器。XChaCha20是`sodium_crypto_secret⁠stream_​xcha⁠cha​20​poly1305_*()`函数族使用的密码，用于在此示例中将数据推送到加密流中并从中拉取数据。在PHP中，实现显式地将长消息（文件）分成一系列相关消息。每个消息都使用底层密码进行加密，并以特定顺序单独标记。
- en: These messages cannot be truncated, removed, reordered, or manipulated in any
    way without the decryption operation detecting that tampering. There is also no
    practical limit to the total number of messages that can be encrypted as part
    of this stream, which means there is no limit to the size of a file that can be
    passed through the Solution examples.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息不能截断、移除、重新排序或以任何方式操纵，否则解密操作会检测到篡改。此流的一部分可以加密的消息总数没有实际限制，这意味着通过解决方案示例传递的文件大小没有限制。
- en: The Solution uses a chunk size of 4,096 bytes (4 KB), but other examples could
    use 1,024, 8,096, or any other number of bytes. The only limitation here is the
    amount of memory available to PHP—iterating over smaller chunks of a file will
    use less memory during encryption and decryption. [Example 9-12](#libsodium_stream_encrypt)
    illustrates how `sodium_​crypto_​secretstream_​xchacha20​poly1305_​push()` encrypts
    one chunk of data at a time, “pushing” that data through the encryption algorithm
    and updating the algorithm’s internal state. The paired `sodium_​crypto_​secretstream_​xcha⁠cha20poly1305_​pull()`
    does the same thing in reverse, pulling corresponding plaintext back out of the
    stream and updating the algorithm’s state.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案使用4,096字节（4 KB）的块大小，但其他示例可以使用1,024、8,096或任何其他字节数。这里唯一的限制是PHP可用的内存量——在加密和解密过程中迭代较小的文件块将使用更少的内存。[示例9-12](#libsodium_stream_encrypt)展示了`sodium_​crypto_​secretstream_​xchacha20​poly1305_​push()`如何一次加密一个数据块，通过加密算法“推送”该数据，并更新算法的内部状态。配对的`sodium_​crypto_​secretstream_​xcha⁠cha20poly1305_​pull()`在反向操作中做同样的事情，从流中拉取对应的明文并更新算法的状态。
- en: Another way to see this in action is with the low-level primitive `sodium_​crypto_​stream_xchacha20_xor()`
    function. This function leverages the XChaCha20 encryption algorithm directly
    to generate a stream of seemingly random bytes based on a given key and random
    nonce. It then performs an XOR operation between that stream of bytes and a given
    message to produce a ciphertext.^([6](ch09.html#idm45875149634064)) [Example 9-14](#simple_crypto_stream)
    illustrates one way in which this function might be used—encrypting phone numbers
    in a database.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种查看此操作的方法是使用低级原语`sodium_​crypto_​stream_xchacha20_xor()`函数。此函数直接利用XChaCha20加密算法，根据给定的密钥和随机nonce生成一系列似乎随机的字节流。然后，它在该字节流和给定消息之间执行异或操作，以产生一个密文。^([6](ch09.html#idm45875149634064))
    [示例9-14](#simple_crypto_stream)展示了此函数可能使用的一种方式——在数据库中加密电话号码。
- en: Example 9-14\. Simple stream encryption for data protection
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例9-14。用于数据保护的简单流加密
- en: '[PRE21]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The advantage of using a cryptographic stream in this way is that the ciphertext
    exactly matches the length of the plaintext. However, this also means there is
    no authentication tag available (meaning the ciphertext could be corrupted or
    manipulated by a third party and jeopardize the reliability of any decrypted ciphertext).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式的加密流的优势在于密文的长度与明文完全匹配。然而，这也意味着没有可用的认证标签（这意味着密文可能会被第三方损坏或篡改，从而危及任何解密后的可靠性）。
- en: As a result, [Example 9-14](#simple_crypto_stream) is not likely something you
    will ever use directly. However, it does illustrate how the more verbose `sodium_​crypto_​secretstream_​xcha⁠cha20poly1305_push()`
    works under the hood. Both functions use the same algorithm, but the “secret stream”
    variant generates its own nonce and keeps track of its internal state over repeated
    uses (in order to encrypt *multiple* chunks of data). When using the simpler XOR
    version you would need to manage that state and repeated calls manually!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，[示例 9-14](#simple_crypto_stream) 可能不会直接使用。然而，它确实展示了更加冗长的 `sodium_​crypto_​secretstream_​xcha⁠cha20poly1305_push()`
    在幕后如何运作。这两个函数使用相同的算法，但是“秘密流”变体生成自己的随机数并跟踪其内部状态以重复使用（用于加密*多个*数据块）。在使用更简单的 XOR 版本时，您需要手动管理该状态并重复调用！
- en: See Also
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on [`sodium_crypto_secretstream_xchacha20poly1305_init_​push()`](https://oreil.ly/chGJC),
    [`sodium_​crypto_​secretstream_​xcha⁠cha20poly1305_​init_​pull()`](https://oreil.ly/ogGvJ),
    and [`sodium_​crypto_​stream_​xchacha20_​xor()`](https://oreil.ly/yQBBC).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 [`sodium_crypto_secretstream_xchacha20poly1305_init_​push()`](https://oreil.ly/chGJC)、[`sodium_​crypto_​secretstream_​xcha⁠cha20poly1305_​init_​pull()`](https://oreil.ly/ogGvJ)
    和 [`sodium_​crypto_​stream_​xchacha20_​xor()`](https://oreil.ly/yQBBC) 的文档。
- en: 9.6 Cryptographically Signing a Message to Be Sent to Another Application
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.6 对发送到另一个应用程序的消息进行加密签名
- en: Problem
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to sign a message or piece of data before sending it to another application
    such that the other application can validate your signature on the data.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在将消息或数据片段发送到另一个应用程序之前对其进行签名，以便另一个应用程序可以验证您对数据的签名。
- en: Solution
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `sodium_crypto_sign()` to attach a cryptographic signature to a plaintext
    message, as shown in [Example 9-15](#cryptographic_signatures_messages).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sodium_crypto_sign()` 将加密签名附加到明文消息，如[示例 9-15](#cryptographic_signatures_messages)所示。
- en: Example 9-15\. Cryptographic signatures on messages
  id: totrans-340
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-15\. 消息上的密码签名
- en: '[PRE22]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO13-1)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO13-1)'
- en: In practice, your signing seed should be a random value kept secret by you.
    It could also be a secure hash derived from a known password.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，您的签名种子应该是由您保密的随机值。它也可以是从已知密码派生的安全哈希值。
- en: Discussion
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Cryptographic signatures are a way to verify that a particular message (or string
    of data) originated from a given source. So long as the private key used to sign
    a message is kept secret, anyone with access to the publicly known key can validate
    that the information came from the owner of the key.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 密码签名是验证特定消息（或数据字符串）来源于给定源的一种方法。只要用于签署消息的私钥保持秘密，任何拥有公开已知密钥访问权限的人都可以验证信息来自密钥所有者。
- en: 'Likewise, only the custodian of that key can sign the data. This helps verify
    that the custodian signed off on the message. It also forms the basis for nonrepudiation:
    the owner of the key cannot claim that someone else used their key without rendering
    their key (and any signatures it created) invalid.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，只有密钥的保管人可以对数据进行签名。这有助于验证保管人对消息的签名。它还构成不可否认性的基础：密钥所有者无法声称其他人使用了他们的密钥，否则将使其密钥（及其创建的任何签名）无效。
- en: In the Solution example, a signature is calculated based on the secret key and
    the contents of the message. The bytes of the signature are then prepended to
    the message itself, and both elements together are passed along to any party who
    wishes to verify the signature.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案示例中，根据秘密密钥和消息内容计算签名。然后，将签名的字节前置到消息本身，并将这两个元素一起传递给希望验证签名的任何一方。
- en: It is also possible to generate a *detached* signature, effectively producing
    the raw bytes of the signature without concatenating it to the message. This is
    useful if the message and signature are meant to be sent independently to the
    third-party verifier—for example, as different elements in an API request.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以生成一个*独立*的签名，有效地生成签名的原始字节而不将其连接到消息中。如果消息和签名打算独立发送到第三方验证者（例如，在 API 请求中作为不同的元素），这将非常有用。
- en: Note
  id: totrans-349
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While raw bytes are fantastic for information stored on disk or in a database,
    they can cause problems with remote APIs. It would make sense to Base64-encode
    the entire payload (the signature and message) when sending it to a remote party.
    Otherwise, you might want to encode the signature separately (e.g., as hexadecimal)
    when sending the two components together.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然原始字节非常适合存储在磁盘或数据库中的信息，但在远程 API 中可能会引发问题。当将它们发送到远程方时，对整个负载（签名和消息）进行 Base64
    编码是有意义的。否则，当同时发送两个组件时，你可能希望单独编码签名（例如，十六进制编码）。
- en: Rather than using `sodium_crypto_sign()` as in the Solution example, you can
    use `sodium_crypto_sign_detached()` as in [Example 9-16](#detached_signatures).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 不要像 Solution 示例中使用 `sodium_crypto_sign()` 那样，可以使用 `sodium_crypto_sign_detached()`，如[示例
    9-16](#detached_signatures)。
- en: Example 9-16\. Creating a detached message signature
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-16\. 创建分离的消息签名
- en: '[PRE23]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Signatures will always be 64 bytes long, regardless of whether they’re attached
    to the plaintext they sign.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 签名总是 64 字节长，无论它们是否附加到它们签名的明文上。
- en: See Also
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on [`sodium_crypto_sign()`](https://oreil.ly/3eqTz).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sodium_crypto_sign()`](https://oreil.ly/3eqTz) 的文档。'
- en: 9.7 Verifying a Cryptographic Signature
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 9.7 验证加密签名
- en: Problem
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to verify the signature on a piece of data sent to you by a third party.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你想验证由第三方发送给你的数据上的签名。
- en: Solution
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `sodium_crypto_sign_open()` to validate the signature on a message, as shown
    in [Example 9-17](#cryptographic_signature_verification).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `sodium_crypto_sign_open()` 来验证消息上的签名，如[示例 9-17](#cryptographic_signature_verification)所示。
- en: Example 9-17\. Cryptographic signature verification
  id: totrans-362
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-17\. 加密签名验证
- en: '[PRE24]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_security_and_encryption_CO14-1)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_security_and_encryption_CO14-1)'
- en: The data in `$signed` is a concatenated raw signature and plaintext message,
    as in the return of `sodium_crypto_sign()`.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `$signed` 中的数据是一个连接的原始签名和明文消息，就像 `sodium_crypto_sign()` 的返回值一样。
- en: '[![2](assets/2.png)](#co_security_and_encryption_CO14-2)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_security_and_encryption_CO14-2)'
- en: If the signature is invalid, the function returns `false` as an error. If the
    signature is valid, the function instead returns the plaintext message.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果签名无效，函数会返回 `false` 作为错误。如果签名有效，函数会返回明文消息。
- en: Discussion
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Signature verification is straightforward when the literal returns from `sodium_crypto_sign()`
    are involved. Merely pass the data and the public key of the signing party into
    `sodium_​crypto_​sign_open()`, and you will have either a Boolean error or the
    original plaintext back as a result.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 `sodium_crypto_sign()` 的字面返回时，签名验证非常简单。只需将数据和签名方的公钥传递给 `sodium_​crypto_​sign_open()`，你将得到一个布尔错误或者原始明文。
- en: If you’re working with a web API, there’s a good chance that the message and
    signature were passed to you separately (e.g., if someone were using `sodium_​crypto_​sign_​detached()`).
    In that case, you need to concatenate the signature and the message together before
    passing them into `sodium_​crypto_​sign_​open()`, as in [Example 9-18](#sodium_crypto_sign_open).
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在处理 web API，消息和签名很可能是分开传递给你的（例如，如果有人使用 `sodium_​crypto_​sign_​detached()`）。在这种情况下，你需要在将它们传递到
    `sodium_​crypto_​sign_​open()` 之前将签名和消息连接在一起，如[示例 9-18](#sodium_crypto_sign_open)。
- en: Example 9-18\. Detached signature verification
  id: totrans-371
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-18\. 验证分离的签名
- en: '[PRE25]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: See Also
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on [`sodium_crypto_sign_open()`](https://oreil.ly/UG5ja).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sodium_crypto_sign_open()`](https://oreil.ly/UG5ja) 的文档。'
- en: ^([1](ch09.html#idm45875152082528-marker)) The [OpenJDK Psychic Signatures bug
    of 2022](https://oreil.ly/uvYXZ) illustrated how an error in cryptographic authentication
    could expose not just applications *but an entire language implementation* to
    potential abuse by malicious actors. This bug was due to an implementation error,
    further underscoring how critical it is to rely on solid, proven, well-tested
    primitives when using cryptographic systems.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch09.html#idm45875152082528-marker)) 2022年的 [OpenJDK Psychic Signatures
    bug](https://oreil.ly/uvYXZ) 展示了加密认证中的错误如何使应用程序甚至整个语言实现容易受到恶意行为的威胁。这个 bug 是由于实现错误造成的，进一步强调在使用加密系统时依赖于可靠、经过充分测试的基本原语的重要性。
- en: ^([2](ch09.html#idm45875152074560-marker)) For more on native extensions, see
    [Chapter 15](ch15.html#chapter_extensions).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch09.html#idm45875152074560-marker)) 欲知更多关于本地扩展的内容，请参阅[第 15 章](ch15.html#chapter_extensions)。
- en: ^([3](ch09.html#idm45875152063760-marker)) For a full breakdown of the process
    through which this extension was added to PHP core, reference the [original RFC](https://oreil.ly/6X4AF).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch09.html#idm45875152063760-marker)) PHP 核心中添加此扩展的详细过程，请参考[原始RFC](https://oreil.ly/6X4AF)。
- en: ^([4](ch09.html#idm45875151024592-marker)) Loading PHP packages via Composer
    is discussed at length in [Recipe 15.3](ch15.html#installing_composer_packages).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch09.html#idm45875151024592-marker)) 通过Composer加载PHP包的详细讨论，请看[第15.3节](ch15.html#installing_composer_packages)。
- en: ^([5](ch09.html#idm45875149639856-marker)) PHP streams, covered extensively
    in [Chapter 11](ch11.html#chapter_streams), expose effective ways to work with
    large chunks of data without exhausting available system memory.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch09.html#idm45875149639856-marker)) PHP 流，在[第11章](ch11.html#chapter_streams)中有详细介绍，展示了在不耗尽系统可用内存的情况下处理大数据块的有效方法。
- en: ^([6](ch09.html#idm45875149634064-marker)) For more on operators and XOR in
    particular, review [Chapter 2](ch02.html#chapter_operators).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch09.html#idm45875149634064-marker)) 操作符及特别是异或运算的更多内容，请查阅[第2章](ch02.html#chapter_operators)。
