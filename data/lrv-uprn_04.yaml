- en: Chapter 4\. Blade Templating
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 刀片模板
- en: Compared to most other backend languages, PHP actually functions relatively
    well as a templating language. But it has its shortcomings, and it’s also just
    ugly to be using `<?php` inline all over the place, so you can expect most modern
    frameworks to offer a templating language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他后端语言相比，PHP实际上作为模板语言运行相对良好。但它也有其缺点，而且在代码中到处使用 `<?php` 简直丑陋不堪，因此你可以期待大多数现代框架提供一种模板语言。
- en: Laravel offers a custom templating engine called *Blade*, which is inspired
    by .NET’s Razor engine. It boasts a concise syntax, a shallow learning curve,
    a powerful and intuitive inheritance model, and easy extensibility.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel提供了一个名为*Blade*的自定义模板引擎，受.NET的Razor引擎启发。它拥有简洁的语法、浅显的学习曲线、强大直观的继承模型以及易于扩展的特点。
- en: For a quick look at what writing Blade looks like, check out [Example 4-1](#EX401).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速了解Blade的编写方式，请查看[示例 4-1](#EX401)。
- en: Example 4-1\. Blade samples
  id: totrans-4
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1 刀片示例
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see, Blade uses curly braces for its “echo” and introduces a convention
    in which its custom tags, called “directives,” are prefixed with an `@`. You’ll
    use directives for all of your control structures and also for inheritance and
    any custom functionality you want to add.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Blade使用花括号来进行“echo”，并引入了一种约定：其自定义标签称为“指令”，以`@`作为前缀。你将使用指令来处理所有的控制结构，还可以用于继承以及任何想要添加的自定义功能。
- en: Blade’s syntax is clean and concise, so at its core it’s just more pleasant
    and tidy to work with than the alternatives. But the moment you need anything
    of any complexity in your templates—​nested inheritance, complex conditionals,
    or recursion—​Blade starts to really shine. Just like the best Laravel components,
    it takes complex application requirements and makes them easy and accessible.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Blade的语法简洁明了，因此在核心上，与其他选择相比，使用起来更加愉悦和整洁。但是一旦在模板中需要复杂的任何内容——如嵌套继承、复杂条件或递归——Blade便开始展现其真正的优势。就像最好的Laravel组件一样，它可以处理复杂的应用程序需求，使其变得简单易操作。
- en: Additionally, since all Blade syntax is compiled into normal PHP code and then
    cached, it’s fast and it allows you to use native PHP in your Blade files if you
    want. However, I’d recommend avoiding using PHP if at all possible—​usually if
    you need to do anything that you can’t do with Blade or a custom Blade directive,
    it doesn’t belong in the template.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，由于所有Blade语法都会被编译成普通的PHP代码并进行缓存，因此它非常快速，并且如果需要的话，可以在Blade文件中使用原生PHP。但我建议尽可能避免使用PHP——通常，如果需要做任何Blade或自定义Blade指令无法实现的事情，那就不应该放在模板中。
- en: Using Twig with Laravel
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Twig与Laravel
- en: Unlike many other Symfony-based frameworks, Laravel doesn’t use Twig by default.
    But if you’re just in love with Twig, there’s a [TwigBridge package](https://oreil.ly/9z_3t)
    that makes it easy to use Twig instead of Blade.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多基于Symfony的框架不同，Laravel默认不使用Twig。但是如果你非常喜欢Twig，可以使用[TwigBridge包](https://oreil.ly/9z_3t)，它可以轻松地在Blade之外使用Twig。
- en: Echoing Data
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输出数据
- en: As you can see in [Example 4-1](#EX401), `{{` and `}}` are used to wrap sections
    of PHP that you’d like to echo. ``{{ `*$variable*` }}`` is similar to `<?=` `*$variable*`
    `?>` in plain PHP.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[示例 4-1](#EX401)中所见，`{{` 和 `}}` 用于包装你想要输出的PHP部分。 ``{{ `*$variable*` }}``
    类似于纯PHP中的 `<?= $variable ?>`。
- en: 'It’s different in one way, however, and you might’ve guessed this already:
    Blade escapes all echoes by default using PHP’s `htmlentities()` to protect your
    users from malicious script insertion. That means ``{{ `*$variable*` }}`` is functionally
    equivalent to `<?=` ``htmlentities(`*$variable*`)`` `?>`. If you want to echo
    without the escaping, use `{!!` and `!!}` instead.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但有一个方面是不同的，你可能已经猜到了：Blade默认使用PHP的`htmlentities()`来转义所有的输出，以保护用户免受恶意脚本的插入。这意味着
    ``{{ `*$variable*` }}`` 在功能上等同于 `<?=` ``htmlentities(`*$variable*`)`` `?>`。如果希望不转义地进行输出，请改用
    `{!!` 和 `!!}`。
- en: Control Structures
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制结构
- en: Most of the control structures in Blade will be very familiar. Many directly
    echo the name and structure of the same tag in PHP.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Blade中的大多数控制结构都非常熟悉，很多直接回显相同PHP标签的名称和结构。
- en: There are a few convenience helpers, but in general, the control structures
    just look cleaner than they would in PHP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Blade提供了一些便利的辅助函数，但总体来说，控制结构看起来比在PHP中更清晰。
- en: Conditionals
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件语句
- en: First, let’s take a look at the control structures that allow for logic.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下允许逻辑的控制结构。
- en: '@if'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@if'
- en: 'Blade’s `@if (*$condition*)` compiles to `<?php if (*$condition*): ?>`. `@else`,
    `@elseif`, and `@endif` also compile to the exact same style of syntax in PHP.
    Take a look at [Example 4-2](#EX402) for some examples.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 'Blade 的 `@if (*$condition*)` 编译为 `<?php if (*$condition*): ?>`。`@else`、`@elseif`
    和 `@endif` 也编译成 PHP 中完全相同的语法样式。查看 [示例 4-2](#EX402) 获取一些示例。'
- en: Example 4-2\. `@if`, `@else`, `@elseif`, and `@endif`
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-2\. `@if`、`@else`、`@elseif` 和 `@endif`
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Just like with the native PHP conditionals, you can mix and match these how
    you want. They don’t have any special logic; there’s literally a parser looking
    for something with the shape of ``@if (`*$condition*`)`` and replacing it with
    the appropriate PHP code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 就像原生 PHP 条件语句一样，你可以随意混合和匹配这些。它们没有任何特殊逻辑；字面上有一个解析器寻找 ``@if (`*$condition*`)``
    的形状，并用适当的 PHP 代码替换它。
- en: '@unless and @endunless'
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@unless` 和 `@endunless`'
- en: '`@unless`, on the other hand, is a new syntax that doesn’t have a direct equivalent
    in PHP. It’s the direct inverse of `@if`. `@unless (*$condition*)` is the same
    as `<?php if (! *$condition*)`. You can see it in use in [Example 4-3](#EX403).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`@unless`，另一种新语法，PHP 中没有直接的等价物。它是 `@if` 的直接反义词。`@unless (*$condition*)` 等同于
    `<?php if (! *$condition*): ?>`。你可以在 [示例 4-3](#EX403) 中看到它的使用。'
- en: Example 4-3\. `@unless` and `@endunless`
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. `@unless` 和 `@endunless`
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Loops
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环
- en: Next, let’s take a look at the loops.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看循环。
- en: '@for, @foreach, and @while'
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@for`、`@foreach` 和 `@while`'
- en: '`@for`, `@foreach`, and `@while` work the same in Blade as they do in PHP;
    see Examples [4-4](#EX404), [4-5](#EX405), and [4-6](#EX405.5).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@for`、`@foreach` 和 `@while` 在 Blade 中与 PHP 中的工作方式相同；参见示例 [4-4](#EX404)、[4-5](#EX405)
    和 [4-6](#EX405.5)。'
- en: Example 4-4\. `@for` and `@endfor`
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. `@for` 和 `@endfor`
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Example 4-5\. `@foreach` and `@endforeach`
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. `@foreach` 和 `@endforeach`
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Example 4-6\. `@while` and `@endwhile`
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. `@while` 和 `@endwhile`
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '@forelse and @endforelse'
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@forelse` 和 `@endforelse`'
- en: '`@forelse` is a `@foreach` that also allows you to program in a fallback if
    the object you’re iterating over is empty. We saw it in action at the start of
    this chapter; [Example 4-7](#EX406) shows another example.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`@forelse` 是 `@foreach`，如果你正在迭代的对象为空，还允许你编写回退。我们在本章开始时看到它的运作；[示例 4-7](#EX406)
    展示了另一个例子。'
- en: Example 4-7\. `@forelse`
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. `@forelse`
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Template Inheritance
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板继承
- en: Blade provides a structure for template inheritance that allows views to extend,
    modify, and include other views.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Blade 提供了一种模板继承结构，允许视图扩展、修改和包含其他视图。
- en: Let’s take a look at how inheritance is structured with Blade.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Blade 如何结构化继承。
- en: Defining Sections with @section/@show and @yield
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 @section/@show 和 @yield 定义区段
- en: Let’s start with a top-level Blade layout, like in [Example 4-8](#EX407). This
    is the definition of a generic page wrapper that we’ll later place page-specific
    content into.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从顶层 Blade 布局开始，就像在 [示例 4-8](#EX407) 中一样。这是一个通用页面包装器的定义，稍后我们将在其中放置特定页面内容。
- en: Example 4-8\. Blade layout
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. Blade 布局
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This looks a bit like a normal HTML page, but you can see we’ve *yielded* in
    two places (`title` and `content`) and we’ve defined a *section* in a third (`footerScripts`).
    We have three Blade directives here: `@yield(''content'')` alone, `@yield(''title'',
    ''Home Page'')` with a defined default, and `@section/@show` with actual content
    in it.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点像普通的 HTML 页面，但你可以看到我们在两个地方 *yielded*（`title` 和 `content`），并在第三个地方定义了 *section*（`footerScripts`）。这里有三个
    Blade 指令：`@yield('content')` 单独使用，`@yield('title', 'Home Page')` 带有定义的默认值，以及带有实际内容的
    `@section/@show`。
- en: Although they each look a little different, *all three function essentially
    the same.* All three are defining that there’s a section with a given name (the
    first parameter) that can be extended later, and all three are defining what to
    do if the section isn’t extended. They do this either by providing a string fallback
    (`'Home Page'`), no fallback (which will just not show anything if it’s not extended),
    or an entire block fallback (in this case, `<script src="app.js"></script>`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们看起来各有些不同，*这三者本质上是一样的*。它们都定义了一个具有给定名称的区段（第一个参数），稍后可以扩展，并且都定义了如果未扩展该部分要执行的操作。它们可以通过提供字符串回退（`'Home
    Page'`）、无回退（如果未扩展，则什么也不显示）、或整个块回退（在这种情况下是 `<script src="app.js"></script>`）来做到这一点。
- en: What’s different? Well, clearly, `@yield('content')` has no default content.
    But additionally, the default content in `@yield('title')` will *only* be shown
    if it’s never extended. If it is extended, its child sections will not have programmatic
    access to the default value. `@section/@show`, on the other hand, is both defining
    a default *and* doing so in such a way that its default contents will be available
    to its children, through `@parent`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么不同？显然，`@yield('content')` 没有默认内容。但是另外，`@yield('title')` 中的默认内容只有在未被扩展时才会显示。如果已被扩展，其子部分将无法通过程序访问默认值。另一方面，`@section/@show`
    不仅定义了一个默认值，而且以这种方式定义的默认内容将通过`@parent`提供给其子级。
- en: Once you have a parent layout like this, you can extend it in a new template
    file like in [Example 4-9](#EX408).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了像这样的父布局，你可以在新的模板文件中扩展它，就像在[示例 4-9](#EX408)中一样。
- en: Example 4-9\. Extending a Blade layout
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. 扩展 Blade 布局
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '@show Versus @endsection'
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '@show 与 @endsection 的区别'
- en: You may have noticed that [Example 4-8](#EX407) uses `@section/@show`, but [Example 4-9](#EX408)
    uses `@section/@endsection`. What’s the difference?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，[示例 4-8](#EX407) 使用了`@section/@show`，但[示例 4-9](#EX408) 使用了`@section/@endsection`。它们有什么区别？
- en: Use `@show` when you’re defining the place for a section, in the parent template.
    Use `@endsection` when you’re defining the content for a template in a child template.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在父模板中定义一个部分的位置时，请使用`@show`。在子模板中定义模板的内容时，请使用`@endsection`。
- en: This child view allows us to cover a few new concepts in Blade inheritance.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此子视图允许我们涵盖 Blade 继承中的一些新概念。
- en: '@extends'
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@extends'
- en: In [Example 4-9](#EX408), with `@extends('layouts.master')`, we define that
    this view should not be rendered on its own but that it instead *extends* another
    view. That means its role is to define the content of various sections, but not
    to stand alone. It’s almost more like a series of buckets of content, rather than
    an HTML page. This line also defines that the view it’s extending lives at *resources/views/layouts/master.blade.php*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-9](#EX408)中，通过`@extends('layouts.master')`，我们定义了这个视图不应单独呈现，而是应扩展另一个视图。这意味着它的角色是定义各个部分的内容，而不是独立存在。它几乎更像是一系列内容桶，而不是一个HTML页面。这行还定义了它扩展的视图位于*resources/views/layouts/master.blade.php*。
- en: Each file should only extend one other file, and the `@extends` call should
    be the first line of the file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个文件应仅扩展另一个文件，并且`@extends`调用应为文件的第一行。
- en: '@section and @endsection'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@section 和 @endsection'
- en: With `@section('title', 'Dashboard')`, we provide our content for the first
    section, `title`. Since the content is so short, instead of using `@section` and
    `@endsection`, we’re just using a shortcut. This allows us to pass the content
    in as the second parameter of `@section` and then move on. If it’s a bit disconcerting
    to see `@section` without `@endsection`, you could just use the normal syntax.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@section('title', '仪表板')`，我们为第一个部分`title`提供了内容。由于内容很短，我们不是使用`@section`和`@endsection`，而是直接使用了一个快捷方式。这允许我们将内容作为`@section`的第二个参数传递，然后继续进行。如果看到没有`@endsection`的`@section`有点令人不安，可以使用常规语法。
- en: With `@section('content')` and following, we use the normal syntax to define
    the contents of the `content` section. We’ll just throw a little greeting in for
    now. Note, however, that when you’re using `@section` in a child view, you end
    it with `@endsection` (or its alias `@stop`), instead of `@show`, which is reserved
    for defining sections in parent views.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`@section('content')`及其后续内容，我们使用常规语法来定义`content`部分的内容。现在我们只是简单地添加一个问候语。请注意，当在子视图中使用`@section`时，应使用`@endsection`（或其别名`@stop`），而不是保留用于在父视图中定义部分的`@show`。
- en: '@parent'
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@parent'
- en: Finally, with `@section('footerScripts')` and on, we use the normal syntax to
    define the contents of the `footerScripts` section.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`@section('footerScripts')`及其后续内容，我们使用常规语法来定义`footerScripts`部分的内容。
- en: 'But remember, we actually defined that content (or, at least, its “default”)
    already in the master layout. So this time, we have two options: we can either
    *overwrite* the content from the parent view, or we can *add* to it.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但请记住，我们实际上已经在主布局中定义了该内容（或者至少是它的“默认”）。所以这一次，我们有两个选择：我们可以覆盖父视图中的内容，或者我们可以添加到其中。
- en: You can see that we have the option to include the content from the parent by
    using the `@parent` directive within the section. If we didn’t, the content of
    this section would entirely overwrite anything defined in the parent for this
    section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，通过在部分内部使用`@parent`指令，我们可以选择包含父级的内容。如果没有这样做，此部分的内容将完全覆盖父级为该部分定义的任何内容。
- en: Including View Partials
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含视图部分
- en: Now that we’ve established the basics of inheritance, there are a few more tricks
    we can perform.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了继承的基础，我们可以执行一些更多的技巧。
- en: '@include'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@include`'
- en: What if we’re in a view and want to pull in another view? Maybe we have a call-to-action
    “Sign up” button that we want to reuse around the site. And maybe we want to customize
    the button text every time we use it. Take a look at [Example 4-10](#EX409).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在一个视图中并且想要引入另一个视图，该怎么办？也许我们有一个“注册”按钮的呼叫到动作，我们想在整个站点重复使用它。也许我们想每次使用时自定义按钮文本。看看[示例 4-10](#EX409)。
- en: Example 4-10\. Including view partials with `@include`
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-10\. 使用`@include`包含视图局部文件
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`@include` pulls in the partial and, optionally, passes data into it. Note
    that not only can you *explicitly* pass data to an include via the second parameter
    of `@include`, but you can also reference any variables within the included file
    that are available to the including view (`$pageName`, in this example). Once
    again, you can do whatever you want, but I would recommend you consider always
    explicitly passing every variable that you intend to use, just for clarity.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`@include`引入局部文件，并可选择将数据传递给它。请注意，不仅可以通过`@include`的第二个参数显式地向包含传递数据，而且还可以引用包含文件中任何可用于包含视图的变量（例如本示例中的`$pageName`）。再次强调，您可以随心所欲地做任何操作，但是我建议您始终明确传递您打算使用的每个变量，以确保清晰性。'
- en: You also use the `@includeIf`, `@includeWhen`, and `@includeFirst` directives,
    as shown in [Example 4-11](#EX411).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`@includeIf`、`@includeWhen`和`@includeFirst`指令，如[示例 4-11](#EX411)所示。
- en: Example 4-11\. Conditionally including views
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-11\. 有条件地包含视图
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '@each'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`@each`'
- en: 'You can probably imagine some circumstances in which you’d need to loop over
    an array or collection and `@include` a partial for each item. There’s a directive
    for that: `@each`.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想象一些情况，您需要遍历数组或集合并`@include`每个项目的局部文件。有一个指令可以做到：`@each`。
- en: Let’s say we have a sidebar composed of modules, and we want to include multiple
    modules, each with a different title. Take a look at [Example 4-12](#EX410).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个由模块组成的侧边栏，并且我们想包含多个模块，每个模块都有不同的标题。看看[示例 4-12](#EX410)。
- en: Example 4-12\. Using view partials in a loop with `@each`
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-12\. 在循环中使用视图局部文件`@each`
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Consider that `@each` syntax. The first parameter is the name of the view partial.
    The second is the array or collection to iterate over. The third is the variable
    name that each item (in this case, each element in the `$modules` array) will
    be passed as to the view. And the optional fourth parameter is the view to show
    if the array or collection is empty (or, optionally, you can pass a string in
    here that will be used as your template).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`@each`语法。第一个参数是视图局部文件的名称。第二个是要迭代的数组或集合。第三个是每个项目的变量名（在这种情况下，是`$modules`数组中的每个元素），将作为视图传递给视图。第四个可选参数是在数组或集合为空时显示的视图（或者，您可以在此处传递一个字符串，该字符串将用作模板）。
- en: Using Components
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用组件
- en: 'Laravel offers another pattern for including content between views: *components*.
    Components make the most sense in contexts where you find yourself using view
    partials and passing large chunks of content into them as variables. Take a look
    at [Example 4-13](#EX431) for an example of a modal, or popover, that might alert
    the user in response to an error or other action.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel还提供了另一种在视图之间包含内容的模式：*组件*。组件在您发现自己使用视图局部文件并将大块内容作为变量传递给它们的情况下最有意义。看看[示例 4-13](#EX431)，以查看一个模态框或弹出窗口的示例，可能会在响应错误或其他操作时向用户发出警告。
- en: Example 4-13\. A modal as an awkward view partial
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-13\. 将模态框作为一个奇怪的视图局部文件
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is too much for these poor variables, and it’s the perfect fit for a component.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于这些可怜的变量来说太多了，它正好适合成为一个组件。
- en: Laravel’s components are another way of structuring view partials that looks
    much closer to how components work in frontend frameworks like Vue. They may be
    more familiar to frontend developers, but they also have a few significant benefits
    compared to view partials, including that it’s much easier to pass large sections
    of template code into them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的组件是结构化视图局部文件的另一种方式，更接近于前端框架（如Vue）中组件的工作方式。它们可能更熟悉于前端开发者，但与视图局部文件相比，它们也有一些显著的好处，包括更容易将大段的模板代码传递给它们。
- en: Take a look at [Example 4-14](#EX420) to see how to refactor [Example 4-13](#EX431)
    with components.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看看[示例 4-14](#EX420)，看看如何使用组件重构[示例 4-13](#EX431)。
- en: Example 4-14\. A modal as a more appropriate component
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-14\. 一个更合适的组件作为模态框
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see in [Example 4-14](#EX420), components allow us to pull our HTML
    out of a cramped variable string and back into the template space.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[示例 4-14](#EX420)中所看到的，组件允许我们将 HTML 从拥挤的变量字符串中提取出来，并重新回到模板空间。
- en: Let’s dig into more of the features of components, how they’re structured, and
    how we write them.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解组件的更多功能、它们的结构以及我们如何编写它们。
- en: Creating components
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建组件
- en: Components can exist either as purely Blade templates (*anonymous components*),
    or as Blade templates backed by a PHP class that injects data and functionality
    (*class-based components*).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 组件可以存在为纯粹的 Blade 模板（*匿名组件*），或者作为由 PHP 类支持的 Blade 模板，该类注入数据和功能（*基于类的组件*）。
- en: 'If you only need a template, you can generate your component with the `--view`
    flag:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只需要模板，可以使用`--view`标志生成您的组件：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you also want to generate the PHP class, exclude that flag:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还想生成 PHP 类，请排除该标志：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you’d like to group your components under folders, you can use the `.` separator:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将组件分组到文件夹中，可以使用`.`分隔符：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Passing data into components
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据传递给组件
- en: 'There are four ways to pass data into components: string attributes, PHP attributes,
    the default slot, and named slots.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法可以将数据传递给组件：字符串属性、PHP 属性、默认插槽和命名插槽。
- en: Passing data into components via attributes
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过属性将数据传递给组件
- en: Let’s start with attributes. You can pass strings directly into components by
    passing attributes with no prefix, or you can pass PHP variables and expressions
    with a colon prefix, as you can see in [Example 4-15](#EX450).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从属性开始。您可以通过不带前缀的属性直接将字符串传递给组件，或者您可以使用冒号前缀传递 PHP 变量和表达式，就像您在[示例 4-15](#EX450)中看到的那样。
- en: Example 4-15\. Passing data to components via attributes
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-15\. 通过属性将数据传递给组件
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For class-based components, you’ll need to define every attribute in the PHP
    class and set it as a public property on the class, as in [Example 4-16](#EX451).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于类的组件，您需要在 PHP 类中定义每个属性，并将其设置为类的公共属性，就像在[示例 4-16](#EX451)中所示。
- en: Example 4-16\. Defining attributes as public on component classes
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-16\. 在组件类上将属性定义为公共属性
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For anonymous components, you’ll need to define the attributes in a `props`
    array at the top of your template:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于匿名组件，您需要在模板顶部的`props`数组中定义属性：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Passing data into components via slots
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 通过插槽将数据传递给组件
- en: In [Example 4-14](#EX420) you may have noticed that the contents of the modal
    were refered to as a variable, `$slot`. But where did this come from?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-14](#EX420)中，您可能已经注意到模态框的内容被称为变量`$slot`。但是这是从哪里来的？
- en: By default, every component that has an opening and a closing tag when it’s
    referenced has a `$slot` variable, and it’s filled with all the HTML between those
    two tags. In [Example 4-14](#EX420), the `$slot` variable contains the two `<p>`
    tags and everything inside (and between) them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个组件在引用时具有开放和关闭标记时都有一个`$slot`变量，并且它填充了这两个标记之间的所有 HTML。在[示例 4-14](#EX420)中，`$slot`变量包含两个`<p>`标记及其之间的所有内容。
- en: But what if you need two or more slots? You can add more than just the default
    slot, giving each slot its own name and variable. Let’s rework [Example 4-14](#EX420)
    assuming we want to define the title in a slot; take a look at [Example 4-17](#EX453).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果您需要两个或更多插槽怎么办？您可以添加不止一个默认插槽，为每个插槽分配自己的名称和变量。让我们重新设计[示例 4-14](#EX420)，假设我们想在一个插槽中定义标题；看看[示例 4-17](#EX453)。
- en: Example 4-17\. Defining multiple slots
  id: totrans-121
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-17\. 定义多个插槽
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The contents of this new `$slot` variable will be accessible to the component
    template as a `$title` variable, just like the attribute was before.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`$slot`变量的内容将作为`$title`变量在组件模板中可访问，就像之前的属性一样。
- en: Component methods
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组件方法
- en: At times it can be helpful to have a helper method in a component that performs
    some logic. One common pattern is to use these methods for complex logic checks
    you’d rather keep out of your templates.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在组件中添加一个执行某些逻辑的辅助方法可能会有所帮助。一个常见的模式是将这些方法用于您希望保持模板之外的复杂逻辑检查。
- en: Components allow you to call any public method on their associated PHP class
    in the template by prefixing the method name with `$`, as you can see in [Example 4-18](#EX452).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 组件允许您在模板中通过在方法名称前加上`$`来调用其关联的 PHP 类上的任何公共方法，就像您在[示例 4-18](#EX452)中看到的那样。
- en: Example 4-18\. Defining and calling component methods
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-18\. 定义和调用组件方法
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Attributes grab bag
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性收集袋
- en: Most of the attributes we’ll pass into our components will be named, specific,
    and similar to passing parameters to a PHP function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将传递给组件的大多数属性都将是命名的、具体的，并且类似于向 PHP 函数传递参数。
- en: But sometimes there are just loose HTML attributes we want to pass in, almost
    always so they can be assigned to the root element of our template.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时我们只需传递一些松散的 HTML 属性，几乎总是为了将它们分配给模板的根元素。
- en: With components, you can grab all of those attributes at once, using the `$attributes`
    variable. This variable captures all the attributes not defined as properties
    and allows you to echo them out (by treating it like a string) or interact with
    some of its methods for grabbing or inspecting data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 使用组件，你可以一次性获取所有这些属性，使用`$attributes`变量。这个变量捕获所有未定义为属性的属性，并允许你输出它们（将其视为字符串）或者使用它的一些方法来获取或检查数据。
- en: 'Take a look at [the docs](https://oreil.ly/JWEjK) to learn about all the ways
    you can interact with the `$attributes` object, but here is one very useful trick:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[文档](https://oreil.ly/JWEjK)以了解与`$attributes`对象交互的所有方式，但这里有一个非常有用的技巧：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Using Stacks
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用堆栈
- en: One common pattern that can be difficult to manage using basic Blade includes
    is when each view in a Blade includes hierarchy needs to add something to a certain
    section—​almost like adding an entry to an array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模式是使用基本的 Blade 包含时可能难以管理的情况，即每个 Blade 包含层次结构中的视图都需要向某个特定部分添加内容 —— 几乎就像向数组中添加条目一样。
- en: The most common situation for this is when certain pages (and sometimes, more
    broadly, certain sections of a website) have specific, unique CSS and JavaScript
    files they need to load. Imagine you have a site-wide “global” CSS file, a “jobs
    section” CSS file, and an “apply for a job” page CSS file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况最常见的情况是某些页面（有时更广泛地说是网站的某些部分）需要加载特定的、唯一的 CSS 和 JavaScript 文件。想象一下，你有一个全站“全局”CSS文件，一个“职位部分”CSS文件，和一个“申请职位”页面的CSS文件。
- en: Blade’s *stacks* are built for exactly this situation. In your parent template,
    define a stack, which is just a placeholder. Then, in each child template you
    can “push” entries onto that stack with `@push/@endpush`, which adds them to the
    bottom of the stack in the final render. You can also use `@prepend/@endprepend`
    to add them to the top of the stack. [Example 4-19](#EX410.5) illustrates.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Blade的*堆栈*专门为这种情况设计。在父模板中定义一个堆栈，这只是一个占位符。然后，在每个子模板中，你可以使用`@push/@endpush`将条目“推送”到堆栈中，在最终渲染时它们被添加到堆栈的底部。你也可以使用`@prepend/@endprepend`将它们添加到堆栈的顶部。[例 4-19](#EX410.5)进行了说明。
- en: Example 4-19\. Using Blade stacks
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 4-19\. 使用Blade堆栈
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'These generate the following result:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些生成以下结果：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: View Composers and Service Injection
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图组合器和服务注入
- en: As we covered in [Chapter 3](ch03.html#routing), it’s simple to pass data to
    our views from the route definition (see [Example 4-20](#EX412)).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](ch03.html#routing)中介绍的那样，从路由定义向视图传递数据是很简单的（参见[例 4-20](#EX412)）。
- en: Example 4-20\. Reminder of how to pass data to views
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例 4-20\. 如何向视图传递数据的提醒
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There may be times, however, when you find yourself passing the same data over
    and over to multiple views. Or you might find yourself using a header partial
    or something similar that requires some data; will you have to pass that data
    in from every route definition that might ever load that header partial?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时你可能发现自己需要将相同的数据多次传递给多个视图。或者你可能发现自己使用了一个需要某些数据的页眉部分或类似部件；你是否需要从每个可能加载该页眉部分的路由定义中传递数据？
- en: Binding Data to Views Using View Composers
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视图组合器将数据绑定到视图
- en: Thankfully, there’s a simpler way. The solution is called a *view composer*,
    and it allows you to define that *any time a particular view loads, it should
    have certain data passed to it*—without the route definition having to pass that
    data in explicitly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种更简单的方法。解决方案称为*视图组合器*，它允许你定义，*每次加载特定视图时，都应该将某些数据传递给它* —— 而不必显式从路由定义中传递该数据。
- en: Let’s say you have a sidebar on every page, which is defined in a partial named
    `partials.sidebar` (*resources/views/partials/sidebar.blade.php*) and then included
    on every page. This sidebar shows a list of the last seven posts that were published
    on your site. If it’s on every page, every route definition would normally have
    to grab that list and pass it in, like in [Example 4-21](#EX413).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在每个页面上都有一个侧边栏，在一个名为`partials.sidebar`的部分中定义（*resources/views/partials/sidebar.blade.php*），然后在每个页面上包含它。这个侧边栏显示了你网站上发布的最近七篇帖子的列表。如果它出现在每个页面上，每个路由定义通常都需要获取该列表并传递它，就像在[例 4-21](#EX413)中一样。
- en: Example 4-21\. Passing sidebar data in from every route
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-21\. 从每个路由中传递侧边栏数据
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That could get annoying quickly. Instead, we’re going to use view composers
    to “share” that variable with a prescribed set of views. We can do this a few
    ways, so let’s start simple and move up.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很快就会变得很烦人。因此，我们将使用视图组合器来“共享”这个变量给一组预定的视图。我们可以通过几种方式来实现这一点，所以让我们从简单的方式开始，然后逐步提升。
- en: Sharing a variable globally
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局共享变量
- en: 'First, the simplest option: just globally “share” a variable with every view
    in your application, like in [Example 4-22](#EX425).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最简单的选项：只需在你的应用程序的每个视图中全局“共享”一个变量，就像在[示例 4-22](#EX425)中一样。
- en: Example 4-22\. Sharing a variable globally
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-22\. 全局共享一个变量
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If you want to use `view()->share()`, the best place would be the `boot()` method
    of a service provider so that the binding runs on every page load. You can create
    a custom `ViewComposerServiceProvider` (see [“Service Providers”](ch10.html#service_providers)
    for more detail), but for now just put it in `App\Providers\AppServiceProvider`
    in the `boot()` method.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用`view()->share()`，最好的地方是服务提供者的`boot()`方法，这样绑定就会在每次页面加载时运行。你可以创建一个自定义的`ViewComposerServiceProvider`（详见[“服务提供者”](ch10.html#service_providers)），但现在只需将其放在`App\Providers\AppServiceProvider`的`boot()`方法中即可。
- en: Using `view()->share()` makes the variable accessible to every view in the entire
    application, however, so it might be overkill.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`view()->share()`使得该变量在整个应用程序的每个视图中都可以访问，但可能有些过头了。
- en: View-scoped view composers with closures
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用闭包的视图作用域视图组合器
- en: The next option is to use a closure-based view composer to share variables with
    a single view, like in [Example 4-23](#EX426).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个选项是使用基于闭包的视图组合器来与单个视图共享变量，就像在[示例 4-23](#EX426)中一样。
- en: Example 4-23\. Creating a closure-based view composer
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-23\. 创建基于闭包的视图组合器
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, we’ve defined the name of the view we want it shared with in
    the first parameter (`partials.sidebar`) and then passed a closure to the second
    parameter; in the closure we’ve used `$view->with()` to share a variable, but
    only with a specific view.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们在第一个参数中定义了要与之共享的视图的名称（`partials.sidebar`），然后在第二个参数中传递了一个闭包；在闭包中，我们使用`$view->with()`来共享一个变量，但只针对特定视图。
- en: View-scoped view composers with classes
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类的视图作用域视图组合器
- en: Finally, the most flexible, but also the most complex, option is to create a
    dedicated class for your view composer.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最灵活但也最复杂的选项是为你的视图组合器创建一个专用的类。
- en: First, let’s create the view composer class. There’s no formally defined place
    for view composers to live, but the docs recommend `App\Http\ViewComposers`. So,
    let’s create `App\Http\ViewComposers\RecentPostsComposer` like in [Example 4-24](#EX414).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建视图组合器类。虽然没有正式定义视图组合器的存放位置，但文档建议放在`App\Http\ViewComposers`中。因此，让我们创建`App\Http\ViewComposers\RecentPostsComposer`，就像在[示例 4-24](#EX414)中一样。
- en: Example 4-24\. A view composer
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-24\. 一个视图组合器
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, when this composer is called, it runs the `compose()` method,
    in which we bind the `recentPosts` variable to the result of running the `Post`
    model’s `recent()` method.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当调用这个组合器时，它会执行`compose()`方法，在该方法中，我们将`recentPosts`变量绑定到运行`Post`模型的`recent()`方法的结果上。
- en: Like the other methods of sharing variables, this view composer needs to have
    a binding somewhere. Again, you’d likely create a custom `ViewComposerServiceProvider`,
    but for now, as seen in [Example 4-25](#EX415), we’ll just put it in the `boot()`
    method of `App\Providers\AppServiceProvider`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他共享变量的方法一样，这个视图组合器需要在某处进行绑定。你很可能会创建一个自定义的`ViewComposerServiceProvider`，但现在，就像在[示例 4-25](#EX415)中看到的那样，我们将它放在`App\Providers\AppServiceProvider`的`boot()`方法中。
- en: Example 4-25\. Registering a view composer in `AppServiceProvider`
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-25\. 在`AppServiceProvider`中注册视图组合器
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that this binding is the same as a closure-based view composer, but instead
    of passing a closure, we’re passing the class name of our view composer. Now,
    every time Blade renders the `partials.sidebar` view, it’ll automatically run
    our provider and pass the view a `recentPosts` variable set to the results of
    the `recent()` method on our `Post` model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种绑定方式与基于闭包的视图组合器相同，但不是传递闭包，而是传递我们视图组合器的类名。现在，每当 Blade 渲染`partials.sidebar`视图时，它将自动运行我们的提供者，并将一个`recentPosts`变量传递给视图，该变量设置为在我们的`Post`模型上运行`recent()`方法的结果。
- en: Blade Service Injection
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blade 服务注入
- en: 'There are three primary types of data we’re most likely to inject into a view:
    collections of data to iterate over, single objects that we’re displaying on the
    page, and services that generate data or views.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 视图中最有可能注入的数据主要有三种类型：需要迭代的数据集合、在页面上展示的单个对象以及生成数据或视图的服务。
- en: With a service, the pattern will most likely look like [Example 4-26](#EX417),
    where we inject an instance of our analytics service into the route definition
    by typehinting it in the route’s method signature, and then pass it into the view.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 使用服务时，模式很可能会像[示例4-26](#EX417)那样，我们通过在路由定义的方法签名中进行类型提示将我们的分析服务的实例注入路由，并将其传递到视图中。
- en: Example 4-26\. Injecting services into a view via the route definition constructor
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-26\. 通过路由定义的构造函数将服务注入视图
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Just as with view composers, Blade’s service injection offers a convenient shortcut
    to reduce duplication in your route definitions. Normally, the content of a view
    using our analytics service might look like [Example 4-27](#EX418).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像视图组合器一样，Blade 的服务注入为你的路由定义提供了一个便捷的快捷方式来减少重复。通常情况下，使用我们的分析服务的视图内容可能会像[示例4-27](#EX418)那样。
- en: Example 4-27\. Using an injected navigation service in a view
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-27\. 在视图中使用注入的导航服务
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Blade service injection makes it easy to inject an instance of a class from
    the container directly into the view, like in [Example 4-28](#EX419).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Blade 服务注入使得直接将容器中的类的实例注入到视图中变得容易，就像[示例4-28](#EX419)中展示的一样。
- en: Example 4-28\. Injecting a service directly into a view
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-28\. 将服务直接注入到视图中
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, this `@inject` directive has actually made an `$analytics` variable
    available, which we’re using later in our view.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个 `@inject` 指令实际上已经使得 `$analytics` 变量可用，我们稍后在视图中使用它。
- en: The first parameter of `@inject` is the name of the variable you’re injecting,
    and the second parameter is the class or interface that you want to inject an
    instance of. This is resolved just like when you typehint a dependency in a constructor
    elsewhere in Laravel; if you’re unfamiliar with how that works, check out [Chapter 11](ch11.html#the_container)
    to learn more.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`@inject` 的第一个参数是你要注入的变量名称，第二个参数是你想要注入实例的类或接口。这与在 Laravel 中在构造函数中声明依赖项的方式相似；如果你对其工作原理不熟悉，请查看[第11章](ch11.html#the_container)以了解更多信息。'
- en: Just like view composers, Blade service injection makes it easy to make certain
    data or functionality available to every instance of a view, without having to
    inject it via the route definition every time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 就像视图组合器一样，Blade 服务注入使得可以很容易地使特定数据或功能对每个视图实例可用，而无需每次通过路由定义来注入。
- en: Custom Blade Directives
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 Blade 指令
- en: 'All of the built-in syntax of Blade that we’ve covered so far—`@if`, `@unless`,
    and so on—are called *directives*. Each Blade directive is a mapping between a
    pattern (e.g., `@if (*$condition*)`) and a PHP output (e.g., `<?php if (*$condition*):
    ?>`).'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，我们已经介绍了 Blade 的所有内置语法——`@if`、`@unless`等等都称为*指令*。每个 Blade 指令都是一个模式（例如
    `@if (*$condition*)`）与 PHP 输出（例如 `<?php if (*$condition*): ?>`）之间的映射。'
- en: Directives aren’t just for the core; you can actually create your own. You might
    think directives are good for making little shortcuts to bigger pieces of code—​for
    example, using `@button('buttonName')` and having it expand to a larger set of
    button HTML. This isn’t a *terrible* idea, but for simple code expansion like
    this you might be better off including a view partial.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 指令不仅仅局限于核心功能；你实际上可以创建自己的指令。你可能认为指令适合用来创建代码的小快捷方式——比如，使用 `@button('buttonName')`
    并将其扩展为更大的按钮 HTML 代码块。这并不是一个*糟糕*的想法，但对于这样简单的代码扩展，包含视图部分可能会更好一些。
- en: Custom directives tend to be most useful when they simplify some form of repeated
    logic. Say we’re tired of having to wrap our code with `@if (auth()``->``guest())`
    (to check if a user is logged in or not) and we want a custom `@ifGuest` directive.
    As with view composers, it might be worth having a custom service provider to
    register these, but for now let’s just put it in the `boot()` method of `App\Providers\AppServiceProvider`.
    Take a look at [Example 4-29](#EX421) to see what this binding will look like.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当定制指令能简化某种重复逻辑时，它们往往最有用。假设我们厌倦了需要用 `@if (auth()->guest())` 来包装代码（用于检查用户是否已登录），我们想要一个自定义的
    `@ifGuest` 指令。就像视图组合器一样，值得注意的是，也许最好有一个自定义服务提供者来注册这些指令，但现在让我们将其放在 `App\Providers\AppServiceProvider`
    的 `boot()` 方法中。查看[示例4-29](#EX421)以查看这个绑定的具体内容。
- en: Example 4-29\. Binding a custom Blade directive in a service provider
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-29\. 在服务提供者中绑定自定义 Blade 指令
- en: '[PRE37]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We’ve now registered a custom directive, `@ifGuest`, which will be replaced
    with the PHP code `<?php if (auth()->guest()): ?>`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '我们现在注册了一个自定义指令 `@ifGuest`，它将被替换为 PHP 代码 `<?php if (auth()->guest()): ?>`。'
- en: This might feel strange. You’re writing a *string* that will be returned and
    then executed as PHP. But what this means is that you can now take the complex,
    ugly, unclear, or repetitive aspects of your PHP templating code and hide them
    behind clear, simple, and expressive syntax.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会感觉奇怪。你正在编写一个*字符串*，它将被返回并作为 PHP 执行。但这意味着你现在可以将 PHP 模板代码中复杂、丑陋、不清晰或重复的部分隐藏在清晰、简单和表达性强的语法背后。
- en: Custom Directive Result Caching
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义指令结果缓存
- en: 'You might be tempted to do some logic to make your custom directive faster
    by performing an operation *in* the binding and then embedding the result within
    the returned string:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想要通过在绑定中执行操作来加速你的自定义指令，并将结果嵌入返回的字符串中：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The problem with this idea is that it assumes this directive will be re-created
    on every page load. However, Blade caches aggressively, so you’re going to find
    yourself in a bad spot if you try this.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个想法的问题在于，它假设这个指令将在每次页面加载时重新创建。然而，Blade 会进行积极的缓存，所以如果你尝试这样做，你会发现自己处于一个困境之中。
- en: Parameters in Custom Blade Directives
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 Blade 指令中的参数
- en: What if you want to accept parameters in your custom logic? Check out [Example 4-30](#EX422).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在自定义逻辑中接受参数，可以查看[示例 4-30](#EX422)。
- en: Example 4-30\. Creating a Blade directive with parameters
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-30\. 创建带参数的 Blade 指令
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `$expression` parameter received by the closure represents whatever’s within
    the parentheses. As you can see, we then generate a valid PHP code snippet and
    return it.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包接收的 `$expression` 参数表示括号内的内容。正如你所看到的，我们生成了一个有效的 PHP 代码片段并返回它。
- en: If you find yourself constantly writing the same conditional logic over and
    over, you should consider a Blade directive.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己一遍又一遍地写相同的条件逻辑，那么你应该考虑使用 Blade 指令。
- en: 'Example: Using Custom Blade Directives for a Multitenant App'
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例：在多租户应用程序中使用自定义 Blade 指令
- en: Let’s imagine we’re building an application that supports *multitenancy*, which
    means users might be visiting the site from *www.myapp.com*, *client1.myapp.com*,
    *client2.myapp.com*, or elsewhere.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在构建一个支持*多租户*的应用程序，这意味着用户可能会从*www.myapp.com*、*client1.myapp.com*、*client2.myapp.com*或其他地方访问该网站。
- en: Suppose we have written a class to encapsulate some of our multitenancy logic
    and named it `Context`. This class will capture information and logic about the
    context of the current visit, such as who the authenticated user is and whether
    the user is visiting the public website or a client subdomain.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们编写了一个类来封装某些多租户逻辑，并命名为 `Context`。该类将捕获有关当前访问上下文的信息和逻辑，例如认证用户是谁，以及用户是访问公共网站还是客户子域。
- en: We’ll probably frequently resolve that `Context` class in our views and perform
    conditionals on it, like in [Example 4-31](#EX423). `app('context')` is a shortcut
    to get an instance of a class from the container, which we’ll learn more about
    in [Chapter 11](ch11.html#the_container).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会经常在视图中解析 `Context` 类，并对其执行条件操作，就像[示例 4-31](#EX423)中那样。`app('context')`
    是从容器中获取类实例的快捷方式，我们将在[第11章](ch11.html#the_container)中进一步学习容器。
- en: Example 4-31\. Conditionals on context without a custom Blade directive
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-31\. 在上下文中进行条件判断，无需自定义 Blade 指令
- en: '[PRE40]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What if we could simplify `@if (app('context')->isPublic())` to just `@ifPublic`?
    Let’s do it. Check out [Example 4-32](#EX424).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能将 `@if (app('context')->isPublic())` 简化为 `@ifPublic`，该有多好？让我们来做吧。查看[示例 4-32](#EX424)。
- en: Example 4-32\. Conditionals on context with a custom Blade directive
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-32\. 使用自定义 Blade 指令进行上下文条件判断
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since this resolves to a simple `if` statement, we can still rely on the native
    `@else` and `@endif` conditionals. But if we wanted, we could also create a custom
    `@elseIfClient` directive, or a separate `@ifClient` directive, or really whatever
    else we want.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这解析为简单的 `if` 语句，我们仍然可以依赖于原生的 `@else` 和 `@endif` 条件。但如果我们愿意，我们也可以创建一个自定义 `@elseIfClient`
    指令，或者单独的 `@ifClient` 指令，或者任何其他我们想要的东西。
- en: Easier Custom Directives for “if” Statements
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更容易定制的“if”语句指令
- en: 'Although custom Blade directives are powerful, the most common use for them
    is `if` statements. So there’s a simpler way to create custom “if” directives:
    `Blade::if()`. [Example 4-33](#EX424.5) shows how we could refactor [Example 4-32](#EX424)
    using the `Blade::if()` method:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管自定义 Blade 指令功能强大，但它们最常见的用途是处理 `if` 语句。所以创建自定义“if”指令的简单方法是使用 `Blade::if()`。[示例 4-33](#EX424.5)
    展示了我们如何使用 `Blade::if()` 方法重构[示例 4-32](#EX424)：
- en: Example 4-33\. Defining a custom “if” Blade directive
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-33\. 定义自定义“if” Blade 指令
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You’ll use the directives exactly the same way, but as you can see, defining
    them is a bit simpler. Instead of having to manually type out PHP braces, you
    can just write a closure that returns a Boolean.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你将以完全相同的方式使用这些指令，但是正如你所看到的，定义它们要简单一些。你不必手动键入 PHP 大括号，只需编写返回布尔值的闭包即可。
- en: Testing
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: The most common method of testing views is through application testing, meaning
    that you’re actually calling the route that displays the views and ensuring the
    views have certain content (see [Example 4-34](#EX428)). You can also click buttons
    or submit forms and ensure that you are redirected to a certain page or that you
    see a certain error. (You’ll learn more about testing in [Chapter 12](ch12.html#testing).)
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 测试视图的最常见方法是通过应用程序测试，这意味着你实际上调用显示视图的路由，并确保视图包含特定内容（参见[示例 4-34](#EX428)）。你还可以点击按钮或提交表单，并确保你被重定向到某个页面或看到某个特定的错误。（你将在[第12章](ch12.html#testing)中了解更多关于测试的内容。）
- en: Example 4-34\. Testing that a view displays certain content
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-34\. 测试一个视图是否显示特定内容
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can also test that a certain view has been passed a particular set of data,
    which, if it accomplishes your testing goals, is less fragile than checking for
    certain text on the page. [Example 4-35](#EX429) demonstrates this approach.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以测试某个视图是否已经传递了特定的数据，如果达到了你的测试目标，这比检查页面上的某些文本更加健壮。[示例 4-35](#EX429)演示了这种方法。
- en: Example 4-35\. Testing that a view was passed certain content
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-35\. 测试一个视图是否传递了特定内容
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With `assertViewHas()` we can pass in a closure, meaning we can customize how
    we want to check more complex data structures. [Example 4-36](#EX430) illustrates
    how we might use this.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`assertViewHas()`，我们可以传递一个闭包，这意味着我们可以自定义如何检查更复杂的数据结构。[示例 4-36](#EX430)说明了我们可能如何使用这个功能。
- en: Example 4-36\. Passing a closure to `assertViewHas()`
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-36\. 向 `assertViewHas()` 传递闭包
- en: '[PRE45]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: TL;DR
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Blade is Laravel’s templating engine. Its primary focus is a clear, concise,
    and expressive syntax with powerful inheritance and extensibility. Its “safe echo”
    brackets are `{{` and `}}`, its unprotected echo brackets are `{!!` and `!!}`,
    and it has a series of custom tags called “directives” that all begin with `@`
    (`@if` and `@unless`, for example).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Blade 是 Laravel 的模板引擎。它的主要关注点是清晰、简洁和表达力强大的语法，具有强大的继承性和可扩展性。它的“安全输出”括号是`{{`和`}}`，其不受保护的输出括号是`{!!`和`!!}`，它还有一系列称为“指令”的自定义标签，所有这些标签都以`@`开头（例如`@if`和`@unless`）。
- en: You can define a parent template and leave “holes” in it for content using `@yield`
    and `@section`/`@show`. You can then teach its child views to extend the parent
    using `@extends('*parent.view*')` and define their sections using `@section`/`@endsection`.
    You use `@parent` to reference the content of the block’s parent.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义一个父模板，并在其中留下“洞口”以用于内容，使用`@yield`和`@section`/`@show`。然后，你可以教会其子视图通过`@extends('*parent.view*')`扩展父视图，并使用`@section`/`@endsection`定义它们的部分。你可以使用`@parent`引用块的父级内容。
- en: View composers make it easy to define that every time a particular view or subview
    loads, it should have certain information available to it. And service injection
    allows the view itself to request data straight from the application container.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 视图组合器使得在每次加载特定视图或子视图时定义特定信息变得轻松。服务注入允许视图本身直接从应用程序容器请求数据。
