- en: Chapter 3\. Introduction to PHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. PHP简介
- en: In [Chapter 1](ch01.xhtml#introduction_to_dynamic_web_content), I explained
    that PHP is the language that you use to make the server generate dynamic output—output
    that is potentially different each time a browser requests a page. In this chapter,
    you’ll start learning this simple but powerful language; it will be the topic
    of the following chapters up through [Chapter 7](ch07.xhtml#practical_php).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ch01.xhtml#introduction_to_dynamic_web_content)中，我解释了PHP是您用来使服务器生成动态输出的语言——每次浏览器请求页面时，输出可能会有所不同。在这一章中，您将开始学习这种简单但功能强大的语言；接下来几章将深入探讨这个主题，直到[第7章](ch07.xhtml#practical_php)。
- en: I encourage you to develop your PHP code using one of the IDEs listed in [Chapter 2](ch02.xhtml#setting_up_a_development_server),
    or a good code editor.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您使用[第2章](ch02.xhtml#setting_up_a_development_server)中列出的IDE之一或良好的代码编辑器来开发您的PHP代码。
- en: Many of these programs will let you run the PHP code and see the output discussed
    in this chapter. I’ll also show you how to create PHP code so that you can see
    what the output looks like in a web page (the way your users will ultimately see
    it). But that step, as thrilling as it may be at first, isn’t really important
    at this stage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些程序中的许多程序将允许您运行PHP代码并查看本章讨论的输出。我还将向您展示如何创建PHP代码，以便您可以看到Web页面中的输出（最终用户将如何看待它）。但是，在这个阶段，这一步骤虽然一开始可能会令人兴奋，但实际上并不重要。
- en: In production, your web pages will be a combination of PHP, HTML, JavaScript,
    and some MySQL statements laid out using CSS. Furthermore, each page can lead
    to other pages to provide users with ways to click through links and fill out
    forms. We can avoid all that complexity while learning each language, though.
    Focus for now on just writing PHP code and making sure that you get the output
    you expect—or at least that you understand the output you actually get!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产中，您的网页将是PHP、HTML、JavaScript和一些MySQL语句的组合，使用CSS布局。此外，每个页面都可以导向其他页面，以便用户通过链接点击和填写表单。尽管如此，在学习每种语言时，我们可以避开所有这些复杂性。现在专注于编写PHP代码，并确保您得到预期的输出，或者至少理解实际得到的输出！
- en: Incorporating PHP Within HTML
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将PHP嵌入HTML中
- en: By default, PHP documents end with the extension *.php*. When a web server encounters
    this extension in a requested file, it automatically passes it to the PHP processor.
    Of course, web servers are highly configurable, and some web developers choose
    to force files ending with *.htm* or *.html* to also get parsed by the PHP processor,
    usually because they want to hide their use of PHP.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PHP文档以扩展名*.php*结尾。当Web服务器在请求的文件中遇到此扩展名时，它会自动将其传递给PHP处理器。当然，Web服务器高度可配置，一些Web开发者选择强制以*.htm*或*.html*结尾的文件也由PHP处理，通常是因为他们想隐藏其对PHP的使用。
- en: Your PHP program is responsible for passing back a clean file suitable for display
    in a web browser. At its very simplest, a PHP document will output only HTML.
    To prove this, you can take any normal HTML document and save it as a PHP document
    (for example, saving *index.html* as *index.php*), and it will display identically
    to the original.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您的PHP程序负责传回一个干净的文件，适合在Web浏览器中显示。在最简单的情况下，一个PHP文档只会输出HTML。为了证明这一点，您可以拿任何普通的HTML文档，并将其保存为PHP文档（例如，将*index.html*另存为*index.php*），它将与原始文档显示完全一致。
- en: 'To trigger the PHP commands, you need to learn a new tag. Here is the first
    part:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发PHP命令，您需要学习一个新的标签。这是第一部分：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The first thing you may notice is that the tag has not been closed. This is
    because entire sections of PHP can be placed inside this tag, and they finish
    only when the closing part is encountered, which looks like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能注意到的第一件事是标签没有关闭。这是因为整个PHP部分可以放置在此标签内，只有当遇到关闭部分时才会结束，其看起来像这样：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A small PHP “Hello World” program might look like [Example 3-1](#invoking_php).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小的PHP“Hello World”程序可能看起来像[示例3-1](#invoking_php)。
- en: Example 3-1\. Invoking PHP
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-1. 调用PHP
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Use of this tag can be quite flexible. Some programmers open the tag at the
    start of a document and close it right at the end, outputting any HTML directly
    from PHP commands. Others, however, choose to insert only the smallest possible
    fragments of PHP within these tags wherever dynamic scripting is required, leaving
    the rest of the document in standard HTML.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此标签可以非常灵活。一些程序员在文档开头就打开标签，并在文档末尾关闭它，直接从PHP命令输出任何HTML。然而，其他人选择仅在这些标签中插入PHP的最小可能片段，只在需要动态脚本时，将文档的其余部分保持为标准HTML。
- en: The latter type of programmer generally argues that their style of coding results
    in faster code, while the former says that the speed increase is so minimal that
    it doesn’t justify the additional complexity of dropping in and out of PHP many
    times in a single document.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 后一种类型的程序员通常认为，他们的编码风格会导致更快的代码，而前者则认为速度提升是如此微小，以至于不能证明在单个文档中多次进出 PHP 的额外复杂性。
- en: As you learn more, you will surely discover your preferred style of PHP development,
    but for the sake of making the examples in this book easier to follow, I have
    adopted the approach of keeping the number of transfers between PHP and HTML to
    a minimum—generally only once or twice in a document.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的学习深入，你肯定会发现自己偏好的 PHP 开发风格，但为了使本书中的示例更易于理解，我采用了尽量减少 PHP 和 HTML 之间转换次数的方法——通常在一个文档中只有一两次。
- en: 'By the way, there is a slight variation to the PHP syntax. If you browse the
    internet for PHP examples, you may also encounter code where the opening and closing
    syntax looks like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，PHP 语法还有一种轻微的变体。如果你在互联网上搜索 PHP 示例，你可能会遇到打开和关闭语法看起来像这样的代码：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Although it’s not as obvious that the PHP parser is being called, this is a
    valid, alternative syntax that also usually works. But I discourage its use, as
    it is incompatible with XML and is now deprecated (meaning that it is no longer
    recommended and support could be removed in future versions).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 PHP 解析器被调用的情况不太明显，但这是一种有效的替代语法，通常也可以工作。但我不鼓励使用，因为它与 XML 不兼容，现在已经被弃用（意味着不再推荐使用，并且未来版本可能会移除支持）。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you have only PHP code in a file, you may omit the closing `?>`. This can
    be a good practice, as it will ensure that you have no excess whitespace leaking
    from your PHP files (especially important when you’re writing object-oriented
    code).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的文件中只有 PHP 代码，可以省略结尾的 `?>`。这是一个很好的做法，因为它可以确保你的 PHP 文件没有多余的空白字符泄漏（特别是在你编写面向对象的代码时尤为重要）。
- en: This Book’s Examples
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本书的示例
- en: To save you the time it would take to type them all in, all the examples from
    this book have been stored at GitHub. You can download the archive to your computer
    by visiting: [GitHub](https://github.com/RobinNixon/lpmj6).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省你输入所有内容的时间，本书中的所有示例都已存储在 GitHub 上。你可以通过访问以下链接将存档下载到你的计算机中：[GitHub](https://github.com/RobinNixon/lpmj6)。
- en: In addition to listing all the examples by chapter and example number (such
    as *example3-1.php*), some of the examples may require explicit filenames, in
    which case copies of the example(s) are also saved using the filename(s) in the
    same folder (such as the upcoming [Example 3-4](#your_first_php_program), which
    should be saved as *test1.php*).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 除了按章节和示例编号列出所有示例（如 *example3-1.php*），某些示例可能需要显式的文件名，此时示例的副本也将使用相同文件夹中的文件名保存（例如即将出现的
    [示例 3-4](#your_first_php_program)，应保存为 *test1.php*）。
- en: The Structure of PHP
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP 的结构
- en: We’re going to cover quite a lot of ground in this section. It’s not too difficult,
    but I recommend that you work your way through it carefully, as it sets the foundation
    for everything else in this book. As always, there are some useful questions at
    the end of the chapter that you can use to test how much you’ve learned.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖相当广泛的内容。这并不太困难，但我建议你仔细阅读，因为这为本书中的所有其他内容奠定了基础。和往常一样，章节末尾有一些有用的问题，可以用来测试你学到了多少知识。
- en: Using Comments
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用注释
- en: 'There are two ways in which you can add comments to your PHP code. The first
    turns a single line into a comment by preceding it with a pair of forward slashes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方式可以向你的 PHP 代码添加注释。第一种通过在前面加上一对斜杠将单行变为注释：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This version of the comment feature is a great way to temporarily remove a
    line of code from a program that is giving you errors. For example, you could
    use such a comment to hide a debugging line of code until you need it, like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种版本的注释功能是暂时从一个给你错误的程序中移除一行代码的好方法。例如，你可以使用这样的注释隐藏一个调试代码行，直到你需要它，就像这样：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can also use this type of comment directly after a line of code to describe
    its action, like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以直接在一行代码后使用这种类型的注释描述它的操作，就像这样：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you need to use multiple lines, there’s a second type of comment, which
    looks like [Example 3-2](#multiline_comment).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用多行时，有第二种类型的注释，看起来像 [示例 3-2](#multiline_comment)。
- en: Example 3-2\. A multiline comment
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. 多行注释
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can use the `/*` and `*/` pairs of characters to open and close comments
    almost anywhere you like inside your code. Most, if not all, programmers use this
    construct to temporarily comment out entire sections of code that do not work
    or that, for one reason or another, they do not wish to be interpreted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`/*`和`*/`字符对来在代码的几乎任何位置打开和关闭注释。大多数程序员使用这种结构来暂时注释掉整个不起作用或由于某种原因他们不希望解释的代码部分。
- en: Warning
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: A common error is to use `/*` and `*/` to comment out a large section of code
    that already contains a commented-out section that uses those characters. You
    can’t nest comments this way; the PHP interpreter won’t know where a comment ends
    and will display an error message. However, if you use an editor or IDE with syntax
    highlighting, this type of error is easier to spot.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是使用`/*`和`*/`来注释一个已包含使用这些字符的注释部分的大段代码。您不能以这种方式嵌套注释；PHP解释器不会知道注释何时结束，并显示错误消息。但是，如果您使用具有语法高亮的编辑器或IDE，这种错误更容易发现。
- en: Basic Syntax
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本语法
- en: PHP is quite a simple language with roots in C and Perl (if you have ever come
    across these), yet it looks more like Java. It is also very flexible, but there
    are a few rules that you need to learn about its syntax and structure.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: PHP是一种相当简单的语言，起源于C和Perl（如果您曾经接触过这些语言），但它看起来更像Java。它也非常灵活，但您需要学习关于其语法和结构的一些规则。
- en: Semicolons
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分号
- en: 'You may have noticed in the previous examples that the PHP commands ended with
    a semicolon, like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在前面的示例中，PHP命令以分号结尾，就像这样：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One of  the most common causes of errors you will encounter with PHP is forgetting
    this semicolon. This causes PHP to treat multiple statements like one statement,
    which it is unable to understand, prompting it to produce a `Parse error` message.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，您将遇到的最常见的错误之一是忘记分号。这会导致PHP将多个语句视为一个语句，PHP无法理解，因此会生成一个`Parse error`消息。
- en: The $ symbol
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`$` 符号'
- en: The `$` symbol has come to be used in many different ways by different programming
    languages. For example, in the BASIC language, it was used to terminate variable
    names to denote them as strings.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`$` 符号已经被许多不同的编程语言以多种方式使用。例如，在BASIC语言中，它被用来终止变量名称以表示它们是字符串。'
- en: In PHP, however, you must place a `$` in front of *all* variables. This is required
    to make the PHP parser faster, as it instantly knows whenever it comes across
    a variable. Whether your variables are numbers, strings, or arrays, they should
    all look something like those in [Example 3-3](#three_different_types_of_variable_assign).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在PHP中，您必须在*所有*变量前面放置一个`$`。这是必需的，以使PHP解析器更快，因为它可以立即知道何时遇到变量。无论您的变量是数字、字符串还是数组，它们都应该看起来像[示例 3-3](#three_different_types_of_variable_assign)中的那些。
- en: Example 3-3\. Three different types of variable assignment
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 三种不同类型的变量赋值
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: And really that’s pretty much all the syntax that you have to remember. Unlike
    languages such as Python, which are very strict about how you indent and lay out
    your code, PHP leaves you completely free to use (or not use) all the indenting
    and spacing you like. In fact, sensible use of whitespace is generally encouraged
    (along with comprehensive commenting) to help you understand your code when you
    come back to it. It also helps other programmers when they have to maintain your
    code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上就是您必须记住的语法。与Python等严格要求缩进和布局的语言不同，PHP完全自由，您可以随意使用或不使用缩进和空格。事实上，合理使用空白通常是鼓励的（以及全面注释），这有助于您在回顾代码时理解它。它还有助于其他程序员在维护代码时理解。
- en: Variables
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: There’s a simple metaphor that will help you understand what PHP variables are
    all about. Just think of them as little (or big) matchboxes! That’s right—matchboxes
    that you’ve painted over and written names on.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个简单的比喻可以帮助您理解PHP变量的含义。只需将它们想象成小（或大）火柴盒！没错，就是您粉刷过并写上名称的火柴盒。
- en: String variables
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串变量
- en: 'Imagine you have a matchbox on which you have written the word *username*.
    You then write *Fred Smith* on a piece of paper and place it into the box (see
    [Figure 3-1](#you_can_think_of_variables_as_matchboxes)). Well, that’s the same
    process as assigning a string value to a variable, like this:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您有一盒火柴上面写着*用户名*。然后，您在一张纸上写下*Fred Smith*并将其放入盒子中（参见[图 3-1](#you_can_think_of_variables_as_matchboxes)）。好吧，这与将字符串值分配给变量的过程相同，就像这样：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The quotation marks indicate that “Fred Smith” is a *string* of characters.
    You must enclose each string in either quotation marks or apostrophes (single
    quotes), although there is a subtle difference between the two types of quote,
    which is explained later. When you want to see what’s in the box, you open it,
    take the piece of paper out, and read it. In PHP, doing so looks like this (which
    displays the contents of the variable):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 引号表明“Fred Smith”是一个由字符组成的*字符串*。你必须用引号或撇号（单引号）将每个字符串括起来，尽管这两种引号之间存在微妙的差异，稍后会进行解释。当你想看看盒子里面装了什么时，你打开它，拿出那张纸，然后阅读它。在PHP中，这样做看起来像这样（显示变量的内容）：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or you can assign it to another variable (photocopy the paper and place the
    copy in another matchbox), like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以将其分配给另一个变量（复印纸张并将副本放入另一个火柴盒），如下所示：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![You can think of variables as matchboxes containing items](Images/pmj6_0301.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![您可以将变量视为装有物品的火柴盒](Images/pmj6_0301.png)'
- en: Figure 3-1\. You can think of variables as matchboxes containing items
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-1\. 您可以将变量视为装有物品的火柴盒
- en: Example 3-4\. Your first PHP program
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. 你的第一个PHP程序
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now you can call it up by entering the following into your browser’s address
    bar:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过在浏览器地址栏中输入以下内容来调用它：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the unlikely event that during the installation of your web server (as detailed
    in [Chapter 2](ch02.xhtml#setting_up_a_development_server)) you changed the port
    assigned to the server to anything other than 80, then you must place that port
    number within the URL in this and all other examples in this book. So, for example,
    if you changed the port to 8080, the preceding URL would become this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在安装网络服务器期间（详见[第2章](ch02.xhtml#setting_up_a_development_server)）不太可能发生，您将服务器分配的端口更改为80以外的任何数字，则必须将该端口号放在本书中的所有示例中的URL中，例如，如果将端口更改为8080，则前述URL将变成如下所示：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: I won’t mention this again, so just remember to use the port number (if required)
    when trying examples or writing your own code.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会再提到这一点了，所以请记住在尝试示例或编写自己的代码时使用端口号（如果需要）。
- en: The result of running this code should be two occurrences of the name *Fred
    Smith*, the first of which is the result of the `echo $username` command and the
    second of which is the result of the `echo $current_user` command.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码的结果应该是两次出现名称*Fred Smith*，第一次是`echo $username`命令的结果，第二次是`echo $current_user`命令的结果。
- en: Numeric variables
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值变量
- en: 'Variables don’t have to contain just strings—they can contain numbers too.
    If we return to the matchbox analogy, to store the number 17 in the variable `$count`,
    the equivalent would be placing, say, 17 beads in a matchbox on which you have
    written the word *count*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 变量不一定只能包含字符串，它们也可以包含数字。如果我们回到火柴盒类比，要在变量`$count`中存储数字17，相当于在火柴盒里放入17颗珠子，并在盒子上写上单词*count*：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You could also use a floating-point number (containing a decimal point). The
    syntax is the same:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用浮点数（包含小数点）。语法是一样的：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To see the contents of the matchbox, you would simply open it and count the
    beads. In PHP, you would assign the value of `$count` to another variable or perhaps
    just echo it to the web browser.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看火柴盒的内容，只需打开它并计算珠子的数量。在PHP中，您可以将`$count`的值分配给另一个变量，或者可能只是将其回显到Web浏览器中。
- en: Arrays
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: You can think of arrays as several matchboxes glued together. For example, let’s
    say we want to store the player names for a five-person soccer team in an array
    called `$team`. To do this, we could glue five matchboxes side by side and write
    down the names of all the players on separate pieces of paper, placing one in
    each matchbox.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将数组视为几个粘在一起的火柴盒。例如，假设我们要在名为`$team`的数组中存储一个五人足球队的球员姓名。为此，我们可以侧向粘合五个火柴盒，并在分别的纸片上写下所有球员的名字，将每个名字放入一个火柴盒中。
- en: 'Across the top of the whole matchbox assembly we would write the word *team*
    (see [Figure 3-2](#array_is_like_several_matchboxes_glue)). The equivalent of
    this in PHP would be the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个火柴盒组件的顶部，我们将写下*team*（参见[图3-2](#array_is_like_several_matchboxes_glue)）。在PHP中，这的等效物将是以下内容：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![An array is like several matchboxes glued together](Images/pmj6_0302.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![数组就像粘在一起的几个火柴盒](Images/pmj6_0302.png)'
- en: Figure 3-2\. An array is like several matchboxes glued together
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-2\. 数组就像粘在一起的几个火柴盒
- en: 'This syntax is more complicated than the other examples you’ve seen so far.
    The array-building code consists of the following construct:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法比您迄今看到的其他示例更复杂。数组构建代码包括以下结构：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: with five strings inside. Each string is enclosed in apostrophes or quotes,
    and strings must be separated with commas.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内部包含五个字符串。每个字符串用单引号或双引号括起来，并用逗号分隔。
- en: 'If we then wanted to know who player 4 is, we could use this command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想知道第四名玩家是谁，我们可以使用这个命令：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The reason the previous statement has the number 3, not 4, is that the first
    element of a PHP array is actually the zeroth element, so the player numbers will
    therefore be 0 through 4.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前述声明中的数字为3而不是4的原因是PHP数组的第一个元素实际上是零索引，因此玩家编号将从0到4。
- en: Two-dimensional arrays
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二维数组
- en: There’s a lot more you can do with arrays. For example, instead of being single-dimensional
    lines of matchboxes, they can be two-dimensional matrixes or even have more dimensions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 数组还有更多用途。例如，它们不仅可以是单维线条的火柴盒，还可以是二维矩阵，甚至具有更多维度。
- en: As an example of a two-dimensional array, let’s say we want to keep track of
    a game of tic-tac-toe, which requires a data structure of nine cells arranged
    in a 3 × 3 square. To represent this with matchboxes, imagine nine of them glued
    to one other in a matrix of three rows by three columns (see [Figure 3-3](#multidimensional_array_simulated_with)).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 举例说明二维数组，比如我们想要跟踪井字棋游戏，这需要一个3 × 3的九个单元格的数据结构。要用火柴盒表示这个结构，想象九个火柴盒按照3行3列的矩阵排列在一起（见[图 3-3](#multidimensional_array_simulated_with)）。
- en: '![A multidimensional array simulated with matchboxes](Images/pmj6_0303.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![用火柴盒模拟的多维数组](Images/pmj6_0303.png)'
- en: Figure 3-3\. A multidimensional array simulated with matchboxes
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 用火柴盒模拟的多维数组
- en: You can now place a piece of paper with either an *x* or an *o* on it in the
    correct matchbox for each move played. To do this in PHP code, you have to set
    up an array containing three more arrays, as in [Example 3-5](#defining_a_two-dimensional_array),
    in which the array is set up with a game already in progress.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在每个移动中正确的火柴盒上放置一个带有*x*或*o*的纸条。要在PHP代码中实现这一点，你必须设置一个包含三个更多数组的数组，就像[示例 3-5](#defining_a_two-dimensional_array)中那样，其中数组已经设置了进行中的游戏。
- en: Example 3-5\. Defining a two-dimensional array
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. 定义一个二维数组
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once again, we’ve moved up a step in complexity, but it’s easy to understand
    if you grasp the basic array syntax. There are three `array()` constructs nested
    inside the outer `array()` construct. We’ve filled each row with an array consisting
    of just one character: an *x*, an *o*, or a blank space. (We use a blank space
    so that all the cells will be the same width when they are displayed.)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们在复杂性上迈出了一步，但是如果你掌握了基本的数组语法，这是很容易理解的。在外部`array()`结构中嵌套了三个`array()`结构。我们用一个字符填充了每一行的数组：*x*，*o*或空格。（我们使用空格以便所有单元格在显示时宽度相同。）
- en: 'To then return the third element in the second row of this array, you would
    use the following PHP command, which will display an `x`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回该数组中第二行的第三个元素，你可以使用以下PHP命令，它将显示一个`x`：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that array indexes (pointers at elements within an array) start from
    zero, not one, so the `[1]` in the previous command refers to the second of the
    three arrays, and the `[2]` references the third position within that array. This
    command will return the contents of the matchbox three along and two down.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，数组索引（指向数组元素的指针）从零开始，而不是从一开始，所以前一个命令中的`[1]`指的是三个数组中的第二个，`[2]`则指的是该数组中的第三个位置。此命令将返回火柴盒中第三行第二列的内容。
- en: As mentioned, we can support arrays with even more dimensions by simply creating
    more arrays within arrays. However, we will not be covering arrays of more than
    two dimensions in this book.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前文所述，我们可以通过简单地在数组中创建更多数组来支持更多维度的数组。但是，在本书中我们不会涉及超过二维的数组。
- en: And don’t worry if you’re still having difficulty coming to grips with using
    arrays, as the subject is explained in detail in [Chapter 6](ch06.xhtml#php_arrays).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然难以掌握使用数组，不要担心，因为这个主题在[第6章](ch06.xhtml#php_arrays)中有详细解释。
- en: Variable-naming rules
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量命名规则
- en: 'When creating PHP variables, you must follow these four rules:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建PHP变量时，必须遵循以下四条规则：
- en: Variable names, after the dollar sign, must start with a letter of the alphabet
    or the *_* (underscore) character.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名在美元符号后必须以字母或下划线字符开头。
- en: Variable names can contain only the characters `a`–`z`, `A`–`Z`, `0`–`9`, and
    `_` (underscore).
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名只能包含字符`a`到`z`，`A`到`Z`，`0`到`9`，和`_`（下划线）。
- en: Variable names may not contain spaces. If a variable name must comprise more
    than one word, a good idea is to separate the words with the `_` **(**underscore**)**
    character (e.g., `$user_name`).
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名不得包含空格。如果变量名必须由多个词组成，一个好主意是用下划线 `_`（下划线）字符分隔单词（例如，`$user_name`）。
- en: Variable names are case-sensitive. The variable `$High_Score` is not the same
    as the variable `$high_score`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名区分大小写。变量 `$High_Score` 与变量 `$high_score` 不同。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To allow extended ASCII characters that include accents, PHP also supports the
    bytes from 127 through 255 in variable names. But unless your code will be maintained
    only by programmers who are used to those characters, it’s probably best to avoid
    them, because programmers using English keyboards will have difficulty accessing
    them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许包含带重音的扩展 ASCII 字符，PHP 还支持变量名中从 127 到 255 的字节。但除非你的代码只由习惯使用这些字符的程序员维护，否则最好避免使用它们，因为使用英文键盘的程序员将难以访问它们。
- en: Operators
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符
- en: '*Operators* let you specify mathematical operations to perform, such as addition,
    subtraction, multiplication, and division. But several other types of operators
    exist too, such as the string, comparison, and logical operators. Math in PHP
    looks a lot like plain arithmetic—for instance, the following statement outputs
    8:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*运算符* 允许你指定执行的数学运算，比如加法、减法、乘法和除法。但还有其他类型的运算符，如字符串、比较和逻辑运算符。在 PHP 中数学运算看起来很像普通算术运算——例如，以下语句输出
    `8`：'
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Before moving on to learn what PHP can do for you, take a moment to learn about
    the various operators it provides.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续学习 PHP 能为你做什么之前，花点时间了解它提供的各种运算符。
- en: Arithmetic operators
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 算术运算符
- en: Arithmetic operators do what you would expect—they are used to perform mathematics.
    You can use them for the main four operations (add, subtract, multiply, and divide)
    as well as to find a modulus (the remainder after a division) and to increment
    or decrement a value (see [Table 3-1](#arithmetic_operators-id00003)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符执行你所期望的操作——它们用于执行数学运算。你可以用它们进行四个主要运算（加、减、乘、除），以及找到模数（除法后的余数），并对值进行增加或减少（参见
    [表 3-1](#arithmetic_operators-id00003)）。
- en: Table 3-1\. Arithmetic operators
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. 算术运算符
- en: '| Operator | Description | Example |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `+` | Addition | `$j` **`+`** `1` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法 | `$j` **`+`** `1` |'
- en: '| `–` | Subtraction | `$j` **`–`** `6` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `–` | 减法 | `$j` **`–`** `6` |'
- en: '| `*` | Multiplication | `$j` **`*`** `11` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 | `$j` **`*`** `11` |'
- en: '| `/` | Division | `$j` **`/`** `4` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法 | `$j` **`/`** `4` |'
- en: '| `%` | Modulus (the remainder after a division is performed) | `$j` **`%`**
    `9` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取模（除法后的余数） | `$j` **`%`** `9` |'
- en: '| `++` | Increment | **`++`**`$j` |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `++` | 递增 | **`++`**`$j` |'
- en: '| `--` | Decrement | **`--`**`$j` |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `--` | 递减 | **`--`**`$j` |'
- en: '| `**` | Exponentiation (or power) | `$j******2` |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `**` | 指数（或幂） | `$j******2` |'
- en: Assignment operators
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: 'These operators assign values to variables. They start with the very simple
    `=` and move on to `+=`, `-=`, and so on (see [Table 3-2](#assignment_operators-id00004)).
    The operator `+=` adds the value on the right side to the variable on the left,
    instead of totally replacing the value on the left. Thus, if `$count` starts with
    the value `5`, the statement:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符将值赋给变量。它们从简单的 `=` 开始，然后是 `+=`、`-=` 等等（参见 [表 3-2](#assignment_operators-id00004)）。运算符
    `+=` 将右侧的值加到左侧的变量上，而不是完全替换左侧的值。因此，如果 `$count` 初始值为 `5`，则语句：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'sets `$count` to `6`, just like the more familiar assignment statement:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `$count` 设置为 `6`，就像更熟悉的赋值语句一样：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `/=` and `*=` operators are similar, but for division and multiplication,
    the `.=` operator concatenates variables, such that `$a .= "."` will append a
    period to the end of `$a`, and `%=` assigns a percentage value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`/=` 和 `*=` 运算符类似，但用于除法和乘法，`.=` 运算符将变量连接起来，使 `$a .= "."` 将句点附加到 `$a` 的末尾，而
    `%=` 分配一个百分比值。'
- en: Table 3-2\. Assignment operators
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-2\. 赋值运算符
- en: '| Operator | Example | Equivalent to |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 示例 | 等价于 |'
- en: '| --- | --- | --- |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `=` | ``$j **`=`** 15`` | `$j = 15` |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `=` | ``$j **`=`** 15`` | `$j = 15` |'
- en: '| `+=` | ``$j **`+=`** 5`` | `$j = $j + 5` |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `+=` | ``$j **`+=`** 5`` | `$j = $j + 5` |'
- en: '| `–=` | ``$j **`-=`** 3`` | `$j = $j – 3` |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `–=` | ``$j **`-=`** 3`` | `$j = $j – 3` |'
- en: '| `*=` | ``$j **`*=`** 8`` | `$j = $j * 8` |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `*=` | ``$j **`*=`** 8`` | `$j = $j * 8` |'
- en: '| `/=` | ``$j **`/=`** 16`` | `$j = $j / 16` |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `/=` | ``$j **`/=`** 16`` | `$j = $j / 16` |'
- en: '| `.=` | ``$j **`.=`** $k`` | `$j = $j . $k` |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `.=` | ``$j **`.=`** $k`` | `$j = $j . $k` |'
- en: '| `%=` | ``$j **`%=`** 4`` | `$j = $j % 4` |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `%=` | ``$j **`%=`** 4`` | `$j = $j % 4` |'
- en: Comparison operators
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Comparison operators are generally used inside a construct such as an `if` statement
    in which you need to compare two items. For example, you may wish to know whether
    a variable you have been incrementing has reached a specific value, or whether
    another variable is less than a set value, and so on (see [Table 3-3](#comparison_operators-id00005)).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符通常用于诸如 `if` 语句等结构中，需要比较两个项的情况下。例如，您可能希望知道一个您一直在递增的变量是否达到了特定值，或者另一个变量是否小于一个设定值等（参见
    [表 3-3](#comparison_operators-id00005)）。
- en: Table 3-3\. Comparison operators
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-3\. 比较运算符
- en: '| Operator | Description | Example |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `==` | Is *equal* to | `$j **==** 4` |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| `==` | *等于* | `$j **==** 4` |'
- en: '| `!=` | Is *not equal* to | ``$j **`!=`** 21`` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `!=` | *不等于* | ``$j **`!=`** 21`` |'
- en: '| `>` | Is *greater than* | ``$j **`>`** 3`` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `>` | *大于* | ``$j **`>`** 3`` |'
- en: '| `<` | Is *less than* | ``$j **`<`** 100`` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `<` | *小于* | ``$j **`<`** 100`` |'
- en: '| `>=` | Is *greater than or equal* to | ``$j **`>=`** 15`` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `>=` | *大于或等于* | ``$j **`>=`** 15`` |'
- en: '| `<=` | Is *less than or equal* to | ``$j **`<=`** 8`` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `<=` | *小于或等于* | ``$j **`<=`** 8`` |'
- en: '| `<>` | Is *not equal* to | ``$j **`<>`** 23`` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `<>` | *不等于* | ``$j **`<>`** 23`` |'
- en: '| `===` | Is *identical* to | ``$j **`===`** "987"`` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `===` | *全等于* | ``$j **`===`** "987"`` |'
- en: '| `!==` | Is *not identical* to | ``$j **`!==`** "1.2e3"`` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `!==` | *不全等于* | ``$j **`!==`** "1.2e3"`` |'
- en: Note the difference between `=` and `==`. The first is an assignment operator,
    and the second is a comparison operator. Even advanced programmers can sometimes
    mix up the two when coding hurriedly, so be careful.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意 `=` 和 `==` 之间的差异。前者是赋值运算符，而后者是比较运算符。即使是高级程序员有时在编码时也可能混淆这两者，所以请小心。
- en: Logical operators
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'If you haven’t used them before, logical operators may at first seem a little
    daunting. But just think of them the way you would use logic in English. For example,
    you might say to yourself, “If the time is later than 12 p.m. and earlier than
    2 p.m., have lunch.” In PHP, the code for this might look something like the following
    (using military time):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前没有使用过逻辑运算符，刚开始可能会感到有些令人畏惧。但只需像在英语中运用逻辑一样思考即可。例如，你可能会对自己说，“如果现在时间晚于下午12点而早于下午2点，则吃午饭。”在PHP中，这段代码可能看起来像以下示例（使用军事时间）：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here we have moved the set of instructions for actually going to lunch into
    a function that we will have to create later called `dolunch`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经将去吃午饭的一系列指令移到一个稍后需要创建的名为 `dolunch` 的函数中。
- en: 'As the previous example shows, you generally use a logical operator to combine
    the results of two of the comparison operators shown in the previous section.
    A logical operator can also be input to another logical operator: “If the time
    is later than 12 p.m. and earlier than 2 p.m., or if the smell of a roast is permeating
    the hallway and there are plates on the table.” As a rule, if something has a
    `TRUE` or `FALSE` value, it can be input to a logical operator. A logical operator
    takes two true or false inputs and produces a true or false result.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的示例所示，通常使用逻辑运算符来组合前一节中显示的比较运算符的结果。逻辑运算符也可以输入到另一个逻辑运算符中：“如果现在时间晚于下午12点且早于下午2点，或者如果烤肉的香味弥漫在走廊上并且桌子上有盘子。”通常情况下，如果某物具有
    `TRUE` 或 `FALSE` 值，它可以输入到一个逻辑运算符中。逻辑运算符需要两个真值或假值输入，并生成一个真值或假值结果。
- en: '[Table 3-4](#logical_operators-id00006) shows the logical operators.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-4](#logical_operators-id00006) 显示了逻辑运算符。'
- en: Table 3-4\. Logical operators
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-4\. 逻辑运算符
- en: '| Operator | Description | Example |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `&&` | *And* | `$j == 3 **&&** $k == 2` |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | *与* | `$j == 3 **&&** $k == 2` |'
- en: '| `and` | Low-precedence *and* | `$j == 3 **and** $k == 2` |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `and` | 低优先级的 *and* | `$j == 3 **and** $k == 2` |'
- en: '| `&#124;&#124;` | *Or* | `$j < 5 **&#124;&#124;** $j > 10` |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | *或* | `$j < 5 **&#124;&#124;** $j > 10` |'
- en: '| `or` | Low-precedence *or* | `$j < 5 **or** $j > 10` |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `or` | 低优先级的 *or* | `$j < 5 **or** $j > 10` |'
- en: '| `!` | *Not* | `! ($j **==** $k)` |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `!` | *非* | `! ($j **==** $k)` |'
- en: '| `xor` | *Exclusive or* | `$j **xor** $k` |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `xor` | *异或* | `$j **xor** $k` |'
- en: 'Note that `&&` is usually interchangeable with `and`; the same is true for
    `||` and `or`. However, because `and` and `or` have a lower precedence, you should
    avoid using them except when they are the only option, as in the following statement,
    which *must* use the `or` operator (`||` cannot be used to force a second statement
    to execute if the first fails):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `&&` 通常可以和 `and` 互换；同样，`||` 和 `or` 也是如此。然而，因为 `and` 和 `or` 的优先级较低，除非它们是唯一的选项，否则应避免使用它们，就像以下语句一样，这个语句必须使用
    `or` 操作符（如果第一个失败，`||` 不能用来强制执行第二个语句）：
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The most unusual of these operators is `xor`, which stands for *exclusive or*
    and returns a `TRUE` value if either value is `TRUE` but a `FALSE` value if both
    inputs are `TRUE` or both inputs are `FALSE`. To understand this, imagine that
    you want to concoct your own cleaner for household items. Ammonia makes a good
    cleaner, and so does bleach, so you want your cleaner to have one of these. But
    the cleaner must not have both, because the combination is hazardous. In PHP,
    you could represent this as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符中最不寻常的是 `xor`，它代表*排他或*，如果任一值为 `TRUE`，则返回 `TRUE` 值，但如果两个输入都为 `TRUE` 或都为
    `FALSE`，则返回 `FALSE` 值。为了理解这一点，想象一下你想要自己调配家庭用品的清洁剂。氨水和漂白剂都是良好的清洁剂，所以你希望你的清洁剂有其中之一。但是清洁剂不能同时有两种，因为这种组合是危险的。在
    PHP 中，你可以这样表示：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, if either `$ammonia` or `$bleach` is `TRUE`, `$ingredient`
    will also be set to `TRUE`. But if both are `TRUE` or both are `FALSE`, `$ingredient`
    will be set to `FALSE`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果 `$ammonia` 或 `$bleach` 的任一值为 `TRUE`，`$ingredient` 也将被设置为 `TRUE`。但是如果两者都为
    `TRUE` 或都为 `FALSE`，`$ingredient` 将被设置为 `FALSE`。
- en: Variable Assignment
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量赋值
- en: The syntax to assign a value to a variable is always *`variable = value`*. Or,
    to reassign the value to another variable, it is *`other_variable = variable`*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将值分配给变量的语法始终为 *`variable = value`*。或者，要将值重新分配给另一个变量，则为 *`other_variable = variable`*。
- en: 'There are also a couple of other assignment operators that you will find useful.
    For example, we’ve already seen this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他的赋值运算符可能会对你有用。例如，我们已经看到了这个：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'which tells the PHP parser to add the value on the right (in this instance,
    the value `10`) to the variable `$x`. Likewise, we could subtract as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 PHP 解析器将右侧的值（在本例中为值 `10`）添加到变量 `$x` 中。同样，我们可以进行减法如下：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Variable incrementing and decrementing
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量递增和递减
- en: 'Adding or subtracting 1 is such a common operation that PHP provides special
    operators for it. You can use one of the following in place of the `+=` and `-=`
    operators:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 增加或减去 1 是一种常见的操作，PHP 提供了特殊的运算符来实现。你可以使用以下之一来代替 `+=` 和 `-=` 运算符：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In conjunction with a test (an `if` statement), you could use the following
    code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试（`if` 语句）结合使用的语法如下：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This tells PHP to *first* increment the value of `$x` and then to test whether
    it has the value `10` and, if it does, to output its value. But you can also require
    PHP to increment (or, as in the following example, decrement) a variable *after*
    it has tested the value, like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 PHP *首先* 递增 `$x` 的值，然后测试它是否为 `10`，如果是，则输出其值。但是你也可以要求 PHP 在测试值之后（或者，如下例中，递减）递增变量的值，就像这样：
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'which gives a subtly different result. Suppose `$y` starts out as `0` before
    the statement is executed. The comparison will return a `TRUE` result, but `$y`
    will be set to `–1` after the comparison is made. So what will the `echo` statement
    display: `0` or `–1`? Try to guess, and then try out the statement in a PHP processor
    to confirm. Because this combination of statements is confusing, it should be
    taken as just an educational example and not as a guide to good programming style.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这给出了一个略有不同的结果。假设 `$y` 在执行该语句之前初始值为 `0`。比较将返回一个 `TRUE` 结果，但是在进行比较后，`$y` 将被设置为
    `-1`。那么 `echo` 语句会显示 `0` 还是 `-1`？试着猜一下，然后在 PHP 处理器中尝试这个语句以确认。因为这些语句的组合很令人困惑，应该只作为教育例子而不是良好编程风格的指南。
- en: In short, a variable is incremented or decremented before the test if the operator
    is placed before the variable, whereas the variable is incremented or decremented
    after the test if the operator is placed after the variable.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，如果运算符放在变量之前，则变量在测试之前被递增或递减，而如果运算符放在变量之后，则变量在测试之后被递增或递减。
- en: By the way, the correct answer to the previous question is that the `echo` statement
    will display the result `–1`, because `$y` was decremented right after it was
    accessed in the `if` statement, and before the `echo` statement.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，前面问题的正确答案是 `echo` 语句将显示结果 `–1`，因为 `$y` 在 `if` 语句中被访问后立即递减，然后在 `echo` 语句之前。
- en: String concatenation
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串连接
- en: '*Concatenation* is a somewhat arcane term for putting something after another
    thing. So, string concatenation uses the period (`.`) to append one string of
    characters to another. The simplest way to do this is as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '*连接* 是一个有些古怪的术语，用于将某物放在另一物后面。因此，字符串连接使用句点（`.`）将一个字符串附加到另一个字符串。这样做的最简单方法如下：'
- en: '[PRE34]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Assuming that the variable `$msgs` is set to the value `5`, the output from
    this line of code will be the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设变量 `$msgs` 被设置为值 `5`，那么这行代码的输出将是：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Just as you can add a value to a numeric variable with the `+=` operator, you
    can append one string to another using `.=`, like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用 `+=` 运算符向数字变量添加值一样，你可以使用 `.=` 将一个字符串附加到另一个字符串上，像这样：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this case, if `$bulletin` contains a news bulletin and `$newsflash` has a
    news flash, the command appends the news flash to the news bulletin so that `$bulletin`
    now comprises both strings of text.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果 `$bulletin` 包含新闻公告，而 `$newsflash` 包含新闻快讯，这条命令将新闻快讯附加到新闻公告中，使得 `$bulletin`
    现在包含了两个文本字符串。
- en: String types
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串类型
- en: 'PHP supports two types of strings that are denoted by the type of quotation
    mark that you use. If you wish to assign a literal string, preserving the exact
    contents, you should use single quotation marks (apostrophes), like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 支持两种类型的字符串，根据你使用的引号类型来表示。如果你希望赋值一个字面字符串，保留其确切内容，你应该使用单引号（撇号），像这样：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case, every character within the single-quoted string is assigned to
    `$info`. If you had used double quotes, PHP would have attempted to evaluate `$variable`
    as a variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，单引号字符串中的每个字符都被赋值给 `$info`。如果你使用了双引号，PHP 将尝试将 `$variable` 解析为一个变量。
- en: 'On the other hand, when you want to include the value of a variable inside
    a string, you do so by using double-quoted strings:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当你想在字符串中包含变量的值时，你可以使用双引号字符串：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you will realize, this syntax also offers a simpler option to concatenation
    in which you don’t need to use a period, or close and reopen quotes, to append
    one string to another. This is called *variable substitution*, and some programmers
    use it extensively, whereas others don’t use it at all.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将会意识到的，这种语法还提供了一个更简单的选项，用于连接字符串而无需使用句点或关闭和重新打开引号来附加一个字符串到另一个字符串上。这称为 *变量替换*，一些程序员广泛使用它，而其他人则根本不使用它。
- en: Escaping characters
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 转义字符
- en: 'Sometimes a string needs to contain characters with special meanings that might
    be interpreted incorrectly. For example, the following line of code will not work,
    because the second quotation mark encountered in the word *spelling’s* will tell
    the PHP parser that the string’s end has been reached. Consequently, the rest
    of the line will be rejected as an error:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时字符串需要包含具有特殊含义的字符，这些字符可能会被错误地解释。例如，以下代码行将无法工作，因为在 *spelling’s* 中遇到的第二个引号告诉
    PHP 解析器字符串已经结束。因此，剩余的部分将被拒绝作为错误：
- en: '[PRE39]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To correct this, you can add a backslash directly before the offending quotation
    mark to tell PHP to treat the character literally and not to interpret it:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要纠正这个问题，你可以直接在有问题的引号前加上反斜杠，告诉 PHP 将该字符视为字面量，而不解释它：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And you can perform this trick in almost all situations in which PHP would
    otherwise return an error by trying to interpret a character. For example, the
    following double-quoted string will be correctly assigned:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 PHP 几乎所有可能导致解释字符错误的情况下使用这个技巧。例如，以下双引号字符串将被正确赋值：
- en: '[PRE41]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Additionally, you can use escape characters to insert various special characters
    into strings, such as tabs, newlines, and carriage returns. These are represented,
    as you might guess, by `\t`, `\n`, and `\r`. Here is an example using tabs to
    lay out a heading—it is included here merely to illustrate escapes, because in
    web pages there are always better ways to do layout:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以使用转义字符插入各种特殊字符到字符串中，如制表符、换行符和回车符。你可能猜到，它们分别用 `\t`、`\n` 和 `\r` 表示。这里有一个使用制表符布局标题的示例—这仅用于说明转义，因为在网页中总有更好的布局方式：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: These special backslash-preceded characters work only in double-quoted strings.
    In single-quoted strings, the preceding string would be displayed with the ugly
    `\t` sequences instead of tabs. Within single-quoted strings, only the escaped
    apostrophe (`\'`) and escaped backslash itself (`\\`) are recognized as escaped
    characters.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些特殊的反斜杠前缀字符只在双引号包围的字符串中起作用。在单引号包围的字符串中，前面的字符串将显示为丑陋的`\t`序列而不是制表符。在单引号包围的字符串中，只有转义的撇号（`\'`）和转义的反斜杠本身（`\\`）被识别为转义字符。
- en: Multiline Commands
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多行命令
- en: There are times when you need to output quite a lot of text from PHP, and using
    several `echo` (or `print`) statements would be time-consuming and messy. To overcome
    this, PHP offers two conveniences. The first is just to put multiple lines between
    quotes, as in [Example 3-6](#multiline_string_echo_statement). Variables can also
    be assigned, as in [Example 3-7](#multiline_string_assignment).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要从PHP中输出大量文本，使用多个`echo`（或`print`）语句会耗时且混乱。为了解决这个问题，PHP提供了两个便利的方法。第一个是将多行放在引号中，如[示例 3-6](#multiline_string_echo_statement)所示。变量也可以像在[示例 3-7](#multiline_string_assignment)中那样赋值。
- en: Example 3-6\. A multiline string `echo` statement
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. 多行字符串`echo`语句
- en: '[PRE43]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Example 3-7\. A multiline string assignment
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. 多行字符串赋值
- en: '[PRE44]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: PHP also offers a multiline sequence using the `<<<` operator—commonly referred
    to as a *here-document* or *heredoc*—as a way of specifying a string literal,
    preserving the line breaks and other whitespace (including indentation) in the
    text. Its use can be seen in [Example 3-8](#alternative_multiline_echo_statement).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: PHP还提供了使用`<<<`运算符的多行序列——通常称为*here-document*或*heredoc*——作为指定字符串文字的一种方式，保留文本中的换行和其他空白（包括缩进）。其使用方法可以在[示例 3-8](#alternative_multiline_echo_statement)中看到。
- en: Example 3-8\. Alternative multiline `echo` statement
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. 替代的多行`echo`语句
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This code tells PHP to output everything between the two `_END` tags as if it
    were a double-quoted string (except that quotes in a heredoc do not need to be
    escaped). This means it’s possible, for example, for a developer to write entire
    sections of HTML directly into PHP code and then just replace specific dynamic
    parts with PHP variables.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码告诉PHP输出两个`_END`标签之间的所有内容，就好像它是一个双引号包围的字符串（但在heredoc中，引号不需要转义）。这意味着开发者可以直接在PHP代码中编写整个HTML部分，然后只需用PHP变量替换特定的动态部分。
- en: It is important to remember that the closing `_END;` *must* appear right at
    the start of a new line, and it must be the *only* thing on that line—not even
    a comment is allowed to be added after it (nor even a single space). Once you
    have closed a multiline block, you are free to use the same tag name again.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，关闭的`_END;` *必须* 出现在新行的开头，并且它必须是那一行中*唯一* 的内容—甚至不能在它后面添加注释（甚至是一个空格）。一旦你关闭了一个多行块，你可以自由地再次使用相同的标签名。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Remember: using the `<<<_END..._END;` heredoc construct, you don’t have to
    add `\n` linefeed characters to send a linefeed—just press Return and start a
    new line. Also, unlike in either a double-quote- or single-quote-delimited string,
    you are free to use all the single and double quotes you like within a heredoc,
    without escaping them by preceding them with a backslash (`\`).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：使用`<<<_END..._END;`这种heredoc结构时，你不需要添加`\n`换行符来换行，只需按回车键并开始新的一行。与双引号或单引号包围的字符串不同的是，在heredoc中，你可以自由地使用所有单引号和双引号，无需通过在它们前面加上反斜杠（`\`）进行转义。
- en: '[Example 3-9](#multiline_string_variable_assignment) shows how to use the same
    syntax to assign multiple lines to a variable.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-9](#multiline_string_variable_assignment)展示了如何使用相同的语法将多行赋值给一个变量。'
- en: Example 3-9\. A multiline string variable assignment
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. 多行字符串变量赋值
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The variable `$out` will then be populated with the contents between the two
    tags. If you were appending, rather than assigning, you could also have used `.=`
    in place of `=` to append the string to `$out`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`$out`将被填充为两个标签之间的内容。如果你是在追加而不是赋值，你也可以使用`.=`来将字符串追加到`$out`而不是使用`=`。
- en: Be careful not to place a semicolon directly after the first occurrence of `_END`,
    as that would terminate the multiline block before it had even started and cause
    a `Parse error` message.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 要小心不要在第一次出现的`_END`后面直接加上分号，因为这会在多行块甚至开始之前终止它，并导致`Parse error`消息。
- en: By the way, the `_END` tag is simply one I chose for these examples because
    it is unlikely to be used anywhere else in PHP code and is therefore unique. You
    can use any tag you like, such as `_SECTION1` or `_OUTPUT` and so on. Also, to
    help differentiate tags such as this from variables or functions, the general
    practice is to preface them with an underscore.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，`_END` 标签只是我为这些示例选择的一个，因为在 PHP 代码中不太可能使用它，因此是唯一的。你可以使用任何你喜欢的标签，比如 `_SECTION1`
    或 `_OUTPUT` 等等。此外，为了区分这样的标签和变量或函数，一般的做法是在它们之前加上一个下划线。
- en: Note
  id: totrans-242
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Laying out text over multiple lines is usually just a convenience to make your
    PHP code easier to read, because once it is displayed in a web page, HTML formatting
    rules take over and whitespace is suppressed (but `$author` in our example will
    still be replaced with the variable’s value).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本布置在多行上通常只是为了使你的 PHP 代码更易于阅读，因为一旦它在网页中显示，HTML 格式规则就接管了，空白会被抑制（但是在我们的例子中，`$author`
    仍然会被替换为变量的值）。
- en: So, for example, if you load these multiline output examples into a browser,
    they will *not* display over several lines, because all browsers treat newlines
    just like spaces. However, if you use the browser’s View Source feature, you will
    find that the newlines are correctly placed and that PHP preserved the line breaks.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，如果你将这些多行输出示例加载到浏览器中，它们将*不会*显示在几行上，因为所有浏览器都像对待空格一样对待换行符。但是，如果你使用浏览器的查看源代码功能，你会发现换行符被正确放置，PHP
    保留了换行符。
- en: Variable Typing
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量类型
- en: PHP is a loosely typed language. This means that variables do not have to be
    declared before they are used and that PHP always converts variables to the type
    required by their context when they are accessed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 是一种弱类型语言。这意味着变量在使用之前不必声明，并且 PHP 总是在访问时根据上下文需要的类型来转换变量。
- en: For example, you can create a multiple-digit number and extract the *n*th digit
    from it simply by assuming it to be a string. In [Example 3-10](#automatic_conversion_from_a_number_to_a),
    the numbers `12345` and `67890` are multiplied together, returning a result of
    `838102050`, which is then placed in the variable `$number`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以创建一个多位数，并通过假设它为字符串来提取它的第*n*位数字。在[示例 3-10](#automatic_conversion_from_a_number_to_a)中，数字`12345`和`67890`相乘，返回结果`838102050`，然后放入变量`$number`中。
- en: Example 3-10\. Automatic conversion from a number to a string
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. 数字自动转换为字符串
- en: '[PRE47]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: At the point of the assignment, `$number` is a numeric variable. But on the
    second line, a call is placed to the PHP function `substr`, which asks for one
    character to be returned from `$number`, starting at the fourth position (remember
    that PHP offsets start from zero). To do this, PHP turns `$number` into a nine-character
    string so that `substr` can access it and return the character, which in this
    case is `1`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在赋值点，`$number`是一个数值变量。但是在第二行，调用了 PHP 函数`substr`，它要求从`$number`中返回一个字符，从第四个位置开始（记住
    PHP 偏移从零开始）。为此，PHP 将`$number`转换为一个九个字符的字符串，以便`substr`可以访问并返回字符，而在本例中是`1`。
- en: The same goes for turning a string into a number, and so on. In [Example 3-11](#automatically_converting_a_string_to_a_n),
    the variable `$pi` is set to a string value, which is then automatically turned
    into a floating-point number in the third line by the equation for calculating
    a circle’s area, which outputs the value `78.5398175`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于将字符串转换为数字，等等。在[示例 3-11](#automatically_converting_a_string_to_a_n)中，变量`$pi`被设置为一个字符串值，然后通过计算圆的面积的方程，在第三行自动转换为浮点数，输出值`78.5398175`。
- en: Example 3-11\. Automatically converting a string to a number
  id: totrans-252
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-11\. 将字符串自动转换为数字
- en: '[PRE48]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In practice, what this all means is that you don’t have to worry too much about
    your variable types. Just assign them values that make sense to you, and PHP will
    convert them if necessary. Then, when you want to retrieve values, just ask for
    them—for example, with an `echo` statement, but do remember that sometimes automatic
    conversions do not operate quite as you might expect.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这一切的意思是你不必过于担心你的变量类型。只需给它们赋予对你来说有意义的值，PHP 将根据需要自动转换它们。然后，当你想检索值时，只需请求它们，例如，使用`echo`语句，但请记住，有时自动转换的操作可能不像你期望的那样运行。
- en: Constants
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常量
- en: '*Constants* are similar to variables, holding information to be accessed later,
    except that they are what they sound like—constant. In other words, once you have
    defined one, its value is set for the remainder of the program and cannot be altered.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*常量*与变量类似，用于保存稍后访问的信息，但它们就像它们听起来的那样——常量。换句话说，一旦定义了常量，其值在程序的其余部分设置，并且无法更改。'
- en: 'For example, you can use a constant to hold the location of your server root
    (the folder with the main files of your website). You would define such a constant
    like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用一个常量来保存服务器根目录的位置（网站主文件夹的位置）。你可以像这样定义这样一个常量：
- en: '[PRE49]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, to read the contents of the variable, you just refer to it like a regular
    variable (but it isn’t preceded by a dollar sign):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要读取变量的内容，只需像普通变量一样引用它（但不需要前面加上美元符号）：
- en: '[PRE50]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, whenever you need to run your PHP code on a different server with a different
    folder configuration, you have only a single line of code to change.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你需要在不同配置的服务器上运行你的 PHP 代码时，你只需要改变一行代码。
- en: Note
  id: totrans-262
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The main two things you have to remember about constants are that they must
    *not* be prefaced with a `$` (unlike regular variables) and that you can define
    them only using the `define` function.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 关于常量，你必须记住的两件主要事情是它们不应该以`$`开头（不像普通变量），并且只能使用`define`函数来定义它们。
- en: It is generally considered a good practice to use only uppercase letters for
    constant variable names, especially if other people will also read your code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通常被认为是一个良好的实践是只为常量变量名使用大写字母，特别是如果其他人也会阅读你的代码。
- en: Predefined Constants
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预定义常量
- en: PHP comes ready-made with dozens of predefined constants that you won’t generally
    use as a beginner. However, there are a few—known as the *magic constants*—that
    you will find useful. The names of the magic constants always have two underscores
    at the beginning and two at the end so that you won’t accidentally try to name
    one of your own constants with a name that is already taken. They are detailed
    in [Table 3-5](#phpapostrophes_magic_constants). The concepts referred to in the
    table will be introduced in future chapters.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 准备了几十个预定义的常量，作为初学者通常不会使用。然而，有一些被称为*魔术常量*，你会发现它们非常有用。魔术常量的名称总是以两个下划线开头和两个下划线结尾，这样你就不会意外地尝试使用已经被占用的名称来定义自己的常量。它们在
    [Table 3-5](#phpapostrophes_magic_constants) 中有详细介绍。表中提到的概念将在后续章节中介绍。
- en: Table 3-5\. PHP’s magic constants
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-5\. PHP 的魔术常量
- en: '| Magic constant | Description |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 魔术常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__LINE__` | The current line number of the file. |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `__LINE__` | 文件的当前行号。 |'
- en: '| `__FILE__` | The full path and filename of the file. If used inside an `include`,
    the name of the included file is returned. Some operating systems allow aliases
    for directories, called *symbolic links*; in `__FILE__` these are always changed
    to the actual directories. |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `__FILE__` | 文件的完整路径和文件名。如果在`include`中使用，则返回被包含文件的文件名。一些操作系统允许目录的别名，称为*符号链接*；在
    `__FILE__` 中，这些始终会被更改为实际的目录。 |'
- en: '| `__DIR__` | The directory of the file. If used inside an `include`, the directory
    of the included file is returned. This is equivalent to *`dirname`*`(__FILE__)`.
    This directory name does not have a trailing slash unless it is the root directory.
    |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `__DIR__` | 文件所在的目录。如果在`include`中使用，返回被包含文件的目录。这相当于*`dirname`*`(__FILE__)`。这个目录名没有尾随的斜杠，除非它是根目录。
    |'
- en: '| `__FUNCTION__` | The function name. Returns the function name as it was declared
    (case-sensitive). In PHP 4, its value is always lowercase. |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `__FUNCTION__` | 函数名。以声明时的大小写形式返回函数名。在 PHP 4 中，其值始终是小写的。 |'
- en: '| `__CLASS__` | The class name. Returns the class name as it was declared (case-sensitive).
    In PHP 4, its value is always lowercase. |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `__CLASS__` | 类名。以声明时的大小写形式返回类名。在 PHP 4 中，其值始终是小写的。 |'
- en: '| `__METHOD__` | The class method name. The method name is returned as it was
    declared (case-sensitive). |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `__METHOD__` | 类方法名。方法名将以声明时的大小写形式返回。 |'
- en: '| `__NAMESPACE__` | The name of the current namespace. This constant is defined
    at compile time (case-sensitive). |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `__NAMESPACE__` | 当前命名空间的名称。此常量在编译时定义（区分大小写）。 |'
- en: 'One handy use of these variables is for debugging, when you need to insert
    a line of code to see whether the program flow reaches it:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量的一个方便用法是调试时，当你需要插入一行代码以查看程序流是否到达它：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This prints the current program line in the current file (including the path)
    to the web browser.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将当前文件中的当前程序行（包括路径）打印到 Web 浏览器。
- en: The Difference Between the echo and print Commands
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: echo和print命令之间的区别
- en: So far, you have seen the `echo` command used in a number of different ways
    to output text from the server to your browser. In some cases, a string literal
    has been output. In others, strings have first been concatenated or variables
    have been evaluated. I’ve also shown output spread over multiple lines.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经看到了`echo`命令在多种不同方式下从服务器向浏览器输出文本。在某些情况下，已输出字符串文字。在其他情况下，首先连接字符串或评估变量。我还展示了分布在多行的输出。
- en: 'But there is an alternative to `echo` that you can use: `print`. The two commands
    are quite similar, but `print` is a function-like construct that takes a single
    parameter and has a return value (which is always `1`), whereas `echo` is purely
    a PHP language construct. Since both commands are constructs, neither requires
    parentheses.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一种可以使用的`echo`替代方案：`print`。这两个命令非常相似，但`print`是一个类似函数的结构，接受一个参数并返回一个值（始终为`1`），而`echo`纯粹是PHP语言的构造。由于这两个命令都是构造，所以都不需要括号。
- en: 'By and large, the `echo` command usually will be a tad faster than `print`,
    because it doesn’t set a return value. On the other hand, because it isn’t implemented
    like a function, `echo` cannot be used as part of a more complex expression, whereas
    `print` can. Here’s an example to output whether the value of a variable is `TRUE`
    or `FALSE` using `print`—something you could not perform in the same manner with
    `echo`, because it would display a `Parse error` message:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`echo`命令通常比`print`命令稍快一点，因为它不设置返回值。另一方面，由于它不像函数实现，`echo`不能作为更复杂表达式的一部分使用，而`print`可以。下面是一个使用`print`输出变量值为`TRUE`或`FALSE`的示例——使用`echo`无法以同样的方式执行，因为它将显示`Parse
    error`消息：
- en: '[PRE52]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The question mark is simply a way of interrogating whether variable `$b` is
    `TRUE` or `FALSE`. Whichever command is on the left of the following colon is
    executed if `$b` is `TRUE`, whereas the command to the right of the colon is executed
    if `$b` is `FALSE`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 问号仅仅是一种询问变量`$b`是否为`TRUE`或`FALSE`的方法。如果`$b`为`TRUE`，则执行冒号后面左侧的命令，而如果`$b`为`FALSE`，则执行冒号后面右侧的命令。
- en: Generally, though, the examples in this book use `echo`, and I recommend that
    you do so as well until you reach such a point in your PHP development that you
    discover the need for using `print`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，本书中的示例通常使用`echo`，我建议您在PHP开发中达到需要使用`print`的阶段之前也这样做。
- en: Functions
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: '*Functions* separate sections of code that perform a particular task. For example,
    maybe you often need to look up a date and return it in a certain format. That
    would be a good example to turn into a function. The code doing it might be only
    three lines long, but if you have to paste it into your program a dozen times,
    you’re making your program unnecessarily large and complex if you don’t use a
    function. And if you decide to change the date format later, putting it in a function
    means having to change it in only one place.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '*函数*分离执行特定任务的代码部分。例如，也许您经常需要查找日期并以特定格式返回。这将是一个将其转换为函数的好例子。执行此操作的代码可能只有三行，但如果您不使用函数，则不得不在程序中粘贴它十几次，这将使您的程序变得不必要地庞大和复杂。而且，如果以后决定更改日期格式，将其放在函数中意味着只需更改一个地方。'
- en: Placing code into a function not only shortens your program and makes it more
    readable but also adds extra functionality (pun intended), because functions can
    be passed parameters to make them perform differently. They can also return values
    to the calling code.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码放入函数中不仅可以缩短程序并提高可读性，还可以增加额外的功能（双关语），因为函数可以接受参数以使其执行不同的操作。它们还可以将值返回给调用代码。
- en: To create a function, declare it in the manner shown in [Example 3-12](#simple_function_declaration).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建函数，请按照[示例 3-12](#simple_function_declaration)中所示的方式声明它。
- en: Example 3-12\. A simple function declaration
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-12\. 一个简单的函数声明
- en: '[PRE53]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This function returns a date in the format *Friday May 2nd 2025*. Any number
    of parameters can be passed between the initial parentheses; we have chosen to
    accept just one. The curly braces enclose all the code that is executed when you
    later call the function. Note that the first letter within the `date` function
    call in this example is a lowercase letter L, not to be confused with the number
    1.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数以*2025年5月2日星期五*的格式返回日期。初始括号之间可以传递任意数量的参数；我们选择只接受一个。花括号包围后续调用该函数时执行的所有代码。请注意，在此示例中`date`函数调用中的第一个字母是小写字母L，不要与数字1混淆。
- en: 'To output today’s date using this function, place the following call in your
    code:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个函数输出今天的日期，请在你的代码中放置以下调用：
- en: '[PRE54]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If you need to print out the date 17 days ago, you now just have to issue the
    following call:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要打印出17天前的日期，现在只需要发出以下调用：
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: which passes to `longdate` the current time less the number of seconds since
    17 days ago (17 days × 24 hours × 60 minutes × 60 seconds).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 它传递给`longdate`当前时间减去17天前的秒数（17天 × 24小时 × 60分钟 × 60秒）。
- en: Functions can also accept multiple parameters and return multiple results, using
    techniques that I’ll introduce over the following chapters.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以接受多个参数并返回多个结果，使用我将在接下来的章节中介绍的技术。
- en: Variable Scope
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域
- en: If you have a very long program, it’s quite possible that you could start to
    run out of good variable names, but with PHP you can decide the *scope* of a variable.
    In other words, you can, for example, tell it that you want the variable `$temp`
    to be used only inside a particular function and to forget it was ever used when
    the function returns. In fact, this is the default scope for PHP variables.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个非常长的程序，很可能你会开始用尽好的变量名，但是在PHP中你可以决定变量的*作用域*。换句话说，你可以告诉它你想要变量`$temp`仅在特定函数内部使用，并在函数返回时忘记它曾经被使用过。事实上，这是PHP变量的默认作用域。
- en: Alternatively, you could inform PHP that a variable is global in scope and thus
    can be accessed by every other part of your program.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以告诉PHP一个变量的作用域是全局的，因此可以被程序中的任何其他部分访问。
- en: Local variables
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部变量
- en: '*Local variables* are variables that are created within, and can be accessed
    only by, a function. They are generally temporary variables that are used to store
    partially processed results prior to the function’s return.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*局部变量*是仅在函数内部创建并且只能被函数访问的变量。它们通常是临时变量，用于存储函数返回之前部分处理的结果。'
- en: One set of local variables is the list of arguments to a function. In the previous
    section, we defined a function that accepted a parameter named `$timestamp`. This
    is meaningful only in the body of the function; you can’t get or set its value
    outside the function.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一组局部变量是函数的参数列表。在前一节中，我们定义了一个接受名为`$timestamp`参数的函数。这仅在函数体中有意义；你不能在函数外部获取或设置它的值。
- en: For another example of a local variable, take another look at the `longdate`
    function, which is modified slightly in [Example 3-13](#expanded_version_of_the_longdate_func).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于局部变量的另一个例子，请再看一下稍微修改过的`longdate`函数，在[示例 3-13](#expanded_version_of_the_longdate_func)中。
- en: Example 3-13\. An expanded version of the `longdate` function
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-13。`longdate`函数的扩展版本
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here we have assigned the value returned by the `date` function to the temporary
    variable `$temp`, which is then inserted into the string returned by the function.
    As soon as the function returns, the `$temp` variable and its contents disappear,
    as if they had never been used at all.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`date`函数返回的值赋给临时变量`$temp`，然后将其插入到函数返回的字符串中。一旦函数返回，`$temp`变量及其内容就会消失，就像它们从未被使用过一样。
- en: Now, to see the effects of variable scope, let’s look at some similar code in
    [Example 3-14](#this_attempt_to_access_dollartemp_in_fun). Here `$temp` has been
    created *before* we call the `longdate` function.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了看到变量作用域的影响，让我们看一些类似的代码，如[示例 3-14](#this_attempt_to_access_dollartemp_in_fun)。在这里，`$temp`在调用`longdate`函数之前被创建。
- en: Example 3-14\. This attempt to access `$temp` in function `longdate` will fail
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例3-14。试图在函数`longdate`中访问`$temp`将失败
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'However, because `$temp` was neither created within the `longdate` function
    nor passed to it as a parameter, `longdate` cannot access it. Therefore, this
    code snippet outputs only the date, not the preceding text. In fact, depending
    on how PHP is configured, it may first display the error message `Notice: Undefined
    variable: temp`, something you don’t want your users to see.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，因为`$temp`既不是在`longdate`函数内创建的，也没有作为参数传递给它，所以`longdate`无法访问它。因此，这段代码仅输出日期，而不是前面的文本。事实上，根据PHP的配置方式，它可能首先显示错误消息`Notice:
    Undefined variable: temp`，这是你不希望用户看到的。'
- en: The reason for this is that, by default, variables created within a function
    are local to that function, and variables created outside of any functions can
    be accessed only by nonfunction code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，默认情况下，函数内创建的变量仅在该函数内部可用，而在任何函数之外创建的变量只能被非函数代码访问。
- en: Some ways to repair [Example 3-14](#this_attempt_to_access_dollartemp_in_fun)
    appear in Examples [3-15](#rewriting_to_refer_to_dollartemp_within) and [3-16](#alternative_solution_passing_dollarte).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 修复 [示例 3-14](#this_attempt_to_access_dollartemp_in_fun) 的一些方法出现在示例 [3-15](#rewriting_to_refer_to_dollartemp_within)
    和 [3-16](#alternative_solution_passing_dollarte) 中。
- en: Example 3-15\. Rewriting to refer to `$temp` within its local scope fixes the
    problem
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-15\. 重新编写以在其本地作用域内引用 `$temp` 修复了问题
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[Example 3-15](#rewriting_to_refer_to_dollartemp_within) moves the reference
    to `$temp` out of the function. The reference appears in the same scope where
    the variable was defined.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-15](#rewriting_to_refer_to_dollartemp_within) 将对 `$temp` 的引用移出函数。引用出现在变量定义的同一作用域内。'
- en: 'Example 3-16\. An alternative solution: passing `$temp` as an argument'
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-16\. 另一种解决方案：将 `$temp` 作为参数传递
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The solution in [Example 3-16](#alternative_solution_passing_dollarte) passes
    `$temp` to the `longdate` function as an extra argument. `longdate` reads it into
    a temporary variable that it creates called `$text` and outputs the desired result.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-16](#alternative_solution_passing_dollarte) 中的解决方案将 `$temp` 作为额外参数传递给
    `longdate` 函数。`longdate` 函数将其读入一个临时变量 `$text` 中，并输出所需的结果。'
- en: Note
  id: totrans-322
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Forgetting the scope of a variable is a common programming error, so remembering
    how variable scope works will help you debug some quite obscure problems. Suffice
    it to say that unless you have declared a variable otherwise, its scope is limited
    to being local: either to the current function, or to the code outside of any
    functions, depending on whether it was first created or accessed inside or outside
    a function.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 忘记变量作用域是一个常见的编程错误，所以记住变量作用域是如何工作的将有助于你调试一些非常晦涩的问题。可以说，除非你另有声明，否则变量的作用域仅限于局部：要么是当前函数内，要么是在任何函数外的代码中，这取决于它是在函数内首次创建还是访问。
- en: Global variables
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局变量
- en: There are cases when you need a variable to have *global* scope, because you
    want all your code to be able to access it. Also, some data may be large and complex,
    and you don’t want to keep passing it as arguments to functions.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你需要一个具有*全局*范围的变量，因为你希望所有的代码都能访问它。此外，有些数据可能又大又复杂，你不想把它作为函数的参数来回传递。
- en: 'To access variables from global scope, add the keyword `global`. Let’s assume
    that you have a way of logging your users in to your website and want all your
    code to know whether it is interacting with a logged-in user or a guest. One way
    to do this is to use the `global` keyword before a variable, such as `$is_logged_in`:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要从全局作用域访问变量，需添加关键字 `global`。假设你有一种方法将用户登录到网站，并希望所有代码都知道它是与已登录用户还是访客进行交互。一种方法是在变量前使用
    `global` 关键字，如 `$is_logged_in`：
- en: '[PRE60]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Now your login function simply has to set that variable to `1` upon a successful
    login attempt or `0` upon failure. Because the scope of the variable is set to
    global, every line of code in your program can access it.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的登录函数只需在成功登录尝试时将该变量设置为 `1`，失败时设置为 `0`。由于变量的作用域设置为全局，你程序中的每一行代码都可以访问它。
- en: You should use variables given global access with caution, though. I recommend
    that you create them only when you absolutely cannot find another way of achieving
    the result you desire. In general, programs that are broken into small parts and
    segregated data are less buggy and easier to maintain. If you have a thousand-line
    program (and some day you will) in which you discover that a global variable has
    the wrong value at some point, how long will it take you to find the code that
    set it incorrectly?
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你应该谨慎使用给予全局访问权限的变量。我建议只有在完全找不到其他实现结果的方法时才创建它们。通常，将程序分成小部分并隔离数据会减少 bug 并更容易维护。如果你有一个千行的程序（总有一天你会有这样的程序），发现某个全局变量在某个时刻有错误的值，你将需要多长时间才能找到设置它错误的代码？
- en: Also, if you have too many variables with global scope, you run the risk of
    using one of those names again locally, or at least thinking you have used it
    locally, when in fact it has already been declared as global. All manner of strange
    bugs can arise from such situations.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你有太多全局作用域的变量，你就有可能在本地再次使用其中的一个变量名，或者至少认为你已经在本地使用过它，实际上它已经声明为全局。这种情况可能导致各种奇怪的
    bug。
- en: Note
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I generally adopt the convention of making all variable names that require global
    access uppercase (just as it’s recommended that constants should be uppercase)
    so that I can see at a glance the scope of a variable.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常采用所有需要全局访问的变量名大写的约定（就像建议将常量设为大写一样），这样我一眼就能看到变量的作用域。
- en: Static variables
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态变量
- en: In the section [“Local variables”](#local_variables), I mentioned that the value
    of a local variable is wiped out when the function ends. If a function runs many
    times, it starts with a fresh copy of the variable, and the previous setting has
    no effect.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在“本地变量”章节（#local_variables）中，我提到当函数结束时，局部变量的值将被清除。如果函数运行多次，它将以变量的新副本开始，并且先前的设置不会产生影响。
- en: Here’s an interesting case. What if you have a local variable inside a function
    that you don’t want any other parts of your code to have access to, but you would
    also like to keep its value for the next time the function is called? Why? Perhaps
    because you want a counter to track how many times a function is called. The solution
    is to declare a *static* variable, as shown in [Example 3-17](#function_using_a_static_variable).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的案例。如果您在函数内部有一个局部变量，不希望代码的其他部分访问它，但又希望保留其值以供下次调用函数时使用怎么办？为什么？也许是因为您想要一个计数器来跟踪函数调用的次数。解决方案是声明一个
    *静态* 变量，如 [示例 3-17](#function_using_a_static_variable) 所示。
- en: Example 3-17\. A function using a static variable
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-17\. 使用静态变量的函数
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Here, the very first line of the function `test` creates a static variable called
    `$count` and initializes it to a value of `0`. The next line outputs the variable’s
    value; the final one increments it.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `test` 的第一行创建了一个名为 `$count` 的静态变量，并将其初始化为 `0`。下一行输出变量的值；最后一行增加变量的值。
- en: The next time the function is called, because `$count` has already been declared,
    the first line of the function is skipped. Then the previously incremented value
    of `$count` is displayed before the variable is again incremented.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 下次调用该函数时，由于 `$count` 已经声明，函数的第一行将被跳过。然后显示 `$count` 先前增加的值，然后再次增加变量。
- en: If you plan to use static variables, you should note that you cannot assign
    the result of an expression in their definitions. They can be initialized only
    with predetermined values (see [Example 3-18](#allowed_and_disallowed_static_variable_d)).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划使用静态变量，应注意不能在定义中分配表达式的结果。它们只能用预定义的值初始化（参见 [示例 3-18](#allowed_and_disallowed_static_variable_d)）。
- en: Example 3-18\. Allowed and disallowed static variable declarations
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-18\. 允许和不允许的静态变量声明
- en: '[PRE62]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Superglobal variables
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超全局变量
- en: Starting with PHP 4.1.0, several predefined variables are available. These are
    known as *superglobal variables*, which means that they are provided by the PHP
    environment but are global within the program, accessible absolutely everywhere.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 从 PHP 4.1.0 开始，几个预定义变量可用。它们被称为 *超全局变量*，这意味着它们由 PHP 环境提供，但在程序中是全局的，可在任何地方访问。
- en: These superglobals contain lots of useful information about the currently running
    program and its environment (see [Table 3-6](#phpapostrophes_superglobal_variables)).
    They are structured as associative arrays, a topic discussed in [Chapter 6](ch06.xhtml#php_arrays).
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这些超全局变量包含关于当前运行程序及其环境的大量有用信息（见 [表 3-6](#phpapostrophes_superglobal_variables)）。它们结构化为关联数组，这是第
    6 章讨论的主题（参见 [第 6 章](ch06.xhtml#php_arrays)）。
- en: Table 3-6\. PHP’s superglobal variables
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-6\. PHP 超全局变量
- en: '| Superglobal name | Contents |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| 超全局变量名称 | 内容 |'
- en: '| --- | --- |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$GLOBALS` | All variables that are currently defined in the global scope
    of the script. The variable names are the keys of the array. |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| `$GLOBALS` | 当前脚本全局范围内定义的所有变量。数组的键是变量名。 |'
- en: '| `$_SERVER` | Information such as headers, paths, and locations of scripts.
    The entries in this array are created by the web server, and there is no guarantee
    that every web server will provide any or all of these. |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| `$_SERVER` | 包含头信息、路径和脚本位置等信息。此数组的条目由 Web 服务器创建，并不能保证每个 Web 服务器都提供所有或部分条目。
    |'
- en: '| `$_GET` | Variables passed to the current script via the HTTP GET method.
    |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| `$_GET` | 通过 HTTP GET 方法传递给当前脚本的变量。 |'
- en: '| `$_POST` | Variables passed to the current script via the HTTP POST method.
    |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| `$_POST` | 通过 HTTP POST 方法传递给当前脚本的变量。 |'
- en: '| `$_FILES` | Items uploaded to the current script via the HTTP POST method.
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| `$_FILES` | 通过 HTTP POST 方法上传到当前脚本的项目。 |'
- en: '| `$_COOKIE` | Variables passed to the current script via HTTP cookies. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `$_COOKIE` | 通过 HTTP cookie 传递给当前脚本的变量。 |'
- en: '| `$_SESSION` | Session variables available to the current script. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `$_SESSION` | 当前脚本可用的会话变量。 |'
- en: '| `$_REQUEST` | Contents of information passed from the browser; by default,
    `$_GET`, `$_POST`, and `$_COOKIE`. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `$_REQUEST` | 浏览器传递的信息的内容；默认包括 `$_GET`、`$_POST` 和 `$_COOKIE`。 |'
- en: '| `$_ENV` | Variables passed to the current script via the environment method.
    |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `$_ENV` | 通过环境方法传递给当前脚本的变量。 |'
- en: All of the superglobals (except for `$GLOBALS`) are named with a single initial
    underscore and only capital letters; therefore, you should avoid naming your own
    variables in this manner to avoid potential confusion.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 所有超全局变量（除了`$GLOBALS`）都以单个下划线和大写字母命名；因此，应避免以此方式命名您自己的变量，以避免潜在的混淆。
- en: 'To illustrate how you use them, let’s look at a common example. Among the many
    nuggets of information supplied by superglobal variables is the URL of the page
    that referred the user to the current web page. This referring page information
    can be accessed like this:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明您如何使用它们，让我们看一个常见的例子。超全局变量提供的众多信息中，有一个是指向当前网页的引用页面的URL。可以这样访问这些引用页面信息：
- en: '[PRE63]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: It’s that simple. Oh, and if the user came straight to your web page, such as
    by typing its URL directly into a browser, `$came_from` will be set to an empty
    string.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。哦，如果用户直接访问您的网页，比如直接在浏览器中输入其URL，那么`$came_from`将被设置为空字符串。
- en: Superglobals and security
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超全局变量和安全性
- en: A word of caution is in order before you start using superglobal variables,
    because they are often used by hackers trying to find exploits to break into your
    website. What they do is load up `$_POST`, `$_GET`, or other superglobals with
    malicious code, such as Unix or MySQL commands that can damage or display sensitive
    data if you naively access them.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开始使用超全局变量之前，需要注意一点，因为黑客经常利用它们来寻找可能破坏您网站的漏洞。他们会通过加载`$_POST`、`$_GET`或其他超全局变量来注入恶意代码，如Unix或MySQL命令，如果您天真地访问它们，可能会导致损坏或显示敏感数据。
- en: Therefore, you should always sanitize superglobals before using them. One way
    to do this is via the PHP `htmlentities` function. It converts all characters
    into HTML entities. For example, less-than and greater-than characters (`<` and
    `>`) are transformed into the strings `&lt;` and `&gt;` so that they are rendered
    harmless, as are all quotes and backslashes, and so on.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在使用它们之前，您应始终对超全局变量进行清理。通过PHP的`htmlentities`函数是一种方法。它将所有字符转换为HTML实体。例如，小于号和大于号（`<`和`>`）被转换为字符串`&lt;`和`&gt;`，这样它们就变得无害了，所有的引号和反斜杠等也是如此。
- en: 'Therefore, a much better way to access `$_SERVER` (and other superglobals)
    is:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，更好的访问`$_SERVER`（以及其他超全局变量）的方法是：
- en: '[PRE64]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Warning
  id: totrans-367
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Using the `htmlentities` function for sanitization is an important practice
    in any circumstance where user or other third-party data is being processed for
    output, not just with superglobals.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何需要处理用户或其他第三方数据以进行输出的情况下，使用`htmlentities`函数进行清理是一种重要的实践，而不仅仅是超全局变量。
- en: This chapter has provided you with a solid introduction to using PHP. In [Chapter 4](ch04.xhtml#expressions_and_control_flow_in_php),
    you’ll start using what you’ve learned to build expressions and control program
    flow—in other words, do some actual programming.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了使用PHP的坚实基础。在[第四章](ch04.xhtml#expressions_and_control_flow_in_php)中，你将开始运用所学内容来构建表达式和控制程序流程，换句话说，进行实际编程。
- en: But before moving on, I recommend that you test yourself with some (if not all)
    of the following questions to ensure that you have fully digested the contents
    of this chapter.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 但在继续之前，我建议你通过以下（如果可能的话，全部都做）问题来测试自己，确保你已经完全消化了本章的内容。
- en: Questions
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What tag is used to invoke PHP to start interpreting program code? And what
    is the short form of the tag?
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于启动PHP解释程序代码的标记是什么？它的简写形式是什么？
- en: What are the two types of comment tags?
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪两种类型的注释标签？
- en: Which character must be placed at the end of every PHP statement?
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个PHP语句的结尾必须放置哪个字符？
- en: Which symbol is used to preface all PHP variables?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个符号用于定义所有PHP变量的前缀？
- en: What can a variable store?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量可以存储什么？
- en: What is the difference between `$variable = 1` and `$variable == 1`?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$variable = 1`和`$variable == 1`之间有什么区别？'
- en: Why do you suppose that an underscore is allowed in variable names (`$current_user`),
    whereas hyphens are not (`$current-user`)?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么变量名允许使用下划线（`$current_user`），而不允许使用连字符（`$current-user`）？
- en: Are variable names case-sensitive?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量名区分大小写吗？
- en: Can you use spaces in variable names?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 变量名可以包含空格吗？
- en: How do you convert one variable type to another (say, a string to a number)?
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将一个变量类型转换为另一个变量类型（比如从字符串到数字）？
- en: What is the difference between `++$j` and `$j++`?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`++$j`和`$j++`之间有什么区别？'
- en: Are the operators `&&` and `and` interchangeable?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运算符`&&`和`and`可以互换使用吗？
- en: How can you create a multiline `echo` or assignment?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建多行的`echo`或赋值？
- en: Can you redefine a constant?
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 能重新定义一个常量吗？
- en: How do you escape a quotation mark?
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何转义引号？
- en: What is the difference between the `echo` and `print` commands?
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`echo` 和 `print` 命令有什么区别？'
- en: What is the purpose of functions?
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的目的是什么？
- en: How can you make a variable accessible to all parts of a PHP program?
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何使一个变量在 PHP 程序的所有部分都可访问？
- en: If you generate data within a function, what are a couple of ways to convey
    the data to the rest of the program?
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在函数内生成数据，有哪些方法可以将数据传递给程序的其余部分？
- en: What is the result of combining a string with a number?
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字符串和数字结合的结果是什么？
- en: See [“Chapter 3 Answers”](app01_split_002.xhtml#chapter_3_answers) in the [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions)
    for the answers to these questions.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[“第三章答案”](app01_split_002.xhtml#chapter_3_answers)，在[附录 A](app01_split_000.xhtml#solutions_to_the_chapter_questions)中找到这些问题的答案。
