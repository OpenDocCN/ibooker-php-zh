- en: Chapter 26\. The HTML5 Canvas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第26章 HTML5画布
- en: Although the collective term given to the new web technologies is *HTML5*, they
    are not all simply HTML tags and properties. Such is the case with the canvas
    element. Yes, you create a canvas by using the `<canvas>` tag, and maybe supply
    a width and height, and can modify it a little with CSS, but to actually write
    to (or read from) a canvas, you must use JavaScript.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然新网页技术的总称是*HTML5*，但它们并不全是简单的HTML标签和属性。canvas 元素就是一个例子。是的，你可以使用`<canvas>`标签创建一个画布，并且可能指定宽度和高度，并可以通过CSS进行一些修改，但要真正向画布写入（或从中读取），你必须使用JavaScript。
- en: Thankfully, the JavaScript you need to learn is minimal and very easy to implement,
    plus I’ve already provided you with a set of three ready-made functions in [Chapter 21](ch21.xhtml#accessing_css_from_javascript)
    (in the file *OSC.js*) to make accessing objects such as the canvas even more
    straightforward. So, let’s dive right in and start using the new `<canvas>` tag.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你需要学习的JavaScript内容很少，而且非常容易实现，而且我已经在[第21章](ch21.xhtml#accessing_css_from_javascript)（*OSC.js*文件中）提供了一套三个现成的函数，使得访问诸如canvas这样的对象更加简单。所以，让我们马上开始使用新的`<canvas>`标签。
- en: Creating and Accessing a Canvas
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和访问一个画布
- en: In [Chapter 25](ch25.xhtml#introduction_to_html5), I showed you how to draw
    a simple circle to display the Japanese flag, as reused here in [Example 26-1](#displaying_the_japanese_flag_using_a_can).
    Let’s now look at what exactly is going on here.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第25章](ch25.xhtml#introduction_to_html5)中，我向你展示了如何绘制一个简单的圆来展示日本国旗，本章中再次使用。现在让我们来看看这里到底发生了什么。
- en: Example 26-1\. Displaying the Japanese flag by using a canvas
  id: totrans-5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例26-1 通过使用canvas显示日本国旗
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, of course, the `<!DOCTYPE html>` declaration tells the browser that the
    document will use HTML5\. After this, a title is displayed and the three functions
    in the *OSC.js* file are loaded in.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`<!DOCTYPE html>`声明告诉浏览器文档将使用HTML5。接着，显示了一个标题，并加载了*OSC.js*文件中的三个函数。
- en: The body of the document defines a canvas element, gives it an ID of `mycanvas`,
    and gives it a width and height of 320 × 240 pixels. The text of the canvas, as
    explained in the previous chapter, will not appear in browsers that support the
    canvas element but will appear in older browsers that don’t.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 文档的主体定义了一个canvas元素，赋予其ID为`mycanvas`，并设置宽度和高度为320 × 240像素。如前一章节所述，canvas的文本在支持canvas元素的浏览器中不会显示，但在不支持canvas的老旧浏览器中会显示出来。
- en: This is followed by a section of JavaScript that styles and draws on the canvas.
    We begin by creating a `canvas` object by calling the `O` function on the canvas
    element. As you will recall, this calls the `document.getElementById` function
    and is therefore a much shorter way of referencing the element.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 接着是一段JavaScript代码，用于样式化和在画布上绘制。我们首先通过调用`O`函数在画布元素上创建一个`canvas`对象。正如你所记得的，这会调用`document.getElementById`函数，因此是引用元素的一种更简短的方式。
- en: 'This is all stuff you’ve seen before, but next comes something new:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是你以前见过的东西，但接下来是一些新内容：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command calls the `getContext` method of the new `canvas` object just created,
    requesting two-dimensional access to the canvas by passing the value `2d`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令调用新创建的`canvas`对象的`getContext`方法，通过传递值`2d`请求对画布进行二维访问。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to display 3D on a canvas, you can either do the math yourself and
    “fake” it in 2D, or you can use WebGL (which is based on OpenGL ES), in which
    case you would create a `context` for it by calling `canvas.getContext('webgl')`.
    There’s no room to cover the subject any further here, but you can find a great
    tutorial at [*https://webglfundamentals.org*](https://webglfundamentals.org).
    Alternatively, check out the [Three.jsJavaScript library](https://threejs.org)
    of 3D functions, which also uses WebGL.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在画布上显示3D效果，可以自己做数学运算，在2D中“伪造”它，或者可以使用基于OpenGL ES的WebGL，这种情况下你需要调用`canvas.getContext('webgl')`来为其创建一个`context`。这里没有更多的空间来进一步讨论这个主题，但你可以在[*https://webglfundamentals.org*](https://webglfundamentals.org)找到一个很棒的教程。或者，可以查看[Three.jsJavaScript库](https://threejs.org)，它也使用WebGL提供3D功能。
- en: 'Armed with this context in the object `context`, we prime the subsequent drawing
    commands by setting the `fillStyle` property of `context` to the value `red`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有了对象`context`中的这个上下文，我们通过将`context`的`fillStyle`属性设置为`red`来准备后续的绘图命令：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then the `S` function is called to set the `border` property of the canvas
    to a 1-pixel, solid black line to outline the flag image:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然后调用`S`函数来设置画布的`border`属性为1像素的实线黑色边框以勾勒出国旗图像：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With everything prepared, a path is opened on the context, and the drawing
    position is moved to the location (160, 120):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好一切后，在上下文中打开路径，并将绘图位置移动到位置（160，120）：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After that, an arc is drawn centered on that coordinate, with a radius of 70
    pixels, beginning at an angle of 0 degrees (which is the right-hand edge of the
    circle as you look at it) and continuing all the way around the circle in radians
    as determined by a value of 2 × π:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，在该坐标中心绘制一个圆弧，半径为 70 像素，从角度为 0 度（即圆的右边缘）开始，以 2 × π 确定的弧度继续绕圆周绘制：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The final value of `false` indicates a clockwise direction for drawing the arc;
    a value of `true` would indicate that the drawing should occur in a counterclockwise
    direction.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的 `false` 值指示顺时针方向绘制圆弧；`true` 值表示应以逆时针方向绘制。
- en: 'Finally, we close and fill the path, using the preselected value in the `fillStyle`
    property that we set to `red` a few lines earlier:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用预先设置为 `red` 的 `fillStyle` 属性来关闭并填充路径：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The result of loading this document into a web browser looks like [Figure 25-1](ch25.xhtml#drawing_the_japanese_flag_using_an_html5)
    in the previous chapter.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文档加载到网络浏览器中的结果类似于上一章节的[图 25-1](ch25.xhtml#drawing_the_japanese_flag_using_an_html5)。
- en: The toDataURL Function
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: toDataURL 函数
- en: After you have created an image in a canvas, you will sometimes want to make
    a copy of it, perhaps to repeat elsewhere on a web page, for animation purposes,
    to save to local storage, or to upload to a web server. This is particularly handy
    since users cannot use drag and drop to save a canvas image.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建画布中的图像后，有时您可能希望复制它，也许是为了在网页的其他地方重复使用，用于动画目的，保存到本地存储或上传到 Web 服务器。这尤其方便，因为用户无法使用拖放来保存画布图像。
- en: To illustrate how you do this, I have added a few lines of code to the previous
    example in [Example 26-2](#copying_a_canvas_image) (highlighted in bold). These
    create a new `<img>` element with the ID `myimage`, give it a solid black border,
    and then copy the canvas image into the `<img>` element (see [Figure 26-1](#image_on_the_right_is_copied_from_th)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何做到这一点，我在[示例 26-2](#copying_a_canvas_image)中添加了几行代码（用粗体标出）。这些代码创建了一个新的
    `<img>` 元素，带有 ID `myimage`，给它加上了一个纯黑色边框，然后将画布图像复制到 `<img>` 元素中（参见[图 26-1](#image_on_the_right_is_copied_from_th)）。
- en: Example 26-2\. Copying a canvas image
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-2\. 复制画布图像
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![The image on the right is copied from the left-hand canvas](Images/pmj6_2601.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![右侧图像是从左侧画布复制的](Images/pmj6_2601.png)'
- en: Figure 26-1\. The image on the right is copied from the left-hand canvas
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-1\. 右侧图像是从左侧画布复制的
- en: If you try this code for yourself, you will notice that although you cannot
    drag and drop the left-hand canvas image, you can do so with the right-hand picture,
    which you could also save to local storage or upload to a web server using the
    right JavaScript (and PHP on the server end).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您自己尝试此代码，您会注意到，尽管您不能拖放左侧画布图像，但您可以对右侧图片进行拖放，您还可以使用适当的 JavaScript（以及服务器端的 PHP）将其保存到本地存储或上传到
    Web 服务器。
- en: Specifying an Image Type
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定图像类型
- en: 'When creating an image from a canvas, you can specify the type of image you
    want as either JPEG (*.jpg* or *.jpeg* files) or PNG (*.png* files). The default
    is PNG (`image/png`), but should you need JPEG for some reason, you can alter
    the call to `toDataURL`. At the same time, you can also specify the amount of
    compression to use, between `0` (for lowest quality) and `1` (for highest quality).
    The following uses a compression value of `0.4` and should generate a reasonably
    good-looking image at a fairly low file size:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在从画布创建图像时，您可以指定要的图像类型，可以是 JPEG（*.jpg* 或 *.jpeg* 文件）或 PNG（*.png* 文件）。默认为 PNG（`image/png`），但如果有必要，您可以修改调用
    `toDataURL` 的方式。同时，您还可以指定要使用的压缩量，介于 `0`（最低质量）和 `1`（最高质量）之间。以下使用了压缩值 `0.4`，应生成一个外观合理且文件大小较小的图像：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Warning
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Remember that the `toDataURL` method applies to a `canvas` object, not to any
    context created from that object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，`toDataURL` 方法适用于 `canvas` 对象，而不适用于从该对象创建的任何上下文。
- en: Now that you know how to create canvas images and then copy or otherwise use
    them, it’s time to look at the drawing commands available, starting with rectangles.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何创建画布图像，然后复制或以其他方式使用它们，是时候看看可用的绘图命令了，首先是矩形。
- en: The fillRect Method
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fillRect 方法
- en: 'There are three different methods you can call for drawing rectangles, the
    first of which is `fillRect`. To use it, you simply supply the top-left coordinates
    of your rectangle, followed by the width and height in pixels, like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种不同的方法可以用来绘制矩形，第一种是`fillRect`。要使用它，只需提供矩形的左上角坐标，然后是宽度和高度（以像素为单位），像这样：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By default, the rectangle will be filled with black, but you can use any other
    color you like by first issuing a command such as the following, where the argument
    can be any acceptable CSS color, name, or value:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，矩形将填充为黑色，但你可以通过首先发出如下命令来使用任何其他你喜欢的颜色，其中参数可以是任何可接受的 CSS 颜色、名称或值：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The clearRect Method
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: clearRect 方法
- en: 'You can also draw a rectangle in which all the color values (red, green, blue,
    and alpha transparency) have been set to `0`, like in the following example, which
    uses the same order of coordinates and width and height arguments:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以绘制一个矩形，其中所有的颜色值（红色、绿色、蓝色和alpha透明度）都被设置为`0`，就像下面的例子一样，它使用了相同的坐标顺序和宽度高度参数：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the `clearRect` method is applied, the new clear rectangle will strip all
    color from the area it covers, leaving only any underlying CSS color that has
    been applied to the canvas element.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用了`clearRect`方法，新清除的矩形将从其覆盖的区域中除去所有颜色，只留下已应用到画布元素的任何底层 CSS 颜色。
- en: The strokeRect Method
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: strokeRect 方法
- en: 'When you want only an outlined rectangle, you can use a command such as the
    following, which will use the default of black or the currently selected stroke
    color:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只想要一个轮廓矩形时，你可以使用如下命令，它将使用黑色或当前选择的描边颜色的默认值：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To change the color used, you can first issue a command such as the following,
    supplying any valid CSS color argument:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变使用的颜色，你可以首先发出如下命令，提供任何有效的 CSS 颜色参数：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Combining These Commands
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合这些命令
- en: In [Example 26-3](#drawing_several_rectangles), the preceding rectangle-drawing
    commands have been combined to display the image shown in [Figure 26-2](#drawing_concentric_rectangles).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 26-3](#drawing_several_rectangles)中，前面的绘制矩形命令已经组合起来显示了[图 26-2](#drawing_concentric_rectangles)中显示的图像。
- en: Example 26-3\. Drawing several rectangles
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-3\. 绘制几个矩形
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Drawing concentric rectangles](Images/pmj6_2602.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![绘制同心矩形](Images/pmj6_2602.png)'
- en: Figure 26-2\. Drawing concentric rectangles
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-2\. 绘制同心矩形
- en: Later in this chapter, you’ll see how you can further modify the output by changing
    stroke types and widths—but first, let’s turn to modifying fills by applying gradients
    (which were introduced in [“Gradients”](ch19.xhtml#gradients) as part of CSS).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 本章后面，你将看到如何通过改变描边类型和宽度来进一步修改输出，但首先，让我们通过应用渐变（作为 CSS 的一部分，已经在[“渐变”](ch19.xhtml#gradients)中介绍过）来修改填充。
- en: The createLinearGradient Method
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: createLinearGradient 方法
- en: There are a couple of ways to apply a gradient to a fill but the simplest is
    with the `createLinearGradient` method. You specify start and end *x* and *y*
    coordinates relative to the canvas (not the object being filled). This allows
    for greater subtlety. For example, you can specify that a gradient begin at the
    far left and end at the far right of a canvas but apply it only within the area
    defined in a fill command, as shown in [Example 26-4](#applying_a_gradient_fill).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以对填充应用渐变，但最简单的方法是使用`createLinearGradient`方法。你可以指定相对于画布（而不是被填充对象）的起始和结束*x*和*y*坐标。这允许更加微妙的效果。例如，你可以指定渐变从画布的最左侧开始，到最右侧结束，但仅在填充命令定义的区域内应用，如[示例 26-4](#applying_a_gradient_fill)所示。
- en: Example 26-4\. Applying a gradient fill
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-4\. 应用渐变填充
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: For brevity and clarity in this and many of the following examples, only salient
    lines of code are shown. Complete examples with the surrounding HTML, setup, and
    other sections of code are available to freely download from [GitHub](https://github.com/RobinNixon/lpmj6).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁和清晰起见，在这个和许多后续示例中，只显示了代码的显著行。完整的例子，包括周围的 HTML、设置和其他代码部分，可以从[GitHub](https://github.com/RobinNixon/lpmj6)免费下载。
- en: In this example, we create a gradient fill object named `gradient` by making
    a call to the `createLinearGradient` method of the `context` object. The start
    position of (0, 80) is halfway down the left-hand canvas edge, while the end of
    (640, 80) is halfway down the right-hand edge.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过调用`context`对象的`createLinearGradient`方法创建了一个名为`gradient`的渐变填充对象。起始位置为（0,
    80），位于左侧画布边缘的中间位置，而结束位置为（640, 80），位于右侧边缘的中间位置。
- en: To create your gradient, determine the direction in which you want it to flow
    and then locate two points to represent the start and end. No matter what values
    you supply for these points, the gradient will smoothly transition in the direction
    given, even if the points are outside the fill area.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建您的渐变，确定您希望其流动的方向，然后找到两个点来表示开始和结束。无论您为这些点提供什么值，渐变都将平滑地过渡到给定的方向，即使这些点在填充区域之外。
- en: Next, a couple of color stops are provided to specify that the very first color
    of the gradient is white and the final color is black. The gradient will then
    transition smoothly between these colors across the canvas from left to right.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，提供了一对颜色停止，以指定渐变的第一个颜色是白色，最终颜色是黑色。然后，渐变将平滑地在画布上从左到右过渡这些颜色。
- en: With the `gradient` object now ready, it is applied to the `fillStyle` property
    of the `context` object so that the final `fillRect` call can use it. In this
    call, the fill is applied only in a central rectangular area of the canvas, so
    although the gradient goes from the far left to the far right of the canvas, the
    portion of it shown is only from 80 pixels in and down from the top-left corner,
    to a width of 480 and depth of 80 pixels. The result (when added to the previous
    example code) looks like [Figure 26-3](#central_rectangle_has_a_horizontal_g).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`gradient`对象已准备就绪，它被应用于`context`对象的`fillStyle`属性，以便最终的`fillRect`调用可以使用它。在此调用中，填充仅应用于画布的中心矩形区域，因此尽管渐变从画布的最左边延伸到最右边，但其显示的部分仅从左上角的80像素处开始，宽度为480像素，深度为80像素。结果（当添加到先前的示例代码中时）看起来像[图 26-3](#central_rectangle_has_a_horizontal_g)。
- en: '![The central rectangle has a horizontal gradient fill](Images/pmj6_2603.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![中央矩形具有水平渐变填充](Images/pmj6_2603.png)'
- en: Figure 26-3\. The central rectangle has a horizontal gradient fill
  id: totrans-73
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-3\. 中央矩形具有水平渐变填充
- en: By specifying different start and end coordinates for a gradient, you can make
    it slant in any direction, as demonstrated with [Example 26-5](#variety_of_gradients_at_different_angl)
    and shown in [Figure 26-4](#range_of_different_linear_gradients).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为渐变指定不同的起始和结束坐标，可以使其朝任何方向倾斜，正如[示例 26-5](#variety_of_gradients_at_different_angl)所演示的，并显示在[图 26-4](#range_of_different_linear_gradients)中。
- en: Example 26-5\. A variety of gradients at different angles and colors
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-5\. 不同角度和颜色的多种渐变
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![A range of different linear gradients](Images/pmj6_2604.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![不同线性渐变的范围](Images/pmj6_2604.png)'
- en: Figure 26-4\. A range of different linear gradients
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-4\. 不同线性渐变的范围
- en: In this example, I chose to place the gradients directly on top of the areas
    to be filled to more clearly show the maximum variation in color from start to
    end.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我选择直接将渐变放置在要填充的区域上方，以更清楚地显示从起始到结束的颜色最大变化。
- en: The addColorStop Method in Detail
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 详细介绍addColorStop方法
- en: You can use as many color stops in a gradient as you like, not just the two
    start and end colors used so far in these examples. This makes it possible to
    clearly describe almost any type of gradient effect you can imagine. To do this,
    you must specify the percent of the gradient that each color should take up, by
    allocating a floating-point start position along the gradient range between `0`
    and `1`. You do not enter a color’s end position, because it is deduced from the
    start position of the next color stop, or the gradient end if the position is
    the last one you specify.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在渐变中使用任意数量的颜色停止，不仅限于这些示例中到目前为止使用的两种起始和结束颜色。这使得几乎可以描述您可以想象到的任何类型的渐变效果。为此，必须指定每种颜色在渐变中所占百分比的浮点起始位置，分配在`0`到`1`之间的渐变范围内。您不输入颜色的结束位置，因为它是从下一个颜色停止的起始位置推导出来的，或者是您指定的最后一个位置的渐变结束。
- en: In the preceding examples, only the two start and end values were chosen, but
    to create a rainbow effect, you could set up your color stops as shown in [Example 26-6](#adding_multiple_color_stops)
    (displayed in [Figure 26-5](#rainbow_effect_with_seven_stop_colors)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，仅选择了两个起始和结束值，但要创建彩虹效果，您可以设置如[示例 26-6](#adding_multiple_color_stops)所示的颜色停止，（显示在[图 26-5](#rainbow_effect_with_seven_stop_colors)中）。
- en: Example 26-6\. Adding multiple color stops
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-6\. 添加多个颜色停止
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![A rainbow effect with seven stop colors](Images/pmj6_2605.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![具有七个停止颜色的彩虹效果](Images/pmj6_2605.png)'
- en: Figure 26-5\. A rainbow effect with seven stop colors
  id: totrans-86
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-5\. 具有七个停止颜色的彩虹效果
- en: In [Example 26-6](#adding_multiple_color_stops), all the colors are spaced roughly
    equidistantly (with each color given 14% of the gradient and the final one 16),
    but you don’t have to stick to that; you can squish several colors near each other,
    while spacing others out. It’s entirely up to you how many colors you use and
    where in the gradient they start and end.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 26-6](#adding_multiple_color_stops) 中，所有颜色大致等间距分布（每种颜色占渐变的14%，最后一种占16%），但您不必局限于此；您可以将几种颜色挤在一起，同时将其他颜色间隔开。您可以完全自由地选择使用多少种颜色以及它们在渐变中的起始和结束位置。
- en: The createRadialGradient Method
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: createRadialGradient 方法
- en: You aren’t restricted to only linear gradients in HTML; you can create radial
    gradients on a canvas too. It’s a little more complex than with a linear gradient
    but not much more so.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML中，您不仅限于线性渐变；您也可以在画布上创建径向渐变。虽然比线性渐变复杂一点，但也不多。
- en: What you need to do is pass the center location as a pair of *x* and *y* coordinates,
    along with a radius in pixels. These are used as the start of the gradient and
    outer circumference, respectively. Then you also pass another set of coordinates
    and a radius to specify the end of the gradient.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的是将中心位置作为一对*x*和*y*坐标传递，并且附带一个像素半径。这些被用作渐变的起始点和外部圆周。然后你还需要传递另一组坐标和半径来指定渐变的结束。
- en: So, for example, to create a gradient that simply starts at the center of a
    circle and then expands out, you could issue a command such as the one in [Example 26-7](#creating_a_radial_gradient)
    (displayed in [Figure 26-6](#centered_radial_gradient)). The coordinates for the
    start and end are the same, but the radius is `0` for the start and encompasses
    the entire gradient for the end.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，要创建一个简单从圆的中心开始然后扩展出去的渐变，您可以发出类似于 [示例 26-7](#creating_a_radial_gradient)
    中的命令（显示在 [Figure 26-6](#centered_radial_gradient) 中）。起始点和结束点的坐标相同，但起始点的半径为 `0`，结束点的半径则包含整个渐变。
- en: Example 26-7\. Creating a radial gradient
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-7\. 创建一个径向渐变
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![A centered radial gradient](Images/pmj6_2606.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![一个居中的径向渐变](Images/pmj6_2606.png)'
- en: Figure 26-6\. A centered radial gradient
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-6\. 一个居中的径向渐变
- en: Or you can be fancy and move the location of the start and end of a radial gradient,
    as in [Example 26-8](#stretching_a_radial_gradient) (and displayed in [Figure 26-7](#stretched_radial_gradient)),
    which starts centered on location (0, 120) with a radius of 0 pixels and ends
    centered at (480, 120) with a radius of 480 pixels.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可以花哨一些，移动径向渐变的起始点和结束点的位置，就像 [示例 26-8](#stretching_a_radial_gradient) 中所示（并显示在
    [Figure 26-7](#stretched_radial_gradient) 中），它从位置 (0, 120) 开始居中，半径为 0 像素，并以位置
    (480, 120) 结束，半径为 480 像素。
- en: Example 26-8\. Stretching a radial gradient
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-8\. 拉伸径向渐变
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![A stretched radial gradient](Images/pmj6_2607.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![一个拉伸的径向渐变](Images/pmj6_2607.png)'
- en: Figure 26-7\. A stretched radial gradient
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-7\. 一个拉伸的径向渐变
- en: Note
  id: totrans-101
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: By manipulating the figures supplied to this method, you can create a wide range
    of weird and wonderful effects—try it for yourself with the supplied examples.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通过操纵此方法提供的图表，您可以创建各种怪异而奇妙的效果——尝试使用提供的示例自己动手。
- en: Using Patterns for Fills
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用图案进行填充
- en: In a similar manner to gradient fills, you can also apply an image as a fill
    pattern. This can be an image anywhere in the current document, or even one created
    from a canvas via the `toDataURL` method (explained earlier in this chapter).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于渐变填充，您也可以将图像应用为填充图案。这可以是当前文档中的任何图像，甚至是通过 `toDataURL` 方法从画布创建的图像（本章前面已经解释过）。
- en: '[Example 26-9](#using_an_image_for_a_pattern_fill) loads a 100 × 100–pixel
    image (the yin-yang symbol) into the new image object `image`. The following statement
    attaches to the `onload` event a function that creates a repeating pattern for
    the `fillStyle` property of the context. This is then used to fill a 600 × 200–pixel
    area within the canvas, as shown in [Figure 26-8](#tiling_an_image_by_using_it_as_a_pattern).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 26-9](#using_an_image_for_a_pattern_fill) 加载一个 100 × 100 像素的图像（阴阳符号）到新的图像对象
    `image` 中。接下来的语句将一个函数附加到 `onload` 事件，该函数为上下文的 `fillStyle` 属性创建一个重复图案。然后用这个图案填充画布中的一个
    600 × 200 像素的区域，如图 [Figure 26-8](#tiling_an_image_by_using_it_as_a_pattern) 所示。'
- en: Example 26-9\. Using an image for a pattern fill
  id: totrans-106
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-9\. 使用图像作为图案填充
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Tiling an image by using it as a pattern fill](Images/pmj6_2608.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![使用图像作为图案填充](Images/pmj6_2608.png)'
- en: Figure 26-8\. Tiling an image by using it as a pattern fill
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-8\. 使用图像作为图案填充
- en: 'We create the pattern by using the `createPattern` method, which also supports
    nonrepeating patterns, or ones that just repeat in the x- or y-axes. We achieve
    this by passing one of the following values to it as the second argument, after
    the image to use:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用 `createPattern` 方法来创建图案，该方法还支持非重复和仅在 x 轴或 y 轴上重复的图案。我们通过将其作为第二个参数传递给它来实现这一点，此参数为要使用的图像之后。
- en: <dfn class="keep-together">`repeat`</dfn>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`repeat`</dfn>
- en: Repeat the image both vertically and horizontally.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直和水平重复图片。
- en: <dfn class="keep-together">`repeat-x`</dfn>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`repeat-x`</dfn>
- en: Repeat the image horizontally.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 水平重复图片。
- en: <dfn class="keep-together">`repeat-y`</dfn>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`repeat-y`</dfn>
- en: Repeat the image vertically.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直重复图片。
- en: <dfn class="keep-together">`no-repeat`</dfn>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`no-repeat`</dfn>
- en: Do not repeat the image.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不要重复图片。
- en: The fill pattern is based on the entire canvas area, so where the fill command
    is set to apply only to a smaller area within the canvas, the images appear cut
    off at the top and left.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 填充图案基于整个画布区域，因此在设置填充命令仅应用于画布内较小区域时，图像在顶部和左侧会显得被截断。
- en: Warning
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If the `onload` event had not been used in this example and, instead, the code
    was simply executed as soon as encountered, the image might not have already loaded
    by the time the web page was displayed and might not appear in the display. Attaching
    to this event ensures that the image is available for use in the canvas, because
    the event triggers only upon successful loading of an image.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在此示例中没有使用 `onload` 事件，而是在遇到代码时直接执行，那么图像可能在网页显示时尚未加载完成，可能不会显示在显示器上。附加到此事件可以确保图像可用于在画布中使用，因为该事件仅在图像成功加载后触发。
- en: Writing Text to the Canvas
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将文本写入画布
- en: As you would expect from a set of graphics features, writing to the canvas with
    text is fully supported with a variety of font, alignment, and fill methods. But
    why would you want to write text to the canvas when there’s already such good
    support for web fonts in CSS these days?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你从一组图形特性中所期望的那样，用文本写入画布是完全受支持的，具备多种字体、对齐和填充方法。但是，当今在 CSS 中已经有如此好的支持 web 字体的情况下，为什么还要将文本写入画布呢？
- en: Well, suppose you wish to display a graph or table with graphical elements.
    You’ll surely also want to label parts of it. What’s more, using the available
    commands, you can produce much more than simply a colored font. So, let’s start
    by assuming you’ve been tasked to create a header for a website on basket weaving,
    called WickerpediA (actually there’s already one of these, but let’s go ahead
    anyway).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '假设你希望显示一个带有图形元素的图表或表格。你肯定也想为其部分标记标签。更重要的是，利用现有的命令，你可以生成的不仅仅是彩色字体。因此，让我们首先假设你被要求为一个名为
    WickerpediA 的篮编网站创建页眉（尽管实际上已经有一个这样的网站，但我们继续进行）。 '
- en: To start with, you need to select a suitable font and size it appropriately,
    perhaps as in [Example 26-10](#writing_text_to_the_canvas-id00118), in which a
    font style of bold, a size of 140 pixels, and a typeface of Times have been selected.
    Also, the `textBaseline` property has been set to `top` so that the `strokeText`
    method can pass coordinates of (0, 0) for the top-left origin of the text, placing
    it at the top left of the canvas. [Figure 26-9](#text_has_been_written_to_the_canvas)
    shows what this looks like.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要选择合适的字体并将其大小调整到适当的尺寸，可能如[示例 26-10](#writing_text_to_the_canvas-id00118)
    中所示，选择了粗体风格、140 像素大小和 Times 字体。同时，还设置了 `textBaseline` 属性为 `top`，以便 `strokeText`
    方法可以使用 (0, 0) 作为文本左上角的起点坐标，将其放置在画布的左上角。[图 26-9](#text_has_been_written_to_the_canvas)
    显示了其效果。
- en: Example 26-10\. Writing text to the canvas
  id: totrans-126
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-10\. 写入文本到画布
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![The text has been written to the canvas](Images/pmj6_2609.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![文本已写入画布](Images/pmj6_2609.png)'
- en: Figure 26-9\. The text has been written to the canvas
  id: totrans-129
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-9\. 文本已写入画布
- en: The strokeText Method
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`strokeText` 方法'
- en: 'To write text to the canvas, you send the text string and a pair of coordinates
    to the `strokeText` method, like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文本写入画布，你需要将文本字符串和一对坐标发送到 `strokeText` 方法，就像这样：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The *x* and *y* coordinates supplied will be used as a relative reference by
    the `textBaseline` and `textAlign` properties.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的 *x* 和 *y* 坐标将被 `textBaseline` 和 `textAlign` 属性作为相对参考使用。
- en: This method—using line drawing—is only one way of drawing text to the canvas.
    So, in addition to all of the following properties that affect text, line-drawing
    properties such as `lineWidth` (detailed later in this chapter) will also affect
    how text displays.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法——使用线条绘制——只是绘制文本到画布的一种方式。因此，除了所有以下影响文本的属性外，如`lineWidth`（稍后在本章详细介绍），还会影响文本显示的线条绘制属性。
- en: The textBaseline Property
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: textBaseline 属性
- en: 'The `textBaseline` property can be given any of the following values:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`textBaseline` 属性可以使用以下任意值：'
- en: <dfn class="keep-together">`top`</dfn>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`top`</dfn>
- en: Aligns to the top of the text
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐到文本的顶部
- en: <dfn class="keep-together">`middle`</dfn>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`middle`</dfn>
- en: Aligns to the middle of the text
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐到文本的中间
- en: <dfn class="keep-together">`alphabetic`</dfn>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`alphabetic`</dfn>
- en: Aligns to the alphabetic baseline of the text
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐到文本的字母基线
- en: <dfn class="keep-together">`bottom`</dfn>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`bottom`</dfn>
- en: Aligns to the bottom of the text
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对齐到文本的底部
- en: The font Property
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体属性
- en: The font style can be any of `bold`, `italic`, or `normal` (the default), or
    a combination of `italic bold`, and the size values can be specified in `em`,
    `ex`, `px`, `%`, `in`, `cm`, `mm`, `pt`, or `pc` measures, just as with CSS. The
    font should be one available to the current browser, which generally means  `Helvetica`,
    `Impact`, `Courier`, `Times`, or `Arial`, or you can choose the default `Serif`
    or `Sans-serif` font of the user’s system. If you’re confident that another font
    you want to use will be available to the browser, you can specify that, too, but
    it’s a good idea to include at least one of the more common or default options
    after it so styling can fall back gracefully if the user doesn’t have your preferred
    font installed.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 字体样式可以是`bold`、`italic`或`normal`（默认），也可以是`italic bold`的组合，大小值可以使用`em`、`ex`、`px`、`%`、`in`、`cm`、`mm`、`pt`或`pc`等单位，与
    CSS 类似。字体应该是当前浏览器可用的其中之一，通常为`Helvetica`、`Impact`、`Courier`、`Times`或`Arial`，或者你可以选择用户系统的默认`Serif`或`Sans-serif`字体。如果你确信另一种你想使用的字体在浏览器中可用，也可以指定它，但最好在之后至少包含一个更常见或默认的选项，以便在用户没有安装首选字体时能够优雅地回退样式。
- en: Warning
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'If you want to use a font such as `Times New Roman`, which incorporates spaces
    in its name, you should change the relevant line to something like this, in which
    the outer quotes are different from the ones surrounding the font name:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用像 `Times New Roman` 这样的字体，其中包含空格，请将相关行更改为以下内容，外部引号与字体名称周围的引号不同：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The textAlign Property
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: textAlign 属性
- en: 'In addition to choosing how to align your text vertically, you can specify
    horizontal alignment by giving the `textAlign` property one of the following values:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 除了选择垂直对齐文本的方式外，还可以通过给 `textAlign` 属性指定以下值来指定水平对齐方式：
- en: <dfn class="keep-together">`start`</dfn>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`start`</dfn>
- en: Aligns the text to the left if the document direction is left to right, or otherwise
    to the right. This is the default setting.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档方向是从左到右，则将文本左对齐，否则右对齐。这是默认设置。
- en: <dfn class="keep-together">`end`</dfn>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`end`</dfn>
- en: Aligns the text to the right if the document direction is left to right, or
    otherwise to the left.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文档方向是从左到右，则将文本右对齐，否则左对齐。
- en: <dfn class="keep-together">`left`</dfn>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`left`</dfn>
- en: Aligns the text to the left.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本向左对齐。
- en: <dfn class="keep-together">`right`</dfn>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`right`</dfn>
- en: Aligns the text to the right.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本向右对齐。
- en: <dfn class="keep-together">`center`</dfn>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`center`</dfn>
- en: Centers the text.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本居中。
- en: 'You use the property like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以像这样使用该属性：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the case of the current example, you need the text left-aligned so that it
    butts up neatly to the edge of the canvas, so the `textAlign` property is not
    used, and therefore the default left alignment occurs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前示例中，需要将文本左对齐，以便其与画布边缘整齐对齐，因此不使用 `textAlign` 属性，因此默认的左对齐效果发生。
- en: The fillText Method
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: fillText 方法
- en: You can also choose to use a fill property to fill in canvas text, which can
    be a solid color, a linear or radial gradient, or a pattern fill. Let’s try a
    pattern fill for our heading based on the texture of a wicker basket, as in [Example 26-11](#filling_in_the_text_with_a_pattern),
    the result of which is shown in [Figure 26-10](#text_now_has_a_pattern_fill).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以选择使用填充属性来填充画布文本，可以是纯色、线性或径向渐变，或图案填充。让我们尝试基于柳条篮子的纹理进行标题的图案填充，如[示例 26-11](#filling_in_the_text_with_a_pattern)，其结果显示在[图 26-10](#text_now_has_a_pattern_fill)中。
- en: Example 26-11\. Filling in the text with a pattern
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-11\. 用图案填充文本
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![The text now has a pattern fill](Images/pmj6_2610.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![文本现在具有图案填充](Images/pmj6_2610.png)'
- en: Figure 26-10\. The text now has a pattern fill
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-10\. 文本现在具有图案填充
- en: For good measure, I also kept the `strokeText` call in this example to ensure
    a black outline to the text; without it, there wasn’t enough definition at the
    edges.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保文本边缘有足够的定义，我还在这个示例中保留了`strokeText`调用；如果没有它，边缘的定义就不够了。
- en: A wide variety of other fill types or patterns can also be used here, and the
    simplicity of the canvas makes it easy to experiment. What’s more, if you wish,
    once you have the heading just right, you can also choose to save a copy by issuing
    a call to `toDataURL`, as detailed earlier in the chapter. Then you can use the
    image as a logo for uploading to other sites, for example.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还可以使用各种其他填充类型或图案，并且画布的简单性使得进行实验变得容易。此外，如果你希望，一旦标题达到完美，你还可以选择通过调用`toDataURL`保存一个副本，正如本章前面详细介绍的那样。然后，你可以将图像用作上传到其他站点的标志，例如。
- en: The measureText Method
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: measureText方法
- en: 'When working with canvas text, you may sometimes need to know how much space
    it will occupy so that you can best position it. You can achieve this with the
    `measureText` method, as follows (assuming all the various text properties have
    already been defined at this point):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用画布文本时，有时需要知道它将占用多少空间，以便最佳位置放置它。你可以使用`measureText`方法来实现这一点（假设在此时已经定义了各种文本属性），如下所示：
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Since the height of the text in pixels is equal to the font size in points when
    the font is defined, the `metrics` object doesn’t provide a height metric.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于像素高度等于定义字体时的点大小，所以`metrics`对象不提供高度度量。
- en: Drawing Lines
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制线条
- en: The canvas provides a plethora of line-drawing functions to cater to almost
    every need, including choices of lines, line caps and joins, and paths and curves
    of all types. But let’s start with a property I touched on in the previous section
    on writing text to the canvas.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 画布提供了丰富的线条绘制函数，以满足几乎所有需求，包括线条、线帽和连接的选择，以及各种类型的路径和曲线。但让我们从上一节中涉及的属性开始，介绍一下。
- en: The lineWidth Property
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lineWidth属性
- en: 'All the canvas methods that draw with lines make use of several line properties,
    one of the most important being `lineWidth`. Using it is as simple as specifying
    a line width in pixels, like this, which sets the width to 3 pixels:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有用线条绘制的画布方法都使用了几个线条属性，其中最重要的之一是`lineWidth`。使用它就像简单地指定像素线宽一样简单，比如这样设置宽度为3像素：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The lineCap and lineJoin Properties
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lineCap和lineJoin属性
- en: 'When lines you draw come to an end and are more than a pixel wide, you can
    choose how this *line cap* (as it is called) should appear by using the `lineCap`
    property, which can have the values `butt` (the default), `round`, or `square`,
    for example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你绘制的线条到达终点并且宽度超过一个像素时，你可以选择如何显示这个*线帽*，通过使用`lineCap`属性，它可以有值`butt`（默认）、`round`或`square`，例如：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Also, when you are joining lines together that are wider than a single pixel,
    it is important to specify exactly how they should meet. You achieve this with
    the `lineJoin` property, which can have values of `round`, `bevel`, or `miter`
    (the default), like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当你连接超过单像素宽度的线条时，指定它们如何相遇非常重要。你可以使用`lineJoin`属性来实现这一点，它可以具有值`round`、`bevel`或`miter`（默认值），例如：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[Example 26-12](#displaying_combinations_of_line_caps_and) (shown here in full
    since it’s a little more complicated) applies all three values of each property
    in combination, creating the result you’ll see in [Figure 26-11](#all_the_combinations_of_line_caps_and_jo).
    The `beginPath`, `closePath`, `moveTo`, and `lineTo` methods used by this example
    are explained next.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 26-12](#显示线帽和连接的组合)（因为有点复杂，这里完整显示）将每个属性的三个值结合起来应用，从而创建了你在[图 26-11](#所有线帽和连接的组合)中看到的结果。该示例使用的`beginPath`、`closePath`、`moveTo`和`lineTo`方法将在下面解释。'
- en: Example 26-12\. Displaying combinations of line caps and joins
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-12\. 显示线帽和连接的组合
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code sets up a few properties and then nests a pair of loops: one for
    the line caps and one for the joins. Inside the central loop, the current values
    for the `lineCap` and `lineJoin` properties are first set and then displayed in
    the canvas with the `fillText` method.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码设置了一些属性，然后嵌套了一对循环：一个用于线帽，一个用于连接。在中央循环内，首先设置了`lineCap`和`lineJoin`属性的当前值，然后用`fillText`方法在画布上显示出来。
- en: Using these settings, the code then draws nine shapes with a 20-pixel-wide line,
    each of which has a different combination of line cap and join settings, as shown
    in [Figure 26-11](#all_the_combinations_of_line_caps_and_jo).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些设置，代码将绘制九个形状，每个形状都有一个 20 像素宽的线，具有不同的线帽和连接设置，如 [图 26-11](#all_the_combinations_of_line_caps_and_jo)
    所示。
- en: As you can see, butted line caps are short, square ones are longer, and the
    round ones are somewhere between the two. Rounded line joins are curved, beveled
    ones are cut across the corner, and mitered ones have sharp corners. Line joins
    also apply to joins at angles other than 90 degrees.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，平截头线帽很短，方形的较长，而圆形的则介于两者之间。圆角连接是曲线的，斜角连接是切割过角的，而尖角连接具有尖锐的角。连接同样适用于不是
    90 度的角的连接。
- en: '![All the combinations of line caps and joins](Images/pmj6_2611.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![所有线帽和连接的组合](Images/pmj6_2611.png)'
- en: Figure 26-11\. All the combinations of line caps and joins
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-11\. 所有线帽和连接的组合
- en: The miterLimit Property
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**miterLimit 属性**'
- en: 'If you find that your mitered joins get cut off too short, you can extend them
    by using the `miterLimit` property, like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现你的尖角斜接被截断得太短，你可以使用 `miterLimit` 属性来延长它们，如下所示：
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The default value is `10`, so you can reduce the miter limit too. If `miterLimit`
    is not set to a sufficiently large value for a miter, then sharply mitered joins
    will simply bevel instead. So, if you are having trouble with your pointed miters,
    simply increase the value you supply for `miterLimit` until the miter displays.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值为 `10`，所以你也可以减少斜接限制。如果 `miterLimit` 没有设置为足够大的值以适应斜接，那么锐角斜接将会简单地变成斜接。因此，如果你遇到尖锐斜接的问题，只需增加你为
    `miterLimit` 提供的值，直到斜接正确显示。
- en: Using Paths
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用路径
- en: 'The previous example made use of two methods to set up paths for the line-drawing
    methods to follow. The `beginPath` method sets the start of a path, and `closePath`
    sets the end. Inside each path, you can then use various methods for moving the
    location of drawing and for creating lines, curves, and other shapes. Let’s examine
    the relevant section from [Example 26-12](#displaying_combinations_of_line_caps_and),
    simplified to create just a single instance of the pattern:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例使用了两种方法来设置路径，供线条绘制方法使用。`beginPath` 方法设置路径的开始，而 `closePath` 设置路径的结束。在每个路径内部，你可以使用各种方法来移动绘图位置以及创建线条、曲线和其他形状。让我们简要看一下来自
    [示例 26-12](#displaying_combinations_of_line_caps_and) 的相关部分，简化为仅创建模式的单个实例：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this code snippet, a path is started in the first line, and then the drawing
    location is moved to a position 20 pixels across and 100 down from the top-left
    corner of the canvas, using a call to the `moveTo` method.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码片段中，第一行开始了一个路径，然后通过调用 `moveTo` 方法将绘图位置移动到离画布左上角 20 像素横向和 100 像素纵向的位置。
- en: This is followed by three calls to `lineTo`, which draw three lines, first upward
    to the location (20, 20), then to the right to (155, 20), and then down again
    to (155, 100). Once this path has been set out, the `stroke` method is called
    to lay it down, and finally the path is closed because it’s no longer needed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后紧接着是对 `lineTo` 的三次调用，分别画出三条线，首先向上到位置 (20, 20)，然后向右到 (155, 20)，最后再次向下到 (155,
    100)。一旦路径设置好了，调用 `stroke` 方法进行绘制，最后关闭路径因为不再需要。
- en: Note
  id: totrans-204
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is essential to close paths as soon as you finish with them; otherwise, you
    can get some very unexpected results when using multiple paths.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成路径后立即关闭路径是非常重要的；否则，在使用多条路径时可能会得到一些非常意想不到的结果。
- en: The moveTo and lineTo Methods
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: moveTo 和 lineTo 方法
- en: The `moveTo` and `lineTo` methods both take simple *x* and *y* coordinates as
    their arguments, with the difference being that `moveTo` picks up an imaginary
    pen from the current location and then moves it to a new one, while `lineTo` draws
    a line from the current location of the imaginary pen to the new one specified.
    Or, at least, a line will be drawn if the `stroke` method is called but not otherwise.
    So let’s just say that `lineTo` creates a *potential* drawn line, but it could
    equally be part of the outline for a fill area, for example.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`moveTo` 方法和 `lineTo` 方法都接受简单的 *x* 和 *y* 坐标作为它们的参数，它们的区别在于 `moveTo` 从当前位置拿起一个虚拟的笔然后移动到一个新位置，而
    `lineTo` 在当前虚拟笔的位置到指定的新位置之间画一条线。或者，如果调用了 `stroke` 方法但没有其他方法的话，将会画出一条线。因此，我们只能说
    `lineTo` 创建了一个*潜在*的画线，但它同样可以是填充区域的轮廓的一部分，例如。'
- en: The stroke Method
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stroke 方法
- en: The `stroke` method has the job of actually drawing all the lines created so
    far in a path onto the canvas. If it is issued from inside an unclosed path, this
    has the effect of immediately drawing everything up to the most recent imaginary
    pen location.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`stroke`方法的作用是将到目前为止在路径中创建的所有线条实际绘制到画布上。如果在未关闭路径的情况下发出该命令，则会立即绘制到最近的虚拟笔位置。'
- en: However, if you close a path and then issue a call to `stroke`, it has the effect
    of also joining a path from the current location back to the start location, which
    in this example would turn the shapes into rectangles (which we don’t want because
    we need to see the line caps as well as joins).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果关闭路径，然后发出一个`stroke`调用，它的效果也会从当前位置回到起始位置连接路径，在这个例子中会将形状变成矩形（这不是我们想要的，因为我们需要看到线帽以及连接点）。
- en: Note
  id: totrans-211
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This joining effect on closing a path is required (as you will see a little
    later) to get paths ready for any `fill` methods you want to use on them; otherwise,
    the graphics you use for a fill might overflow the bounds of the path.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这种路径闭合后的连接效果是必需的（稍后您将看到），以便准备好任何您希望对其使用的`fill`方法；否则，用于填充的图形可能会超出路径的边界。
- en: The rect Method
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: rect方法
- en: 'Should it have been necessary to create four-sided rectangles instead of the
    three-sided shapes in the preceding example (and you didn’t wish to close the
    path yet), another `lineTo` call could have been issued to join everything up,
    like this (highlighted in bold):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要创建四边形而不是前面示例中的三边形（并且您不希望关闭路径），可以发出另一个`lineTo`调用以连接所有内容，就像这样（以粗体显示）：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But there’s a much simpler way to draw outlined rectangles, which is with the
    `rect` method, like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有一种更简单的方法可以绘制带有轮廓的矩形，即使用`rect`方法，就像这样：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In just a single call, this command takes two pairs of *x* and *y* coordinates
    and draws a rectangle with its top-left corner at location (20, 20) and bottom-right
    corner at (155,100).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在单个调用中，此命令接受两对*x*和*y*坐标并绘制一个矩形，其左上角位于(20, 20)位置，右下角位于(155, 100)位置。
- en: Filling Areas
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充区域
- en: Using paths, you can create complicated areas that can also be filled in with
    solid, gradient, or pattern fills. In [Example 26-13](#filling_in_a_complex_path),
    some basic trigonometry is used to create a complex star pattern. I won’t detail
    how the math works because that’s not important to the example (although if you
    want to play with the code, try changing the values assigned to `points`, and
    the `scale1` and `scale2` variables, for different effects).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路径，您可以创建复杂的区域，还可以填充实色、渐变色或图案填充。在[示例26-13](#filling_in_a_complex_path)中，使用了一些基本的三角函数来创建复杂的星形图案。我不会详细说明数学如何工作，因为这对示例不重要（尽管如果您想玩转代码，请尝试更改分配给`points`、`scale1`和`scale2`变量的值，以获得不同的效果）。
- en: Example 26-13\. Filling in a complex path
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例26-13\. 填充复杂路径
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All you really need to look at are the lines highlighted in bold, in which a
    path is started, a pair of `lineTo` calls defines the shape, the path is closed,
    and then the `stroke` and `fill` methods are used to draw the shape outline in
    orange and fill it in with yellow (as shown in [Figure 26-12](#drawing_and_filling_in_a_complex_path)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您真正需要查看的只是以粗体显示的那些行，其中开始了一个路径，一对`lineTo`调用定义了形状，路径被关闭，然后使用`stroke`和`fill`方法绘制橙色的形状轮廓并填充黄色（如[图26-12](#drawing_and_filling_in_a_complex_path)所示）。
- en: Note
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: With paths, it’s possible to create as complex an object as you like, either
    using formulae or loops (as in this example) or simply with a long string of `moveTo`
    and/or `lineTo` or other calls.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路径，您可以创建任意复杂的对象，可以使用公式或循环（如本例中）或仅使用一长串的`moveTo`和/或`lineTo`调用。
- en: '![Drawing and filling in a complex path](Images/pmj6_2612.png)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![绘制和填充复杂路径](Images/pmj6_2612.png)'
- en: Figure 26-12\. Drawing and filling in a complex path
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图26-12\. 绘制和填充复杂路径
- en: The clip Method
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: clip方法
- en: Sometimes when you are building a path, you may want to ignore sections of the
    canvas (perhaps if you are drawing partly “behind” another object and want only
    the visible part to display). You can achieve this using the `clip` method, which
    creates a boundary outside of which `stroke`, `fill`, or other methods will not
    have any effect.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在构建路径时，您可能希望忽略画布的某些部分（也许是因为您正在部分“后面”绘制另一个对象，只想显示可见部分）。您可以使用`clip`方法来实现这一点，该方法创建一个边界，超出该边界的`stroke`、`fill`或其他方法将不会产生任何效果。
- en: To illustrate this, [Example 26-14](#creating_a_clip_area) creates an effect
    similar to window blinds by moving the imaginary pen pointer to the left-hand
    edge, then drawing a `lineTo` over to the right-hand edge, another down by 30
    pixels, and then another back to the left-hand edge, and so on. This creates a
    sort of snaking pattern in which a series of 30-pixel-deep, horizontal bars are
    drawn on the canvas, as shown in [Figure 26-13](#path_of_horizontal_bars).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，[示例 26-14](#creating_a_clip_area)通过将虚拟笔指针移动到左边缘，然后画一条`lineTo`到右边缘，再向下移动30像素，然后再返回到左边缘，依此类推，创建了类似窗帘的效果。这在画布上绘制了一系列深度为30像素的水平条，如[图 26-13](#path_of_horizontal_bars)所示。
- en: Example 26-14\. Creating a clip area
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-14\. 创建剪辑区域
- en: '[PRE36]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![A path of horizontal bars](Images/pmj6_2613.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![水平条形图的路径](Images/pmj6_2613.png)'
- en: Figure 26-13\. A path of horizontal bars
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-13\. 水平条形图的路径
- en: 'To turn this example into a clipped area of the canvas, you simply need to
    replace the call to `stroke` (highlighted in bold in the example) with one to
    `clip`, like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此示例转换为画布上的剪辑区域，您只需将示例中用粗体突出显示的`stroke`调用替换为`clip`调用，如下所示：
- en: '[PRE37]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now the outline of the bars won’t be seen, but a clipping area that consists
    of all the individual bars will be in place. To illustrate this, [Example 26-15](#drawing_within_the_clipped_areaapostroph)
    makes this method substitution and then adds to the previous example by drawing
    on the canvas a simple picture of green grass below a blue sky containing a shining
    sun (modified from [Example 26-12](#displaying_combinations_of_line_caps_and)),
    with the changes highlighted in bold and the result shown in [Figure 26-14](#drawing_occurs_only_within_the_allowed_c).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不会看到条形图的轮廓，但是一个由所有单独的条形图组成的剪辑区域将会存在。为了说明这一点，[示例 26-15](#drawing_within_the_clipped_areaapostroph)使用这种方法替代，并在之前的示例基础上添加了在画布上绘制简单的绿草图像的修改，位于一个包含闪耀太阳的蓝天下（修改自[示例 26-12](#displaying_combinations_of_line_caps_and)），用粗体突出显示的更改，并在[图 26-14](#drawing_occurs_only_within_the_allowed_c)中显示结果。
- en: Example 26-15\. Drawing within the clipped area’s bounds
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-15\. 在剪辑区域的边界内绘制
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![Drawing occurs only within the allowed clipped area](Images/pmj6_2614.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![仅在允许的剪辑区域内绘制](Images/pmj6_2614.png)'
- en: Figure 26-14\. Drawing occurs only within the allowed clipped area
  id: totrans-241
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-14\. 仅在允许的剪辑区域内绘制
- en: OK, we’re not going to win any competitions here, but you can see how powerful
    clipping can be when used effectively.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们不会在这里赢得任何比赛，但您可以看到在有效使用时剪辑可以有多强大。
- en: The isPointInPath Method
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: isPointInPath方法
- en: 'Sometimes you need to know whether a particular point lies in a path you’ve
    constructed. However, you will probably want to use this function only if you’re
    quite proficient with JavaScript and with writing fairly complex programs, and
    you’ll generally call it as part of a conditional `if` statement, like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候您需要知道特定点是否位于您构建的路径中。但是，您可能只有在非常熟练于JavaScript并且能够编写相当复杂的程序时才会想要使用此功能，并且通常会将其作为条件`if`语句的一部分调用，如下所示：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first argument to the call is the location’s *x* coordinate, and the second
    is the location’s *y* coordinate. If the location specified lies along any of
    the points in the path, the method returns the value `true`, so the contents of
    the `if` statement are executed. Otherwise, the value `false` is returned, and
    the contents of the `if` statement don’t get executed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 调用的第一个参数是位置的*x*坐标，第二个参数是位置的*y*坐标。如果指定的位置位于路径中的任何点上，则该方法返回值为`true`，因此执行`if`语句的内容。否则，返回值为`false`，则不执行`if`语句的内容。
- en: Note
  id: totrans-247
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A perfect use for the `isPointInPath` method is creating games using the canvas
    in which you wish to check for a missile hitting a target, a ball hitting a wall
    or bat, or similar boundary conditions.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`isPointInPath`方法的完美场景是创建使用画布的游戏，例如希望检查导弹击中目标、球击中墙壁或球拍等边界条件。
- en: Working with Curves
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用曲线
- en: In addition to straight paths, you can create an almost infinite variety of
    curved paths with a selection of different methods, ranging from simple arcs and
    circles to complex quadratic and Bézier curves.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直线路径，您还可以使用各种不同的方法创建几乎无限种类的曲线路径，从简单的弧线和圆到复杂的二次和贝塞尔曲线。
- en: Actually, you don’t need to use paths to create many lines, rectangles, and
    curves, because you can draw them directly by simply calling their methods. But
    using paths gives you more precise control, so I tend to draw on the canvas within
    defined paths, as with the following examples.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您不需要使用路径来创建许多线条、矩形和曲线，因为您可以通过直接调用它们的方法来直接绘制它们。但是使用路径可以给您提供更精确的控制，因此我倾向于在定义的路径内绘制画布上的内容，就像以下示例一样。
- en: The arc Method
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弧方法
- en: 'The `arc` method requires you to pass it the *x* and *y* location of the center
    of the arc, and the radius in pixels. In addition to these values, you need to
    pass a pair of radian offsets, and you can optionally include a direction, like
    this:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`arc`方法要求您传递弧的中心的*x*和*y*位置，以及像素的半径。除了这些值，您还需要传递一对弧度偏移量，并且可以选择包括方向，如下所示：'
- en: '[PRE40]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Since the default direction is clockwise (a value of `false`), this can be omitted,
    or you can change it to `true` to draw the arc in a counterclockwise direction.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于默认方向是顺时针的（一个值为`false`），这可以省略，或者您可以将其更改为`true`以逆时针方向绘制弧。
- en: '[Example 26-16](#drawing_a_variety_of_arcs) creates three sets of four arcs,
    the first two sets in a clockwise direction and the third set in a counterclockwise
    direction. Additionally, the first set of four arcs has its paths closed before
    the `stroke` method is called, so the start and end points are joined up, whereas
    the other two sets of arcs are drawn before the path is closed, so they are not
    joined up.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 26-16](#drawing_a_variety_of_arcs)创建了三组四个弧，前两组顺时针方向，第三组逆时针方向。此外，前两组弧在调用`stroke`方法之前路径已关闭，因此起点和终点相连，而后面的两组弧在路径关闭之前绘制，因此不相连。'
- en: Example 26-16\. Drawing a variety of arcs
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-16\. 绘制各种弧
- en: '[PRE41]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To create shorter code, I drew all the arcs using loops so that the length
    of each arc is stored in the array `arcs`. These values are in radians, and since
    a radian is equivalent to 180 ÷ π (π being the ratio of a circle’s circumference
    to its diameter, or approximately 3.1415927), they evaluate as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建更短的代码，我使用循环绘制了所有的弧，以便将每个弧的长度存储在数组`arcs`中。这些值以弧度表示，一个弧度相当于180 ÷ π（π是圆周与直径的比值，约为3.1415927），它们的计算如下：
- en: <dfn class="keep-together">`Math.PI`</dfn>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Math.PI`</dfn>
- en: Equivalent to 180 degrees
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于180度
- en: <dfn class="keep-together">`Math.PI * 2`</dfn>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Math.PI * 2`</dfn>
- en: Equivalent to 360 degrees
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于360度
- en: <dfn class="keep-together">`Math.PI / 2`</dfn>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Math.PI / 2`</dfn>
- en: Equivalent to 90 degrees
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于90度
- en: <dfn class="keep-together">`Math.PI / 180 * 59`</dfn>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Math.PI / 180 * 59`</dfn>
- en: Equivalent to 59 degrees
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于59度
- en: '[Figure 26-15](#variety_of_arc_types) shows the three rows of arcs and illustrates
    both the use of the direction argument `true` in the final set and the importance
    of carefully choosing where you close paths depending on whether you want to draw
    a line connecting the start and end points.'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 26-15](#variety_of_arc_types)展示了三行弧，并说明了在最后一组中使用方向参数`true`以及根据您是否希望绘制连接起始点和终点的线条而仔细选择关闭路径的重要性。'
- en: '![A variety of arc types](Images/pmj6_2615.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![各种弧类型](Images/pmj6_2615.png)'
- en: Figure 26-15\. A variety of arc types
  id: totrans-270
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-15\. 各种弧类型
- en: Note
  id: totrans-271
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you prefer to work with degrees instead of radians, you could create a new
    `Math` library function, like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更喜欢使用度而不是弧度，可以创建一个新的`Math`库函数，如下所示：
- en: '[PRE42]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'And then replace the array-creating code, starting at the second line of [Example 26-16](#drawing_a_variety_of_arcs),
    with the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后用以下内容替换从[示例 26-16](#drawing_a_variety_of_arcs)的第二行开始的创建数组的代码：
- en: '[PRE43]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The arcTo Method
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: arcTo方法
- en: 'Rather than creating a whole arc at once, you can choose to arc from the current
    location in the path to another one, like in the following call to `arcTo` (which
    simply requires two pairs of *x* and *y* coordinates and a radius):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是一次创建整个弧，您可以选择从路径中的当前位置弧到另一个位置，就像在以下`arcTo`调用中（它只需要两对*x*和*y*坐标和一个半径）：
- en: '[PRE44]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The locations you pass to the method represent the points where imaginary tangent
    lines touch the circumference of the arc at its start and end points. A tangent
    is the angle at which a straight line touches the circumference of a circle such
    that the angles between the line and circle on either side of the point of touch
    are equal.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您传递给该方法的位置代表想象的切线触及弧的圆周的起点和终点处。切线是一条直线与圆周的接触点，使得接触点两侧的角度相等。
- en: To illustrate how this works, [Example 26-17](#drawing_eight_arcs_of_different_radii)
    draws eight different arcs with radii from 0 up to 280 pixels. Each time around
    the loop, a new path is created with a start point at location (20, 20). Then
    an arc is drawn using imaginary tangent lines from that location to position (240,
    240), and from there to location (460, 20). In this instance, it defines a pair
    of tangents at 90 degrees to each other, in a *V* shape.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明其工作原理，[例子 26-17](#drawing_eight_arcs_of_different_radii) 绘制了八个不同半径从 0 到
    280 像素的弧线。每次循环时，都会在位置 (20, 20) 处创建一个新路径的起始点。然后使用虚拟切线从该位置绘制弧线到位置 (240, 240)，然后再到位置
    (460, 20)。在这种情况下，它定义了一个互相成直角的 *V* 形的切线对。
- en: Example 26-17\. Drawing eight arcs of different radii
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 26-17\. 绘制八个不同半径的弧线
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The `arcTo` method draws only up to the point at which the arc touches the second
    imaginary tangent. So, after each call to `arcTo`, the `lineTo` method creates
    the remainder of the line from wherever `arcTo` left off to location (460,20).
    Then the result is drawn to the canvas with a call to `stroke`, and the path is
    closed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '`arcTo` 方法仅绘制弧线触及第二个虚拟切线的点。因此，在每次调用 `arcTo` 后，`lineTo` 方法创建从 `arcTo` 结束位置到位置
    (460,20) 的剩余线段。然后使用 `stroke` 方法将结果绘制到画布上，并关闭路径。'
- en: As you can see in [Figure 26-16](#drawing_arcs_of_different_radii), when `arcTo`
    is called with a radius value of `0`, it creates a sharp join. In this case, it’s
    a right angle (but if the two imaginary tangents are at other angles to each other,
    the join will be at that angle). Then, as the radius increases in size, you can
    see the arcs getting larger and larger.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在 [图 26-16](#drawing_arcs_of_different_radii) 中看到的，当 `arcTo` 使用半径值 `0` 调用时，它会创建一个尖锐的连接点。在这种情况下，它是一个直角（但如果两条虚拟切线相互形成其他角度，连接点将位于那个角度）。随着半径的增大，您可以看到弧线变得越来越大。
- en: '![Drawing arcs of different radii](Images/pmj6_2616.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![不同半径的弧线绘制](Images/pmj6_2616.png)'
- en: Figure 26-16\. Drawing arcs of different radii
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-16\. 绘制不同半径的弧线
- en: 'Essentially, what you can best use `arcTo` for is to curve from one section
    of drawing to another, following an arc based on the previous and subsequent positions,
    as if they were tangential to the arc to be created. If this sounds complicated,
    don’t worry: you’ll soon get the hang of it and find it’s actually a handy and
    logical way to draw arcs.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从根本上说，您可以最好地使用 `arcTo` 来从绘制的一个部分弯曲到另一个部分，根据前后位置的弧度切线，仿佛它们是弧线的切线。如果这听起来很复杂，别担心：您很快就会掌握它，并发现这实际上是一种方便和逻辑的绘制弧线的方式。
- en: The quadraticCurveTo Method
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二次曲线绘制方法
- en: 'Useful as arcs are, they are only one type of curve and can be limiting for
    more-complex designs. But have no fear: there are still more ways to draw curves,
    such as the `quadraticCurveTo` method. Using this method, you can place an imaginary
    attractor near to (or far from) a curve to pull it in that direction, in a similar
    way to the path of an object in space being pulled by the gravity of the planets
    and stars it passes. Unlike with gravity, though, the farther away the attractor
    is, the *more* it pulls!'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管弧线很有用，但它们只是一种曲线类型，对于更复杂的设计可能有所限制。但不用担心：还有更多方法来绘制曲线，例如 `quadraticCurveTo` 方法。使用这种方法，您可以在曲线附近放置一个虚拟吸引子，将其朝该方向拉动，就像空间中的物体路径被它经过的行星和恒星的引力所拉动一样。不过，与重力不同的是，吸引子距离越远，它的吸引力就*越*大！
- en: '[Example 26-18](#drawing_a_cloud_with_quadratic_curves) contains six calls
    to this method, creating the path for a fluffy cloud, which is then filled in
    with white. [Figure 26-17](#drawing_with_quadratic_curves) illustrates how the
    angles of the dashed line outside the cloud represent the attractor points applied
    to each curve.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 26-18](#drawing_a_cloud_with_quadratic_curves) 包含对此方法的六次调用，创建了一朵蓬松云朵的路径，然后用白色填充。
    [图 26-17](#drawing_with_quadratic_curves) 说明了云朵外部虚线的角度代表应用于每条曲线的吸引点。'
- en: Example 26-18\. Drawing a cloud with quadratic curves
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 26-18\. 使用二次曲线绘制云朵
- en: '[PRE46]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![Drawing with quadratic curves](Images/pmj6_2617.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![使用二次曲线绘制](Images/pmj6_2617.png)'
- en: Figure 26-17\. Drawing with quadratic curves
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-17\. 使用二次曲线绘制
- en: Note
  id: totrans-295
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Incidentally, to achieve the dotted line around the cloud in this image, I used
    the `stroke` method in conjunction with the `setLineDash` method, which takes
    a list representing the dash and space lengths. In this instance, I used `setLineDash([2,
    3])`, but you can create dashed lines as complicated as you like, such as `setLineDash([1,
    2, 1, 3, 5, 1, 2, 4])`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，为了在此图像中实现云的虚线周围的虚线，我使用了`stroke`方法与`setLineDash`方法结合使用，后者接受表示短划线和空格长度的列表。在这种情况下，我使用了`setLineDash([2,
    3])`，但您可以创建复杂到您喜欢的虚线，比如`setLineDash([1, 2, 1, 3, 5, 1, 2, 4])`。
- en: The bezierCurveTo Method
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: bezierCurveTo 方法
- en: If you still don’t find quadratic curves flexible enough for your needs, how
    about having access to two attractors for each curve? Using the `bezierCurveTo`
    method you can do just that, as in [Example 26-19](#creating_a_beacutezier_curve_with_two_at),
    where a curve is created between location (24, 20) and (240, 220) but with invisible
    attractors off the canvas (in this case) at locations (720, 480) and (–240, –240).
    [Figure 26-18](#beacutezier_curve_with_two_attractors) shows how this curve gets
    warped.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仍然觉得二次曲线对您的需求不够灵活，那么对于每条曲线使用两个吸引子如何？使用`bezierCurveTo`方法，您可以做到这一点，就像在[示例 26-19](#creating_a_beacutezier_curve_with_two_at)中那样，其中创建了一个曲线，连接位置(24,
    20)和(240, 220)，但是吸引子在画布外部不可见（在此示例中位于位置(720, 480)和(-240, -240)）。[图 26-18](#beacutezier_curve_with_two_attractors)展示了这条曲线的形变过程。
- en: Example 26-19\. Creating a Bézier curve with two attractors
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-19\. 创建具有两个吸引子的贝塞尔曲线
- en: '[PRE47]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![A Bézier curve with two attractors](Images/pmj6_2618.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![具有两个吸引子的贝塞尔曲线](Images/pmj6_2618.png)'
- en: Figure 26-18\. A Bézier curve with two attractors
  id: totrans-302
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-18\. 具有两个吸引子的贝塞尔曲线
- en: Attractors do not need to be at opposite sides of a canvas; you can place them
    anywhere, and when they are near each other, they will exert a combined pull (rather
    than opposing pulls, as in the preceding example). Using these various types of
    curve methods, it’s possible for you to draw every type of curve you could ever
    need.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 吸引子不需要位于画布的相对两侧；您可以将它们放置在任何位置，当它们彼此靠近时，它们将施加联合的吸引力（而不是像前面的例子中那样的对立吸引力）。使用这些不同类型的曲线方法，您可以绘制您所需的每种类型的曲线。
- en: Manipulating Images
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像操作
- en: Not only can you draw and write on the canvas with graphical methods, but you
    can also place images on or extract them from a canvas. And you’re not limited
    to simple copy-and-paste commands, because you can stretch and distort images
    when reading or writing them and also have full control over compositing and shadow
    effects.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 您不仅可以使用图形方法在画布上绘制和书写，还可以在画布上放置图像或从中提取它们。而且，您不限于简单的复制粘贴命令，因为在读取或写入图像时，您可以拉伸和扭曲图像，并完全控制混合和阴影效果。
- en: The drawImage Method
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: drawImage 方法
- en: 'Using the `drawImage` method, you can take an image object that was loaded
    from a website, uploaded to a server, or even extracted from a canvas and draw
    it onto a canvas. The method supports a wide variety of arguments, many of which
    are optional, but at its simplest you call `drawImage` as follows, passing just
    the image and a pair of *x* and *y* coordinates:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`drawImage`方法，您可以获取从网站加载的图像对象、上传到服务器的图像，甚至从画布中提取的图像，并将其绘制到画布上。该方法支持多种参数，其中许多是可选的，但在其最简单的形式下，您可以像以下这样调用`drawImage`，仅传递图像及一对*x*和*y*坐标：
- en: '[PRE48]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This command draws the image contained in the `myimage` object onto the canvas
    with the context of `context`, with its top-left corner at location (20, 20).
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将`myimage`对象中包含的图像绘制到具有`context`上下文的画布上，其左上角位于位置(20, 20)。
- en: Warning
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'To ensure that an image has been loaded before you use it, best practice is
    to enclose your image-handling code within a function that is triggered only upon
    image load, like this:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用图像之前确保其已加载的最佳实践是将您的图像处理代码封装在一个仅在图像加载时触发的函数中，如下所示：
- en: '[PRE49]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Resizing an Image
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整图像大小
- en: 'If you need to resize an image when it is placed on the canvas, add a second
    pair of arguments to the call representing the width and height you require, like
    this (highlighted in bold):'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在放置在画布上的图像上调整大小，请在调用中添加第二对表示所需宽度和高度的参数，如下（用粗体标记）：
- en: '[PRE50]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Here the image is placed at two locations: the first is at (140, 20), where
    the image is enlarged (from a 100-pixel square to a 220-pixel square), while the
    second goes to location (380, 20) with the image being squashed horizontally and
    expanded vertically, to a width and height of 80 × 220 pixels.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 此处图像放置在两个位置：第一个位置为(140, 20)，图像被放大（从100像素正方形到220像素正方形），而第二个位置为(380, 20)，图像在水平方向被挤压并在垂直方向上扩展，宽度和高度为80
    × 220像素。
- en: Selecting an Image Area
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择图像区域
- en: You’re not stuck having to use an entire image; it’s also possible to choose
    an area within an image when using `drawImage`. This can be handy, for example,
    if you wish to place all the graphical images you intend to use in a single image
    file and then just grab the sections of the image that you need. This is a trick
    developers often use to speed up page loading and decrease server hits.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `drawImage` 时，并不局限于使用整个图像；还可以选择图像内的区域。例如，如果希望将所有打算使用的图形图像放在一个单独的图像文件中，然后只需抓取所需的图像部分，这会非常方便。开发人员经常使用这种技巧来加快页面加载速度并减少服务器请求。
- en: It’s a little trickier to do this, though, because rather than adding more arguments
    at the end of the list for this method, when extracting a portion of an image,
    you must place those arguments first.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这样做稍微复杂一些，因为在这种方法中，与在参数列表末尾添加更多参数不同的是，在提取图像的部分时，必须首先放置这些参数。
- en: 'So, for example, to place an image at location (20, 140), you might issue this
    command:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，要在位置 (20, 140) 处放置一个图像，可以发出以下命令：
- en: '[PRE51]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'And to give it a width and height of 100 × 100 pixels, you would modify the
    call like this (highlighted in bold):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要给抓取的部分设置宽度和高度为 100 × 100 像素，可以像这样修改调用（用粗体标出）：
- en: '[PRE52]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'But to grab (or crop) just a 40 × 40–pixel subsection (for example), with its
    top-left corner at location (30, 30) of the image, you would call the method like
    this (with the new arguments in bold):'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果想要抓取（或裁剪）一个只有 40 × 40 像素的子区域（例如），其位于图像的 (30, 30) 处，你可以像这样调用该方法（新参数用粗体表示）：
- en: '[PRE53]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And to resize the grabbed portion to 100 pixels square, you would use the following:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 要将抓取的部分调整为 100 像素正方形，可以使用以下方式：
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Warning
  id: totrans-328
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: I find this very confusing and cannot think of a logical reason for why this
    method works this way. But since it does, I’m afraid there’s nothing you can do
    other than force yourself to remember which arguments go where under which conditions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得这非常令人困惑，无法想到这种方法为什么会这样工作的合乎逻辑的原因。但既然它确实如此，我恐怕除了强迫自己记住在哪些条件下哪些参数放在哪里之外，别无他法。
- en: '[Example 26-20](#various_ways_of_drawing_an_image_on_the) uses a variety of
    calls to the `drawImage` method to obtain the result shown in [Figure 26-19](Images/#drawing_images_to_a_canvas_with_resizing).
    To make things clearer, I have spaced out the arguments so that the values in
    each column provide the same information.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 26-20](#various_ways_of_drawing_an_image_on_the) 使用多种调用 `drawImage` 方法的方式来获得
    [图 26-19](Images/#drawing_images_to_a_canvas_with_resizing) 所显示的结果。为了更清楚，我已经分开参数，使得每列的值提供相同的信息。'
- en: Example 26-20\. Various ways of drawing an image on the canvas
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-20\. 画布上绘制图像的各种方式
- en: '[PRE55]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![Drawing images to a canvas with resizing and cropping](Images/pmj6_2619.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![调整大小和裁剪图像到画布上的图像](Images/pmj6_2619.png)'
- en: Figure 26-19\. Drawing images to a canvas with resizing and cropping
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-19\. 调整大小和裁剪图像到画布上的图像
- en: Copying from a Canvas
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从画布复制
- en: You can also use a canvas as a source image for drawing to the same (or another)
    canvas. Just supply the canvas object’s name in place of an image object, and
    use all the remaining arguments in the same way you would with an image.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个画布用作绘制到同一个（或另一个）画布的源图像。只需在图像对象的位置提供画布对象的名称，并以与图像相同的方式使用所有其余的参数。
- en: Adding Shadows
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加阴影
- en: 'When you draw an image (or image section), or, indeed, anything else on the
    canvas, you can also place a shadow under it by setting one or more of the following
    properties:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘制图像（或图像部分）或者任何其他内容时，还可以通过设置以下一个或多个属性来放置阴影：
- en: <dfn class="keep-together">`shadowOffsetX`</dfn>
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`shadowOffsetX`</dfn>
- en: The horizontal offset in pixels by which the shadow should be shifted to the
    right (or to the left if the value is negative).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影向右移动的水平偏移量（如果值为负，则向左移动）。
- en: <dfn class="keep-together">`shadowOffsetY`</dfn>
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`shadowOffsetY`</dfn>
- en: The vertical offset in pixels by which the shadow should be shifted down (or
    up if the value is negative).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影向下移动的垂直偏移量（如果值为负，则向上移动）。
- en: <dfn class="keep-together">`shadowBlur`</dfn>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`shadowBlur`</dfn>
- en: The number of pixels over which to blur the shadow’s outline.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊阴影轮廓的像素数量。
- en: <dfn class="keep-together">`shadowColor`</dfn>
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`shadowColor`</dfn>
- en: The base color to use for the shadow. If a blur is in use, this color will blend
    with the background in the blurred area.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 用于阴影的基础颜色。如果使用了模糊，这种颜色将与模糊区域的背景混合。
- en: These properties can apply to text and lines as well as solid images, as demonstrated
    in [Example 26-21](#applying_shadows_when_drawing_on_the_can), in which some text,
    an image, and an object created using a path all have shadows added to them. In
    [Figure 26-20](#shadows_under_different_types_of_drawing), you can see that the
    shadows intelligently flow around the visible portions of images, not just their
    rectangular boundaries.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性不仅适用于文本和线条，还适用于实心图像，如示例 [26-21](#applying_shadows_when_drawing_on_the_can)
    中所示，其中一些文本、图像和使用路径创建的对象都添加了阴影。在图 [26-20](#shadows_under_different_types_of_drawing)
    中，您可以看到阴影智能地围绕图像的可见部分流动，而不仅仅是其矩形边界。
- en: Example 26-21\. Applying shadows when drawing on the canvas
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-21\. 在画布上绘制时应用阴影
- en: '[PRE56]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '![Shadows under different types of drawing objects](Images/pmj6_2620.png)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![不同类型绘图对象下的阴影](Images/pmj6_2620.png)'
- en: Figure 26-20\. Shadows under different types of drawing objects
  id: totrans-351
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-20\. 不同类型绘图对象下的阴影
- en: Editing at the Pixel Level
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在像素级别编辑
- en: Not only does the HTML5 canvas provide you with a powerful range of drawing
    methods, but it also lets you get your hands dirty and work under the hood directly
    at the pixel level with a trio of powerful methods.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 画布不仅为您提供了强大的绘图方法范围，还允许您在像素级别直接在引擎盖下进行操作，其中包括三种强大的方法。
- en: The getImageData Method
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`getImageData` 方法'
- en: With the `getImageData` method, you can grab a portion (or all) of a canvas
    so that you can alter the retrieved data in any way you like and then save it
    back or elsewhere in the canvas (or to another canvas).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`getImageData`方法，您可以抓取画布的一部分（或全部），以便您可以按任何方式修改检索到的数据，然后将其保存回画布的其他位置（或另一画布）。
- en: To illustrate how this works, [Example 26-22](#manipulating_image_data) first
    loads in a ready-made image and draws it onto a canvas. Then the canvas data is
    read back into an object called `idata`, where all the colors are averaged together
    to change each pixel to grayscale and then tweaked a little to shift each color
    toward sepia, as shown in [Figure 26-21](#converting_an_image_to_sepia_left_parent).
    The following section explains the `data` array of pixels and what happens when
    the value `50` is added to or subtracted from an element of the array.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这是如何工作的，[示例 26-22](#manipulating_image_data) 首先加载一个现成的图像并将其绘制到画布上。然后，画布数据被读取到一个名为`idata`的对象中，其中所有颜色被平均在一起以将每个像素更改为灰度，然后稍微调整以将每种颜色向深褐色移动，如图
    [26-21](#converting_an_image_to_sepia_left_parent) 所示。下一部分解释了像素的`data`数组及当值`50`被添加到或从数组元素中减去时会发生什么。
- en: Example 26-22\. Manipulating image data
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-22\. 操纵图像数据
- en: '[PRE57]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![Converting an image to sepia (only a minor difference will be seen when this
    figure is viewed in gray scale)](Images/pmj6_2621.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![将图像转换为深褐色（在灰度模式下查看此图像时，只会看到细微差异）](Images/pmj6_2621.png)'
- en: Figure 26-21\. Converting an image to sepia (only a minor difference will be
    seen when this figure is viewed in grayscale)
  id: totrans-360
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-21\. 将图像转换为深褐色（在灰度模式下查看此图像时，只会看到细微差异）
- en: The data array
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`data` 数组'
- en: This image manipulation works thanks to the `data` array, which is a property
    of the `idata` object returned by the call to `getImageData`. This method returns
    an array containing all the pixel data for the selected area in its component
    parts of red, green, blue, and alpha transparency. Therefore, four items of data
    are used to store each colored pixel.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这种图像操作依赖于`data`数组，它是通过调用`getImageData`返回的`idata`对象的属性。此方法返回一个包含所选区域的所有像素数据的数组，其组成部分包括红色、绿色、蓝色和
    alpha 透明度。因此，每个彩色像素使用四个数据项来存储。
- en: Many recent browsers have adopted strict security measures to prevent cross-origin
    exploits, which is why we have to add the `crossOrigin` attribute with a value
    of the empty string (representing the default of `'anonymous'`) to the `myimage`
    object in this example, to expressly allow the image data to be read. For the
    same security reasons, the example will only work correctly when served from a
    web server (such as a server online or the AMPPS installation from [Chapter 2](ch02.xhtml#setting_up_a_development_server));
    it will not work correctly when just loaded in from a local filesystem.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 许多最近的浏览器已采纳严格的安全措施以防止跨源攻击，这就是为什么在这个示例中我们必须为`myimage`对象添加`crossOrigin`属性，并将其值设置为空字符串（代表默认值为`'anonymous'`），以明确允许读取图像数据。出于同样的安全原因，该示例只有在从
    Web 服务器（如在线服务器或[第 2 章](ch02.xhtml#setting_up_a_development_server)中的 AMPPS 安装）加载时才能正确工作；在仅从本地文件系统加载时将无法正确工作。
- en: 'All the data is stored sequentially in the `data` array, such that the value
    for red is followed by that for blue, then green, and then alpha; then, the next
    item in the array is the red value for the following pixel, and so on. So, you’ll
    have the following for the pixel at location (0, 0):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 所有数据按顺序存储在`data`数组中，因此红色值的后面是蓝色值，然后是绿色值，最后是透明度值；然后，数组中的下一个项是下一个像素的红色值，依此类推。因此，对于位置(0,
    0)的像素，你将会有以下数值：
- en: '[PRE58]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Location (1, 0) then follows, like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是位置(1, 0)，如下所示：
- en: '[PRE59]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In this image, everything continues in the same fashion until the rightmost
    pixel of the image in row 0—which is the 320th pixel, at location (319, 0)—is
    reached. At that point, the value 319 is multiplied by 4 (the number of items
    of data in each pixel) to arrive at the following array elements, which contain
    this pixel’s data:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图像中，一切都继续以同样的方式进行，直到第一行中最右边的像素——即第0行中的第320像素，位于位置(319, 0)——被达到。此时，将319乘以4（每个像素数据项的数量）以获得以下数组元素，它们包含这个像素的数据：
- en: '[PRE60]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This causes the data pointer to move all the way back to the first column of
    the image, but this time of row 1, at location (0, 1) which (because each row
    in this image is 320 pixels wide) is at an offset of (0 × 4) + (1 × 320 × 4),
    or 1,280:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致数据指针移动回到图像的第一列，但这次是第1行的第一列，即位置(0, 1)，其偏移量为(0 × 4) + (1 × 320 × 4)，即1,280：
- en: '[PRE61]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'So, if the image data is stored in `idata`, the image width in `w`, and the
    pixel location to access in `x` and `y`, the key formulae to use when directly
    accessing image data are:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果图像数据存储在`idata`中，图像宽度为`w`，要访问的像素位置为`x`和`y`，则在直接访问图像数据时使用的关键公式如下：
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Using this knowledge, we create the sepia effect in [Figure 26-12](#drawing_and_filling_in_a_complex_path)
    by taking just the red, blue, and green components of each pixel and averaging
    them, like this (where `pos` is a variable pointer to the location in the array
    of the current pixel):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些知识，我们通过仅获取每个像素的红色、蓝色和绿色分量并求平均值，来创建[图 26-12](#drawing_and_filling_in_a_complex_path)中的棕色效果（其中`pos`是当前像素数组位置的变量指针）：
- en: '[PRE63]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'With `average` now containing the average color value (which we attain by adding
    all the pixel values and dividing by 3), this value is written back to all colors
    of the pixel but with the red boosted by a value of `50` and the blue reduced
    by the same amount:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`average`包含了平均颜色值（通过将所有像素值相加并除以3获得），这个值被写回到像素的所有颜色中，但红色增加了值`50`，蓝色减少了相同数量：
- en: '[PRE64]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The result is to increase the red and reduce the blue level of each pixel (of
    what would otherwise now become a monochrome image, if only the average value
    were written back to these colors), giving it a sepia cast.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是增加每个像素的红色值并减少蓝色值（否则这些颜色只需写回平均值将成为单色图像），从而赋予它棕色色调。
- en: The putImageData Method
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 放置图像数据方法
- en: 'When you’ve modified the image data array to your requirements, all you need
    to do to write it to the canvas, as shown in the previous example, is call the
    `putImageData` method, passing it the `idata` object and the coordinates of the
    top-left corner at which it should appear. The call shown earlier places the modified
    copy of the image to the right of the original:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修改了图像数据数组以满足你的要求后，只需像前面的示例中显示的那样调用`putImageData`方法，传递`idata`对象和应该出现的左上角的坐标即可将其写入画布。之前显示的调用将修改后的图像副本放置在原始图像的右侧：
- en: '[PRE65]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-382
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you wish to modify only part of a canvas, you don’t have to grab the entire
    canvas; just fetch a section containing the area in which you are interested.
    And neither do you have to write back image data to the location from where you
    got it; image data can be written to any part of a canvas.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想修改画布的一部分，你无需获取整个画布；只需获取包含你感兴趣区域的部分。你也不需要将图像数据写回到原来获取它的位置；图像数据可以写入画布的任何部分。
- en: The createImageData Method
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建图像数据方法
- en: 'You don’t have to create an object directly from a canvas; you can also create
    a new one with blank data by calling the `createImageData` method. The following
    example creates an object with a width of 320 and height of 240 pixels:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必直接从画布创建对象；你也可以通过调用`createImageData`方法创建一个新的对象，并使用空白数据。以下示例创建一个宽度为320像素、高度为240像素的对象：
- en: '[PRE66]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Alternatively, you can create a new object from an existing object, like this:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以像这样从现有对象创建一个新对象：
- en: '[PRE67]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: It’s then up to you how you add pixel data to these objects or otherwise modify
    them, how you paste them onto the canvas or create other objects from them, and
    so on.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 然后由您决定如何向这些对象添加像素数据或以其他方式修改它们，如何将它们粘贴到画布上或从它们创建其他对象，等等。
- en: Advanced Graphical Effects
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级图形效果
- en: Among the more advanced features available on the HTML5 canvas is the ability
    to assign various compositing and transparency effects, as well as to apply powerful
    transformations such as scaling, stretching, and rotating.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5画布上的更高级功能之一是能够分配各种合成和透明效果，以及应用强大的转换，如缩放、拉伸和旋转。
- en: The globalCompositeOperation Property
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局合成操作属性
- en: 'There are 12 different methods available to fine-tune the way you place an
    object on the canvas, taking into account existing and future objects. These are
    called *compositing* options, and they are applied like this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 有12种不同的方法可用于精细调整如何在画布上放置对象，考虑到现有和未来的对象。这些称为*合成*选项，并且它们的应用方式如下：
- en: '[PRE68]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The compositing types are as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 合成类型如下：
- en: <dfn class="keep-together">`source-over`</dfn>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`source-over`</dfn>
- en: The default. The source image is copied over the destination image.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 默认。源图像被复制到目标图像上。
- en: <dfn class="keep-together">`source-in`</dfn>
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`source-in`</dfn>
- en: Only parts of the source image that will appear within the destination are shown,
    and the destination image is removed. Any alpha transparency in the source image
    causes the destination under it to be removed.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 只显示出现在目标内的源图像部分，并移除目标图像。源图像的任何alpha透明度会导致其下的目标被移除。
- en: <dfn class="keep-together">`source-out`</dfn>
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`source-out`</dfn>
- en: Only parts of the source image that do not appear within the destination are
    shown, and the destination image is removed. Any alpha transparency in the source
    image causes the destination under it to be removed.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 只显示未出现在目标内的源图像部分，并移除目标图像。源图像的任何alpha透明度会导致其下的目标被移除。
- en: <dfn class="keep-together">`source-atop`</dfn>
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`source-atop`</dfn>
- en: The source image is displayed where it overlays the destination. The destination
    image is displayed where the destination image is opaque and the source image
    is transparent. Other regions are transparent.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 源图像在覆盖目标的地方显示。目标图像在目标不透明且源图像透明时显示。其他区域为透明。
- en: <dfn class="keep-together">`destination-over`</dfn>
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`destination-over`</dfn>
- en: The source image is drawn under the destination image.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 源图像在目标图像下绘制。
- en: <dfn class="keep-together">`destination-in`</dfn>
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`destination-in`</dfn>
- en: The destination image displays where the source and destination image overlap
    but not in any areas of source image transparency. The source image does not display.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在源和目标图像重叠但源图像透明部分不在的区域显示目标图像。源图像不显示。
- en: <dfn class="keep-together">`destination-out`</dfn>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`destination-out`</dfn>
- en: Only those parts of the destination outside of the source image’s nontransparent
    sections are shown. The source image does not display.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 只显示目标中在源图像非透明部分之外的部分。源图像不显示。
- en: <dfn class="keep-together">`destination-atop`</dfn>
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`destination-atop`</dfn>
- en: The source image displays where the destination is not displayed. Where the
    destination and source overlap, the destination image is displayed. Any transparency
    in the source image prevents that area of the destination image being shown.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 源图像显示在目标未显示的位置。目标和源重叠的地方，显示目标图像。源图像的任何透明部分防止目标图像的该区域显示。
- en: <dfn class="keep-together">`lighter`</dfn>
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`lighter`</dfn>
- en: The sum of the source and destination is applied such that where they do not
    overlap, they display as normal; where they do overlap, the sum of both images
    is shown but lightened.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 应用源和目标的总和，以便它们不重叠的地方正常显示；它们重叠的地方，显示两者的总和但变亮。
- en: <dfn class="keep-together">`darker`</dfn>
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`darker`</dfn>
- en: The sum of the source and destination is applied such that where they do not
    overlap, they display as normal; where they do overlap, the sum of both images
    is shown but darkened.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 应用源和目标的总和，以便它们不重叠的地方正常显示；它们重叠的地方，显示两者的总和但变暗。
- en: <dfn class="keep-together">`copy`</dfn>
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`copy`</dfn>
- en: The source image is copied over the destination. Any transparent area of the
    source causes any destination that it overlaps to not display.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 源图像复制到目标上。源的任何透明区域会导致它所覆盖的目标不显示。
- en: <dfn class="keep-together">`xor`</dfn>
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`xor`</dfn>
- en: Where the source and destination images do not overlap, they display as normal.
    Where they do overlap, their color values are exclusive-ored.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 当源和目标图像不重叠时，它们显示为正常。它们重叠的区域，它们的颜色值进行异或运算。
- en: '[Example 26-23](#using_all_12_types_of_compositing_effect) illustrates the
    effect of all of these compositing types by creating 12 different canvases, each
    with two objects (a filled circle and the yin-yang image) offset from each other
    but overlapping.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 26-23](#using_all_12_types_of_compositing_effect) 通过创建 12 个不同的画布来展示所有这些合成类型的效果，每个画布上都有两个对象（一个填充的圆和阴阳图像），它们彼此偏移但有重叠。'
- en: Example 26-23\. Using all 12 types of compositing effects
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-23\. 使用所有 12 种合成效果
- en: '[PRE69]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Note
  id: totrans-423
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As with some other examples in this chapter, this example (downloadable from
    the companion website) includes some HTML and/or CSS to enhance the display, which
    isn’t shown here because it’s not essential to the program’s operation.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章的其他一些示例类似，此示例（可从配套网站下载）包含一些 HTML 和/或 CSS 来增强显示效果，这里未显示因为它对程序的运行不是必需的。
- en: This program uses a `for` loop to iterate through each compositing type, as
    stored in the array `types`. Each time around the loop, a new context is created
    on the next of the 12 canvas elements already created in some earlier HTML (not
    shown), with the IDs of `c1` through `c12`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序使用 `for` 循环来迭代存储在数组 `types` 中的每种合成类型。每次循环时，在先前某些 HTML（未显示）中已经创建的 12 个画布元素上创建一个新的上下文，它们的
    ID 分别为 `c1` 到 `c12`。
- en: In each canvas, a 100-pixel-diameter red circle is first placed at the top left,
    and then the compositing type is selected and the yin-yang image is placed over
    the circle but offset to the right and down by 20 pixels. [Figure 26-22](#one2_compositing_effects_in_action)
    shows the results of each type in action. As you can see, it’s possible to achieve
    a wide variety of effects.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个画布上，首先放置一个直径为 100 像素的红色圆在左上角，然后选择合成类型并将阴阳图像放置在圆上，但向右和向下偏移 20 像素。[图 26-22](#one2_compositing_effects_in_action)
    显示了每种类型的效果。正如你所见，可以实现多种效果。
- en: '![The 12 compositing effects in action](Images/pmj6_2622.png)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![12 种合成效果示例](Images/pmj6_2622.png)'
- en: Figure 26-22\. The 12 compositing effects in action
  id: totrans-428
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-22\. 12 种合成效果示例
- en: The globalAlpha Property
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: globalAlpha 属性
- en: 'When drawing on the canvas, you can specify the amount of transparency to apply
    using the `globalAlpha` property, which supports values from `0` (fully transparent)
    to `1` (fully opaque). The following command sets the alpha to a value of `0.9`,
    such that future draw operations will be 90% opaque (or 10% transparent):'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在画布上绘图时，可以使用 `globalAlpha` 属性指定要应用的透明度，支持从 `0`（完全透明）到 `1`（完全不透明）的值。以下命令将 alpha
    设置为 `0.9`，使得未来的绘图操作将是 90% 不透明（或 10% 透明）：
- en: '[PRE70]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This property can be used with all other properties, including the compositing
    options.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性可与所有其他属性一起使用，包括合成选项。
- en: Transformations
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变换
- en: 'The canvas supports four functions for applying transformations to elements
    when drawing them to the HTML5 canvas: `scale`, `rotate`, `translate`, and `transform`.
    They can be used alone or together to produce even more interesting effects.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在将元素绘制到 HTML5 画布时，画布支持四个函数来应用变换：`scale`、`rotate`、`translate` 和 `transform`。它们可以单独或一起使用，产生更加有趣的效果。
- en: The scale Method
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缩放方法
- en: You can scale future drawing operations by first calling the `scale` method.
    This method takes horizontal and vertical scaling factors, which can be negative,
    zero, or positive.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过首先调用 `scale` 方法来缩放未来的绘图操作。该方法接受水平和垂直缩放因子，可以为负、零或正。
- en: In [Example 26-24](#scaling_up_and_down_in_size), the yin-yang image is drawn
    to the canvas at its original size of 100 × 100 pixels. Then scaling of three
    times horizontally and two times vertically is applied, and the `drawImage` function
    is called again to place the stretched image next to the original. Finally, scaling
    is reapplied with values of `0.33` and `0.5` to restore everything back to normal,
    and the image is once more drawn, this time below the original. [Figure 26-23](#scaling_an_image_up_and_then_down_again)
    shows the result.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 26-24](#scaling_up_and_down_in_size)中，阴阳图像以其原始尺寸100 × 100像素绘制到画布上。然后水平放大三倍和垂直放大两倍，再次调用`drawImage`函数将伸展的图像放置在原始图像旁边。最后，使用值为`0.33`和`0.5`再次应用缩放来恢复一切正常，并且再次绘制图像，这次是在原始图像下方。[图 26-23](#scaling_an_image_up_and_then_down_again)显示了结果。
- en: Example 26-24\. Scaling up and down in size
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例26-24\. 放大和缩小尺寸
- en: '[PRE71]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![Scaling an image up and then down again](Images/pmj6_2623.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![将图像放大然后再次缩小](Images/pmj6_2623.png)'
- en: Figure 26-23\. Scaling an image up and then down again
  id: totrans-441
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图26-23\. 将图像放大然后再次缩小
- en: If you look carefully, you may notice that the copy image under the original
    is a little bit fuzzy due to the scaling up and then down.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细观察，你会发现原图下方的复制图像由于放大和再次缩小而变得稍微模糊了一点。
- en: 'By using negative values for one or more scaling parameters, you can reverse
    an element in either the horizontal or vertical direction (or both) at the same
    time as (or instead of) scaling. For example, the following flips the context
    to create a mirror image:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个或多个缩放参数的负值，你可以在水平或垂直方向（或两者）中反转一个元素，同时（或代替）缩放。例如，以下代码翻转上下文以创建镜像图像：
- en: '[PRE72]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The save and restore Methods
  id: totrans-445
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`save`和`restore`方法'
- en: If you need to use several scaling operations on different drawing elements,
    not only can you introduce fuzziness into the results, but it can also be very
    time-consuming to calculate that a three-times upward scaling requires a `0.33`
    value to scale back down again (and a two-times upscale requires a value of `0.5`
    to reverse).
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要对不同绘图元素进行多次缩放操作，不仅可能会使结果变得模糊，而且计算起来也会非常耗时，例如，三倍放大后再缩小需要`0.33`的值来还原（而两倍放大则需要`0.5`的值来逆转）。
- en: 'For this reason, you can call `save` to save the current context before issuing
    a `scale` call and later return scaling back to normal by issuing a `restore`
    call. Check out the following, which can replace the code in [Example 26-24](#scaling_up_and_down_in_size):'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以在发出`scale`调用之前调用`save`保存当前上下文，并在稍后通过`restore`调用将缩放恢复到正常。查看下面的示例，可以替换[示例 26-24](#scaling_up_and_down_in_size)中的代码：
- en: '[PRE73]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `save` and `restore` methods are very powerful because they don’t just
    apply to image scaling. In fact, they apply across all the following properties
    and can therefore be used at any time to save the current properties and then
    restore them later: `fillStyle`, `font`, `globalAlpha`, `globalCompositeOperation`,
    `lineCap`, `lineJoin`, `lineWidth`, `miterLimit`, `shadowBlur`, `shadowColor`,
    `shadowOffsetX`, `shadowOffsetY`, `strokeStyle`, `textAlign`, and `textBaseline`.
    The properties of all four transformation methods are also managed by `save` and
    `restore`: `scale`, `rotate`, `translate`, and `transform`.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`save`和`restore`方法非常强大，因为它们不仅适用于图像缩放，实际上它们适用于以下所有属性，并且因此可以随时用于保存当前属性，然后稍后恢复它们：`fillStyle`、`font`、`globalAlpha`、`globalCompositeOperation`、`lineCap`、`lineJoin`、`lineWidth`、`miterLimit`、`shadowBlur`、`shadowColor`、`shadowOffsetX`、`shadowOffsetY`、`strokeStyle`、`textAlign`和`textBaseline`。所有四个转换方法的属性也由`save`和`restore`管理：`scale`、`rotate`、`translate`和`transform`。'
- en: The rotate Method
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旋转方法
- en: Using the `rotate` method, you can choose the angle at which to apply an object
    (or any of the drawing methods) to the canvas. The angle is specified in radians,
    which are the same as 180 / π, or about 57 degrees, each.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`rotate`方法，你可以选择应用对象（或任何绘图方法）到画布的角度。角度用弧度指定，与180 / π相同，约为57度。
- en: Rotation takes place around the canvas origin, which, by default, is its top-left
    corner (but as you’ll see shortly, this can be changed). [Example 26-25](#rotating_an_image)
    displays the yin-yang image four times, rotating each consecutive image by `Math.PI`
    / `25` radians.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转发生在画布原点周围，默认情况下是左上角（但很快你会看到，这可以更改）。[示例 26-25](#rotating_an_image)展示了四次显示阴阳图像，每个连续的图像旋转`Math.PI`
    / `25`弧度。
- en: Example 26-25\. Rotating an image
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例26-25\. 旋转图像
- en: '[PRE74]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As you can see in [Figure 26-24](#image_at_four_different_rotations), the result
    may not be quite what you expect, because the image hasn’t been rotated about
    itself. Rather, the rotations have taken place around the canvas origin at location
    (0, 0). What’s more, each new rotation has compounded the previous one. However,
    to correct for these things, you can always use the `translate` method in conjunction
    with the `save` and `restore` methods.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在[图 26-24](#image_at_four_different_rotations) 中，结果可能并非你所期望的，因为图像并未围绕自身旋转。相反，旋转发生在画布原点（位置为（0,
    0））。更重要的是，每次新的旋转都累加了前一个旋转。但是，为了纠正这些问题，你可以始终使用`translate`方法与`save`和`restore`方法结合使用。
- en: '![An image at four different rotations](Images/pmj6_2624.png)'
  id: totrans-456
  prefs: []
  type: TYPE_IMG
  zh: '![四种不同旋转角度的图像](Images/pmj6_2624.png)'
- en: Figure 26-24\. An image at four different rotations
  id: totrans-457
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-24\. 四种不同旋转角度的图像
- en: Note
  id: totrans-458
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Radians are a sensible unit of measurement because there are π × 2 radians in
    a complete circle. So, π radians is a half-circle, π ÷ 2 radians is a quarter
    circle, π ÷ 2 × 3 (or π × 1.5) radians is three-quarters of a circle, and so on.
    To save having to remember the value of π, you can always refer to the value in
    `Math.PI`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度是一个合理的度量单位，因为一个完整圆有 π × 2 弧度。因此，π 弧度是半圆，π ÷ 2 弧度是一个四分之一圆，π ÷ 2 × 3（或 π × 1.5）弧度是三分之三圆，等等。为了避免记住
    π 的值，你可以随时参考`Math.PI`中的值。
- en: The translate Method
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: translate 方法
- en: To change the origin of a rotation, you can call the `translate` method to shift
    it to somewhere else. The destination can be anywhere inside (or outside) the
    canvas. Usually, you specify a point somewhere within the destination location
    of the object (typically its center).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变旋转的原点，你可以调用`translate`方法将其移动到其他位置。目标位置可以在画布内（或外）的任何地方。通常，你会指定对象目标位置内的某个点（通常是其中心）。
- en: '[Example 26-26](#rotating_objects_in_place) performs this translation prior
    to each call to `rotate`, now resulting in the effect that was probably intended
    by the previous example. Additionally, the `save` and `restore` methods are called
    before and after each operation to ensure that each rotation is applied independently,
    not compounded on the previous one.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 26-26](#rotating_objects_in_place) 在每次调用`rotate`之前执行此转换，现在产生了可能由前面示例意图的效果。此外，在每次操作之前和之后调用`save`和`restore`方法，确保每次旋转都是独立应用的，而不是在上一个旋转的基础上累加的。'
- en: Example 26-26\. Rotating objects in place
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-26\. 在原地旋转对象
- en: '[PRE75]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: In this example, before each rotation the context is saved and the origin is
    translated to a point exactly in the center of where each image will be drawn.
    We then issue the rotation and draw the image up and to the left of the new origin
    by supplying negative values, such that its center matches the origin point. The
    result of this is shown in [Figure 26-25](Images/#rotating_images_in_place).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，在每次旋转之前，上下文被保存，并且原点被转换到每个图像将被绘制的确切中心点。然后我们发出旋转指令，并通过提供负值将图像绘制到新原点的左上方，使其中心与原点匹配。其结果显示在[图 26-25](Images/#rotating_images_in_place)
    中。
- en: '![Rotating images in place](Images/pmj6_2625.png)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![旋转图像](Images/pmj6_2625.png)'
- en: Figure 26-25\. Rotating images in place
  id: totrans-467
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-25\. 在原地旋转图像
- en: 'To recap: when you wish to rotate or transform (described next) an object in
    place, you should perform the following actions:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：当你希望在原地旋转或变换（接下来描述）一个对象时，你应该执行以下操作：
- en: Save the context.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存上下文。
- en: Translate the canvas origin to the center of where the object is to be placed.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将画布原点转换为要放置对象的中心。
- en: Issue the rotation or transformation instruction.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发出旋转或变换指令。
- en: Draw the object with any drawing method supported, using a negative destination
    location point half the object’s width to the left and half its height upward.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用任何支持的绘图方法绘制对象，使用负的目标位置点宽度的一半向左和高度的一半向上绘制。
- en: Restore the context to revert the origin.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 恢复上下文以恢复原点。
- en: The transform Method
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: transform 方法
- en: When you’ve exhausted all the other canvas features and still can’t manipulate
    objects in just the way you need, it’s time to turn to the `transform` method.
    With it, you can apply a transformation matrix to the objects you draw to the
    canvas, giving you a multitude of possibilities and powerful features that can
    combine scaling and rotating in a single instruction.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当你已经尝试过所有其他画布功能，但仍无法以你需要的方式操纵对象时，就该使用`transform`方法了。使用它，你可以在画布上绘制的对象应用变换矩阵，给你提供多种可能性和强大的功能，可以在单个指令中结合缩放和旋转。
- en: 'The transformation matrix used by this method is a 3 × 3 matrix of 9 values,
    but only 6 of these are supplied externally to the `transform` method. So, rather
    than explain how this matrix multiplication works, I only need to explain the
    effects of its six arguments, which, in order, are as follows (the order may be
    a little counterintuitive):'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用的转换矩阵是一个3 × 3矩阵，具有9个值，但只有6个是外部提供给`transform`方法的。因此，与其解释这个矩阵乘法是如何工作的，我只需要解释其六个参数的效果，依次是（顺序可能有点反直觉）：
- en: Horizontal scale
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水平缩放
- en: Horizontal skew
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水平斜切
- en: Vertical skew
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垂直斜切
- en: Vertical scale
  id: totrans-480
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垂直缩放
- en: Horizontal translate
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 水平平移
- en: Vertical translate
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 垂直平移
- en: 'You can apply these values in many ways—for example, by emulating the `scale`
    method from [Example 26-24](#scaling_up_and_down_in_size) by replacing this call:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过多种方式应用这些值，例如，通过模仿[示例 26-24](#scaling_up_and_down_in_size)中的`scale`方法来替换这个调用：
- en: '[PRE76]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'with the following:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是：
- en: '[PRE77]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'In the same way, you can replace this call from [Example 26-26](#rotating_objects_in_place):'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以用[示例 26-26](#rotating_objects_in_place)中的这个调用替换它：
- en: '[PRE78]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'with the following:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是：
- en: '[PRE79]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-491
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note how the horizontal and vertical scaling arguments are given values of `1`
    to ensure a 1:1 result, while the skew values are `0` to prevent the result from
    being skewed.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，水平和垂直缩放参数被赋予值`1`，以确保1:1的结果，而斜切值为`0`，以防止结果被斜切。
- en: 'You could even combine the previous two lines of code to get a translation
    and scale at the same time, like this:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以结合前两行代码一起进行翻译和同时缩放，就像这样：
- en: '[PRE80]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As you might expect, the skew arguments slant an element in the direction specified—for
    example, creating a rhombus from a square.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预料的，斜切参数会将元素按指定方向倾斜，例如，从正方形创建一个菱形。
- en: As another example of skew, [Example 26-27](#creating_an_original_and_skewed_image)
    draws the yin-yang image on the canvas, followed by a skewed copy created with
    the `transform` method. The skew value can be any negative, zero, or positive
    amount, but I chose a horizontal value of `1`, which has skewed the bottom of
    the image by one image width to the right and pulled everything else along with
    it proportionally (see [Figure 26-26](#horizontally_skewing_an_object_to_the_ri)).
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 作为斜切的另一个例子，[示例 26-27](#creating_an_original_and_skewed_image)在画布上绘制阴阳图像，然后用`transform`方法创建一个斜切副本。斜切值可以是任何负数、零或正数，但我选择了水平值为`1`，这使得图像底部向右斜切了一个图像宽度，并按比例拉动了其他部分（见[图 26-26](#horizontally_skewing_an_object_to_the_ri)）。
- en: Example 26-27\. Creating an original and skewed image
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-27\. 创建一个原始和斜切的图像
- en: '[PRE81]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '![Horizontally skewing an object to the right](Images/pmj6_2626.png)'
  id: totrans-499
  prefs: []
  type: TYPE_IMG
  zh: '![将对象水平向右斜切](Images/pmj6_2626.png)'
- en: Figure 26-26\. Horizontally skewing an object to the right
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图26-26\. 将对象水平向右倾斜
- en: Note
  id: totrans-501
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can even rotate an object with `transform` by supplying one negative and
    one opposite positive skew value. But beware: when you do this, you’ll modify
    the size of an element and will therefore also need to adjust the scale arguments
    at the same time. Plus, you’ll need to remember to translate the origin. Thus,
    I recommend sticking with the `rotate` method for this until you are fully experienced
    with using `transform`.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以通过提供一个负值和一个相反的正斜切值来用`transform`旋转一个对象。但要注意：这样做会修改元素的大小，因此你还需要同时调整比例参数。另外，你需要记住平移原点。因此，我建议在完全熟练使用`transform`之前，坚持使用`rotate`方法。
- en: The setTransform Method
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: setTransform方法
- en: 'As an alternative to using the `save` and `restore` methods, you can set an
    absolute transform, which has the effect of resetting the transformation matrix
    and then applying the supplied values. Use the `setTransform` method just like
    `transform`, as in this example (which applies a horizontal positive skew with
    the value `1`):'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用`save`和`restore`方法的替代方案，你可以设置绝对变换，这将重置变换矩阵，然后应用提供的值。像这样使用`setTransform`方法（它应用了一个水平正斜切值为`1`的例子）：
- en: '[PRE82]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Note
  id: totrans-506
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about transformation matrixes, see the [Wikipedia article](https://tinyurl.com/transform-matrix).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于变换矩阵的信息，请参阅[Wikipedia文章](https://tinyurl.com/transform-matrix)。
- en: 'The HTML5 canvas is a tremendous asset for web developers to make bigger, better,
    and more professional and compelling websites. In the following chapter, we’ll
    take a look at two other great HTML5 features: in-browser, plug-in-free audio
    and video.'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5画布是网页开发者制作更大、更好、更专业和更引人入胜网站的重要资产。在接下来的章节中，我们将看看另外两个伟大的HTML5功能：无需插件的浏览器内音频和视频。
- en: Questions
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you create a canvas element in HTML?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 HTML 中创建一个画布元素？
- en: How do you give JavaScript access to a canvas element?
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何让 JavaScript 访问画布元素？
- en: How do you start and finish the creation of a canvas path?
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何开始和结束创建画布路径？
- en: What method can you use to extract data from a canvas into an image?
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用什么方法将画布中的数据提取成图像？
- en: How can you create gradient fills of more than two colors?
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建包含超过两种颜色的渐变填充？
- en: How can you adjust the width of lines when drawing?
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在绘图时如何调整线条的宽度？
- en: Which method would you use to specify a section of a canvas such that future
    drawing takes place only within that area?
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪种方法来指定画布的一个部分，以便未来的绘图只发生在那个区域内？
- en: How can you draw a complex curve with two imaginary attractors?
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何用两个虚拟吸引子绘制复杂曲线？
- en: How many items of data per pixel are returned by the `getImageData` method?
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getImageData` 方法每像素返回多少个数据项？'
- en: Which two parameters to the `transform` method apply to scaling operations?
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`transform` 方法的哪两个参数用于缩放操作？'
- en: See [“Chapter 26 Answers”](app01_split_025.xhtml#chapter_26_answers) in the
    [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions) for the
    answers to these questions.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[“第26章答案”](app01_split_025.xhtml#chapter_26_answers)，在[附录 A](app01_split_000.xhtml#solutions_to_the_chapter_questions)中找到这些问题的答案。
