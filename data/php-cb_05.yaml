- en: Chapter 5\. Numbers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 数字
- en: Another fundamental building block of data in PHP is numbers. It’s easy to find
    different types of numbers in the world around us. The page number in a book is
    often printed in the footer. Your smartwatch displays the current time and perhaps
    the number of steps you’ve taken today. Some numbers can be impossibly large,
    others impossibly small. Numbers can be whole, fractional, or irrational like
    π.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 数据的另一个基本构建块是数字。在我们周围的世界中很容易找到不同类型的数字。书中的页码通常打印在页脚上。你的智能手表显示当前时间，也许还有你今天走的步数。一些数字可能非常大，另一些可能非常小。数字可以是整数、分数，或者是像
    π 这样的无理数。
- en: 'In PHP, numbers are represented natively in one of two formats: as integers
    (the `int` type) or as floating-point numbers (the `float` type). Both numeric
    types are highly flexible, but the range of values you can use depends on the
    processor architecture of your system—​a 32-bit system has tighter bounds than
    a 64-bit system.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中，数字可以以两种格式之一本地表示：作为整数（int 类型）或浮点数（float 类型）。两种数值类型都非常灵活，但你可以使用的值的范围取决于你系统的处理器架构
    — 32 位系统比 64 位系统有更严格的边界。
- en: PHP defines several constants that help programs understand the available range
    of numbers in the system. Given that the capabilities of PHP will differ greatly
    based on how it was compiled (for 32 or 64 bits), it is wise to use the constants
    defined in [Table 5-1](#php_numeric_constants) rather than trying to determine
    what these values will be in a program. It’s always safer to defer to the operating
    system and language defaults.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 定义了几个常量，帮助程序理解系统中可用数字的范围。考虑到 PHP 的能力因编译方式不同（32位或64位）而有显著差异，最好使用在 [表 5-1](#php_numeric_constants)
    中定义的常量，而不是尝试在程序中确定这些值将会是什么。最安全的做法是遵循操作系统和语言的默认设置。
- en: Table 5-1\. Constant numeric values in PHP
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1. PHP 中的常量数值
- en: '| Constant | Description |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PHP_INT_MAX` | The largest integer value supported by PHP. On 32-bit systems,
    this will be `2147483647`. On 64-bit systems, this will be `9223372036854775807`.
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_INT_MAX` | PHP 支持的最大整数值。在 32 位系统上，这个值是 `2147483647`。在 64 位系统上，这个值是 `9223372036854775807`。
    |'
- en: '| `PHP_INT_MIN` | The smallest integer value supported by PHP. On 32-bit systems,
    this will be `-2147483648`. On 64-bit systems, this will be `-9223372036854775808`.
    |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_INT_MIN` | PHP 支持的最小整数值。在 32 位系统上，这个值是 `-2147483648`。在 64 位系统上，这个值是
    `-9223372036854775808`。 |'
- en: '| `PHP_INT_SIZE` | Size of integers in bytes for this build of PHP. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_INT_SIZE` | 此 PHP 构建中整数的字节大小。 |'
- en: '| `PHP_FLOAT_DIG` | Number of digits that can be rounded in a `float` and back
    without a loss in precision. |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_FLOAT_DIG` | 可以在 `float` 中往返舍入的位数，而不会丢失精度。 |'
- en: '| `PHP_FLOAT_​EPSI⁠LON` | The smallest representable positive number `*x*`
    such that `*x* + 1.0 !== 1.0`. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_FLOAT_​EPSI⁠LON` | 最小可表示的正数 `*x*`，使得 `*x* + 1.0 !== 1.0`。 |'
- en: '| `PHP_FLOAT_MIN` | Smallest representable positive floating-point number.
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_FLOAT_MIN` | 可以表示的最小正浮点数。 |'
- en: '| `PHP_FLOAT_MAX` | Largest representable floating-point number. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_FLOAT_MAX` | 可以表示的最大浮点数。 |'
- en: '| `-PHP_FLOAT_MAX` | Not a separate constant, but the way to represent the
    smallest negative floating-point number. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `-PHP_FLOAT_MAX` | 不是单独的常量，但是表示最小负浮点数的方式。 |'
- en: The unfortunate limitation of PHP’s number systems is that very large or very
    small numbers cannot be represented natively. Instead, you need to leverage an
    extension like [BCMath](https://oreil.ly/qFeO3) or [GNU Multiple Precision Arithmetic
    Library (GMP)](https://oreil.ly/u9Mbf), both of which wrap operating system–native
    operations on numbers. I’ll cover GMP specifically in [Recipe 5.10](#very_large_or_small_numbers).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 数字系统的不幸限制在于非常大或非常小的数字无法本地表示。相反，你需要利用像 [BCMath](https://oreil.ly/qFeO3) 或
    [GNU 多精度算术库 (GMP)](https://oreil.ly/u9Mbf) 这样的扩展，两者都包装了操作系统原生的数字操作。我将在 [Recipe
    5.10](#very_large_or_small_numbers) 中具体介绍 GMP。
- en: The recipes that follow cover many of the problems developers need to solve
    with numbers in PHP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的配方涵盖了 PHP 中开发者需要解决的许多与数字相关的问题。
- en: 5.1 Validating a Number Within a Variable
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.1 在变量中验证一个数字
- en: Problem
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to check whether a variable contains a number, even if that variable
    is explicitly typed as a string.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要检查一个变量是否包含一个数字，即使该变量明确被声明为字符串类型。
- en: Solution
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `is_numeric()` to check whether a variable can be successfully cast as
    a numeric value—for example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `is_numeric()` 来检查一个变量是否可以成功转换为数值，例如：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding example will print the following when run in a console:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台中运行时，上述示例将打印以下内容：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Discussion
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: At its core, PHP is a dynamically typed language. You can easily interchange
    strings for integers (and vice versa), and PHP will try to infer your intention,
    dynamically casting values from one type to another as needed. While you can (and
    probably should) enforce strict typing as discussed in [Recipe 3.4](ch03.html#argument_and_return_typing),
    often you will explicitly need to encode numbers as strings.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，PHP是一种动态类型语言。您可以轻松地将字符串与整数（反之亦然）进行交换，并且PHP将尝试推断您的意图，根据需要动态地将值从一种类型转换为另一种类型。虽然您可以（并且可能应该）像[配方 3.4](ch03.html#argument_and_return_typing)中讨论的那样强制执行严格类型，但通常您需要显式地将数字编码为字符串。
- en: In those situations, you will lose the ability to identify numeric strings by
    leveraging PHP’s type system. A variable passed into a function as a `string`
    will be invalid for mathematical operations without an explicit cast to a numeric
    type (`int` or `float`). Unfortunately, not every string that contains numbers
    is numeric.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您将失去利用PHP类型系统识别数值字符串的能力。将一个作为`string`传递到函数中的变量，在没有显式强制转换为数值类型（`int`或`float`）的情况下，将无法进行数学运算。不幸的是，并非每个包含数字的字符串都是数值的。
- en: The string `15 apples` contains a number but is not numeric. The string `10e10`
    contains non-numeric characters but is a valid numeric representation.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串`15 apples`包含一个数字但不是数值。字符串`10e10`包含非数值字符但是有效的数值表示。
- en: The difference between strings that have numbers and truly numeric strings can
    be best illustrated through a userland implementation of PHP’s native `is_numeric()`
    function, as defined in [Example 5-1](#userland_is_numeric).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 数字字符串和真正的数值字符串之间的差异可以通过PHP的本地`is_numeric()`函数的用户空间实现来最好地说明，如[示例 5-1](#userland_is_numeric)所定义。
- en: Example 5-1\. Userland `is_numeric()` implementation
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 用户空间`is_numeric()`实现
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Applied to the same array of `$candidates` from the Solution example, [Example 5-1](#userland_is_numeric)
    will accurately verify numeric strings in everything *except* the literal `INF`
    constant and the `10e10` exponent shorthand. This is because `floatval()` will
    strip any non-numeric characters from the string entirely while converting it
    to a floating-point number prior to `(string)` casting things back to a string.^([1](ch05.html#idm45875173113616))
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于与解决方案示例中相同的`$candidates`数组，[示例 5-1](#userland_is_numeric) 将准确验证几乎所有的数值字符串，除了字面上的`INF`常量和`10e10`指数缩写。这是因为在将其转换为浮点数之前，`floatval()`
    将完全去除字符串中的任何非数值字符，同时进行`(string)`强制类型转换。
- en: The userland implementation isn’t adequate for every situation, so you should
    use the native implementation to be safe. The goal of `is_numeric()` is to indicate
    whether a given string can be safely cast to a numeric type without losing information.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 用户空间实现并不适用于每种情况，因此您应该使用本机实现以确保安全。`is_numeric()`的目标是指示给定的字符串是否可以安全地转换为数值类型而不会丢失信息。
- en: See Also
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation for [`is_numeric()`](https://oreil.ly/jTGcF).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: PHP [`is_numeric()`](https://oreil.ly/jTGcF)的文档。
- en: 5.2 Comparing Floating-Point Numbers
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.2 比较浮点数
- en: Problem
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to test for equality of two floating-point numbers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要测试两个浮点数的相等性。
- en: Solution
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Define an appropriate error bound (called `epsilon`) that represents the greatest
    acceptable difference between the two numbers and evaluate their difference against
    it as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个合适的误差界限（称为`epsilon`），表示两个数之间的最大可接受差异，并按以下方式评估它们的差异：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Discussion
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Floating-point arithmetic with modern computers is less than exact because of
    the way machines internally represent numbers. Different operations you might
    calculate by hand and assume to be precise can trip up the machines you rely on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机的浮点运算由于机器内部表示数字的方式而不那么精确。您可能手工计算并假设是精确的不同操作可能会让您依赖的机器出现问题。
- en: For example, the mathematic operation `1 - 0.83` is obviously `0.17`. It’s simple
    enough to mentally calculate or even work out on paper. But asking a computer
    to calculate this will produce a strange result, as demonstrated in [Example 5-2](#float_subtraction_example).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数学运算`1 - 0.83`显然是`0.17`。这足够简单，在头脑中计算甚至在纸上工作出来。但是让计算机计算这个将产生一个奇怪的结果，正如在[示例 5-2](#float_subtraction_example)中演示的那样。
- en: Example 5-2\. Floating-point subtraction
  id: totrans-45
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. 浮点数减法
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_numbers_CO1-1)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_numbers_CO1-1)'
- en: '`bool(false)`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool(false)`'
- en: '[![2](assets/2.png)](#co_numbers_CO1-2)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_numbers_CO1-2)'
- en: '`float(0.17)`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`float(0.17)`'
- en: '[![3](assets/3.png)](#co_numbers_CO1-3)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_numbers_CO1-3)'
- en: '`float(0.17000000000000004)`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`float(0.17000000000000004)`'
- en: When it comes to floating-point arithmetic, the best computers can do is an
    approximate result within an acceptable margin of error. As a result, comparing
    this result to an expected value requires the explicit definition of that margin
    (`epsilon`) and a comparison to that margin rather than an exact value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及浮点运算时，计算机能够做到的最好结果是在可接受误差范围内的近似结果。因此，将此结果与预期值进行比较需要明确定义该误差（`epsilon`）并与该误差进行比较，而不是与精确值进行比较。
- en: Rather than leverage either of PHP’s equality operators (a double or triple
    equals sign), you can define a function to check for the *relative* equality of
    two floats, as shown in [Example 5-3](#float_equality).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 与其利用 PHP 的任一等式运算符（双或三个等号），不如定义一个函数来检查两个浮点数的*相对*相等性，如[示例 5-3](#float_equality)所示。
- en: Example 5-3\. Comparing equality of floating-point numbers
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. 比较浮点数的相等性
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_numbers_CO2-1)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_numbers_CO2-1)'
- en: '`bool(false)`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool(false)`'
- en: '[![2](assets/2.png)](#co_numbers_CO2-2)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_numbers_CO2-2)'
- en: '`bool(false)`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool(false)`'
- en: '[![3](assets/3.png)](#co_numbers_CO2-3)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_numbers_CO2-3)'
- en: '`bool(false)`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool(false)`'
- en: '[![4](assets/4.png)](#co_numbers_CO2-4)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_numbers_CO2-4)'
- en: '`bool(true)`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool(true)`'
- en: '[![5](assets/5.png)](#co_numbers_CO2-5)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_numbers_CO2-5)'
- en: '`bool(true)`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool(true)`'
- en: '[![6](assets/6.png)](#co_numbers_CO2-6)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_numbers_CO2-6)'
- en: '`bool(true)`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`bool(true)`'
- en: See Also
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [floating-point numbers](https://oreil.ly/-311_).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 文档中关于[浮点数](https://oreil.ly/-311_)的介绍。
- en: 5.3 Rounding Floating-Point Numbers
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.3 浮点数四舍五入
- en: Problem
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to round a floating-point number either to a fixed number of decimal
    places or to an integer.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将浮点数要么舍入到指定的小数位数，要么舍入到整数。
- en: Solution
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'To round a floating-point number to a set number of decimal places, use `round()`
    while specifying the number of places:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要将浮点数舍入到指定小数位数，使用 `round()` 并指定小数位数：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To explicitly round up to the nearest whole number, use `ceil()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确地向上舍入到最接近的整数，使用 `ceil()`：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To explicitly round down to the nearest whole number, use `floor()`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要明确地向下舍入到最接近的整数，使用 `floor()`：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: All three functions referenced in the Solution examples—`round()`, `ceil()`,
    and `floor()`—are intended to operate on any numeric value but will return a `float`
    after operating on it. By default, `round()` will round to zero digits after the
    decimal point but will still return a floating-point number.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例中提到的三个函数——`round()`、`ceil()` 和 `floor()`——旨在对任何数值进行操作，但在操作后将返回一个浮点数。默认情况下，`round()`
    将四舍五入到小数点后零位，但仍将返回一个浮点数。
- en: To convert from a `float` to an `int` for any of these functions, wrap the function
    itself in `intval()` to convert to an integer type.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将 `float` 转换为 `int` 以便应用这些函数中的任何一个，请将函数本身包装在 `intval()` 中以转换为整数类型。
- en: 'Rounding in PHP is more flexible than merely rounding up or down. By default,
    `round()` will always round the input number away from 0 when it’s halfway there.
    This means numbers like 1.4 will round down, while 1.5 will round up. This also
    holds true with negative numbers: −1.4 will be rounded towards 0 to −1, while
    −1.5 will be rounded away from 0 to −2.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中进行四舍五入比仅仅向上或向下舍入更为灵活。默认情况下，`round()` 函数在数字正好处于中间值时，会向远离 0 的方向进行舍入。这意味着像
    1.4 这样的数字会向下舍入，而 1.5 则会向上舍入。负数同样适用：−1.4 会向 0 舍入到 −1，而 −1.5 则会远离 0 舍入到 −2。
- en: You can change the behavior of `round()` by passing an optional third argument
    (or by using named parameters as shown in [Recipe 3.3](ch03.html#named_function_parameters))
    to specify the rounding mode. This argument accepts one of four default constants
    defined by PHP, as enumerated in [Table 5-2](#php_rounding_constants).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递可选的第三个参数（或像[Recipe 3.3](ch03.html#named_function_parameters)中显示的使用命名参数），可以更改
    `round()` 的行为以指定舍入模式。该参数接受 PHP 定义的四个默认常量之一，如[表 5-2](#php_rounding_constants)所列。
- en: Table 5-2\. Rounding mode constants
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-2\. 舍入模式常量
- en: '| Constant | Description |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 常量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PHP_ROUND_HALF_UP` | Rounds a value away from 0 when it is halfway there,
    making 1.5 into 2 and −1.5 into −2 |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_ROUND_HALF_UP` | 当数字正好处于中间值时，远离 0 进行舍入，使得 1.5 变成 2，−1.5 变成 −2 |'
- en: '| `PHP_ROUND_HALF_DOWN` | Rounds a value towards 0 when it is halfway there,
    making 1.5 into 1 and −1.5 into −1 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_ROUND_HALF_DOWN` | 当数字正好处于中间值时，向 0 舍入，使得 1.5 变成 1，−1.5 变成 −1 |'
- en: '| `PHP_ROUND_HALF_EVEN` | Rounds a value towards the nearest even value when
    it is halfway there, making both 1.5 and 2.5 into 2 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_ROUND_HALF_EVEN` | 当值处于中间时，将其向最接近的偶数值舍入，使 1.5 和 2.5 都变为 2 |'
- en: '| `PHP_ROUND_HALF_ODD` | Rounds a value towards the nearest odd value when
    it is halfway there, making 1.5 into 1 and 2.5 into 3 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `PHP_ROUND_HALF_ODD` | 当值处于中间时，将其向最接近的奇数值舍入，使 1.5 变为 1，2.5 变为 3 |'
- en: '[Example 5-4](#php_rounding_with_modes) illustrates the effect of each rounding
    mode constant when applied to the same numbers.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 5-4](#php_rounding_with_modes) 阐明了在应用于相同数字时每个舍入模式常量的效果。'
- en: Example 5-4\. Rounding floats in PHP with different modes
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-4\. 使用不同模式在 PHP 中对浮点数进行四舍五入
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding example will print the following to your console:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将以下内容打印到控制台：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: See Also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [floating-point numbers](https://oreil.ly/ONHjD), the [`round()`](https://oreil.ly/010CB)
    function, the [`ceil()`](https://oreil.ly/i5Rpy) function, and the [`floor()`](https://oreil.ly/VAZ6t)
    function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 文档关于 [浮点数](https://oreil.ly/ONHjD)，[`round()`](https://oreil.ly/010CB) 函数，[`ceil()`](https://oreil.ly/i5Rpy)
    函数和 [`floor()`](https://oreil.ly/VAZ6t) 函数。
- en: 5.4 Generating Truly Random Numbers
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.4 生成真正随机数
- en: Problem
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to generate random integers within specific bounds.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在特定边界内生成随机整数。
- en: Solution
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `random_int()` as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `random_int()` 如下所示：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Discussion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When you need randomness, you most often need explicitly true, completely unpredictable
    randomness. In those situations, you can rely on the cryptographically secure
    pseudorandom number generators built into the machine itself. PHP’s `random_int()`
    function relies on these operating system–level number generators rather than
    implementing its own algorithm.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要随机性时，通常需要显式真正完全不可预测的随机性。在这些情况下，您可以依赖于内置于机器本身的加密安全伪随机数生成器。PHP 的 `random_int()`
    函数依赖于这些操作系统级数生成器，而不是实现其自己的算法。
- en: 'On Windows, PHP will leverage either [`CryptGenRandom()`](https://oreil.ly/0kVO9)
    or the [`Cryptography API: Next Generation (CNG)`](https://oreil.ly/otHP9) depending
    on the language version in use. On Linux, PHP leverages a system call to [`getrandom(2)`](https://oreil.ly/07DIE).
    On any other platform, PHP will fall back on the system-level */dev/urandom* interface.
    All of these APIs are well tested and proven to be cryptographically secure, meaning
    they generate numbers with sufficient randomness that they are indistinguishable
    from noise.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '在 Windows 上，PHP 将根据使用的语言版本利用 [`CryptGenRandom()`](https://oreil.ly/0kVO9) 或
    [`Cryptography API: Next Generation (CNG)`](https://oreil.ly/otHP9)。在 Linux 上，PHP
    利用系统调用 [`getrandom(2)`](https://oreil.ly/07DIE)。在任何其他平台上，PHP 将回退到系统级 */dev/urandom*
    接口。所有这些 API 都经过充分测试，被证明是密码学安全的，意味着它们生成具有足够随机性的数字，几乎与噪声不可区分。'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In rare situations, you’ll want a random number generator to produce a predictable
    series of pseudorandom values. In those circumstances, you can rely on algorithmic
    generators like the Mersenne Twister, which is further discussed in [Recipe 5.5](#predictable_random_numbers).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见情况下，您可能希望随机数生成器生成可预测的伪随机值序列。在这些情况下，您可以依赖于像 Mersenne Twister 这样的算法生成器，如 [Recipe
    5.5](#predictable_random_numbers) 进一步讨论的那样。
- en: PHP doesn’t natively support a method to create a random floating-point number
    (i.e., selecting a random decimal between 0 and 1). Instead, you can use `ran⁠dom_​int()`
    and your knowledge of integers in PHP to create your own function to do exactly
    that, as shown in [Example 5-5](#random_float).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 并不原生支持创建随机浮点数的方法（即在 0 和 1 之间选择随机小数）。相反，您可以使用 `ran⁠dom_​int()` 和您在 PHP 中整数的知识来创建自己的函数来实现这一点，如
    [Example 5-5](#random_float) 所示。
- en: Example 5-5\. Userland function for generating a random floating-point number
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-5\. 生成随机浮点数的用户空间函数
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This implementation of `random_float()` lacks bounds because it will always
    generate a number between 0 and 1, inclusively. This might be useful to create
    random percentages, either for creating artificial data or for selecting randomly
    sized samples of arrays. A more complicated implementation might incorporate bounds
    as shown in [Example 5-6](#random_float_with_bounds), but often being able to
    choose between 0 and 1 is utility enough.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此 `random_float()` 实现缺乏边界，因此它将始终生成一个介于 0 和 1 之间的数字。这可能对创建随机百分比或随机选择数组的样本大小非常有用。更复杂的实现可能会像
    [Example 5-6](#random_float_with_bounds) 中展示的那样包含边界，但通常选择在 0 和 1 之间进行选择就足够实用了。
- en: Example 5-6\. Userland function for generating a random `float` within bounds
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-6\. 生成处于边界内的随机 `float` 的用户空间函数
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This newer definition of `random_float()` merely scales the original definition
    to the newly defined bounds. If you were to leave the default bounds in place,
    the function reduces down to the original definition.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新版本的`random_float()`函数仅仅是将原始定义按照新的边界进行缩放。如果你保持默认边界不变，函数就会退化成原始定义。
- en: See Also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`random_int()`](https://oreil.ly/kLoas).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档关于[`random_int()`](https://oreil.ly/kLoas)。
- en: 5.5 Generating Predictable Random Numbers
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.5 生成可预测的随机数
- en: Problem
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to predict random numbers in such a way that the sequence of numbers
    is the same every time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 想要预测随机数，使得每次生成的数列都相同。
- en: Solution
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `mt_rand()` function after passing a predefined seed into `mt_srand()`—for
    example:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`mt_srand()`并传入预定义种子后，可以使用`mt_rand()`函数，例如：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Both arrays in the preceding example will have the following contents:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面示例中的两个数组都将具有以下内容：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Discussion
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When writing any other example about truly random numbers, the best anyone can
    do is to illustrate what the output *might* look like. When it comes to the output
    of `mt_rand()`, however, the output will be the same on every computer, given
    you’re using the same seed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论真正的随机数示例时，任何人都只能展示输出的*可能*样子。但是当涉及到`mt_rand()`的输出时，只要使用相同的种子，输出在任何计算机上都将相同。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: PHP automatically seeds `mt_rand()` at random by default. It is not necessary
    to specify your own seed unless your goal is deterministic output from the function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PHP默认情况下会随机种子`mt_rand()`。除非目标是从函数中获取确定性输出，否则不需要指定自己的种子。
- en: The output is the same because `mt_rand()` leverages an algorithmic pseudorandom
    number generator called the *Mersenne Twister*. This is a well-known and heavily
    used algorithm first introduced in 1997; it’s also used in languages like Ruby
    and Python.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出相同是因为`mt_rand()`使用了名为*Mersenne Twister*的算法伪随机数生成器。这是一个广为人知和广泛使用的算法，首次引入于1997年；它还被用在Ruby和Python等语言中。
- en: Given an initial seed value, the algorithm creates an initial state and then
    generates seemingly random numbers by executing a “twist” operation on that state.
    The advantage of this approach is that it’s deterministic—​given the same seed,
    the algorithm will create the same sequence of “random” numbers every time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个初始种子值，算法创建一个初始状态，然后通过在该状态上执行“扭转”操作生成看似随机的数字序列。这种方法的优势在于它是确定性的——给定相同的种子，算法每次都会生成相同的“随机”数序列。
- en: Warning
  id: totrans-134
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Predictability in random numbers can be hazardous to certain computing operations,
    specifically to cryptography. The use cases requiring a deterministic sequence
    of pseudorandom numbers are rare enough that `mt_rand()` should be avoided as
    much as possible. If you need to generate random numbers, leverage true sources
    of randomness like `random_int()` and `random_bytes()`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 随机数的可预测性对于某些计算操作可能具有危害，特别是在密码学中。需要确定性伪随机数序列的用例并不常见，因此应尽量避免使用`mt_rand()`。如果需要生成随机数，应该利用像`random_int()`和`random_bytes()`这样的真实随机源。
- en: Creating a pseudorandom but predictable sequence of numbers might be useful
    in creating object IDs for a database. You can easily test that your code operates
    correctly by running it multiple times and verifying the output. The disadvantage
    is that algorithms like the Mersenne Twister can be gamed by an outside party.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个伪随机但可预测的数列可能在为数据库创建对象ID时很有用。通过多次运行代码并验证输出，可以轻松测试代码的正确运行。缺点是像Mersenne Twister这样的算法可能会受到外部方的操纵。
- en: Given a sufficiently long sequence of seemingly random numbers and knowledge
    of the algorithm, it is trivial to reverse the operation and identify the original
    seed. Once an attacker knows the seed value, they can generate every possible
    “random” number your system will leverage moving forward.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果知道算法并给定足够长的看似随机数序列，反向操作识别原始种子将变得非常容易。一旦攻击者知道种子值，他们就能生成系统未来将使用的每一个“随机”数。
- en: See Also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`mt_rand()`](https://oreil.ly/niU_q) and [`mt_srand()`](https://oreil.ly/xSa53).
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档关于[`mt_rand()`](https://oreil.ly/niU_q)和[`mt_srand()`](https://oreil.ly/xSa53)。
- en: 5.6 Generating Weighted Random Numbers
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.6 生成加权随机数
- en: Problem
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to generate random numbers in order to select a specific item from
    a collection at random, but you want some items to have a higher chance of being
    selected than others. For example, you want to select the winner of a particular
    challenge at an event, but some participants have earned more points than others
    and need to have a greater chance of being selected.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望生成随机数以随机选择集合中的特定项目，但希望某些项目被选中的机会更高。例如，您希望在活动中选择特定挑战的获胜者，但有些参与者赚取的积分比其他人多，因此需要更大的被选中机会。
- en: Solution
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Pass a map of choices and weights into an implementation of `weighted_​ran⁠dom_choice()`,
    as demonstrated in [Example 5-7](#solution_weighted_random_choice).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 将选择和权重的映射传递给`weighted_​ran⁠dom_choice()`的实现，就像在[示例5-7](#solution_weighted_random_choice)中演示的那样。
- en: Example 5-7\. Implementation of a weighted random choice
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-7\. 加权随机选择的实现
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discussion
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In the Solution example, each possible choice is assigned a weight. To choose
    a final option, you can *order* each option by weight, with the highest-weighted
    option coming first in the list. You then identify a random number somewhere in
    the field of total possible weights. That random number selects which of the options
    you chose.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案示例中，每个可能的选择都被分配了一个权重。为了选择最终选项，您可以按权重*排序*每个选项，权重最高的选项在列表中排在第一位。然后，您在总可能权重范围内确定一个随机数。该随机数选择您选择的选项之一。
- en: This is easiest to visualize on a number line. In the Solution example, Tony
    is entered into the selection with a weight of 10 and Peter with a weight of 1\.
    This means Tony is 10 times as likely to win as Peter, but it’s still possible
    *neither* of them will be chosen. [Figure 5-1](#weighted_number_line) illustrates
    the relative weight of each if you order the possible choices by weight and print
    them on a number line.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这在数轴上最容易进行可视化。在解决方案示例中，Tony的权重为10，Peter的权重为1。这意味着Tony比Peter有可能赢得的机会多10倍，但仍然有可能*两者都不会*被选择。[图5-1](#weighted_number_line)说明了如果按权重排序并在数轴上打印可能的选择，每个选择的相对权重。
- en: '![Weighted random choice visualized on a continuous line](assets/phpc_0501.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![在连续线上可视化的加权随机选择](assets/phpc_0501.png)'
- en: Figure 5-1\. Potential selections ordered and visualized by weight
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1\. 按权重排序和可视化的潜在选择
- en: The algorithm defined in `weighted_random_choice()` will check whether the selected
    random number is within the bounds of each possible choice and, if not, move on
    to the next candidate. If, for any reason, you’re unable to make a selection,
    the function will throw an exception.^([2](ch05.html#idm45875166236512))
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`weighted_random_choice()`中定义的算法将检查所选随机数是否在每个可能选择的范围内，如果不在，则继续下一个候选项。如果由于任何原因无法进行选择，函数将抛出异常。^([2](ch05.html#idm45875166236512))
- en: It is possible to verify the weighted nature of this choice by executing a random
    selection a thousand times and then plotting the relative number of times each
    choice is picked. [Example 5-8](#weighted_random_outcome_code) shows how such
    a repeated choice can be tabulated, while [Figure 5-2](#weighted_random_outcome)
    illustrates the outcome. Both demonstrate just how much more likely Tony is to
    be chosen than any other option in the candidate array.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过执行一千次随机选择并绘制每个选择被选中的相对次数来验证这种选择的加权性质。[示例5-8](#weighted_random_outcome_code)展示了如何对这样的重复选择进行制表，而[图5-2](#weighted_random_outcome)说明了结果。两者都清楚地展示了Tony被选中的可能性比候选数组中的任何其他选项更高。
- en: Example 5-8\. Repeated selection of a weighted random choice
  id: totrans-154
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-8\. 重复选择加权随机选择
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![Outcome of 1000 iterations of a weighted random choice.](assets/phpc_0502.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![1000次加权随机选择的结果。](assets/phpc_0502.png)'
- en: Figure 5-2\. Pie chart illustrating the relative number of times each choice
    is selected
  id: totrans-157
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-2\. 饼图说明每个选择被选中的相对次数
- en: This illustration of outcomes after 1,000 iterations clearly demonstrates that
    Tony is chosen roughly 10 times more frequently than Peter. This lines up perfectly
    with his having a weight of 10 to Peter’s 1\. Likewise, Wanda’s weight of 4 reliably
    lines up with her being chosen twice as frequently as Steve, who has a weight
    of 2.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这个在1,000次迭代后的结果清楚地表明，Tony被选择的频率大约是Peter的10倍。这与他的权重为10，Peter的权重为1完美契合。同样，Wanda的权重为4可靠地表明她被选择的频率是Steve的两倍，后者的权重为2。
- en: Given that the choices here are random, running the same experiment again will
    result in slightly different percentages for each candidate. However, the integer
    weights of each will always translate into roughly the same distribution of choices.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这里的选择是随机的，再次运行相同的实验将导致每个候选人的百分比略有不同。然而，每个候选人的整数权重始终会转化为大致相同的选择分布。
- en: See Also
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`random_int()`](https://oreil.ly/Pq16w) and [`arsort()`](https://oreil.ly/VZ-Vz)
    as well as [Recipe 5.4](#recipe_random_numbers) for further examples of `random_int()`
    in practice.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档关于[`random_int()`](https://oreil.ly/Pq16w)和[`arsort()`](https://oreil.ly/VZ-Vz)，以及在实践中进一步使用`random_int()`的[Recipe
    5.4](#recipe_random_numbers)的例子。
- en: 5.7 Calculating Logarithms
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.7 计算对数
- en: Problem
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to calculate the logarithm of a number.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要计算一个数的对数。
- en: Solution
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'For natural logarithms (using base `e`), use `log()` as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对于自然对数（使用基数`e`），使用`log()`如下：
- en: '[PRE18]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For any arbitrary base logarithm, specify the base as a second optional parameter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意基数的对数，将基数作为第二个可选参数指定：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Discussion
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP supports the calculation of logarithms with its native Math extension. When
    you call `log()` without specifying a base, PHP will fall back on the default
    `M_E` constant, which is coded to the value of `e`, or approximately 2.718281828459.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: PHP通过其本机Math扩展支持对数计算。当您调用`log()`而不指定基数时，PHP将回退到默认的`M_E`常量，其编码为`e`的值，约为2.718281828459。
- en: If you try to take the logarithm of a negative value, PHP will always return
    `NAN`, a constant (typed as a `float`) that represents *not a number*. If you
    attempt to pass a negative base, PHP will return a `ValueError` and trigger a
    warning.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试对负值取对数，PHP将始终返回`NAN`，一个表示*不是一个数字*的常量（类型为`float`）。如果尝试传递一个负的底数，PHP将返回一个`ValueError`并触发警告。
- en: Any positive, nonzero base is supported by `log()`. Many applications use base
    10 so frequently that PHP supports a separate `log10()` function for just that
    base. This is functionally equivalent to passing the integer `10` as a base to
    `log()`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`log()`支持任何正的非零基数。许多应用程序如此频繁地使用基数10，以至于PHP支持一个单独的`log10()`函数专门用于此基数。这在功能上等同于将整数`10`作为基数传递给`log()`。'
- en: See Also
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on the various functionality supported by the [Math extension](https://oreil.ly/nLOM7),
    including [`log()`](https://oreil.ly/r-WYo) and [`log10()`](https://oreil.ly/7Tn4t).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档对[Math扩展](https://oreil.ly/nLOM7)支持的各种功能的说明，包括[`log()`](https://oreil.ly/r-WYo)和[`log10()`](https://oreil.ly/7Tn4t)。
- en: 5.8 Calculating Exponents
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.8 计算指数
- en: Problem
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to raise a number to an arbitrary power.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您想将一个数提升到任意幂。
- en: Solution
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use PHP’s `pow()` function as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP的`pow()`函数如下：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Discussion
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'PHP’s `pow()` function is an efficient way to raise any number to an arbitrary
    power and return either the integer or floating-point result. In addition to the
    function form, PHP provides a special operator for raising a number to a power:
    `**`.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的`pow()`函数是将任意数提升到任意幂并返回整数或浮点结果的有效方法。除了函数形式外，PHP还提供了一个特殊的运算符来将一个数提升到幂：`**`。
- en: 'The following code is equivalent to the use of `pow()` in the Solution examples:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码等效于解决方案示例中使用`pow()`的使用：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Warning
  id: totrans-186
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While the mathematical shorthand for exponentiation is usually the caret (`^`),
    this character in PHP is reserved for the XOR operator. Review [Chapter 2](ch02.html#chapter_operators)
    for more details on this and other operators.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数学上指数运算的简写通常是插入符（`^`），但在PHP中，此字符保留为异或运算符。请查看[第2章](ch02.html#chapter_operators)以获取更多关于此及其他运算符的详细信息。
- en: 'While raising the constant `e` to an arbitrary power is possible through `pow()`,
    PHP also ships with a specific function for that use: `exp()`. The statements
    `pow(M_E, 2)` and `exp(2)` are functionally equivalent. They are implemented via
    different code and, because of the way floating-point numbers are represented
    internally by PHP, will return slightly different results.^([3](ch05.html#idm45875165878960))'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当对常数`e`进行任意幂运算时，可以通过`pow()`实现，PHP还内置了专门用于此用途的函数：`exp()`。表达式`pow(M_E, 2)`和`exp(2)`在功能上是等效的。它们通过不同的代码实现，并且由于PHP内部浮点数的表示方式，它们返回的结果略有不同。^([3](ch05.html#idm45875165878960))
- en: See Also
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`pow()`](https://oreil.ly/JEsKM) and [`exp()`](https://oreil.ly/AsgKw).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档关于[`pow()`](https://oreil.ly/JEsKM)和[`exp()`](https://oreil.ly/AsgKw)。
- en: 5.9 Formatting Numbers as Strings
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.9 将数字格式化为字符串
- en: Problem
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to print a number with thousands separators to make it more readable
    to end users of your application.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望打印一个带有千位分隔符的数字，以使您的应用程序的最终用户更容易阅读。
- en: Solution
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `number_format()` to automatically add thousands separators when converting
    a number to a string. For example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`number_format()`在将数字转换为字符串时自动添加千位分隔符。例如：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Discussion
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP’s native `number_format()` function will automatically group thousands together
    as well as round decimal digits to the given precision. You can also optionally
    *change* the decimal and thousands separators to match a given locale or format.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的本机`number_format()`函数将自动将千位分组并将小数位四舍五入到指定的精度。您还可以选择*更改*小数和千位分隔符，以匹配给定的语言环境或格式。
- en: 'For example, assume you want to use periods to separate thousands groups and
    a comma to separate decimal digits (as is common in Danish number formats). To
    accomplish this, you would leverage `number_format()` as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您希望使用句点分隔千位组，并使用逗号分隔小数位（如丹麦数值格式中常见）。要实现这一点，您可以利用`number_format()`如下所示：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'PHP’s native `NumberFormatter` class provides similar utility but gives you
    the ability to explicitly define the locale rather than needing to remember a
    specific regional format.^([4](ch05.html#idm45875165714064)) You can rewrite the
    preceding example to use `NumberFormatter` specifically with the `da_DK` locale
    to identify a Danish format as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的本机`NumberFormatter`类提供类似的实用功能，但允许您显式定义语言环境，而无需记住特定的区域格式。^([4](ch05.html#idm45875165714064))您可以重写前面的例子，使用`NumberFormatter`特定于`da_DK`语言环境来识别丹麦格式，如下所示：
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See Also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`number_format()`](https://oreil.ly/3_L6J) and the [`NumberFormatter`
    class](https://oreil.ly/IC3a9).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: PHP关于[`number_format()`](https://oreil.ly/3_L6J)和[`NumberFormatter`类](https://oreil.ly/IC3a9)的文档。
- en: 5.10 Handling Very Large or Very Small Numbers
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.10 处理非常大或非常小的数字
- en: Problem
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to use numbers that are too large (or too small) to be handled by PHP’s
    native integer and floating-point types.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用超出PHP本机整数和浮点类型处理能力的数字时。
- en: Solution
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the GMP library:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GMP库：
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Discussion
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP supports two extensions for working with numbers either too large or too
    small to be represented with native types. The [BCMath extension](https://oreil.ly/XhhdH)
    is an interface to a system-level *basic calculator* utility that supports arbitrary
    precision mathematics. Unlike native PHP types, BCMath supports working with up
    to 2,147,483,647 decimal digits so long as the system has adequate memory.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: PHP支持两个扩展来处理超出本机类型范围的数字。[BCMath扩展](https://oreil.ly/XhhdH)是一个接口，连接到一个支持任意精度数学的系统级*基本计算器*实用程序。与本机PHP类型不同，BCMath支持使用高达2,147,483,647位小数，只要系统内存足够。
- en: Unfortunately, BCMath encodes all numbers as regular strings in PHP, which makes
    using it somewhat difficult in modern applications that target strict type enforcement.^([5](ch05.html#idm45875165610784))
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，BCMath在PHP中将所有数字编码为常规字符串，这使得在目标为严格类型强制的现代应用程序中使用它有些困难。^([5](ch05.html#idm45875165610784))
- en: The GMP extension is a valid alternative also available to PHP that does not
    have this drawback. Internal to itself, numbers are stored as strings. They are,
    however, wrapped as `GMP` objects when exposed to the rest of PHP. This distinction
    helps clarify whether a function is operating on a small number encoded as a string
    or a large one necessitating the use of an extension.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: GMP扩展也是PHP的一种有效替代方案，它没有这个缺点。在内部，数字被存储为字符串。但是，当与PHP的其他部分接触时，它们被包装为`GMP`对象。这种区别有助于澄清一个函数是在一个被编码为字符串的小数字上操作，还是在需要使用扩展的大数字上操作。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: BCMath and GMP act on and return integer values rather than floating points.
    If you need to conduct operations on floating-point numbers, you might need to
    increase the size of your numbers by an order of magnitude (i.e., multiply by
    10) and then reduce them again once your calculations are complete in order to
    account for decimals or fractions.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: BCMath和GMP操作和返回整数值，而不是浮点数。如果需要对浮点数进行操作，您可能需要将数字大小增加一个数量级（即乘以10），然后在计算完成后再次减少，以考虑小数或分数。
- en: GMP isn’t included with PHP by default, although many distributions will make
    it available quite easily. If you’re compiling PHP from source, doing so with
    the `--with-gmp` option will add support automatically. If you’re using a package
    manager to install PHP (for example, on a Linux machine) you can likely install
    the `php-gmp` package to add this support directly.^([6](ch05.html#idm45875165604832))
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: PHP默认情况下不包含GMP，尽管许多发行版都可以很容易地提供它。如果您从源代码编译PHP，可以使用`--with-gmp`选项来自动添加支持。如果您使用软件包管理器安装PHP（例如在Linux机器上），您可能可以直接安装`php-gmp`软件包以添加这种支持。^([6](ch05.html#idm45875165604832))
- en: Once available, GMP will empower you to execute any mathematic operation you
    desire on numbers of limitless size. The caveat is that you can no longer use
    native PHP operators and must use a functional format defined by the extension
    itself. [Example 5-9](#gmp_function_calls) presents some translations from native
    operators to GMP function calls. Note that the return type of each function call
    is a `GMP` object, so you must convert it back to either a number or a string
    by using `gmp_intval()` or `gmp_strval()`, respectively.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦可用，GMP将使您能够在无限大小的数字上执行任何数学操作。但问题是，您不能再使用PHP的原生运算符，必须使用扩展本身定义的函数格式。[Example 5-9](#gmp_function_calls)展示了从原生运算符到GMP函数调用的一些转换。请注意，每个函数调用的返回类型都是一个`GMP`对象，因此您必须使用`gmp_intval()`或`gmp_strval()`将其转换回数字或字符串。
- en: Example 5-9\. Various mathematical operations and their GMP function equivalents
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-9。各种数学操作及其GMP函数等效项
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The final illustration in [Example 5-9](#gmp_function_calls) introduces the
    `gmp_cmp()` function, which allows you to compare two GMP-wrapped values. This
    function will return a positive value if the first parameter is greater than the
    second, 0 if they are equal, and a negative value if the second parameter is greater
    than the first. It’s effectively the same as PHP’s spaceship operator (introduced
    in [Recipe 2.4](ch02.html#spaceship_operator)) rather than an equality comparison,
    which potentially provides more utility.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 5-9](#gmp_function_calls)中的最后一个示例介绍了`gmp_cmp()`函数，它允许您比较两个GMP封装的值。如果第一个参数大于第二个参数，则此函数将返回一个正值，如果它们相等，则返回0，如果第二个参数大于第一个参数，则返回一个负值。这与PHP的太空船操作符（在[Recipe
    2.4](ch02.html#spaceship_operator)中引入）实际上是相同的，而不是一个相等比较，这可能提供了更多的实用性。'
- en: See Also
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [GMP](https://oreil.ly/rtfm3).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档上的[GMP](https://oreil.ly/rtfm3)部分。
- en: 5.11 Converting Numbers Between Numerical Bases
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5.11 数字之间的进制转换
- en: Problem
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to convert a number from one base to another.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将一个数字从一种基数转换为另一种基数。
- en: Solution
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `base_convert()` function as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`base_convert()`函数如下：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Discussion
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `base_convert()` function attempts to convert a number from one base to
    another, which is particularly helpful when working with hexadecimal or binary
    strings of data. PHP will work only with bases between 2 and 36\. Bases higher
    than 10 will use alphabet characters to represent additional digits—`a` is equal
    to `10`, `b` to `11`, all the way to `z` being equal to `35`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`base_convert()`函数尝试将一个数字从一种基数转换为另一种基数，这在处理十六进制或二进制数据字符串时特别有用。PHP仅支持2到36之间的基数。高于10的基数将使用字母字符表示额外的数字——`a`等于`10`，`b`等于`11`，一直到`z`等于`35`。'
- en: Note that the Solution example passes a *string* into `base_convert()` rather
    than an integer or a float value. This is because PHP will attempt to cast the
    input string to a number with an appropriate base before converting it to another
    base and returning a string. Strings are the best way to represent hexadecimal
    or octal numbers in PHP, but they’re generic enough they can represent numbers
    of *any* base.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，解决方案示例将一个*字符串*传递给`base_convert()`而不是一个整数或浮点数值。这是因为PHP将尝试将输入字符串转换为具有适当基数的数字，然后将其转换为另一种基数并返回一个字符串。在PHP中，字符串是表示十六进制或八进制数的最佳方式，但它们足够通用，可以表示*任何*基数的数字。
- en: PHP supports several other base-specific conversion functions in addition to
    the more generic `base_convert()`. These additional functions are enumerated in
    [Table 5-3](#base_conversions).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更通用的`base_convert()`外，PHP还支持几种基数特定的转换函数。这些额外的函数在[Table 5-3](#base_conversions)中列出。
- en: Warning
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'PHP supports two functions for converting back and forth between binary data
    and its hexadecimal representation: `bin2hex()` and `hex2bin()`. These functions
    are *not* intended for converting a string representation of binary (e.g., `11111001`)
    into hexadecimal but will instead operate the binary *bytes* of that string.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: PHP支持两个函数用于二进制数据和其十六进制表示之间的相互转换：`bin2hex()`和`hex2bin()`。这些函数不用于将二进制的字符串表示（例如`11111001`）转换为十六进制，而是操作该字符串的二进制*字节*。
- en: Table 5-3\. Specific base conversion functions
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-3\. 特定的基数转换函数
- en: '| Function name | From base | To base |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 函数名称 | 从基数 | 到基数 |'
- en: '| --- | --- | --- |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `bindec()` | Binary (encoded as a `string`) | Decimal (encoded as an `int`
    or, for size reasons, a `float`) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| `bindec()` | 二进制（以`string`编码） | 十进制（以`int`或由于大小原因而是`float`） |'
- en: '| `decbin()` | Decimal (encoded as an `int`) | Binary (encoded as a `string`)
    |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| `decbin()` | 十进制（以`int`编码） | 二进制（以`string`编码） |'
- en: '| `hexdec()` | Hexadecimal (encoded as a `string`) | Decimal (encoded as an
    `int` or, for size reasons, a `float`) |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| `hexdec()` | 十六进制（以`string`编码） | 十进制（以`int`或由于大小原因而是`float`） |'
- en: '| `dechex()` | Decimal (encoded as an `int`) | Hexadecimal (encoded as a `string`)
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `dechex()` | 十进制（以`int`编码） | 十六进制（以`string`编码） |'
- en: '| `octdec()` | Octal (encoded as a `string`) | Decimal (encoded as an `int`
    or, for size reasons, a `float`) |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `octdec()` | 八进制（以`string`编码） | 十进制（以`int`或由于大小原因而是`float`） |'
- en: '| `decoct()` | Decimal (encoded as an `int`) | Octal (encoded as a `string`)
    |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `decoct()` | 十进制（以`int`编码） | 八进制（以`string`编码） |'
- en: Note that, unlike `base_convert()`, the specialized base conversion functions
    often work with numeric types directly. If you are using strict typing, this will
    avoid requiring an explicit cast from a numeric type to a `string` before changing
    bases, which *would* be required with `base_convert()`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`base_convert()`不同，专用的基数转换函数通常直接与数值类型一起工作。如果使用严格的类型检查，这将避免在改变基数之前需要从数值类型显式转换为`string`，这在使用`base_convert()`时是必需的。
- en: See Also
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`base_convert()`](https://oreil.ly/NVsk_).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: PHP关于[`base_convert()`](https://oreil.ly/NVsk_)的文档。
- en: ^([1](ch05.html#idm45875173113616-marker)) For more on type casting, review
    [“Type Casting”](ch02.html#typecasting_intro).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch05.html#idm45875173113616-marker)) 更多关于类型转换的信息，请查阅[“类型转换”](ch02.html#typecasting_intro)。
- en: ^([2](ch05.html#idm45875166236512-marker)) Exceptions and error handling are
    discussed at length in [Chapter 12](ch12.html#chapter_errors).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch05.html#idm45875166236512-marker)) 异常和错误处理在[第12章](ch12.html#chapter_errors)中有详细讨论。
- en: ^([3](ch05.html#idm45875165878960-marker)) For more on the acceptable differences
    between floating-point numbers, review [Recipe 5.2](#floating_point_comparison).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch05.html#idm45875165878960-marker)) 关于浮点数之间可接受差异的更多信息，请参阅[Recipe 5.2](#floating_point_comparison)。
- en: ^([4](ch05.html#idm45875165714064-marker)) The `NumberFormatter` class itself
    is part of PHP’s [intl](https://oreil.ly/B-85H) extension. This module is not
    built in by default and might need to be installed/enabled for the class to be
    available.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch05.html#idm45875165714064-marker)) `NumberFormatter`类本身是PHP的[intl](https://oreil.ly/B-85H)扩展的一部分。这个模块不是默认内置的，可能需要安装或启用该扩展才能使用该类。
- en: ^([5](ch05.html#idm45875165610784-marker)) Review [Recipe 3.4](ch03.html#argument_and_return_typing)
    for more on strict typing in PHP.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch05.html#idm45875165610784-marker)) 更多关于PHP严格类型的信息，请参阅[“类型转换”](ch03.html#argument_and_return_typing)。
- en: ^([6](ch05.html#idm45875165604832-marker)) Native extensions are covered in
    depth in [Chapter 15](ch15.html#chapter_extensions).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch05.html#idm45875165604832-marker)) 本地扩展在[第15章](ch15.html#chapter_extensions)中有详细介绍。
