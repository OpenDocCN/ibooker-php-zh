- en: Chapter 3\. Routing and Controllers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章 路由和控制器
- en: The essential function of any web application framework is to take requests
    from a user and deliver responses, usually via HTTP(S). This means defining an
    application’s routes is the first and most important project to tackle when learning
    a web framework; without routes, you have little to no ability to interact with
    the end user.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Web应用程序框架的基本功能是接收用户请求并传递响应，通常通过HTTP(S)完成。这意味着定义应用程序路由是学习Web框架时首先要解决的最重要的项目；没有路由，您几乎无法与最终用户进行交互。
- en: In this chapter we will examine routes in Laravel; you’ll see how to define
    them, how to point them to the code they should execute, and how to use Laravel’s
    routing tools to handle a diverse array of routing needs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Laravel中的路由；您将看到如何定义它们，如何将它们指向应执行的代码，并如何使用Laravel的路由工具处理各种各样的路由需求。
- en: A Quick Introduction to MVC, the HTTP Verbs, and REST
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MVC、HTTP动词和REST的快速介绍
- en: Most of what we’ll talk about in this chapter references how Model–View–Controller
    (MVC) applications are structured, and many of the examples we’ll be looking at
    use REST-ish route names and verbs, so let’s take a quick look at both.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论的大部分内容涉及如何组织Model–View–Controller（MVC）应用程序的结构，我们将查看许多示例使用类REST的路由名称和动词，因此让我们快速看一下两者。
- en: What Is MVC?
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是MVC？
- en: 'In MVC, you have three primary concepts:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVC中，您有三个主要概念：
- en: model
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模型
- en: Represents an individual database table (or a record from that table)—think
    “Company” or “Dog.”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表示一个单独的数据库表（或来自该表的记录）—想象“公司”或“狗”。
- en: view
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 视图
- en: Represents the template that outputs your data to the end user—​think “the login
    page template with this given set of HTML and CSS and JavaScript.”
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 表示将数据输出到最终用户的模板—​想象“带有给定HTML、CSS和JavaScript集的登录页面模板”。
- en: controller
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器
- en: Like a traffic cop, takes HTTP requests from the browser, gets the right data
    out of the database and other storage mechanisms, validates user input, and eventually
    sends a response back to the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于交通警察，从浏览器接收HTTP请求，从数据库和其他存储机制获取正确的数据，验证用户输入，并最终向用户发送响应。
- en: In [Figure 3-1](#FIG301), you can see that the end user will first interact
    with the controller by sending an HTTP request using their browser. The controller,
    in response to that request, may write data to and/or pull data from the model
    (database). The controller will then likely send data to a view, and then the
    view will be returned to the end user to display in their browser.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 3-1](#FIG301)中，您可以看到，最终用户将首先通过其浏览器发送HTTP请求与控制器进行交互。控制器响应该请求后，可能会向模型（数据库）写入数据和/或从模型中拉取数据。然后，控制器很可能会向视图发送数据，然后将视图返回给最终用户在其浏览器中显示。
- en: '![A diagram of a Model, a View, and a Controller, together with the User, all
    with arrows pointing to each other](assets/lur3_0301.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![模型、视图和控制器以及用户的图表，彼此之间都有指向的箭头](assets/lur3_0301.png)'
- en: Figure 3-1\. A basic illustration of MVC
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-1. MVC的基本示意图
- en: We’ll cover some use cases for Laravel that don’t fit this relatively simplistic
    way of looking at application architecture, so don’t get hung up on MVC, but this
    will at least get you ready to approach the rest of this chapter as we talk about
    views and controllers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖一些不符合这种相对简单的应用架构方式的Laravel用例，所以不要陷入MVC，但这将至少让您准备好在我们讨论视图和控制器时接近本章的其余部分。
- en: The HTTP Verbs
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTTP动词
- en: the most common HTTP verbs are `GET` and `POST`, followed by `PUT` and `DELETE`.
    There are also `HEAD`, `OPTIONS`, and `PATCH`, and two others that are pretty
    much never used in normal web development, `TRACE` and `CONNECT`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的HTTP动词是`GET`和`POST`，其次是`PUT`和`DELETE`。还有`HEAD`，`OPTIONS`和`PATCH`，以及两个在正常网页开发中几乎不使用的其他动词，`TRACE`和`CONNECT`。
- en: 'Here’s a quick rundown:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速概述：
- en: '`GET`'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`'
- en: Request a resource (or a list of resources).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 请求资源（或资源列表）。
- en: '`HEAD`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEAD`'
- en: Ask for a headers-only version of the `GET` response.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请求`GET`响应的仅包含头信息的版本。
- en: '`POST`'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`'
- en: Create a resource.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源。
- en: '`PUT`'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`'
- en: Overwrite a resource.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖资源。
- en: '`PATCH`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATCH`'
- en: Modify a resource.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 修改资源。
- en: '`DELETE`'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`DELETE`'
- en: Delete a resource.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 删除资源。
- en: '`OPTIONS`'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`OPTIONS`'
- en: Ask the server which verbs are allowed at this URL.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 询问服务器此URL允许哪些动词。
- en: '[Table 3-1](#table0301) shows the actions available on a resource controller
    (more on these in [“Resource Controllers”](#resource_controllers)). Each action
    expects you to call a specific URL pattern using a specific verb, so you can get
    a sense of what each verb is used for.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[Table 3-1](#table0301) 显示了资源控制器上可用的操作（更多详情见 [“资源控制器”](#resource_controllers)）。每个动作期望你使用特定的
    URL 模式和特定的动词调用，因此你可以了解每个动词的用途。'
- en: Table 3-1\. The methods of Laravel’s resource controllers
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3-1\. Laravel 资源控制器的方法
- en: '| Verb | URL | Controller method | Name | Description |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 动词 | URL | 控制器方法 | 名称 | 描述 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| `GET` | `tasks` | `index()` | `tasks.index` | Show all tasks |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `tasks` | `index()` | `tasks.index` | 显示所有任务 |'
- en: '| `GET` | `tasks/create` | `create()` | `tasks.create` | Show the create task
    form |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `tasks/create` | `create()` | `tasks.create` | 显示创建任务表单 |'
- en: '| `POST` | `tasks` | `store()` | `tasks.store` | Accept form submission from
    the create task form |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | `tasks` | `store()` | `tasks.store` | 接受创建任务表单的表单提交 |'
- en: '| `GET` | `tasks/{task}` | `show()` | `tasks.show` | Show one task |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `tasks/{task}` | `show()` | `tasks.show` | 显示一个任务 |'
- en: '| `GET` | `tasks/{task}/edit` | `edit()` | `tasks.edit` | Edit one task |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | `tasks/{task}/edit` | `edit()` | `tasks.edit` | 编辑一个任务 |'
- en: '| `PUT/PATCH` | `tasks/{task}` | `update()` | `tasks.update` | Accept form
    submission from the edit task form |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `PUT/PATCH` | `tasks/{task}` | `update()` | `tasks.update` | 接受编辑任务表单的表单提交
    |'
- en: '| `DELETE` | `tasks/{task}` | `destroy()` | `tasks.destroy` | Delete one task
    |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | `tasks/{task}` | `destroy()` | `tasks.destroy` | 删除一个任务 |'
- en: What Is REST?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是 REST？
- en: 'We’ll cover REST in greater detail in [“The Basics of REST-Like JSON APIs”](ch13.html#intro_to_rest),
    but as a brief introduction, it’s an architectural style for building APIs. When
    we talk about REST in this book, we’ll mainly be referencing a few characteristics,
    such as:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [“REST-Like JSON APIs 基础”](ch13.html#intro_to_rest) 中详细讨论 REST，但简要介绍一下，它是一种构建
    API 的架构风格。在本书中讨论 REST 时，主要指一些特征，例如：
- en: Being structured around one primary resource at a time (e.g., `tasks`)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次围绕一个主要资源结构化（例如，`tasks`）
- en: Consisting of interactions with predictable URL structures using HTTP verbs
    (as seen in [Table 3-1](#table0301))
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由使用 HTTP 动词与可预测的 URL 结构进行交互组成（如 [Table 3-1](#table0301) 中所见）
- en: Returning JSON and often being requested with JSON
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回 JSON 数据并经常被请求为 JSON
- en: There’s more to it, but usually “RESTful” as it’ll be used in this book will
    mean “patterned after these URL-based structures so we can make predictable calls
    like `GET /tasks/14/edit` for the edit page.” This is relevant (even when not
    building APIs) because Laravel’s routing structures are based around a REST-like
    structure, as you can see in [Table 3-1](#table0301).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是更复杂的内容，但通常情况下，本书中使用的 “RESTful” 将意味着 “基于这些基于 URL 结构的模式，因此我们可以像 `GET /tasks/14/edit`
    这样进行可预测的调用”。这很重要（即使不构建 API）因为 Laravel 的路由结构是基于类似 REST 的结构，正如你可以在 [Table 3-1](#table0301)
    中看到的。
- en: REST-based APIs follow mainly this same structure, except they don’t have a
    *create* route or an *edit* route, since APIs just represent actions, not pages
    that prep for the actions.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 REST 的 API 主要遵循相同的结构，除了它们没有 *create* 路由或 *edit* 路由，因为 API 只表示动作，而不是为动作准备页面。
- en: Route Definitions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由定义
- en: In a Laravel application, you will define your web routes in *routes/web.php*
    and your API routes in *routes/api.php*. *Web routes* are those that will be visited
    by your end users; *API routes* are those for your API, if you have one. For now,
    we’ll primarily focus on the routes in *routes/web.php*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Laravel 应用中，你将在 *routes/web.php* 中定义你的 web 路由，而在 *routes/api.php* 中定义 API
    路由。*Web 路由* 是终端用户访问的路由；*API 路由* 是你的 API 的路由（如果有的话）。目前，我们主要关注 *routes/web.php*
    中的路由。
- en: The simplest way to define a route is to match a path (e.g., `/`) with a closure,
    as seen in [Example 3-1](#EX1X).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 定义路由的最简单方法是将路径（例如 `/`）与闭包匹配，如 [Example 3-1](#EX1X) 中所示。
- en: Example 3-1\. Basic route definition
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-1\. 基本路由定义
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You’ve now defined that if anyone visits `/` (the root of your domain), Laravel’s
    router should run the closure defined there and return the result. Note that we
    `return` our content and don’t `echo` or `print` it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了如果有人访问 `/`（你域名的根），Laravel 的路由器应该运行在那里定义的闭包并返回结果。注意我们是 `return` 我们的内容，而不是
    `echo` 或 `print` 它。
- en: A Quick Introduction to Middleware
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件的快速介绍
- en: You might be wondering, “Why am I returning ‘Hello, World!’ instead of echoing
    it?”
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：“为什么我返回 ‘Hello, World!’ 而不是回显它？”
- en: There are quite a few answers, but the simplest is that there are a lot of wrappers
    around Laravel’s request and response cycle, including something called *middleware*.
    When your route closure or controller method is done, it’s not time to send the
    output to the browser yet; returning the content allows it to continue flowing
    through the response stack and the middleware before it is returned to the user.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多答案，但最简单的答案是 Laravel 的请求和响应周期周围有很多包装，包括一种称为*中间件*的东西。当路由闭包或控制器方法完成时，现在还不是将输出发送到浏览器的时间；返回内容允许它继续通过响应堆栈和中间件流动，然后再返回给用户。
- en: Many simple websites could be defined entirely within the web routes file. With
    a few simple `GET` routes combined with some templates, as illustrated in [Example 3-2](#EX30),
    you can serve a classic website easily.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 许多简单的网站完全可以在 web 路由文件中定义。通过一些简单的`GET`路由结合一些模板，如[示例 3-2](#EX30)所示，您可以轻松地提供经典网站服务。
- en: Example 3-2\. Sample website
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2\. 示例网站
- en: '[PRE1]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Static Calls
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态调用
- en: If you have much experience developing with PHP, you might be surprised to see
    static calls on the `Route` class. This is not actually a static method per se,
    but rather a service location using Laravel’s facades, which we’ll cover in [Chapter 11](ch11.html#the_container).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有 PHP 开发经验，您可能会惊讶地看到在`Route`类上进行静态调用。这实际上不是静态方法本身，而是使用 Laravel 的门面进行的服务定位，我们将在[第 11
    章](ch11.html#the_container)中介绍。
- en: 'If you prefer to avoid facades, you can accomplish these same definitions like
    this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢避免使用门面，您可以通过以下方式完成相同的定义：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Route Verbs
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由动词
- en: You might’ve noticed that we’ve been using `Route::get()` in our route definitions.
    This means we’re telling Laravel to only match for these routes when the HTTP
    request uses the `GET` action. But what if it’s a form `POST`, or maybe some JavaScript
    sending `PUT` or `DELETE` requests? There are a few other options for methods
    to call on a route definition, as illustrated in [Example 3-3](#EX31).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们在路由定义中一直在使用`Route::get()`。这意味着我们告诉 Laravel 只有当 HTTP 请求使用`GET`动作时才匹配这些路由。但是如果是表单的`POST`，或者可能是一些
    JavaScript 发送的`PUT`或`DELETE`请求呢？在路由定义中调用的方法还有几个其他选项，如[示例 3-3](#EX31)所示。
- en: Example 3-3\. Route verbs
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 路由动词
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Route Handling
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由处理
- en: As you’ve probably guessed, passing a closure to the route definition is not
    the only way to teach it how to resolve a route. Closures are quick and simple,
    but the larger your application gets, the clumsier it becomes to put all of your
    routing logic in one file. Additionally, applications using route closures can’t
    take advantage of Laravel’s route caching (more on that later), which can shave
    up to hundreds of milliseconds off of each request.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，将闭包传递给路由定义并不是教它如何解析路由的唯一方法。闭包快速简单，但是随着应用程序的规模变大，将所有路由逻辑放在一个文件中变得越来越笨拙。此外，使用路由闭包的应用程序无法利用
    Laravel 的路由缓存（稍后详述），这可以减少每个请求高达数百毫秒的响应时间。
- en: The other common option is to pass a controller name and method as a string
    in place of the closure, as in [Example 3-4](#EX32).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见选项是在闭包的位置以字符串形式传递控制器名称和方法，如[示例 3-4](#EX32)所示。
- en: Example 3-4\. Routes calling controller methods
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. 调用控制器方法的路由
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is telling Laravel to pass requests to that path to the `index()` method
    of the `App\Http\Controllers\WelcomeController` controller. This method will be
    passed the same parameters and treated the same way as a closure you might’ve
    alternatively put in its place.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Laravel 将请求传递给该路径的`index()`方法，该方法位于`App\Http\Controllers\WelcomeController`控制器中。此方法将接收相同的参数并像您可能替代放置在其中的闭包一样对待它。
- en: Route Parameters
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由参数
- en: If the route you’re defining has parameters—​segments in the URL structure that
    are variable—​it’s simple to define them in your route and pass them to your closure
    (see [Example 3-5](#EX34)).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义的路由有参数——URL 结构中的可变段落——那么在路由中定义它们并传递给闭包非常简单（见[示例 3-5](#EX34)）。
- en: Example 3-5\. Route parameters
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. 路由参数
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can also make your route parameters optional by including a question mark
    (`?`) after the parameter name, as illustrated in [Example 3-6](#EX35). In this
    case, you should also provide a default value for the route’s corresponding variable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在参数名后面加上问号（`?`）使路由参数变为可选，如[示例 3-6](#EX35)所示。在这种情况下，您还应为路由的对应变量提供默认值。
- en: Example 3-6\. Optional route parameters
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. 可选路由参数
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And you can use regular expressions (regexes) to define that a route should
    only match if a parameter meets particular requirements, as in [Example 3-7](#EX36).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用正则表达式（regexes）来定义一个路由只有在参数满足特定要求时才匹配，就像在 [示例 3-7](#EX36) 中一样。
- en: Example 3-7\. Regular expression route constraints
  id: totrans-86
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. 正则表达式路由约束
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you’ve probably guessed, if you visit a path that matches a route string
    but the regex doesn’t match the parameter, it won’t be matched. Since routes are
    matched top to bottom, `users/abc` would skip the first closure in [Example 3-7](#EX36),
    but it would be matched by the second closure, so it would get routed there. On
    the other hand, `posts/abc/123` wouldn’t match any of the closures, so it would
    return a 404 (Not Found) error.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，如果访问的路径匹配了路由字符串但正则表达式不匹配参数，它将不会被匹配。由于路由从上到下匹配，`users/abc`会跳过 [示例 3-7](#EX36)
    的第一个闭包，但它将会被第二个闭包匹配，因此会被路由到那里。另一方面，`posts/abc/123`不会匹配任何闭包，因此会返回404（未找到）错误。
- en: Laravel also offers convenience methods for common regular expression matching
    patterns, as you can see in [Example 3-8](#EX36.5).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel还提供了方便的方法来匹配常见的正则表达式模式，正如你在 [示例 3-8](#EX36.5) 中看到的那样。
- en: Example 3-8\. Regular expression route constraint helpers
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. 正则表达式路由约束辅助函数
- en: '[PRE8]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Route Names
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由名称
- en: The simplest way to refer to these routes elsewhere in your application is just
    by their path. There’s a `url()` global helper to simplify that linking in your
    views, if you need it; see [Example 3-9](#EX37) for an example. The helper will
    prefix your route with the full domain of your site.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中最简单的引用这些路由的方式只是使用它们的路径。如果需要的话，在视图中有一个`url()`全局辅助函数来简化链接；例如，查看 [示例 3-9](#EX37)。这个辅助函数会在你的路由前加上你的站点的完整域名。
- en: Example 3-9\. The `url()` helper
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. `url()`辅助函数
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, Laravel also allows you to name each route, which enables you to refer
    to it without explicitly referencing the URL. This is helpful because it means
    you can give simple nicknames to complex routes, and also because linking them
    by name means you don’t have to rewrite your frontend links if the paths change
    (see [Example 3-10](#EX38)).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Laravel也允许你为每个路由命名，这样你就可以在不显式引用URL的情况下引用它们。这很有帮助，因为这意味着你可以给复杂的路由起一个简单的昵称，同时通过名称链接它们意味着如果路径变化，你不必重写前端链接（参见
    [示例 3-10](#EX38)）。
- en: Example 3-10\. Defining route names
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. 定义路由名称
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This example illustrates a few new concepts. First, we’re using fluent route
    definition to add the name, by chaining the `name()` method after the `get()`
    method. This method allows us to name the route, giving it a short alias to make
    it easier to reference elsewhere.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了一些新概念。首先，我们使用流畅的路由定义通过在`get()`方法后链接`name()`方法来添加名称。这种方法允许我们为路由命名，为其提供一个简短的别名，以便在其他地方更容易引用。
- en: In our example, we’ve named this route `members.show`; `*resourcePlural*.*action*`
    is a common convention within Laravel for route and view names.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将这个路由命名为`members.show`；`*resourcePlural*.*action*`是Laravel中用于路由和视图名称的常见约定。
- en: This example also introduced the `route()` helper. Just like `url()`, it’s intended
    to be used in views to simplify linking to a named route. If the route has no
    parameters, you can simply pass the route name (`route('members.index')`) and
    receive a route string (`"http://myapp.com/members"`). If it has parameters, pass
    them as an array in the second parameter like we did in [Example 3-10](#EX38).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本例还介绍了`route()`辅助函数。就像`url()`一样，它旨在在视图中使用，简化链接到命名路由。如果路由没有参数，你可以简单地传递路由名称（`route('members.index')`），会得到一个路由字符串（`"http://myapp.com/members"`）。如果有参数，就像我们在
    [示例 3-10](#EX38) 中所做的那样，将它们作为数组传递到第二个参数中。
- en: In general, I recommend using route names instead of paths to refer to your
    routes, and therefore using the `route()` helper instead of the `url()` helper.
    Sometimes it can get a bit clumsy—​for example, if you’re working with multiple
    subdomains—​but it provides an incredible level of flexibility to later change
    the application’s routing structure without major penalty.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，我建议使用路由名称而不是路径来引用你的路由，因此建议使用`route()`辅助函数而不是`url()`辅助函数。有时会显得有些笨拙，比如当你使用多个子域名时，但它提供了极大的灵活性，以便稍后更改应用程序的路由结构而不会受到重大惩罚。
- en: Route Groups
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由组
- en: Often a group of routes shares a particular characteristic—a certain authentication
    requirement, a path prefix, or perhaps a controller namespace. Defining these
    shared characteristics again and again on each route not only seems tedious but
    also can muddy up the shape of your routes file and obscure some of the structures
    of your application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一组路由共享特定的特征—​特定的身份验证要求、路径前缀或者控制器命名空间。在每个路由上重复定义这些共享特征不仅显得乏味，而且还可能使路由文件的结构混乱，并且模糊了应用程序的一些结构。
- en: '*Route groups* allow you to reduce this duplication by grouping several routes
    together and applying any shared configuration settings once to the entire group.
    Additionally, route groups are visual cues to future developers (and to your own
    brain) that these routes are grouped together.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*路由组* 允许您通过将多个路由分组在一起并一次性应用任何共享的配置设置来减少这种重复。此外，路由组对未来开发人员（以及您自己）是视觉线索，表明这些路由是一组的。'
- en: To group two or more routes together, you “surround” the route definitions with
    a route group, as shown in [Example 3-11](#EX40). In reality, you’re actually
    passing a closure to the group definition and defining the grouped routes within
    that closure.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将两个或多个路由分组在一起，您可以通过路由组定义周围的路由定义，如 [Example 3-11](#EX40) 中所示。实际上，您正在将一个闭包传递给组定义，并在该闭包中定义分组的路由。
- en: Example 3-11\. Defining a route group
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-11\. 定义一个路由组
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By default, a route group doesn’t actually do anything. There’s no difference
    between using the group in [Example 3-11](#EX40) and separating a segment of your
    routes with code comments.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，路由组实际上并不执行任何操作。在 [Example 3-11](#EX40) 中使用组与在路由中使用代码注释分离的效果没有区别。
- en: Middleware
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件
- en: Probably the most common use for route groups is to apply middleware to a group
    of routes. You’ll learn more about middleware in [Chapter 10](ch10.html#requests_and_responses),
    but, among other things, they’re what Laravel uses for authenticating users and
    restricting guest users from using certain parts of a site.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 路由组最常见的用途之一是对一组路由应用中间件。您将在 [Chapter 10](ch10.html#requests_and_responses) 中学习更多关于中间件的内容，但它们主要用于
    Laravel 中对用户进行身份验证和限制访客用户访问站点某些部分。
- en: In [Example 3-12](#EX41), we’re creating a route group around the `dashboard`
    and `account` views and applying the `auth` middleware to both. In this example,
    this means users have to be logged in to the application to view the dashboard
    or the account page.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Example 3-12](#EX41) 中，我们围绕 `dashboard` 和 `account` 视图创建了一个路由组，并将 `auth`
    中间件应用于两者。在此示例中，这意味着用户必须登录应用程序才能查看仪表板或帐户页面。
- en: Example 3-12\. Restricting a group of routes to logged-in users only
  id: totrans-113
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-12\. 限制一组路由仅供已登录用户使用
- en: '[PRE12]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Often, it’s clearer and more direct to attach middleware to your routes in
    the controller instead of at the route definition. You can do this by calling
    the `middleware()` method in the constructor of your controller. The string you
    pass to the `middleware()` method is the name of the middleware, and you can optionally
    chain modifier methods (`only()` and `except()`) to define which methods will
    receive that middleware:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将中间件附加到控制器中的路由比在路由定义时更清晰、更直接。您可以通过在控制器的构造函数中调用 `middleware()` 方法来实现这一点。传递给
    `middleware()` 方法的字符串是中间件的名称，您还可以可选地链式调用修饰方法 (`only()` 和 `except()`) 来定义哪些方法将接收该中间件：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that if you’re doing a lot of “only” and “except” customizations, that’s
    often a sign that you should break out a new controller for the exceptional routes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您经常进行“only”和“except”自定义，这通常是需要为异常路由新建一个控制器的标志。
- en: Path Prefixes
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径前缀
- en: If you have a group of routes that share a segment of their path—​for example,
    if your site’s dashboard is prefixed with `/dashboard`—you can use route groups
    to simplify this structure (see [Example 3-13](#EX42)).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一组路由共享其路径的一部分—​例如，如果您的站点的仪表板以 `/dashboard` 为前缀—​您可以使用路由组来简化此结构（参见 [Example 3-13](#EX42)）。
- en: Example 3-13\. Prefixing a group of routes
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 3-13\. 为一组路由添加前缀
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that each prefixed group also has a `/` route that represents the root
    of the prefix—​in [Example 3-13](#EX42) that’s `/dashboard`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个带前缀的组还有一个表示前缀根的 `/` 路由—​在 [Example 3-13](#EX42) 中即为 `/dashboard`。
- en: Subdomain Routing
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子域路由
- en: Subdomain routing is the same as route prefixing, but it’s scoped by subdomain
    instead of route prefix. There are two primary uses for this. First, you may want
    to present different sections of the application (or entirely different applications)
    to different subdomains. [Example 3-14](#EX43) shows how you can achieve this.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 子域路由与路由前缀相同，但其范围限定为子域而不是路由前缀。这有两个主要用途。首先，您可能希望为应用程序的不同部分（或完全不同的应用程序）提供不同的子域。[示例 3-14](#EX43)展示了如何实现这一点。
- en: Example 3-14\. Subdomain routing
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-14\. 子域路由
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Second, you might want to set part of the subdomain as a parameter, as illustrated
    in [Example 3-15](#EX44). This is most often done in cases of multitenancy (think
    Slack or Harvest, where each company gets its own subdomain, like *tighten.slack.co*).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您可能希望将子域的一部分设置为参数，如[示例 3-15](#EX44)所示。这在多租户情况下最常见（想想Slack或Harvest，每个公司都有自己的子域，如*tighten.slack.co*）。
- en: Example 3-15\. Parameterized subdomain routing
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-15\. 参数化子域路由
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that any parameters for the group get passed into the grouped routes’ methods
    as the first parameter(s).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，组的任何参数都作为第一个参数传递给组内路由的方法。
- en: Name Prefixes
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 名称前缀
- en: It’s common that route names will reflect the inheritance chain of path elements,
    so `users/comments/5` will be served by a route named `users.comments.show`. In
    this case, it’s common to use a route group around all of the routes that are
    beneath the `users.comments` resource.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 路由名称通常会反映路径元素的继承链，因此`users/comments/5`将由名为`users.comments.show`的路由提供服务。在这种情况下，通常在所有属于`users.comments`资源下的路由周围使用路由组。
- en: Just like we can prefix URL segments, we can also prefix strings to the route
    name. With route group name prefixes, we can define that every route within this
    group should have a given string prefixed to its name. In this context, we’re
    prefixing `"users."` to each route name, then `"comments."` (see [Example 3-16](#EX46)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们可以为URL段添加前缀一样，我们也可以为路由名称添加前缀字符串。使用路由组名称前缀，我们可以定义该组内的每个路由名称都应该以给定的字符串前缀`"users."`开头，然后是`"comments."`（参见[示例 3-16](#EX46)）。
- en: Example 3-16\. Route group name prefixes
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-16\. 路由组名称前缀
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Route Group Controllers
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由组控制器
- en: When you’re grouping routes that are served by the same controller, such as
    when we’re showing, editing, and deleting users, for example, we can use the route
    group `controller()` method, as shown in [Example 3-17](#EX45), to avoid having
    to define the full tuple for every route.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对由同一控制器提供服务的路由进行分组时，例如我们显示、编辑和删除用户时，可以使用路由组的`controller()`方法，如[示例 3-17](#EX45)所示，避免为每个路由定义完整的元组。
- en: Example 3-17\. Route group controllers
  id: totrans-138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-17\. 路由组控制器
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Fallback Routes
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回退路由
- en: 'In Laravel you can define a “fallback route” (which you need to define at the
    end of your routes file) to catch all unmatched requests:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Laravel中，您可以定义一个“回退路由”（需要在路由文件末尾定义），以捕获所有未匹配的请求：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Signed Routes
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签名路由
- en: Many applications regularly send notifications about one-off actions (resetting
    a password, accepting an invitation, etc.) and provide simple links to take those
    actions. Let’s imagine sending an email confirming the recipient was willing to
    be added to a mailing list.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序定期发送关于一次性操作的通知（如重置密码、接受邀请等），并提供简单的链接执行这些操作。让我们想象发送一封电子邮件，确认收件人愿意加入邮件列表。
- en: 'There are three ways to send that link:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方式发送该链接：
- en: Make that URL public and hope no one else discovers the approval URL or modifies
    their own approval URL to approve someone else.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将该URL公开，并希望没有其他人发现批准URL或修改自己的批准URL以批准其他人。
- en: Put the action behind authentication, link to the action, and require the user
    to log in if they’re not logged in yet (which, in this case, may be impossible,
    as many mailing list recipients likely won’t be users with accounts).
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将操作放在身份验证后，链接到操作，并要求用户在尚未登录的情况下登录（在这种情况下，许多邮件列表接收者可能不会是具有帐户的用户，因此可能不可能登录）。
- en: “Sign” the link so that it uniquely proves that the user received the link from
    your email, without them having to log in—something like *http://myapp.com/invitations/5816/yes?signature=030ab0ef6a8237bd86a8b8*.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “签名”链接，以唯一证明用户从您的电子邮件收到了链接，而无需登录——类似于*http://myapp.com/invitations/5816/yes?signature=030ab0ef6a8237bd86a8b8*。
- en: One simple way to accomplish the last option is to use a feature called *signed
    URLs*, which makes it easy to build a signature authentication system for sending
    out authenticated links. These links are composed of the normal route link with
    a “signature” appended that proves that the URL has not been changed since it
    was sent (and therefore that no one has modified the URL to access someone else’s
    information).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 实现最后一种选项的一种简单方法是使用称为 *signed URLs* 的功能，它使得为发送验证链接的人员构建签名身份验证系统变得简单。这些链接由正常路由链接组成，附加一个“签名”，证明自链接发送以来未更改该
    URL（因此没有人修改了 URL 以访问他人的信息）。
- en: Signing a Route
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 签名路由
- en: 'To build a signed URL to access a given route, the route must have a name:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个签名 URL 来访问给定路由，该路由必须有一个名称：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To generate a normal link to this route you would use the `route()` helper,
    as we’ve already covered, but you could also use the `URL` facade to do the same
    thing: `URL::route(''invitations'', [''invitation'' => 12345, ''answer'' => ''yes''])`.
    To generate a *signed* link to this route, simply use the `signedRoute()` method
    instead. And if you want to generate a signed route with an expiration, use `temporarySignedRoute()`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成到此路由的普通链接，您可以使用我们已经介绍的 `route()` 辅助函数，但您也可以使用 `URL` 外观执行相同的操作：`URL::route('invitations',
    ['invitation' => 12345, 'answer' => 'yes'])`。要生成带有 *signed* 的链接到此路由，只需使用 `signedRoute()`
    方法。如果您想生成带有过期时间的签名路由，请使用 `temporarySignedRoute()`：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Using the now() Helper
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 now() 辅助函数
- en: Laravel offers a `now()` helper that’s the equivalent of `Carbon::now()`; it
    returns a Carbon object representative of today, right at this second.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 提供了 `now()` 辅助函数，相当于 `Carbon::now()`；它返回一个代表当前时间的 Carbon 对象。
- en: Carbon is a datetime library that’s included with Laravel.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Carbon 是 Laravel 自带的日期时间库。
- en: Modifying Routes to Allow Signed Links
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改路由以允许签名链接
- en: 'Now that you’ve generated a link to your signed route, you need to protect
    against any unsigned access. The easiest option is to apply the `signed` middleware:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经生成了到您的签名路由的链接，您需要保护免受任何未签名的访问。最简单的选择是应用 `signed` 中间件：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you’d prefer, you can manually validate using the `hasValidSignature()`
    method on the `Request` object instead of using the `signed` middleware:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以手动验证使用 `Request` 对象上的 `hasValidSignature()` 方法，而不是使用 `signed` 中间件：
- en: '[PRE23]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Views
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: In a few of the route closures we’ve looked at so far, we’ve seen something
    along the lines of `return view('account')`. What’s going on here?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前查看的一些路由闭包中，我们看到类似 `return view('account')` 的代码。这里发生了什么？
- en: In the MVC pattern ([Figure 3-1](#FIG301)), *views* (or templates) are files
    that describe what some particular output should look like. You might have views
    that output JSON or XML or email, but the most common views in a web framework
    output HTML.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MVC 模式中（见[图 3-1](#FIG301)），*视图*（或模板）是描述特定输出应该如何看起来的文件。您可能有输出 JSON、XML 或电子邮件的视图，但在
    Web 框架中，最常见的视图输出是 HTML。
- en: 'In Laravel, there are two view formats you can use out of the box: plain PHP
    and Blade templates (see [Chapter 4](ch04.html#blade_templating)). The difference
    is in the filename: *about.php* will be rendered with the PHP engine, and *about.blade.php*
    will be rendered with the Blade engine.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Laravel 中，您可以使用两种视图格式：纯 PHP 和 Blade 模板（参见[第四章](ch04.html#blade_templating)）。区别在于文件名：*about.php*
    将使用 PHP 引擎呈现，而 *about.blade.php* 将使用 Blade 引擎呈现。
- en: Three Ways to Load a View
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载视图的三种方式
- en: There are three ways to return a view. For now, just concern yourself with `view()`,
    but if you ever see `View::make()`, it’s the same thing, or you could inject `Illuminate\View\ViewFactory`
    if you prefer.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以返回视图。目前只需要关注 `view()`，但如果你看到 `View::make()`，它是一样的，或者你可以注入 `Illuminate\View\ViewFactory`
    如果你更喜欢。
- en: Once you’ve “loaded” a view with the `view()` helper, you have the option to
    simply return it (as in [Example 3-18](#EX47)), which will work fine if the view
    doesn’t rely on any variables from the controller.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您使用 `view()` 辅助函数“加载”视图，您可以选择简单地返回它（如[示例 3-18](#EX47)），如果视图不依赖于控制器中的任何变量，这将运行良好。
- en: Example 3-18\. Simple `view()` usage
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-18\. 简单的 `view()` 使用方法
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code looks for a view in *resources/views/home.blade.php* or *resources/views/home.php*
    and loads its contents and parses any inline PHP or control structures until you
    have just the view’s output. Once you return it, it’s passed on to the rest of
    the response stack and eventually returned to the user.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码查找 *resources/views/home.blade.php* 或 *resources/views/home.php* 中的视图，并加载其内容并解析任何内联
    PHP 或控制结构，直到只剩下视图的输出。一旦返回它，它将传递给响应堆栈的其余部分，并最终返回给用户。
- en: But what if you need to pass in variables? Take a look at [Example 3-19](#EX48).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果需要传入变量怎么办？看一下[示例 3-19](#EX48)。
- en: Example 3-19\. Passing variables to views
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-19\. 将变量传递给视图
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This closure loads the *resources/views/tasks/index.blade.php* or *resources/views/tasks/index.php*
    view and passes it a single variable named `tasks`, which contains the result
    of the `Task::all()` method. `Task::all()` is an Eloquent database query you’ll
    learn about in [Chapter 5](ch05.html#database_and_eloquent).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此闭包加载 *resources/views/tasks/index.blade.php* 或 *resources/views/tasks/index.php*
    视图，并传递一个名为 `tasks` 的单一变量，其中包含 `Task::all()` 方法的结果。 `Task::all()` 是您将在[第五章](ch05.html#database_and_eloquent)学习的
    Eloquent 数据库查询。
- en: Returning Simple Routes Directly with Route::view()
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Route::view() 直接返回简单路由
- en: Because it’s so common for a route to just return a view with no custom data,
    Laravel allows you to define a route as a “view” route without even passing the
    route definition a closure or a controller/method reference, as you can see in
    [Example 3-20](#route_view).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 因为路由只返回视图而不传递自定义数据非常常见，所以 Laravel 允许您将路由定义为“视图”路由，甚至不传递闭包或控制器/方法引用，正如您可以在[示例 3-20](#route_view)中看到的那样。
- en: Example 3-20\. `Route::view()`
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-20\. `Route::view()`
- en: '[PRE26]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Using View Composers to Share Variables with Every View
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用视图组合器与每个视图共享变量
- en: Sometimes it can become a hassle to pass the same variables over and over. There
    may be a variable that you want accessible to every view in the site or to a certain
    class of views or a certain included subview—​for example, all views related to
    tasks or the header partial.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 有时反复传递相同变量可能会变得很麻烦。可能有一个您希望每个网站视图或某个视图类或某个包含的子视图都可以访问的变量，例如与任务相关的所有视图或页眉部分。
- en: 'It’s possible to share certain variables with every template or just certain
    templates, like in the following code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可以与每个模板或仅某些模板共享某些变量，如以下代码所示：
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: To learn more, check out [“View Composers and Service Injection”](ch04.html#view-comp-serv).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多，请参阅[“视图组合器和服务注入”](ch04.html#view-comp-serv)。
- en: Controllers
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: I’ve mentioned controllers a few times, but until now, most of the examples
    have shown route closures. In the MVC pattern, controllers are essentially classes
    that organize the logic of one or more routes together in one place. Controllers
    tend to group similar routes together, especially if your application is structured
    in a traditionally CRUD-like format; in this case, a controller might handle all
    the actions that can be performed on a particular resource.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到控制器，但直到现在，大多数示例都展示了路由闭包。在 MVC 模式中，控制器本质上是组织一个或多个路由逻辑的类，集中在一个地方。控制器倾向于将类似的路由组合在一起，特别是如果您的应用程序结构类似于传统的
    CRUD 格式；在这种情况下，控制器可能处理与特定资源相关的所有操作。
- en: What is CRUD?
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 CRUD？
- en: CRUD stands for *create*, *read*, *update*, *delete*, which are the four primary
    operations that web applications most commonly provide on a resource. For example,
    you can create a new blog post, you can read that post, you can update it, or
    you can delete it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: CRUD 是 *创建*、*读取*、*更新*、*删除* 的缩写，这是 Web 应用程序对资源提供的四种主要操作。例如，您可以创建新的博客文章，可以阅读该文章，可以更新它，或者可以删除它。
- en: It may be tempting to cram all of the application’s logic into the controllers,
    but it’s better to think of controllers as the traffic cops that route HTTP requests
    around your application. Since there are other ways requests can come into your
    application—cron jobs, Artisan command-line calls, queue jobs, etc.—it’s wise
    to not rely on controllers for much behavior. This means a controller’s primary
    job is to capture the intent of an HTTP request and pass it on to the rest of
    the application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 或许把应用程序所有的逻辑都塞进控制器中是很诱人的，但是将控制器视为路由 HTTP 请求在应用程序中导航的交通警察会更好。由于请求可以通过其他方式进入应用程序——如定时任务、Artisan
    命令行调用、队列作业等——因此不要依赖控制器处理太多行为是明智的。这意味着控制器的主要工作是捕获 HTTP 请求的意图并将其传递给应用程序的其他部分。
- en: 'So, let’s create a controller. One easy way to do this is with an Artisan command,
    so from the command line, run the following:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们创建一个控制器。一个简单的方法是使用 Artisan 命令，在命令行中运行以下命令：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Artisan and Artisan Generators
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Artisan 和 Artisan 生成器
- en: Laravel comes bundled with a command-line tool called Artisan. Artisan can be
    used to run migrations, create users and other database records manually, and
    perform many other manual, one-time tasks.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 捆绑了一个称为 Artisan 的命令行工具。 Artisan 可用于运行迁移，手动创建用户和其他数据库记录，并执行许多其他一次性手动任务。
- en: Under the `make` namespace, Artisan provides tools for generating skeleton files
    for a variety of system files. That’s what allows us to run `php artisan make:controller`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`make`命名空间下，Artisan提供了生成各种系统文件骨架文件的工具。这就是我们能够运行`php artisan make:controller`的原因。
- en: To learn more about this and other Artisan features, see [Chapter 8](ch08.html#artisan_and_tinker).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这个和其他Artisan功能的信息，请参阅[第8章](ch08.html#artisan_and_tinker)。
- en: This will create a new file named *TaskController.php* in *app/Http/Controllers*,
    with the contents shown in [Example 3-21](#EX52).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在*app/Http/Controllers*目录下创建一个名为*TaskController.php*的新文件，并显示示例[3-21](#EX52)中的内容。
- en: Example 3-21\. Default generated controller
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-21\. 默认生成的控制器
- en: '[PRE29]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Modify this file as shown in [Example 3-22](#EX53), creating a new public method
    called `index()`. We’ll just return some text there.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 修改这个文件，如[示例 3-22](#EX53)所示，创建一个名为`index()`的新公共方法。我们将在那里返回一些文本。
- en: Example 3-22\. Simple controller example
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-22\. 简单的控制器示例
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Then, like we learned before, we’ll hook up a route to it, as shown in [Example 3-23](#EX54).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，就像我们之前学到的那样，我们将把一个路由链接到它，如[示例 3-23](#EX54)所示。
- en: Example 3-23\. Route for the simple controller
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-23\. 简单控制器的路由
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That’s it. Visit the `/` route and you’ll see the words “Hello, World!”
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。访问`/`路由，你将看到“Hello, World!”这几个字。
- en: The most common use of a controller method, then, will be something like [Example 3-24](#EX55),
    which provides the same functionality as our route closure in [Example 3-19](#EX48).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器方法最常见的用法之一将是像[示例 3-24](#EX55)那样，它提供了与我们在[示例 3-19](#EX48)中路由闭包相同的功能。
- en: Example 3-24\. Common controller method example
  id: totrans-208
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-24\. 常见的控制器方法示例
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This controller method loads the *resources/views/tasks/index.blade.php* or
    *resources/views/tasks/index.php* view and passes it a single variable named `tasks`,
    which contains the result of the `Task::all()` Eloquent method.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个控制器方法加载*resources/views/tasks/index.blade.php*或*resources/views/tasks/index.php*视图，并传递一个名为`tasks`的单个变量，其中包含`Task::all()`
    Eloquent方法的结果。
- en: Generating Resource Controllers
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成资源控制器
- en: 'If you want to create a resource controller with autogenerated methods for
    all the basic resource routes like `create()` and `update()`, you can pass the
    `--resource` flag when using `php artisan make:controller`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个资源控制器，并为所有基本的资源路由（如`create()`和`update()`）生成自动生成的方法，你可以在使用`php artisan
    make:controller`时传递`--resource`标志：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Getting User Input
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户输入
- en: The second most common action to perform in a controller method is to take input
    from the user and act on it. That introduces a few new concepts, so let’s take
    a look at a bit of sample code and walk through the new pieces.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器方法中执行的第二个最常见操作是从用户获取输入并对其进行操作。这引入了一些新概念，所以让我们看一些示例代码，并逐步了解新的内容。
- en: First, let’s bind our route; see [Example 3-25](#EX56).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们绑定我们的路由；参见[示例 3-25](#EX56)。
- en: Example 3-25\. Binding basic form actions
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-25\. 绑定基本表单操作
- en: '[PRE34]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Notice that we’re binding the `GET` action of `tasks/create` (which shows a
    form for creating a new task) and the `POST` action of `tasks` (which is where
    our form will `POST` to when we’re creating a new task). We can assume the `create()`
    method in our controller just shows a form, so let’s look at the `store()` method
    in [Example 3-26](#EX57).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在绑定`tasks/create`的`GET`动作（显示创建新任务的表单）和`tasks`的`POST`动作（我们创建新任务时将`POST`到的地方）。我们可以假设我们控制器中的`create()`方法只是显示一个表单，所以让我们看看[示例
    3-26](#EX57)中的`store()`方法。
- en: Example 3-26\. Common form input controller method
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-26\. 常见的表单输入控制器方法
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This example makes use of Eloquent models and the `redirect()` functionality,
    and we’ll talk about them more later, but for now let’s talk quickly about how
    we’re getting our data here.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例使用了Eloquent模型和`redirect()`功能，稍后我们会详细讲解它们，但现在让我们快速看看我们如何在这里获取我们的数据。
- en: We’re using the `request()` helper to represent the HTTP request (more on that
    later) and using its `only()` method to pull just the `title` and `description`
    fields the user submitted.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`request()`助手来表示HTTP请求（稍后详细介绍），并使用它的`only()`方法来提取用户提交的`title`和`description`字段。
- en: We’re then passing that data into the `create()` method of our `Task` model,
    which creates a new instance of the `Task` with `title` set to the passed-in title
    and `description` set to the passed-in description. Finally, we redirect back
    to the page that shows all tasks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些数据传递给我们的`Task`模型的`create()`方法，该方法使用传入的标题设置一个新的`Task`实例，并将传入的描述设置为`description`。最后，我们重定向回显示所有任务的页面。
- en: 'There are a few layers of abstraction at work here, which we’ll cover in a
    second, but know that the data coming from the `only()` method comes from the
    same pool of data all common methods used on the `Request` object draw from, including
    `all()` and `get()`. The set of data each of these methods is pulling from represents
    all user-provided data, whether from query parameters or `POST` values. So, our
    user filled out two fields on the “add task” page: “title” and “description.”'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几层抽象在起作用，我们稍后会详细介绍，但需要知道来自 `only()` 方法的数据来自于 `Request` 对象上所有常用方法使用的同一组数据池，包括
    `all()` 和 `get()`。每个方法提取的数据集代表了所有用户提供的数据，无论是来自查询参数还是 `POST` 值。所以，我们的用户在“添加任务”页面上填写了两个字段：“标题”和“描述”。
- en: 'To break down the abstraction a bit, `request()->only()` takes an associative
    array of input names and returns them:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 简单解释一下，`request()->only()`接受一个输入名称的关联数组并返回它们：
- en: '[PRE36]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And `Task::create()` takes an associative array and creates a new task from
    it:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `Task::create()` 接受一个关联数组并根据此数组创建一个新任务：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Combining them together creates a task with just the user-provided “title” and
    “description” fields.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 结合它们一起，只需用户提供的“标题”和“描述”字段就可以创建一个任务。
- en: Injecting Dependencies into Controllers
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将依赖项注入到控制器中
- en: Laravel’s facades and global helpers present a simple interface to the most
    useful classes in Laravel’s codebase. You can get information about the current
    request and user input, the session, caches, and much more.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的外观和全局助手为 Laravel 代码库中最有用的类提供了一个简单的接口。你可以获取关于当前请求和用户输入、会话、缓存等的信息。
- en: But if you prefer to inject your dependencies, or if you want to use a service
    that doesn’t have a facade or a helper, you’ll need to find some way to bring
    instances of these classes into your controller.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果你更喜欢注入你的依赖项，或者想使用一个没有外观或助手的服务，你需要找到一些方法将这些类的实例引入到你的控制器中。
- en: This is our first exposure to Laravel’s service container. For now, if this
    is unfamiliar, you can think about it as a little bit of Laravel magic; or, if
    you want to know more about how it’s actually functioning, you can skip ahead
    to [Chapter 11](ch11.html#the_container).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次接触 Laravel 的服务容器。如果现在这个概念还不熟悉，可以把它想象成是一点点 Laravel 的魔法；或者，如果你想更深入地了解它的实际运作方式，可以跳到[第
    11 章](ch11.html#the_container)。
- en: All controller methods (including the constructors) are resolved out of Laravel’s
    container, which means anything you typehint that the container knows how to resolve
    will be automatically injected.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 所有控制器方法（包括构造函数）都是通过 Laravel 的容器解析出来的，这意味着任何你在容器中能够解析的类型提示将被自动注入。
- en: Typehints in PHP
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP 中的类型提示
- en: '*Typehinting* in PHP means putting the name of a class or interface in front
    of a variable in a method signature:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*PHP 中的类型提示* 意味着在方法签名中的变量前放置类或接口的名称：'
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This typehint is telling PHP that whatever is passed into the method *must*
    be of type `Logger`, which could be either an interface or a class.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型提示告诉 PHP，传递到方法中的任何东西 *必须* 是 `Logger` 类型，这可以是接口或类。
- en: As a nice example, what if you’d prefer having an instance of the `Request`
    object instead of using the global helper? Just typehint `Illuminate\Http\Request`
    in your method parameters, like in [Example 3-27](#EX58).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个好的示例，如果你更喜欢使用 `Request` 对象的实例而不是使用全局助手，只需在你的方法参数中进行类型提示 `Illuminate\Http\Request`，就像在[示例 3-27](#EX58)中一样。
- en: Example 3-27\. Controller method injection via typehinting
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-27\. 通过类型提示进行控制器方法注入
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So, you’ve defined a parameter that must be passed into the `store()` method.
    And since you typehinted it, and since Laravel knows how to resolve that class
    name, you’re going to have the `Request` object ready for you to use in your method
    with no work on your part. No explicit binding, no anything else—​it’s just there
    as the `$request` variable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你定义了一个必须传递到 `store()` 方法中的参数。由于你进行了类型提示，并且由于 Laravel 知道如何解析该类名，你将在方法中直接得到
    `Request` 对象，而不需要额外工作。没有显式绑定，没有其他任何东西——它只是作为 `$request` 变量存在。
- en: And, as you can tell from comparing Examples [3-26](#EX57) and [3-27](#EX58),
    the `request()` helper and the `Request` object behave exactly the same.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，通过比较示例 [3-26](#EX57) 和 [3-27](#EX58)，可以看出 `request()` 助手和 `Request` 对象的行为完全一样。
- en: Resource Controllers
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源控制器
- en: Sometimes naming the methods in your controllers can be the hardest part of
    writing a controller. Thankfully, Laravel has some conventions for all of the
    routes of a traditional REST/CRUD controller (called a *resource controller* in
    Laravel); additionally, it comes with a generator out of the box and a convenience
    route definition that allows you to bind an entire resource controller at once.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，在编写控制器时，为控制器中的方法命名可能是最困难的部分。幸运的是，Laravel 对传统的 REST/CRUD 控制器（在 Laravel 中称为
    *资源控制器*）有一些约定，此外，它还提供了一个默认生成器和一个便捷的路由定义，允许你一次性绑定整个资源控制器。
- en: 'To see the methods that Laravel expects for a resource controller, let’s generate
    a new controller from the command line:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Laravel 期望资源控制器的方法，请从命令行生成一个新的控制器：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now open *app/Http/Controllers/MySampleResourceController.php*. You’ll see it
    comes prefilled with quite a few methods. Let’s walk through what each represents.
    We’ll use a `Task` as an example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 *app/Http/Controllers/MySampleResourceController.php*。你会看到它已经预先填充了许多方法。让我们逐一看看每个方法代表什么。我们将以一个`Task`为例。
- en: The methods of Laravel’s resource controllers
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Laravel 资源控制器的方法
- en: Remember the table from earlier? [Table 3-1](#table0301) shows the HTTP verb,
    the URL, the controller method name, and the name for each of these default methods
    that are generated in Laravel’s resource controllers.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得前面的表格吗？[Table 3-1](#table0301) 显示了每个默认生成的方法的 HTTP 动词、URL、控制器方法名以及名称。
- en: Binding a resource controller
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定资源控制器
- en: So, we’ve seen that these are the conventional route names to use in Laravel,
    and also that it’s easy to generate a resource controller with methods for each
    of these default routes. Thankfully, you don’t have to generate routes for each
    of these controller methods by hand, if you don’t want to. There’s a trick for
    that, called *resource controller binding*. Take a look at [Example 3-28](#EX59).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们已经看到这些是在 Laravel 中使用的传统路由名称，也看到可以轻松生成一个带有每个默认路由方法的资源控制器。幸运的是，如果你不想手动为每个控制器方法生成路由，也不必如此。有一个名为
    *资源控制器绑定* 的技巧，看看 [Example 3-28](#EX59)。
- en: Example 3-28\. Resource controller binding
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-28\. 资源控制器绑定
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This will automatically bind all of the routes listed in [Table 3-1](#table0301)
    for this resource to the appropriate method names on the specified controller.
    It’ll also name these routes appropriately; for example, the `index()` method
    on the `tasks` resource controller will be named `tasks.index`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这将自动将资源中列出的所有路由绑定到指定控制器上相应的方法名。它还会适当地命名这些路由；例如，`tasks`资源控制器上的`index()`方法将被命名为`tasks.index`。
- en: artisan route:list
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: artisan route:list
- en: 'If you ever find yourself in a situation where you’re wondering what routes
    your current application has available, there’s a tool for that: from the command
    line, run `php artisan route:list` and you’ll get a listing of all of the available
    routes. I prefer `php artisan route:list --exclude-vendor` so I don’t see all
    the weird routes my dependencies register in order for them to operate (see [Figure 3-2](#FIG301X)).'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己想知道当前应用程序有哪些可用路由，请使用工具来解决这个问题：从命令行运行 `php artisan route:list`，你将得到所有可用路由的列表。我更喜欢
    `php artisan route:list --exclude-vendor`，这样我就不会看到所有我依赖项注册的怪异路由（参见图 3-2）。
- en: '![lur3 0302](assets/lur3_0302.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![lur3 0302](assets/lur3_0302.png)'
- en: Figure 3-2\. artisan route:list
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-2\. artisan route:list
- en: API Resource Controllers
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 资源控制器
- en: When you’re working with RESTful APIs, the list of potential actions on a resource
    is not the same as it is with an HTML resource controller. For example, you can
    send a `POST` request to an API to create a resource, but you can’t really “show
    a create form” in an API.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 RESTful API 时，资源的潜在操作列表与 HTML 资源控制器不同。例如，你可以向 API 发送 `POST` 请求来创建资源，但在
    API 中你不能真正“显示创建表单”。
- en: 'To generate an *API resource controller*, which is a controller that has the
    same structure as a resource controller except it excludes the *create* and *edit*
    actions, pass the `--api` flag when creating a controller:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个 *API 资源控制器*，它的结构与资源控制器相同，但不包括 *create* 和 *edit* 操作，请在创建控制器时传递 `--api`
    标志：
- en: '[PRE42]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: To bind an API resource controller, use the `apiResource()` method instead of
    the `resource()` method, as shown in [Example 3-29](#EX60).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 要绑定一个 API 资源控制器，请使用 `apiResource()` 方法，而不是 `resource()` 方法，如 [Example 3-29](#EX60)
    所示。
- en: Example 3-29\. API resource controller binding
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-29\. API 资源控制器绑定
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Single Action Controllers
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一操作控制器
- en: There will be times in your applications when a controller should only service
    a single route. You may find yourself wondering how to name the controller method
    for that route. Thankfully, you can point a single route at a single controller
    without concerning yourself with naming the one method.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中会有时候需要一个控制器只服务一个路由。你可能会想知道如何为该路由命名控制器方法。幸运的是，你可以将单个路由指向单个控制器，而无需担心命名该方法。
- en: As you may already know, the `__invoke()` method is a PHP magic method that
    allows you to “invoke” an instance of a class, treating it like a function and
    calling it. This is the tool Laravel’s *single action controllers* use to allow
    you to point a route to a single controller, as you can see in [Example 3-30](#EX61).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经知道的那样，`__invoke()` 方法是 PHP 的一个魔术方法，允许你“调用”类的实例，像调用函数一样调用它。这是 Laravel
    的 *单操作控制器* 使用的工具，允许你将路由指向单个控制器，正如你可以在 [示例 3-30](#EX61) 中看到的那样。
- en: Example 3-30\. Using the `__invoke()` method
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-30\. 使用 `__invoke()` 方法
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Route Model Binding
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由模型绑定
- en: One of the most common routing patterns is that the first line of any controller
    method tries to find the resource with the given ID, like in [Example 3-31](#EX62).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的路由模式之一是任何控制器方法的第一行尝试查找具有给定 ID 的资源，例如 [示例 3-31](#EX62)。
- en: Example 3-31\. Getting a resource for each route
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-31\. 为每个路由获取资源
- en: '[PRE45]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Laravel provides a feature that simplifies this pattern called *route model
    binding*. This allows you to define that a particular parameter name (e.g., `{conference}`)
    will indicate to the route resolver that it should look up an Eloquent database
    record with that ID and then pass it in as the parameter *instead* of just passing
    the ID.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 提供了一个简化此模式的功能称为 *路由模型绑定*。这允许你定义一个特定的参数名称（例如 `{conference}`），表示路由解析器应该查找具有该
    ID 的 Eloquent 数据库记录，然后将其作为参数传递给闭包或控制器方法 *而不是* 仅仅传递 ID。
- en: 'There are two kinds of route model binding: implicit and custom (or explicit).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的路由模型绑定：隐式和自定义（或显式）。
- en: Implicit Route Model Binding
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式路由模型绑定
- en: The simplest way to use route model binding is to name your route parameter
    something unique to that model (e.g., name it `$conference` instead of `$id`),
    then typehint that parameter in the closure/controller method and use the same
    variable name there. It’s easier to show than to describe, so take a look at [Example 3-32](#EX75).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路由模型绑定的最简单方法是将路由参数命名为该模型独有的名称（例如，将其命名为 `$conference` 而不是 `$id`），然后在闭包/控制器方法中对该参数进行类型提示并在那里使用相同的变量名。展示起来比描述容易，因此请查看
    [示例 3-32](#EX75)。
- en: Example 3-32\. Using an implicit route model binding
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-32\. 使用隐式路由模型绑定
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Because the route parameter (`{conference}`) is the same as the method parameter
    (`$conference`), and the method parameter is typehinted with a `Conference` model
    (`Conference $conference`), Laravel sees this as a route model binding. Every
    time this route is visited, the application will assume that whatever is passed
    into the URL in place of `{conference}` is an ID that should be used to look up
    a `Conference`, and then that resulting model instance will be passed in to your
    closure or controller method.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 因为路由参数（`{conference}`）与方法参数（`$conference`）相同，并且方法参数是用 `Conference` 模型进行类型提示的（`Conference
    $conference`），Laravel 将其视为路由模型绑定。每次访问此路由时，应用程序将假定传入 URL 中的任何内容代替 `{conference}`
    都是一个 ID，应该用于查找 `Conference`，然后将生成的模型实例传递给你的闭包或控制器方法。
- en: Customizing the Route Key for an Eloquent Model
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义 Eloquent 模型的路由键
- en: Any time an Eloquent model is looked up via a URL segment (usually because of
    route model binding), the default column Eloquent will look it up by is its primary
    key (ID).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 每当通过 URL 段查找 Eloquent 模型（通常是因为路由模型绑定），Eloquent 将使用其主键（ID）进行查找。
- en: 'To change the column your Eloquent model uses for URL lookups in all your routes,
    add a method to your model named `getRouteKeyName()`:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改你的 Eloquent 模型在所有路由中用于 URL 查找的列，请在模型中添加一个名为 `getRouteKeyName()` 的方法：
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now, a URL like `conferences/{conference}` will expect to get an entry from
    the slug column instead of the ID and will perform its lookups accordingly.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，像 `conferences/{conference}` 这样的 URL 将期望从 slug 列获取条目而不是 ID，并且将根据其进行查找。
- en: Customizing the Route Key in a Specific Route
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在特定路由中自定义路由键
- en: 'In Laravel, you can also change the route key on a specific route instead of
    globally by appending a colon and the column name in the route definition:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Laravel 中，你还可以通过在路由定义中追加冒号和列名来在特定路由上更改路由键：
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you have two dynamic segments in your URL (for example: `organizers/{organizer}/conferences/{conference:slug`),
    Laravel will automatically attempt to scope the second model’s queries to only
    those related to the first. So it’ll check the `Organizer` model for a `conferences`
    relationship, and if it exists, only return Conferences that are associated with
    the `Organizer` found by the first segment.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的 URL 中有两个动态段（例如：`organizers/{organizer}/conferences/{conference:slug}`），Laravel
    将自动尝试将第二个模型的查询范围限定为仅与第一个相关联的内容。因此，它将检查 `Organizer` 模型是否具有 `conferences` 关系，如果存在，则只返回与第一个段找到的
    `Organizer` 相关联的 Conferences。
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Custom Route Model Binding
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义路由模型绑定
- en: To manually configure route model bindings, add a line like the one in [Example 3-33](#EX63)
    to the `boot()` method in `App\Providers\RouteServiceProvider`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动配置路由模型绑定，请在 `App\Providers\RouteServiceProvider` 的 `boot()` 方法中添加类似 [Example 3-33](#EX63)
    的行。
- en: Example 3-33\. Adding a route model binding
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-33\. 添加路由模型绑定
- en: '[PRE50]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You’ve now specified that whenever a route has a parameter in its definition
    named `{event}`, as demonstrated in [Example 3-34](#EX64), the route resolver
    will return an instance of the `Conference` class with the ID of that URL parameter.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你指定了当路由定义中有一个名为 `{event}` 的参数时（例如 [Example 3-34](#EX64) 中演示的），路由解析器将返回一个带有该
    URL 参数 ID 的 `Conference` 类的实例。
- en: Example 3-34\. Using an explicit route model binding
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-34\. 使用显式路由模型绑定
- en: '[PRE51]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Route Caching
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由缓存
- en: If you’re looking to squeeze every millisecond out of your load time, you may
    want to take a look at *route caching*. One of the pieces of Laravel’s bootstrap
    that can take anywhere from a few dozen to a few hundred milliseconds is parsing
    the *routes/** files, and route caching speeds up this process dramatically.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尽可能减少加载时间，你可能需要关注 *路由缓存*。 Laravel 启动过程中的一个步骤是解析 *routes/** 文件，可能需要几十到几百毫秒，而路由缓存可以极大加快这一过程。
- en: To cache your routes file, you need to be using all controller, redirect, view,
    and resource routes (no route closures). If your app isn’t using any route closures,
    you can run `php artisan route:cache` and Laravel will serialize the results of
    your *routes/** files. If you want to delete the cache, run `php artisan route:clear`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要缓存你的路由文件，你需要使用所有控制器、重定向、视图和资源路由（不使用路由闭包）。如果你的应用程序不使用任何路由闭包，你可以运行 `php artisan
    route:cache`，Laravel 将序列化你的 *routes/** 文件的结果。如果想删除缓存，请运行 `php artisan route:clear`。
- en: 'Here’s the drawback: Laravel will now match routes against that cached file
    instead of your actual *routes/** files. You can make endless changes to your
    routes files, and they won’t take effect until you run `route:cache` again. This
    means you’ll have to recache every time you make a change, which introduces a
    lot of potential for confusion.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是：Laravel 现在将匹配路由与缓存文件而不是实际的 *routes/** 文件。你可以对路由文件进行无限更改，但在再次运行 `route:cache`
    之前，这些更改不会生效。这意味着每次更改都需要重新缓存，这可能会带来很多混乱的潜力。
- en: 'Here’s what I would recommend instead: since Git ignores the route cache file
    by default anyway, consider only using route caching on your production server,
    and run the `php artisan route:cache` command every time you deploy new code (whether
    via a Git post-deploy hook, a Forge deploy command, or as a part of whatever other
    deployment system you use). This way, you won’t have confusing local development
    issues, but your remote environment will still benefit from route caching.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议的替代方案是：由于 Git 默认会忽略路由缓存文件，因此考虑仅在生产服务器上使用路由缓存，并在每次部署新代码时运行 `php artisan route:cache`
    命令（无论是通过 Git 的后处理挂钩、Forge 部署命令还是其他部署系统的一部分）。这样，你不会在本地开发时遇到混乱的问题，但远程环境仍然可以从路由缓存中受益。
- en: Form Method Spoofing
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表单方法欺骗
- en: Sometimes you need to manually define which HTTP verb a form should send as.
    HTML forms only allow for `GET` or `POST`, so if you want any other sort of verb,
    you’ll need to specify that yourself.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要手动定义表单应发送的 HTTP 动词。HTML 表单只允许 `GET` 或 `POST`，所以如果你想使用其他动词，就需要自行指定。
- en: HTTP Verbs in Laravel
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Laravel 中的 HTTP 动词
- en: As we’ve seen already, you can define which verbs a route will match in the
    route definition using `Route::get()`, `Route::post()`, `Route::any()`, or `Route::match()`.
    You can also match with `Route::patch()`, `Route::put()`, and `Route::delete()`.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经看到的，你可以使用 `Route::get()`、`Route::post()`、`Route::any()` 或 `Route::match()`
    来定义路由匹配的动词。你还可以使用 `Route::patch()`、`Route::put()` 和 `Route::delete()` 进行匹配。
- en: 'But how does one send a request other than `GET` with a web browser? First,
    the `method` attribute in an HTML form determines its HTTP verb: if your form
    has a `method` of `"GET"`, it will submit via query parameters and a `GET` method;
    if the form has a `method` of `"POST"`, it will submit via the post body and a
    `POST` method.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如何通过 Web 浏览器发送除了 `GET` 之外的请求呢？首先，HTML 表单中的 `method` 属性决定了它的 HTTP 动词：如果你的表单的
    `method` 是 `"GET"`，它将通过查询参数和 `GET` 方法提交；如果表单的 `method` 是 `"POST"`，它将通过 post body
    和 `POST` 方法提交。
- en: JavaScript frameworks make it easy to send other requests, like `DELETE` and
    `PATCH`. But if you find yourself needing to submit HTML forms in Laravel with
    verbs other than `GET` or `POST`, you’ll need to use *form method spoofing*, which
    means spoofing the HTTP method in an HTML form.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 框架使得发送其他请求变得容易，比如 `DELETE` 和 `PATCH`。但是如果你发现自己需要在 Laravel 中提交除了 `GET`
    或 `POST` 之外的动词的 HTML 表单，你需要使用 *表单方法伪造*（form method spoofing），这意味着在 HTML 表单中伪造
    HTTP 方法。
- en: HTTP Method Spoofing in HTML Forms
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML 表单中的 HTTP 方法伪造
- en: To inform Laravel that the form you’re currently submitting should be treated
    as something other than a `POST`, add a hidden variable named `_method` with the
    value of `"PUT"`, `"PATCH"`, or `"DELETE"`, and Laravel will match and route that
    form submission as if it were actually a request with that verb.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要告诉 Laravel 当前提交的表单应被视为非 `POST` 方法的请求，需添加一个名为 `_method` 的隐藏变量，并赋值为 `"PUT"`,
    `"PATCH"` 或 `"DELETE"`，Laravel 将会根据该动词匹配和路由该表单提交。
- en: The form in [Example 3-35](#EX65), since it’s passing Laravel the method of
    `"DELETE"`, will match routes defined with `Route::delete()`, but not those with
    `Route::post()`.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-35](#EX65) 中的表单，因为它传递了方法 `"DELETE"` 给 Laravel，将匹配使用 `Route::delete()`
    定义的路由，但不会匹配使用 `Route::post()` 定义的路由。'
- en: Example 3-35\. Form method spoofing
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-35\. 表单方法伪造
- en: '[PRE52]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: CSRF Protection
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CSRF 保护
- en: If you’ve tried to submit a form in a Laravel application already, including
    the one in [Example 3-35](#EX65), you’ve likely run into the dreaded `TokenMismatchException`.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经尝试在 Laravel 应用中提交表单，包括 [示例 3-35](#EX65) 中的表单，你很可能遇到了可怕的 `TokenMismatchException`。
- en: By default, all routes in Laravel except “read-only” routes (those using `GET`,
    `HEAD`, or `OPTIONS`) are protected against cross-site request forgery (CSRF)
    attacks by requiring a token, in the form of an input named `_token`, to be passed
    along with each request. This token is generated at the start of every session,
    and every non–read-only route compares the submitted `_token` against the session
    token.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Laravel 中，默认情况下，除了“只读”路由（使用 `GET`、`HEAD` 或 `OPTIONS`）之外的所有路由都受到跨站请求伪造（CSRF）攻击的保护，要求在每个请求中传递一个名为
    `_token` 的输入。此 token 在每个会话开始时生成，并且每个非“只读”路由会将提交的 `_token` 与会话 token 进行比较。
- en: What is CSRF?
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 CSRF？
- en: A *cross-site request forgery* is when one website pretends to be another. The
    goal is for someone to hijack your users’ access to your website by submitting
    forms from *their* website to *your* website via the logged-in user’s browser.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '*跨站请求伪造* 是指一个网站假装成另一个网站。其目的是通过在已登录用户的浏览器中从 *他们* 的网站提交到 *你* 的网站上的表单，来劫持你用户对你网站的访问权限。'
- en: The best way around CSRF attacks is to protect all inbound routes—`POST`, `DELETE`,
    etc.—with a token, which Laravel does out of the box.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 避免 CSRF 攻击的最佳方法是默认保护所有入站路由——`POST`、`DELETE` 等——通过一个 token，Laravel 已经内置支持。
- en: You have two options for getting around this CSRF error. The first, and preferred,
    method is to add the `_token` input to each of your submissions. In HTML forms,
    there’s a simple way to do it, as you can see in [Example 3-36](#EX66).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两种方法可以解决 CSRF 错误。第一种，也是首选的方法，是在每个提交中添加 `_token` 输入。在 HTML 表单中，有一种简单的方法，如 [示例
    3-36](#EX66) 中所示。
- en: Example 3-36\. CSRF tokens
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-36\. CSRF tokens
- en: '[PRE53]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'In JavaScript applications, it takes a bit more work, but not much. The most
    common solution for sites using JavaScript frameworks is to store the token on
    every page in a `<meta>` tag like this one:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 应用中，需要更多的工作，但并不复杂。对于使用 JavaScript 框架的站点，最常见的解决方案是在每个页面的 `<meta>`
    标签中存储 token，例如：
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Storing the token in a `<meta>` tag makes it easy to bind it to the correct
    HTTP header, which you can do once globally for all requests from your JavaScript
    framework, like in [Example 3-37](#EX67).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 将 token 存储在 `<meta>` 标签中使得可以轻松地绑定到正确的 HTTP 头部，你可以像在 [示例 3-37](#EX67) 中一样，全局为你的
    JavaScript 框架的所有请求绑定它。
- en: Example 3-37\. Globally binding a header for CSRF
  id: totrans-329
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-37\. 全局绑定 CSRF 的头部
- en: '[PRE55]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Laravel will check the `X-CSRF-TOKEN` (and `X-XSRF-TOKEN`, which Axios and other
    JavaScript frameworks like Angular use) on every request, and valid tokens passed
    there will mark the CSRF protection as satisfied.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 将在每个请求中检查 `X-CSRF-TOKEN`（以及 Axios 和其他 JavaScript 框架如 Angular 使用的 `X-XSRF-TOKEN`），并且传递有效的令牌将标记
    CSRF 保护为满足状态。
- en: Binding CSRF Tokens with Vue Resource
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Vue Resource 绑定 CSRF 令牌的方法有些不同于 Laravel；查看 [Vue Resource 文档](https://oreil.ly/YT0Nb)
    获取示例。
- en: Bootstrapping the CSRF token into Vue Resource looks a bit different than it
    does for Laravel; see the [Vue Resource docs](https://oreil.ly/YT0Nb) for examples.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 将 CSRF 令牌引导到 Vue Resource 看起来与 Laravel 的方式有所不同；查看 [Vue Resource 文档](https://oreil.ly/YT0Nb)
    获取示例。
- en: Redirects
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重定向
- en: So far, the only things we’ve explicitly talked about returning from a controller
    method or route definition have been views. But there are a few other structures
    we can return to give the browser instructions on how to behave.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们明确讨论过从控制器方法或路由定义中返回的仅仅是视图。但是还有一些其他结构可以返回，以便向浏览器提供行为指令。
- en: First, let’s cover the *redirect*. You’ve already seen a few of these in other
    examples. There are two common ways to generate a redirect; we’ll use the `redirect()`
    global helper here, but you may prefer the facade. Both create an instance of
    `Illuminate\Http\RedirectResponse`, perform some convenience methods on it, and
    then return it. You can also do this manually, but you’ll have to do a little
    more work yourself. Take a look at [Example 3-38](#EX68) to see a few ways you
    can return a redirect.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来讨论 *重定向*。你在其他示例中已经看到了一些这样的示例。生成重定向有两种常见的方法；我们将在这里使用 `redirect()` 全局辅助方法，但你可能更喜欢门面。两者都会创建一个
    `Illuminate\Http\RedirectResponse` 实例，对其执行一些便捷方法，然后返回它。你也可以手动执行这些操作，但你将需要做更多的工作。看看
    [示例 3-38](#EX68)，你可以看到几种返回重定向的方法。
- en: Example 3-38\. Different ways to return a redirect
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-38\. 返回重定向的不同方式
- en: '[PRE56]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note that the `redirect()` helper exposes the same methods as the `Redirect`
    facade, but it also has a shortcut; if you pass parameters directly to the helper
    instead of chaining methods after it, it’s a shortcut to the `to()` redirect method.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`redirect()` 辅助方法暴露了与 `Redirect` 门面相同的方法，但它还有一个快捷方式；如果你直接将参数传递给辅助方法，而不是在其后链接方法，那么这是
    `to()` 重定向方法的快捷方式。
- en: Also note that the (optional) third parameter for the `Route::redirect()` route
    helper can be the status code (e.g., 302) for your redirect.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`Route::redirect()` 路由辅助方法的（可选的）第三个参数可以是重定向的状态码（例如，302）。
- en: redirect()->to()
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`redirect()->to()`'
- en: 'The method signature for the `to()` method for redirects looks like this:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 用于重定向的 `to()` 方法的方法签名如下：
- en: '[PRE57]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`$to` is a valid internal path, `$status` is the HTTP status (defaulting to
    `302`), `$headers` allows you to define which HTTP headers to send along with
    your redirect, and `$secure` allows you to override the default choice of `http`
    versus `https` (which is normally set based on your current request URL). [Example 3-39](#EX76)
    shows an example of its use.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`$to` 是有效的内部路径，`$status` 是 HTTP 状态（默认为 `302`），`$headers` 允许你定义随重定向发送的 HTTP
    头，`$secure` 允许你覆盖默认的 `http` 或 `https` 选择（通常基于当前请求 URL 设置）。[示例 3-39](#EX76) 展示了其使用示例。'
- en: Example 3-39\. `redirect()->to()`
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-39\. `redirect()->to()`
- en: '[PRE58]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: redirect()->route()
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`redirect()->route()`'
- en: The `route()` method is the same as the `to()` method, but rather than pointing
    to a particular path, it points to a particular route name (see [Example 3-40](#EX69)).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`route()` 方法与 `to()` 方法相同，但不是指向特定路径，而是指向特定路由名称（参见 [示例 3-40](#EX69)）。'
- en: Example 3-40\. `redirect()->route()`
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-40\. `redirect()->route()`
- en: '[PRE59]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note that since some route names require parameters, its parameter order is
    a little different. `route()` has an optional second parameter for the route parameters:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于某些路由名称需要参数，其参数顺序有点不同。`route()` 方法有一个可选的第二个参数用于路由参数：
- en: '[PRE60]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: So, using it might look a little like [Example 3-41](#EX70).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用它可能看起来有点像 [示例 3-41](#EX70)。
- en: Example 3-41\. `redirect()->route()` with parameters
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-41\. `redirect()->route()` 带有参数
- en: '[PRE61]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Redirect to_route() Helper
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `to_route()` 辅助方法
- en: 'You can use the `to_route()` helper as an alias for the `redirect()->route()`
    method. The signature for both is the same:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `to_route()` 辅助方法作为 `redirect()->route()` 方法的别名。它们的签名都是一样的：
- en: '[PRE62]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: redirect()->back()
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`redirect()->back()`'
- en: 'Because of some of the built-in conveniences of Laravel’s session implementation,
    your application will always have knowledge of what the user’s previously visited
    page was. That opens up the opportunity for a `redirect()->back()` redirect, which
    simply redirects the user to whatever page they came from. There’s also a global
    shortcut for this: `back()`.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Laravel会话实现的一些内置便利性，您的应用程序始终知道用户之前访问的页面是什么。这就开启了`redirect()->back()`重定向的机会，它简单地将用户重定向到他们来自的页面。这也有一个全局快捷方式：`back()`。
- en: Other Redirect Methods
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他重定向方法
- en: 'The redirect service provides other methods that are less commonly used, but
    still available:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向服务提供了其他一些较少使用但仍可用的方法：
- en: '`refresh()`'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`refresh()`'
- en: Redirects to the same page the user is currently on.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向到用户当前正在访问的同一页面。
- en: '`away()`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`away()`'
- en: Allows for redirecting to an external URL without the default URL validation.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 允许重定向到外部URL，而不进行默认URL验证。
- en: '`secure()`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`secure()`'
- en: Like `to()` with the `secure` parameter set to `"true"`.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 像`to()`一样，`secure`参数设置为`"true"`。
- en: '`action()`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`action()`'
- en: 'Allows you to link to a controller and method in one of two ways: as a string
    (`redirect()->action(''MyController@myMethod'')`) or as a tuple (`r⁠e⁠d⁠i⁠r⁠e⁠c⁠t⁠(⁠)​\-⁠>⁠a⁠c⁠t⁠i⁠o⁠n⁠([MyController::class,
    ''myMethod''])`).'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您以两种方式之一链接到控制器和方法：作为字符串（`redirect()->action('MyController@myMethod')`）或作为元组（`r⁠e⁠d⁠i⁠r⁠e⁠c⁠t⁠(⁠)​\-⁠>⁠a⁠c⁠t⁠i⁠o⁠n⁠([MyController::class,
    'myMethod'])`）。
- en: '`guest()`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`guest()`'
- en: Used internally by the authentication system (discussed in [Chapter 9](ch09.html#user_authentication_and_authorization));
    when a user visits a route they’re not authenticated for, this captures the “intended”
    route and then redirects the user (usually to a login page).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在认证系统内部使用（在[第9章](ch09.html#user_authentication_and_authorization)中讨论）；当用户访问他们未经身份验证的路由时，这会捕获“预期”路由，然后重定向用户（通常是到登录页面）。
- en: '`intended()`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`intended()`'
- en: Also used internally by the authentication system; after a successful authentication,
    this grabs the “intended” URL stored by the `guest()` method and redirects the
    user there.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 也在认证系统内部使用；成功认证后，它会获取`guest()`方法存储的“预期”URL，并将用户重定向到那里。
- en: redirect()->with()
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`redirect()->with()`'
- en: While it is structured similarly to the other methods you can call on `redirect()`,
    `with()` is different in that it doesn’t define where you’re redirecting to, but
    what data you’re passing along with the redirect. When you’re redirecting users
    to different pages, you often want to pass certain data along with them. You could
    manually flash the data to the session, but Laravel has some convenience methods
    to help you with that.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它的结构与您在`redirect()`上调用的其他方法类似，但`with()`不同之处在于它不定义您要重定向到哪里，而是定义您要传递的数据。当您将用户重定向到不同页面时，通常希望将某些数据传递给他们。您可以手动将数据闪存到会话中，但Laravel提供了一些便利方法来帮助您完成这些操作。
- en: Most commonly, you can pass along either an array of keys and values or a single
    key and value using `with()`, like in [Example 3-42](#EX71). This saves your `with()`
    data to the session just for the next page load.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是，您可以使用`with()`传递键和值的数组或单个键和值，就像[示例 3-42](#EX71)中的一样。这会将您的`with()`数据保存到会话中，只用于下一次页面加载。
- en: Example 3-42\. Redirect with data
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-42\. 带数据的重定向
- en: '[PRE63]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Chaining Methods on Redirects
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在重定向上链接方法
- en: As with many other facades, most calls to the `Redirect` facade can accept fluent
    method chains, like the `with()` calls in [Example 3-42](#EX71). You’ll learn
    more about fluency in [“What Is a Fluent Interface?”](ch05.html#fluent).
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他门面一样，`Redirect`门面的大多数调用可以接受流畅的方法链，就像[示例 3-42](#EX71)中的`with()`调用一样。您将在[“什么是流畅接口？”](ch05.html#fluent)中了解更多信息。
- en: You can also use `withInput()`, as in [Example 3-43](#EX72), to redirect with
    the user’s form input flashed; this is most common in the case of a validation
    error, where you want to send the user back to the form they just came from.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`withInput()`，如[示例 3-43](#EX72)中所示，以闪存用户的表单输入重定向；这在验证错误的情况下最常见，您希望将用户发送回他们刚刚来自的表单。
- en: Example 3-43\. Redirect with form input
  id: totrans-383
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-43\. 带表单输入的重定向
- en: '[PRE64]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The easiest way to get the flashed input that was passed with `withInput()`
    is using the `old()` helper, which can be used to get all old input (`old()`)
    or just the value for a particular key, as shown in the following example, with
    the second parameter as the default if there is no old value. You’ll commonly
    see this in views, which allows this HTML to be used both on the “create” and
    the “edit” view for this form:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 获取通过`withInput()`传递的闪存输入的最简单方法是使用`old()`辅助函数，它可以用于获取所有旧输入（`old()`）或只是特定键的值，如下例所示，如果没有旧值，则第二个参数作为默认值。你通常会在视图中看到这一点，这使得这段HTML可以在此表单的“创建”和“编辑”视图中通用：
- en: '[PRE65]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Speaking of validation, there is also a useful method for passing errors along
    with a redirect response: `withErrors()`. You can pass it any “provider” of errors,
    which may be an error string, an array of errors, or, most commonly, an instance
    of the Illuminate `Validator`, which we’ll cover in [Chapter 10](ch10.html#requests_and_responses).
    [Example 3-44](#EX73) shows an example of its use.'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 谈到验证，还有一种有用的方法可以将错误与重定向响应一起传递：`withErrors()`。你可以传递任何“错误提供者”，它可以是一个错误字符串，一个错误数组，或者，最常见的情况是，Illuminate
    `Validator` 的一个实例，我们将在[第10章](ch10.html#requests_and_responses)中详细介绍。[示例 3-44](#EX73)展示了其使用示例。
- en: Example 3-44\. Redirect with errors
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-44\. 带错误的重定向
- en: '[PRE66]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`withErrors()` automatically shares an `$errors` variable with the views of
    the page it’s redirecting to, for you to handle however you’d like.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`withErrors()`会自动与它重定向到的页面的视图共享一个`$errors`变量，以便你可以按照自己的意愿处理。'
- en: The validate() Method on Requests
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求对象上的validate()方法
- en: Don’t like how [Example 3-44](#EX73) looks? There’s a simple and powerful tool
    that will make it easy for you to clean up that code. Read more in [“validate()
    on the Request Object”](ch07.html#validation_on_request).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 不喜欢[示例 3-44](#EX73)的外观？有一个简单而强大的工具，可以帮助你轻松清理代码。在[“请求对象上的validate()”](ch07.html#validation_on_request)中详细了解更多。
- en: Aborting the Request
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中止请求
- en: Aside from returning views and redirects, the most common way to exit a route
    is to abort. There are a few globally available methods (`abort()`, `abort_if()`,
    and `abort_unless()`), which optionally take HTTP status codes, a message, and
    a headers array as parameters.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回视图和重定向之外，退出路由的最常见方式是中止。有几种全局可用的方法（`abort()`、`abort_if()`和`abort_unless()`），可以选择使用HTTP状态码、消息和头数组作为参数。
- en: As [Example 3-45](#EX74) shows, `abort_if()` and `abort_unless()` take a first
    parameter that is evaluated for its truthiness and perform the abort depending
    on the result.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例[3-45](#EX74)所示，`abort_if()`和`abort_unless()`接受一个首要参数，该参数根据其真实性进行评估，并根据结果执行中止。
- en: Example 3-45\. 403 Forbidden aborts
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-45\. 403 Forbidden 中止
- en: '[PRE67]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Custom Responses
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义响应
- en: There are a few other options available for us to return, so let’s go over the
    most common responses after views, redirects, and aborts. Just like with redirects,
    you can run these methods on either the `response()` helper or the `Response`
    facade.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们返回的几种其他选项，让我们先了解一下最常见的视图、重定向和中止响应之后的响应。与重定向一样，你可以在`response()`辅助函数或`Response`外观上运行这些方法。
- en: response()->make()
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: response()->make()
- en: 'If you want to create an HTTP response manually, just pass your data into the
    first parameter of `response()->make()`: for example, `return response()->make(*Hello,
    World!*)`. Once again, the second parameter is the HTTP status code and the third
    is your headers.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想手动创建HTTP响应，只需将你的数据传递给`response()->make()`的第一个参数：例如 `return response()->make(*Hello,
    World!*)`。再次提醒，第二个参数是HTTP状态代码，第三个是你的头部。
- en: response()->json() and ->jsonp()
  id: totrans-402
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: response()->json()和->jsonp()
- en: 'To create a JSON-encoded HTTP response manually, pass your JSON-able content
    (arrays, collections, or whatever else) to the `json()` method: for example `return
    response()->json(User::all())`. It’s just like `make()`, except it `json_encode`s
    your content and sets the appropriate headers.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动创建JSON编码的HTTP响应，请将你的可JSON化内容（数组、集合或其他内容）传递给`json()`方法：例如 `return response()->json(User::all())`。它与`make()`类似，只是`json_encode`了你的内容并设置了适当的头。
- en: response()->download(), ->streamDownload(), and ->file()
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: response()->download()、->streamDownload()和->file()
- en: 'To send a file for the end user to download, pass either an `SplFileInfo` instance
    or a string filename to `download()`, with an optional second parameter of the
    download filename: for example, `return response()->download(''file501751.pdf'',
    ''myFile.pdf'')`, which would send a file that’s at *file501751.pdf* and rename
    it, as it’s sent, to *myFile.pdf*.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送文件供最终用户下载，请将`download()`传递给`SplFileInfo`实例或字符串文件名，第二个可选参数是下载文件名：例如，`return
    response()->download('file501751.pdf', 'myFile.pdf')`，这将发送名为*file501751.pdf*的文件，并在发送时重命名为*myFile.pdf*。
- en: To display the same file in the browser (if it’s a PDF or an image or something
    else the browser can handle), use `response()->file()` instead, which takes the
    same parameters as `response->download()`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 要在浏览器中显示相同的文件（如果是PDF或浏览器可以处理的图像或其他内容），请改用`response()->file()`，它接受与`response->download()`相同的参数。
- en: If you want to make some content from an external service available as a download
    without having to write it directly to your server’s disk, you can stream the
    download using `response()->streamDownload()`. This method expects as parameters
    a closure that echoes a string, a filename, and optionally an array of headers;
    see [Example 3-46](#EX78).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将外部服务的某些内容作为下载可用，而无需直接将其写入服务器磁盘，则可以使用`response()->streamDownload()`来流式下载。该方法期望的参数包括一个回调函数（回显一个字符串）、一个文件名，以及可选的头部数组；参见[示例 3-46](#EX78)。
- en: Example 3-46\. Streaming downloads from external servers
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-46\. 从外部服务器进行流式下载
- en: '[PRE68]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Testing
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: In some other communities the idea of unit-testing controller methods is common,
    but within Laravel (and most of the PHP community) it’s typical to rely on *application
    testing* to test the functionality of routes.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他一些社区中，单元测试控制器方法的想法很常见，但在Laravel（以及大多数PHP社区）中，通常依赖*应用程序测试*来测试路由的功能。
- en: For example, to verify that a `POST` route works correctly, we can write a test
    like [Example 3-47](#EX80).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要验证`POST`路由是否正常工作，我们可以编写类似于[示例 3-47](#EX80)的测试。
- en: Example 3-47\. Writing a simple `POST` route test
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-47\. 编写简单的`POST`路由测试
- en: '[PRE69]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Did we directly call the controller methods? No. But we ensured that the goal
    of this route—to receive a `POST` and save its important information to the database—was
    met.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接调用了控制器方法吗？没有。但我们确保了该路由的目标——接收`POST`并将其重要信息保存到数据库中——得到了实现。
- en: You can also use similar syntax to visit a route and verify that certain text
    shows up on the page, or that clicking certain buttons does certain things (see
    [Example 3-48](#EX75X)).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用类似的语法访问一个路由，并验证页面上是否显示了某些文本，或者点击某些按钮是否执行了某些操作（参见[示例 3-48](#EX75X)）。
- en: Example 3-48\. Writing a simple `GET` route test
  id: totrans-417
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-48\. 编写简单的`GET`路由测试
- en: '[PRE70]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: TL;DR
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简而言之
- en: Laravel’s routes are defined in *routes/web.php* and *routes/api.php*. You can
    define the expected path for each route, which segments are static and which are
    parameters, which HTTP verbs can access the route, and how to resolve it. You
    can also attach middleware to routes, group them, and give them names.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的路由定义在*routes/web.php*和*routes/api.php*中。您可以为每个路由定义预期的路径，哪些段是静态的，哪些是参数，哪些HTTP动词可以访问路由，以及如何解析它。您还可以将中间件附加到路由上，对它们进行分组，并为它们命名。
- en: What is returned from the route closure or controller method dictates how Laravel
    responds to the user. If it’s a string or a view, it’s presented to the user;
    if it’s other sorts of data, it’s converted to JSON and presented to the user;
    and if it’s a redirect, it forces a redirect.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 路由闭包或控制器方法返回的内容决定了Laravel如何响应用户。如果是字符串或视图，它会呈现给用户；如果是其他类型的数据，它会转换为JSON并呈现给用户；如果是重定向，它会强制进行重定向。
- en: Laravel provides a series of tools and conveniences to simplify common routing-related
    tasks and structures. These include resource controllers, route model binding,
    and form method spoofing.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel提供了一系列工具和便利功能，用于简化常见的与路由相关的任务和结构。这些包括资源控制器、路由模型绑定和表单方法欺骗。
