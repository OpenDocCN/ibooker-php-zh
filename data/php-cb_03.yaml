- en: Chapter 3\. Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。函数
- en: Every computer program in every language is built by tying various components
    of business logic together. Often, these components need to be somewhat reusable,
    encapsulating common functionality that needs to be referenced in multiple places
    throughout an application. The easiest way to make these components modular and
    reusable is to encapsulate their business logic into *functions*, specific constructs
    within the application that can be referenced elsewhere throughout an application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每种语言中的每个计算机程序都是通过将各种业务逻辑组件绑定在一起来构建的。通常，这些组件需要有些可重用性，封装常见功能，这些功能需要在应用程序的多个地方引用。将这些组件的业务逻辑封装到*函数*中是使其模块化和可重用的最简单方式，函数是应用程序中的特定构造，可以在其他地方引用。
- en: '[Example 3-1](#imperative_code_without_functions) illustrates how a simple
    program might be written to capitalize the first character in a string. Coding
    without using functions is considered *imperative* programming, as you define
    exactly what the program needs to accomplish one command (or line of code) at
    a time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-1](#imperative_code_without_functions)说明了如何编写一个简单的程序来将字符串的第一个字符大写。编写不使用函数的代码被视为*命令式*编程，因为您逐行定义程序需要完成的确切任务（或代码行）。'
- en: Example 3-1\. Imperative (function-free) string capitalization
  id: totrans-3
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-1。命令式（无函数）字符串大写
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The functions `ord()` and `chr()` are references to native functions defined
    by PHP itself. The [`ord()`](https://oreil.ly/kSI-4) function returns the binary
    value of a character as an integer. Similarly, [`chr()`](https://oreil.ly/0KUmf)
    converts a binary value (represented as an integer) into its corresponding character.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`ord()`和`chr()`是对PHP本身定义的本地函数的引用。[`ord()`](https://oreil.ly/kSI-4)函数将字符的二进制值作为整数返回。类似地，[`chr()`](https://oreil.ly/0KUmf)将二进制值（表示为整数）转换为其对应的字符。
- en: 'When you write code without defining functions, your code ends up rather repetitive
    as you’re forced to copy and paste identical blocks throughout the application.
    This violates one of the key principles of software development: *DRY*, or *don’t
    repeat yourself*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写没有定义函数的代码时，由于必须在应用程序中复制和粘贴相同的代码块，您的代码会变得非常重复。这违反了软件开发的关键原则之一：*DRY*，即*不要重复自己*。
- en: 'A common way to describe the *opposite* of this principle is *WET*, or *write
    everything twice*. Writing the same block of code over again leads to two problems:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 描述此原则的*相反*方式是*WET*，或*写两次一切*。重复编写相同的代码块会导致两个问题：
- en: Your code becomes rather long and difficult to maintain.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的代码变得相当冗长且难以维护。
- en: If the logic within the repeated code block needs to change, you have to update
    *several* parts of your program every time.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果重复代码块内的逻辑需要更改，则必须每次更新*多个*程序部分。
- en: Rather than repeating logic imperatively, as in [Example 3-1](#imperative_code_without_functions),
    you can define a function that wraps this logic and later invoke that function
    directly, as in [Example 3-2](#procedural_code_with_functions). Defining functions
    is an evolution of imperative to procedural programming that augments the functions
    provided by the language itself with those defined by your application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 与以命令式方式重复逻辑不同，如[示例 3-1](#imperative_code_without_functions)，您可以定义一个包装此逻辑的函数，并直接调用该函数，如[示例 3-2](#procedural_code_with_functions)。定义函数是从命令式到过程式编程的演变，通过这种方式增强语言本身提供的函数与应用程序定义的函数。
- en: Example 3-2\. Procedural string capitalization
  id: totrans-12
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-2。过程式字符串大写
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'User-defined functions are incredibly powerful and quite flexible. The `capitalize_string()`
    function in [Example 3-2](#procedural_code_with_functions) is relatively simple—it
    takes a single string parameter and returns a string. However, there is no indication
    in the function as defined that the `$str` parameter must be a string—you could
    just as easily pass a number or even an array as follows:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的函数非常强大且非常灵活。在[示例 3-2](#procedural_code_with_functions)中的`capitalize_string()`函数相对简单——它接受一个字符串参数并返回一个字符串。但在函数定义中没有指示`$str`参数必须是一个字符串——您可以很容易地传递一个数字甚至一个数组，如下所示：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Recall the discussion of PHP’s loose type system from [Chapter 1](ch01.html#chapter_variables)--by
    default, PHP will try to infer your intent when you pass a parameter into `capitalize_string()`
    and, in most cases, will return something useful. In the case of passing an integer,
    PHP will trigger a warning that you are trying to access elements of an array
    incorrectly, but it will still return an integer without crashing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，来自[第1章](ch01.html#chapter_variables)关于PHP宽松类型系统的讨论--默认情况下，当你将参数传递给`capitalize_string()`时，PHP会尝试推断你的意图，并且在大多数情况下返回一些有用的东西。如果传递一个整数，在访问数组元素时，PHP将触发警告，表示你正在错误地访问数组元素，但仍然会返回一个整数而不会崩溃。
- en: More sophisticated programs can add explicit typing information to both the
    function parameters and its return to provide safety checks around this kind of
    usage. Other functions could return *multiple* values rather than a single item.
    Strong typing is illustrated explicitly in [Recipe 3.4](#argument_and_return_typing).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的程序可以在函数参数和返回类型中添加显式类型信息，以便对这种用法进行安全检查。其他函数可以返回*多个*值而不是单个项。强类型在[食谱 3.4](#argument_and_return_typing)中明确说明。
- en: The recipes that follow cover a variety of ways functions can be used in PHP
    and begins scratching at the surface of building a full application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的示例涵盖了PHP中函数的多种使用方式，并开始探讨构建完整应用程序的基础。
- en: 3.1 Accessing Function Parameters
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.1 访问函数参数
- en: Problem
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access the values passed into a function when it’s called elsewhere
    in a program.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当在程序的其他地方调用函数时，你想要访问传递给函数的值。
- en: Solution
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the variables defined in the function signature within the body of the
    function itself as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数体内可以使用函数签名中定义的变量名来使用函数签名中定义的变量名如下：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Discussion
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The variable names defined in the function signature are available only within
    the scope of the function itself and will contain values matching the data passed
    into the function when it’s called. Inside the curly braces that define the function,
    you can use these variables as if you’ve defined them yourself. Just know that
    any changes you make to those variables will *only* be available within the function
    and won’t impact anything elsewhere in the application by default.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 函数签名中定义的变量名仅在函数本身的作用域内有效，并将包含与调用函数时传入的数据匹配的值。在定义函数的花括号内部，你可以像自己定义它们一样使用这些变量。只需知道，对这些变量进行的任何更改将*仅*在函数内部可用，并且默认情况下不会影响应用程序中的其他任何内容。
- en: '[Example 3-3](#local_function_scoping) illustrates how a specific variable
    name can be used both within a function and outside a function while referring
    to two, completely independent values. Said another way, changing the value of
    `$number` within the function will only impact the value within the function,
    not within the parent application.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-3](#local_function_scoping)说明了如何在函数内部和外部同时使用特定变量名，同时引用两个完全独立的值。换句话说，更改函数内部`$number`的值只会影响函数内部的值，而不会影响父应用程序中的值。'
- en: Example 3-3\. Local function scoping
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-3\. 本地函数作用域
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By default, PHP passes values into functions rather than passing a reference
    to the variable. In [Example 3-3](#local_function_scoping), this means PHP passes
    the *value* `6` into a new `$number` variable within the function, performs a
    calculation, and returns the result. The `$number` variable outside the function
    is entirely unaffected.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PHP将值传递到函数中，而不是传递变量的引用。在[示例 3-3](#local_function_scoping)中，这意味着PHP将值`6`传递给函数内部的新变量`$number`，执行计算并返回结果。函数外部的`$number`变量完全不受影响。
- en: Warning
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: PHP passes simple values (strings, integers, Booleans, arrays) by value by default.
    More complex objects, however, are *always* passed by reference. In the case of
    objects, the variable inside the function points back to the same object as the
    variable outside the function rather than to a copy of it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: PHP默认按值传递简单值（字符串、整数、布尔值、数组）。然而，更复杂的对象*总是*按引用传递。对于对象，函数内部的变量指向与函数外部变量相同的对象，而不是它的副本。
- en: In some cases, you might want to explicitly pass a variable by reference rather
    than just passing its value. In that case, you need to modify the function signature
    as this is a change to its very definition rather than something that can be modified
    when the function is called. [Example 3-4](#variable_pass_by_reference) illustrates
    how the `increment()` function would change to pass `$number` by reference instead
    of by value.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望显式地通过引用传递变量，而不仅仅传递其值。 在这种情况下，您需要修改函数签名，因为这是对其定义的更改，而不是在调用函数时可以修改的内容。
    [示例 3-4](#variable_pass_by_reference)说明了如何修改`increment()`函数，以通过引用而不是值传递`$number`。
- en: Example 3-4\. Passing variables by reference
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-4\. 通过引用传递变量
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In reality, the variable name doesn’t need to match both inside and outside
    the function. I’m using `$number` in both cases here to illustrate the difference
    in scoping. If you stored an integer in `$a` and passed that variable instead
    as `increment($a)`, the result would be identical to that in [Example 3-4](#variable_pass_by_reference).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在函数内外，变量名称不需要完全匹配。 我在这里两种情况下都使用`$number`来说明作用域的差异。 如果在`$a`中存储了一个整数并将该变量作为`increment($a)`传递，则结果与[示例 3-4](#variable_pass_by_reference)中的结果相同。
- en: See Also
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP reference documentation on [user-defined functions](https://oreil.ly/9c1Nr)
    and [passing variables by reference](https://oreil.ly/ZfOLR).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: PHP参考文档上的[用户定义函数](https://oreil.ly/9c1Nr)和[通过引用传递变量](https://oreil.ly/ZfOLR)。
- en: 3.2 Setting a Function’s Default Parameters
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.2 设置函数的默认参数
- en: Problem
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to set a default value for a function’s parameter so invocations don’t
    have to pass it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望为函数的参数设置默认值，以便调用无需传递它。
- en: Solution
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Assign a default value within the function signature itself. For example:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数签名内部分配默认值。例如：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The example in the Solution attempts to query a database for the title of a
    book based on its ISBN. If the query fails for any reason, the function will return
    the string passed into the `$error` parameter instead.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案中的示例尝试基于其ISBN查询书籍的标题。 如果由于任何原因查询失败，则函数将返回传递给`$error`参数的字符串。
- en: To make this parameter optional, the function signature assigns a default value.
    When calling `get_book_title()` with a single parameter, the default `$error`
    value is used automatically. You alternatively have the option to pass your own
    string into this variable when invoking the function, such as `get_book_title​(*978-1-098-12132-7*,
    *Oops!*);`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使该参数可选，函数签名分配了一个默认值。 当使用单个参数调用`get_book_title()`时，将自动使用默认的`$error`值。 您还可以选择在调用函数时将自己的字符串传递给此变量，例如`get_book_title​(*978-1-098-12132-7*,
    *Oops!*);`。
- en: When defining a function with default parameters, it’s a best practice to place
    all parameters with default values *last* in the function signature. While defining
    parameters in any order is *possible*, doing so makes it difficult to call the
    function properly.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义具有默认参数的函数时，最佳做法是在函数签名中将所有具有默认值的参数放在*最后*。 虽然可以按任何顺序定义参数，但这样做会使正确调用函数变得困难。
- en: '[Example 3-5](#misordered_default_parameters) illustrates the kinds of problems
    that can come up by placing optional parameters before required ones.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 3-5](#misordered_default_parameters)说明了在必填参数之后放置可选参数可能会出现的问题类型。'
- en: Warning
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: It is possible to define function parameters with specific defaults in any order.
    However, declaring mandatory parameters after optional ones is deprecated as of
    PHP 8.0\. Continuing to do so might result in an error in a future version of
    PHP.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按任意顺序定义具有特定默认值的函数参数。 但是，自PHP 8.0起，声明必填参数在可选参数之后已弃用。 继续这样做可能会导致未来版本的PHP中出现错误。
- en: Example 3-5\. Misordered default parameters
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-5\. 错误的默认参数顺序
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_functions_CO1-1)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_CO1-1)'
- en: Proper execution. Returns `Brewing a 2-shot, vanilla latte!`
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 适当执行。 返回`Brewing a 2-shot, vanilla latte!`
- en: '[![2](assets/2.png)](#co_functions_CO1-2)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_CO1-2)'
- en: Triggers an `ArgumentCountError` exception because `$shots` is undefined.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 引发`ArgumentCountError`异常，因为`$shots`未定义。
- en: In some cases, placing the parameters themselves in a particular order might
    make logical sense (to make the code more readable, for example). Know that if
    any parameters are required, every parameter to their left is also effectively
    required even if you try to define a default value.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将参数按特定顺序放置可能更符合逻辑（例如使代码更易读）。请注意，如果需要任何参数，则它们左侧的每个参数即使尝试定义默认值也是必需的。
- en: See Also
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Examples of default arguments in the [PHP Manual](https://oreil.ly/XVoK1).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在[PHP手册](https://oreil.ly/XVoK1)中有默认参数的示例。
- en: 3.3 Using Named Function Parameters
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.3 使用命名函数参数
- en: Problem
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to pass arguments into a function based on the name of the parameter
    rather than its position.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望根据参数的名称而不是位置将参数传递给函数。
- en: Solution
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the named argument syntax while calling a function as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用函数时，请使用命名参数语法如下：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Discussion
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'By default, PHP leverages positional parameters in function definitions. The
    Solution example references the native [`array_fill()`](https://oreil.ly/jdZQH)
    function that has the following function signature:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PHP在函数定义中使用位置参数。解决方案示例引用了原生的[`array_fill()`](https://oreil.ly/jdZQH)函数，具有以下函数签名：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Basic PHP coding must supply arguments to `array_fill()` in the same order
    in which they’re defined—`$start_index` followed by `$count` followed by `$value`.
    While the order itself is not a problem, making sense of the meaning of each value
    when scanning visually through code can be a challenge. Using the basic, ordered
    parameters, the Solution example would be written as follows, requiring deep familiarity
    with the function signature to know which integer represents which parameter:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的PHP编码必须按照定义的顺序向`array_fill()`提供参数——先是`$start_index`，然后是`$count`，最后是`$value`。顺序本身并不是问题，但是在通过代码进行视觉扫描时理解每个值的含义可能会有挑战。使用基本的有序参数，解决方案示例将写成以下形式，需要对函数签名深入了解，以知道哪个整数代表哪个参数：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Named function parameters disambiguate which value is being assigned to which
    internal variable. They also allow for arbitrary reordering of parameters when
    you invoke the function as that invocation is now explicit as to which value is
    assigned to which parameter.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 命名函数参数可以消除对内部变量分配的歧义。当您调用函数时，命名函数参数还允许任意重新排序参数。
- en: Another key advantage of named arguments is that optional arguments can be *skipped*
    entirely during function invocation. Consider a verbose activity logging function
    like in [Example 3-6](#verbose_logging_function), where multiple parameters are
    considered optional as they set defaults.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 命名参数的另一个关键优势是在函数调用时可以完全跳过可选参数。考虑一个冗长的活动日志函数，例如[示例 3-6](#verbose_logging_function)，其中多个参数被视为可选参数，因为它们设置了默认值。
- en: Example 3-6\. Verbose activity logging function
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-6\. 冗长的活动日志函数
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Internally, [Example 3-6](#verbose_logging_function) will use its default values
    when it’s called with a single argument; if `$time` is `null`, the value will
    be silently replaced with a new `DateTime` instance representing “now.” However,
    sometimes you might want to populate one of these optional parameters without
    wanting to explicitly set *all* of them.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，[示例 3-6](#verbose_logging_function)将在仅使用一个参数调用时使用其默认值；如果`$time`为`null`，则该值将被默默替换为代表“现在”的新`DateTime`实例。然而，有时您可能希望填充其中一个可选参数，而不希望显式设置*所有*可选参数。
- en: Say you want to replay previously witnessed events from a static log file. User
    activity was anonymous (so the defaults for `$user_name` and `$ip_address` are
    adequate), but you need to explicitly set the date at which an event occurred.
    Without named arguments, an invocation in this case would look similar to [Example 3-7](#verbose_logging_utilization).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想要从静态日志文件中重新播放先前观察到的事件。用户活动是匿名的（因此`$user_name`和`$ip_address`的默认值是足够的），但您需要显式设置事件发生的日期。没有命名参数的情况下，此类调用看起来类似于[示例 3-7](#verbose_logging_utilization)。
- en: Example 3-7\. Invoking the verbose `activity_log()` function
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-7\. 调用冗长的`activity_log()`函数
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'With named arguments, you can skip setting parameters to their defaults and
    explicitly set just the parameters you need to. The preceding code can be simplified
    to the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命名参数，您可以跳过设置参数为其默认值，并仅显式设置您需要的参数。前面的代码可以简化为以下形式：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In addition to drastically simplifying the usage of `activity_log()`, named
    parameters have the added benefit of keeping your code DRY. The default values
    for your arguments are stored directly in the function definition rather than
    being copied to every invocation of the function as well. If you later need to
    change a default, you can edit the function definition alone.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了极大地简化`activity_log()`的使用之外，命名参数还有一个额外的好处，即保持代码DRY。参数的默认值直接存储在函数定义中，而不是在每次调用函数时都复制一遍。如果以后需要更改默认值，只需编辑函数定义即可。
- en: See Also
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The original RFC [proposing named parameters](https://oreil.ly/UdoDP).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的RFC[提出命名参数](https://oreil.ly/UdoDP)。
- en: 3.4 Enforcing Function Argument and Return Typing
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.4 强制函数参数和返回类型
- en: Problem
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to force your program to implement type safety and avoid PHP’s native
    loose type comparisons.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望强制程序实现类型安全性，并避免PHP的本机松散类型比较。
- en: Solution
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Add input and return types to function definitions. Optionally, add a strict
    type declaration to the top of each file to enforce values matching type annotations
    (and emit a fatal error if they don’t match). For example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为函数定义添加输入和返回类型。可选地，在每个文件的顶部添加严格的类型声明，以强制值匹配类型注解（如果不匹配则发出致命错误）。例如：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_functions_CO2-1)'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_CO2-1)'
- en: This is a perfectly valid operation and will return the integer `5`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全有效的操作，将返回整数`5`。
- en: '[![2](assets/2.png)](#co_functions_CO2-2)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_CO2-2)'
- en: While `2 + '3'` is valid PHP code, the string `'3'` violates the function’s
    type definitions and will trigger a fatal error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`2 + '3'`是有效的PHP代码，但字符串`'3'`违反了函数的类型定义，将触发致命错误。
- en: Discussion
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP natively supports various scalar types and allows developers to declare
    both function input parameters and returns to identify the kinds of values that
    are allowable for each. In addition, developers can specify their own custom classes
    and interfaces as types, or leverage class inheritance within the type system.^([1](ch03.html#idm45875184619360))
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: PHP本身支持多种标量类型，并允许开发者声明函数的输入参数和返回值，以确定每种值的允许性。此外，开发者还可以将自定义类和接口作为类型，或在类型系统中利用类继承。^([1](ch03.html#idm45875184619360))
- en: 'Parameter types are annotated by placing the type directly before the name
    of the parameter when defining the function. Similarly, return types are specified
    by appending the function signature with a `:` and the type that function would
    return as in the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，通过在参数名称前直接注释类型来标注参数类型。类似地，通过在函数签名后附加`:`和函数可能返回的类型来指定返回类型，如下所示：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Table 3-1](#php_single_types) enumerates the simplest types leveraged by PHP.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 3-1](#php_single_types)列举了PHP利用的最简单类型。'
- en: Table 3-1\. Simple single types in PHP
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-1\. PHP中的简单单类型
- en: '| Type | Description |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `array` | The value must be an array (containing any type of values). |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `array` | 值必须是一个数组（包含任何类型的值）。 |'
- en: '| `callable` | The value must be a callable function. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `callable` | 值必须是可调用函数。 |'
- en: '| `bool` | The value must be a Boolean. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | 值必须是布尔值。 |'
- en: '| `float` | The value must be a floating-point number. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `float` | 值必须是浮点数。 |'
- en: '| `int` | The value must be an integer. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `int` | 值必须是整数。 |'
- en: '| `string` | The value must be a string. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `string` | 值必须是一个字符串。 |'
- en: '| [`iterable`](https://oreil.ly/tiTI1) | The value must be an array or an object
    that implements `Traversable`. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| [`iterable`](https://oreil.ly/tiTI1) | 值必须是一个数组或实现了`Traversable`接口的对象。 |'
- en: '| [`mixed`](https://oreil.ly/V8VOc) | The object can be any value. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| [`mixed`](https://oreil.ly/V8VOc) | 对象可以是任意值。 |'
- en: '| [`void`](https://oreil.ly/Izmvp) | A return-only type indicating that the
    function does not return a value. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| [`void`](https://oreil.ly/Izmvp) | 表示函数不返回任何值。 |'
- en: '| [`never`](https://oreil.ly/48KVB) | A return-only type indicating a function
    does not return; it either calls `exit`, throws an exception, or is intentionally
    an infinite loop. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| [`never`](https://oreil.ly/48KVB) | 表示函数不返回任何值；它要么调用`exit`，抛出异常，或故意是一个无限循环。
    |'
- en: In addition, both built-in and custom classes can be used to define types, as
    shown in [Table 3-2](#php_object_types).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，无论是内置还是自定义类都可以用来定义类型，如[表 3-2](#php_object_types)所示。
- en: Table 3-2\. Object types in PHP
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 表3-2\. PHP中的对象类型
- en: '| Type | Description |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Class/interface name | The value must be an instance of the specified class
    or implementation of an interface. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 类/接口名称 | 值必须是指定类的实例或接口的实现。 |'
- en: '| `self` | The value must be an instance of the same class as the one in which
    the declaration is used. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `self` | 值必须是与声明使用的同一类的实例。 |'
- en: '| `parent` | The value must be an instance of the parent of the class in which
    the declaration is used. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `parent` | 值必须是在声明使用的类的父类的实例。 |'
- en: '| `object` | The value must be an instance of an object. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `object` | 值必须是一个对象的实例。 |'
- en: PHP also permits simple scalar types to be expanded by either making them nullable
    or combining them into *union types*. To make a specific type nullable, you have
    to prefix the type annotation with a `?`. This will instruct the compiler to allow
    values to be either the specified type or `null`, as in [Example 3-8](#function_using_nullable_types).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 还允许将简单标量类型扩展为可为空，或者将它们组合为*联合类型*。要使特定类型可为空，必须在类型注释前面加上 `?`。这将指示编译器允许值为指定类型或`null`，例如在
    [示例 3-8](#function_using_nullable_types) 中。
- en: Example 3-8\. Function utilizing nullable parameters
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-8\. 使用可空参数的函数
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A union type declaration combines multiple types into a single declaration by
    concatenating simple types together with the pipe character (`|`). If you were
    to rewrite the type declarations on the Solution example with a union type combining
    strings and integers, the fatal error thrown by passing in a string for addition
    would resolve itself. Consider the possible rewrite in [Example 3-9](#type_solution_rewrite)
    that would permit *either* integers or strings as parameters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 联合类型声明通过使用管道字符(`|`)将多个类型组合成单个声明。如果您在 Solution 示例中重新编写类型声明，将字符串和整数组合成联合类型，通过传递字符串进行加法操作时引发的致命错误将解决。考虑在
    [示例 3-9](#type_solution_rewrite) 中可能的重写，允许*整数或字符串*作为参数。
- en: Example 3-9\. Rewriting the Solution example to leverage union types
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-9\. 重新编写 Solution 示例以利用联合类型
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The biggest problem with this alternative is that adding strings together with
    the `+` operator has no meaning in PHP. If both parameters are numeric (either
    integers or integers represented as strings), the function will work just fine.
    If either is a non-numeric string, PHP will throw a `TypeError` as it doesn’t
    know how to “add” two strings together. These kinds of errors are what you hope
    to avoid by adding type declarations to your code and enforcing strict typing—they
    formalize the contract you expect your code to support and encourage programming
    practices that naturally defend against coding mistakes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代方案的最大问题是，使用 `+` 运算符将字符串连接在一起在 PHP 中没有意义。如果两个参数都是数字（整数或表示为字符串的整数），则函数将正常工作。如果其中一个是非数字字符串，PHP
    将抛出 `TypeError`，因为它不知道如何将两个字符串“加”在一起。通过为代码添加类型声明并强制执行严格类型化，可以避免这类错误。类型声明形式化了您希望代码支持的契约，并鼓励自然防御编码错误的编程实践。
- en: By default, PHP uses its typing system to *hint* at which types are allowed
    into and returned from functions. This is useful to prevent passing bad data into
    a function, but it relies heavily on either developer diligence or additional
    tooling^([2](ch03.html#idm45875190957904)) to enforce typing. Rather than rely
    on humans’ ability to check code, PHP allows for a static declaration in each
    file that all invocations should follow strict typing.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，PHP 使用其类型系统来*提示*哪些类型允许进入函数并从函数返回。这对于防止将坏数据传递给函数很有用，但它在很大程度上依赖于开发人员的勤奋或额外的工具^([2](ch03.html#idm45875190957904))来强制执行类型。与依赖于人类检查代码不同，PHP
    允许在每个文件中静态声明，以便所有调用都遵循严格的类型化。
- en: Placing `declare(strict_types=1);` at the top of a file tells the PHP compiler
    you intend for all invocations in that file to obey parameter and return type
    declarations. Note that this directive applies to *invocations* within the file
    where it’s used, not to the definitions of functions in that file. If you call
    functions from another file, PHP will honor the type declarations in that file
    as well. However, placing this directive in your file will not force other files
    that reference your functions to obey the typing system.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `declare(strict_types=1);` 放置在文件顶部告诉 PHP 编译器，您打算让该文件中的所有调用遵守参数和返回类型声明。请注意，此指令适用于文件内部的调用，而不适用于该文件中函数的定义。如果从另一个文件调用函数，PHP
    也会遵守该文件中的类型声明。然而，将此指令放置在您的文件中不会强制要求引用您的函数的其他文件遵循类型系统。
- en: See Also
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [type declarations](https://oreil.ly/I9D33) and the [`declare`
    construct](https://oreil.ly/P2jM_).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 关于 [类型声明](https://oreil.ly/I9D33) 和 [`declare` 结构](https://oreil.ly/P2jM_)
    的文档。
- en: 3.5 Defining a Function with a Variable Number of Arguments
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.5 定义具有可变数量参数的函数
- en: Problem
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define a function that takes one or more arguments without knowing
    ahead of time how many values will be passed in.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要定义一个函数，该函数接受一个或多个参数，而不知道预先传入多少个值。
- en: Solution
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use PHP’s spread operator (`…​`) to define a variable number or arguments:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PHP 的扩展操作符(`…​`)来定义可变数量的参数：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Discussion
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The *spread operator* automatically adds all parameters passed in that particular
    position or after it to an array. This array can be typed by prefixing the spread
    operator with a type declaration (review [Recipe 3.4](#argument_and_return_typing)
    for more on typing), thus requiring every element of the array to match a specific
    type. Invoking the function defined in the Solution example as `greatest(2, "five");`
    will throw a `TypeError`, as you have explicitly declared an `int` type for every
    member of the `$numbers` array.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*展开运算符*会自动将传递给特定位置或之后的所有参数添加到一个数组中。可以通过在展开运算符前面添加类型声明来为此数组指定类型（详见[示例 3.4](#argument_and_return_typing)了解更多关于类型的内容），因此需要确保数组的每个元素都与特定类型匹配。调用解决方案示例中定义的函数如
    `greatest(2, "five");` 将抛出 `TypeError`，因为您已经明确声明了 `$numbers` 数组的每个成员为 `int` 类型。'
- en: Your function can accept more than one positional parameter while still leveraging
    the spread operator to accept an unlimited number of additional arguments. The
    function defined in [Example 3-10](#utilizing_the_spread_operator) will print
    a greeting to the screen for an unlimited number of individuals.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您的函数可以接受多个位置参数，同时利用展开运算符接受无限数量的额外参数。在[示例 3-10](#utilizing_the_spread_operator)中定义的函数将向屏幕上无限数量的个人打印问候语。
- en: Example 3-10\. Utilizing the spread operator
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-10\. 利用展开运算符
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The spread operator has more utility than just function definition. While it
    can be used to pack multiple arguments into an array, it can also be used to unpack
    an array into multiple arguments for a more traditional function invocation. [Example 3-11](#ellipsis_unpacking_array)
    provides a trivial illustration of how this array unpacking works by using the
    spread operator to pass an array into a function that does not accept an array.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 展开运算符不仅在函数定义时更有用。虽然它可以用于将多个参数打包到一个数组中，但也可以用于将数组解包为多个参数，以便进行更传统的函数调用。[示例 3-11](#ellipsis_unpacking_array)通过使用展开运算符将数组传递给一个不接受数组的函数提供了展示如何工作的简单示例。
- en: Example 3-11\. Unpacking an array with the spread operator
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-11\. 使用展开运算符解包数组
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In some cases, a more complex function might return multiple values (as discussed
    in the next recipe), so passing the return of one function into another becomes
    simple with the spread operator. In fact, any array or variable that implements
    PHP’s [Traversable](https://oreil.ly/jVUvs) interface can be unpacked into a function
    invocation in this manner.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，更复杂的函数可能会返回多个值（如下一篇章节所讨论的），因此将一个函数的返回值传递给另一个函数在使用展开运算符时变得非常简单。事实上，任何实现
    PHP 的[可遍历](https://oreil.ly/jVUvs)接口的数组或变量都可以以这种方式解包到函数调用中。
- en: See Also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [variable-length argument lists](https://oreil.ly/9IoHh).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: PHP关于[可变长度参数列表](https://oreil.ly/9IoHh)的文档。
- en: 3.6 Returning More Than One Value
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.6 返回多个值
- en: Problem
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to return multiple values from a single function invocation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望从单个函数调用中返回多个值。
- en: Solution
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Rather than returning a single value, return an array of multiple values and
    unpack them by using `list()` outside the function:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是返回单个值，可以通过在函数外部使用 `list()` 来返回多个值的数组：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Discussion
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP is only capable of returning one value from a function invocation, but that
    value itself could be an array containing multiple values. When paired with PHP’s
    `list()` construct, this array can be easily destructured to individual variables
    for further use by the program.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 只能从函数调用中返回一个值，但该值本身可以是包含多个值的数组。与 PHP 的 `list()` 结构配对时，可以轻松地将此数组解构为单独的变量，以供程序进一步使用。
- en: While the need to return many different values isn’t common, when the occasion
    comes up, being able to do so can be incredibly handy. One example is in web authentication.
    Many modern systems today use JSON Web Tokens (JWTs), which are period-delimited
    strings of Base64-encoded data. Each component of a JWT represents a separate,
    discrete thing—a header describing the algorithm used, the data in the token payload,
    and a verifiable signature on that data.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管需要返回许多不同的值并不常见，但在需要时能够这样做确实非常方便。一个例子是在Web身份验证中。许多现代系统今天使用JSON Web Tokens（JWT），这些是以Base64编码的数据的期限分隔字符串。JWT的每个组件代表一个单独的离散事物：描述所使用算法的标头，令牌有效负载中的数据以及该数据上的可验证签名。
- en: 'When reading a JWT as a string, PHP applications often leverage the built-in
    `explode()` function to split the string on the periods delimiting each component.
    A simple use of `explode()` might appear as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在将JWT作为字符串读取时，PHP应用程序通常利用内置的`explode()`函数来在每个组件的句点上拆分字符串。简单使用`explode()`可能如下所示：
- en: '[PRE22]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code works just fine, but the repeated references to positions
    within an array can be difficult to follow both during development and debugging
    later if a problem arises. In addition, developers must manually decode every
    part of the JWT separately; forgetting to invoke `base64_decode()` could be fatal
    to the operation of the program.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码可以正常工作，但数组内的重复引用位置在开发期间和后期调试时可能难以跟踪。此外，开发人员必须手动分别解码JWT的每个部分；忘记调用`base64_decode()`可能对程序的运行造成致命影响。
- en: An alternative approach is to unpack and automatically decode the JWT within
    a function and return an array of the components, as shown in [Example 3-12](#decoding_jwt).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在函数内部解包并自动解码JWT，并以数组形式返回各个组件，如[示例 3-12](#decoding_jwt)所示。
- en: Example 3-12\. Decoding a JWT
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-12\. 解码JWT
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A further advantage of using a function to unpack a JWT rather than decomposing
    each element directly is that you could build in automated signature verification
    or even filter JWTs for acceptability based on the encryption algorithms declared
    in the header. While this logic could be applied procedurally while processing
    a JWT, keeping everything in a single function definition leads to cleaner, more
    maintainable code.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用函数解包JWT而不是直接分解每个元素的另一个优点是，你可以在其中构建自动签名验证或甚至根据头部声明的加密算法过滤JWT。虽然这种逻辑在处理JWT时可以被逐步应用，但将所有内容保持在单个函数定义中会导致更清晰、更易维护的代码。
- en: The biggest drawback to returning multiple values in one function call is in
    typing. These functions have an `array` return type, but PHP doesn’t natively
    allow for specifying the type of the elements within an array. We have potential
    workarounds to this limitation by way of documenting the function signature and
    integrating with a static analysis tool like [Psalm](https://psalm.dev) or [PHPStan](https://phpstan.org),
    but we have no native support within the language for typed arrays. As such, if
    you’re using strict typing (and you *should* be), returning multiple values from
    a single function invocation should be a rare occurrence.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个函数调用中返回多个值的最大缺点在于类型。这些函数具有`array`返回类型，但PHP本身不允许指定数组中元素的类型。我们有潜在的解决方法来解决这个限制，比如文档化函数签名并集成静态分析工具如[Psalm](https://psalm.dev)或[PHPStan](https://phpstan.org)，但语言本身不支持数组类型。因此，如果你在使用严格类型（你*应该*使用），从单个函数调用返回多个值应该是一个少见的情况。
- en: See Also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 3.5](#variable_number_of_arguments) on passing a variable number of
    arguments and [Recipe 1.3](ch01.html#swapping_variables_inplace) for more on PHP’s
    `list()` construct. Also reference the [phpDocumentor documentation on typed arrays](https://oreil.ly/RsXGh)
    that can be enforced by tools like Psalm.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[食谱 3.5](#variable_number_of_arguments) 关于传递可变数量的参数和[食谱 1.3](ch01.html#swapping_variables_inplace)
    更多关于PHP的`list()`构造的信息。还可以参考像[phpDocumentor关于类型数组的文档](https://oreil.ly/RsXGh)，可以通过Psalm等工具强制执行。'
- en: 3.7 Accessing Global Variables from Within a Function
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.7 从函数内访问全局变量
- en: Problem
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your function needs to reference a globally defined variable from elsewhere
    in the application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数需要引用应用程序其他地方定义的全局变量。
- en: Solution
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Prefix any global variables with the `global` keyword to access them within
    the function’s scope:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数的范围内使用`global`关键字前缀来访问任何全局变量：
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Discussion
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP separates operations into various scopes based on the context in which a
    variable is defined. For most programs, a single scope spans all included or required
    files. A variable defined in this global scope is available *everywhere* regardless
    of which file is currently executing, as demonstrated in [Example 3-13](#globally_defined_variables).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: PHP根据变量定义的上下文将操作分为不同的范围。对于大多数程序，单个范围覆盖所有已包含或所需的文件。定义在全局范围内的变量在*任何地方*都可用，无论当前执行的是哪个文件，如[示例 3-13](#globally_defined_variables)中所示。
- en: Example 3-13\. Variables defined in the global scope are available to included
    scripts
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-13\. 在全局范围内定义的变量可供包含的脚本使用
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_functions_CO3-1)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_CO3-1)'
- en: The `$apple` variable is also defined within this script and available for use.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`$apple`变量也在此脚本中定义并可供使用。'
- en: User-defined functions, however, define their own scope. A variable defined
    outside a user-defined function is *not available* within the body of the function.
    Likewise, any variable defined within the function is not available outside the
    function. [Example 3-14](#local_vs_global_scoping) illustrates the boundaries
    of the parent and function scope in a program.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户定义的函数定义了它们自己的作用域。在用户定义的函数外定义的变量*不可用*于函数体内。同样，函数内定义的任何变量在函数外部也是不可用的。[示例 3-14](#local_vs_global_scoping)说明了程序中父作用域和函数作用域的边界。
- en: Example 3-14\. Local versus global scoping
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-14\. 本地与全局作用域
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_functions_CO4-1)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_CO4-1)'
- en: The variable `$a` is initially defined in the parent scope.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`$a`最初是在父作用域中定义的。
- en: '[![2](assets/2.png)](#co_functions_CO4-2)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_CO4-2)'
- en: Inside the function scope, `$a` is not yet defined. Attempting to `echo` its
    value will result in a warning.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数作用域内，`$a`尚未定义。尝试`echo`其值将导致警告。
- en: '[![3](assets/3.png)](#co_functions_CO4-3)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_CO4-3)'
- en: Defining a variable called `$a` within the function will *not* overwrite the
    value of the same-named variable outside the function.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内定义名为`$a`的变量将*不会*覆盖函数外部相同名称变量的值。
- en: '[![4](assets/4.png)](#co_functions_CO4-4)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_CO4-4)'
- en: Defining a variable called `$b` within the function makes it available within
    the function, but this value will not escape the scope of the function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中定义一个名为`$b`的变量，使其在函数内可用，但此值不会逃逸函数的作用域。
- en: '[![5](assets/5.png)](#co_functions_CO4-5)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functions_CO4-5)'
- en: Echoing `$a` outside the function, even after invoking `example()`, will print
    the initial value you’ve set, as the function did not change the variable’s value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在调用`example()`后，在函数外部也会打印你设置的初始值的`$a`。
- en: '[![6](assets/6.png)](#co_functions_CO4-6)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_functions_CO4-6)'
- en: Since `$b` was defined within the function, it is undefined in the scope of
    the parent application.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`$b`是在函数内定义的，因此在父应用程序的作用域中未定义。
- en: Note
  id: totrans-195
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is possible to pass a variable into a function call *by reference* if the
    function is defined to accept a variable in such a way. However, this is a decision
    made by the definition of the function and not a runtime flag available to routines
    leveraging that function after the fact. [Example 3-4](#variable_pass_by_reference)
    shows what pass-by-reference might look like.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数定义为接受这种方式的变量，那么可以通过引用将变量传递给函数调用。然而，这是函数定义的决定，而不是在调用该函数后可用于利用该函数的程序的运行时标志。[示例 3-4](#variable_pass_by_reference)展示了传递引用可能的效果。
- en: To reference variables defined outside its scope, a function needs to declare
    those variables as *global* within its own scope. To reference the parent scope,
    you can rewrite [Example 3-14](#local_vs_global_scoping) as [Example 3-15](#local_vs_globals_rewrite).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用在其作用域外定义的变量，函数需要在其自身作用域内将这些变量声明为*全局*变量。要引用父作用域，可以将[示例 3-14](#local_vs_global_scoping)重写为[示例 3-15](#local_vs_globals_rewrite)。
- en: Example 3-15\. Local versus global scoping, revisited
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-15\. 本地与全局作用域的再访问
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_functions_CO5-1)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_CO5-1)'
- en: By declaring both `$a` and `$b` to be global variables, you are telling the
    function to use values from the parent scope rather than its own scope.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`$a`和`$b`为全局变量后，函数将使用父作用域的值而不是自己的作用域。
- en: '[![2](assets/2.png)](#co_functions_CO5-2)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_CO5-2)'
- en: With a reference to the *global* `$a` variable, you can now actually print it
    to output.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对*全局*变量`$a`的引用，你现在可以将其打印到输出中。
- en: '[![3](assets/3.png)](#co_functions_CO5-3)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_CO5-3)'
- en: Likewise, any changes to `$a` within the scope of the function will impact the
    variable in the parent scope.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在函数作用域内对`$a`的任何更改都将影响父作用域中的变量。
- en: '[![4](assets/4.png)](#co_functions_CO5-4)'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_CO5-4)'
- en: Similarly, you now define `$b` but, as it’s global, this definition will bubble
    out to the parent scope as well.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你现在定义了`$b`，但由于它是全局的，此定义也将向上冒泡到父作用域中。
- en: '[![5](assets/5.png)](#co_functions_CO5-5)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functions_CO5-5)'
- en: Echoing `$a` will now reflect the changes made within the scope of `example()`
    as you made the variable global.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`echo $a`将反映在`example()`作用域内所做的更改，因为你将变量设置为全局的。
- en: '[![6](assets/6.png)](#co_functions_CO5-6)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_functions_CO5-6)'
- en: Likewise, `$b` is now defined globally and can be echoed to output as well.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`$b`现在已全局定义，并且也可以打印到输出中。
- en: There is no limit on the number of global variables PHP can support aside from
    the memory available to the system. Additionally, *all* globals can be listed
    by enumerating the special `$GLOBALS` array defined by PHP. This associative array
    contains references to all variables defined within the global scope. This special
    array can be useful if you want to reference a specific variable in the global
    scope *without* declaring the variable as global, as in [Example 3-16](#global_assoc_array).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 除了系统可用的内存外，PHP可以支持的全局变量数量没有限制。此外，可以通过枚举PHP定义的特殊$GLOBALS数组来列出所有全局变量。这个关联数组对于想要在全局范围内引用特定变量而不声明为全局变量的情况非常有用，例如[例子 3-16](#global_assoc_array)。
- en: Example 3-16\. Using the associative `$GLOBALS` array
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 3-16\. 使用关联的$GLOBALS数组
- en: '[PRE28]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Warning
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of PHP 8.1, it is no longer possible to overwrite the entirety of the `$GLOBALS`
    array. In previous versions, you could reset it to an empty array (for example,
    during test runs of your code). Moving forward, you can edit only the contents
    of the array rather than manipulating the collection in its entirety.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 从PHP 8.1开始，不再可能完全覆盖$GLOBALS数组。在以前的版本中，你可以将其重置为空数组（例如，在代码的测试运行期间）。从现在开始，你只能编辑数组的内容，而不能再整体操作集合了。
- en: Global variables are a handy way to reference state across your application,
    but they can lead to confusion and maintainability issues if overused. Some large
    applications leverage global variables heavily—WordPress, a PHP-based project
    that powers more than 40% of the internet,^([3](ch03.html#idm45875191172432))
    [uses global variables throughout its codebase](https://oreil.ly/jztni). However,
    most application developers agree that global variables should be used sparingly,
    if at all, to help keep systems clean and easy to maintain.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量是在应用程序中引用状态的方便方式，但如果过度使用可能会导致混乱和可维护性问题。一些大型应用程序大量使用全局变量——WordPress是一个基于PHP的项目，驱动着超过40%的互联网[^3]，[在其代码库中广泛使用全局变量](https://oreil.ly/jztni)。然而，大多数应用程序开发人员都同意，应尽可能少地使用全局变量，以帮助保持系统的清洁和易维护性。
- en: See Also
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [variable scope](https://oreil.ly/tN5tV) and the [special
    `$GLOBALS` array](https://oreil.ly/z9JJS).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档中关于[变量作用域](https://oreil.ly/tN5tV)和特殊的[$GLOBALS](https://oreil.ly/z9JJS)数组。
- en: 3.8 Managing State Within a Function Across Multiple Invocations
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.8 在多次调用之间管理函数内部的状态
- en: Problem
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your function needs to keep track of its change in state over time.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数需要随着时间的推移跟踪其状态变化。
- en: Solution
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `static` keyword to define a locally scoped variable that retains its
    state between function invocations:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static`关键字定义一个在函数调用之间保持状态的本地作用域变量：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: A static variable exists only within the scope of the function in which it is
    declared. However, unlike regular local variables, it holds on to its value every
    time you return to the scope of the function. In this way, a function can become
    *stateful* and keep track of certain data (like the number of times it’s been
    called) between independent invocations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量仅存在于其声明的函数作用域内。然而，与普通的局部变量不同的是，它在每次返回函数作用域时保留其值。通过这种方式，函数可以变得*有状态*，并在独立调用之间跟踪某些数据（如被调用的次数）。
- en: In a typical function, using the `=` operator will assign a value to a variable.
    When the `static` keyword is applied, this assignment operation only happens the
    first time that function is called. Subsequent calls will reference the previous
    state of the variable and allow the program to either use or modify the stored
    value as well.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的函数中，使用`=`运算符将值分配给变量。当应用`static`关键字时，此赋值操作仅在首次调用该函数时发生。后续调用将引用变量的先前状态，并允许程序使用或修改存储的值。
- en: One of the most common use cases of static variables is to track the state of
    a recursive function. [Example 3-17](#static_variable) demonstrates a function
    that recursively calls itself a fixed number of times before exiting.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量的最常见用例之一是跟踪递归函数的状态。[例子 3-17](#static_variable)展示了一个在退出之前递归调用自身固定次数的函数。
- en: Example 3-17\. Using a static variable to limit recursion depth
  id: totrans-230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 3-17\. 使用静态变量限制递归深度
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `static` keyword can also be used to keep track of expensive resources
    that might be needed by a function multiple times but that you might only want
    a single instance of. Consider a function that logs messages to a database: you
    might not be able to pass a database connection into the function itself, but
    you want to ensure that the function only opens a *single* database connection.
    Such a logging function might be implemented as in [Example 3-18](#static_database_connection).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 关键字还可以用于跟踪可能需要多次函数调用但您可能只想要单个实例的昂贵资源。考虑一个将消息记录到数据库的函数：您可能无法将数据库连接传递给函数本身，但希望确保该函数只打开一个*单一*数据库连接。这样的记录函数可以实现如
    [示例 3-18](#static_database_connection) 中所示。'
- en: Example 3-18\. Using a static variable to hold a database connection
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-18\. 使用静态变量保存数据库连接
- en: '[PRE31]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_functions_CO6-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_CO6-1)'
- en: The first time `logger()` is called, it will define the value of the static
    `$dbh` variable. In this case, it will connect to a database by using the [PHP
    Data Objects (PDO)](https://oreil.ly/do1eJ) interface. This interface is a standard
    object provided by PHP for accessing databases.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用 `logger()` 时，它将定义静态变量 `$dbh` 的值。在此情况下，它将通过[PHP 数据对象（PDO）](https://oreil.ly/do1eJ)接口连接到数据库。此接口是
    PHP 提供的用于访问数据库的标准对象。
- en: '[![2](assets/2.png)](#co_functions_CO6-2)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_CO6-2)'
- en: Every subsequent call to `logger()` will leverage the initial connection opened
    to the database and stored in `$dbh`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `logger()` 都将利用存储在 `$dbh` 中的初始数据库连接。
- en: Note that PHP automatically manages its memory usage and automatically clears
    variables from memory when they leave scope. For regular variables within a function,
    this means the variables are freed from memory as soon as the function completes.
    Static and global variables are *never* cleaned up until the program itself exits,
    as they are always in scope. Take care when using the `static` keyword to ensure
    that you aren’t storing unnecessarily large pieces of data in memory. In [Example 3-18](#static_database_connection),
    you open a connection to a database that will never be automatically closed by
    the function you’ve created.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，PHP 自动管理其内存使用情况，并在变量离开作用域时从内存中自动清除变量。对于函数内的常规变量，这意味着变量在函数完成后从内存中释放。静态和全局变量*永远*不会在程序本身退出之前清除，因为它们始终在作用域中。在使用
    `static` 关键字时要小心，确保不会在内存中存储不必要的大数据块。在 [示例 3-18](#static_database_connection) 中，您打开一个连接到数据库的连接，该连接永远不会被您创建的函数自动关闭。
- en: While the `static` keyword can be a powerful way to reuse state across function
    calls, it should be used with care to ensure that your application doesn’t do
    anything unexpected. In many cases, it might be better to explicitly pass variables
    representing state into the function. Even better would be to encapsulate the
    function’s state as part of an overarching object, which is covered in [Chapter 8](ch08.html#chapter_classes).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `static` 关键字可以是在函数调用之间重用状态的强大方式，但应谨慎使用以确保您的应用程序不会执行意外操作。在许多情况下，明确传递表示状态的变量到函数中可能更好。更好的方法是将函数的状态封装为一个全局对象的一部分，这在[第
    8 章](ch08.html#chapter_classes)中有详细介绍。
- en: See Also
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [variable scoping, including the `static` keyword](https://oreil.ly/-yflc).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 文档关于[变量作用域，包括 `static` 关键字](https://oreil.ly/-yflc)。
- en: 3.9 Defining Dynamic Functions
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.9 定义动态函数
- en: Problem
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define an anonymous function and reference it as a variable within
    your application because you only want to use or call the function a single time.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望定义一个匿名函数，并将其作为变量引用到应用程序中，因为您只想使用或调用该函数一次。
- en: Solution
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Define a closure that can be assigned to a variable and passed into another
    function as needed:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个可以分配给变量并根据需要传递到另一个函数中的闭包：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Discussion
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Whereas most functions in PHP have defined names, the language supports the
    creation of unnamed (so-called *anonymous*) functions, also called *closures*
    or *lambdas*. These functions can encapsulate either simple or complex logic and
    can be assigned directly to variables for reference elsewhere in the program.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 PHP 中的大多数函数都有定义的名称，该语言支持创建无名（所谓的*匿名*）函数，也称为*闭包*或*lambda*。这些函数可以封装简单或复杂的逻辑，并可以直接分配给变量以供程序中其他地方引用。
- en: Internally, anonymous functions are implemented using PHP’s native [`Closure`](https://oreil.ly/u5qt7)
    class. This class is declared as `final`, which means no class can extend it directly.
    Yet, anonymous functions are all instances of this class and can be used either
    directly as functions or as objects.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，匿名函数使用PHP的原生[`Closure`](https://oreil.ly/u5qt7)类实现。该类声明为`final`，这意味着没有类可以直接扩展它。然而，匿名函数都是这个类的实例，可以直接用作函数或作为对象使用。
- en: By default, closures do not inherit any scope from the parent application and,
    like regular functions, define variables within their own scope. Variables from
    the parent scope can be passed directly into a closure by leveraging the `use`
    directive when defining a function. [Example 3-19](#closure_with_use) illustrates
    how variables from one scope can be passed into another dynamically.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，闭包不会继承任何父应用程序的作用域，并且像普通函数一样，在其自己的作用域内定义变量。可以通过在定义函数时利用`use`指令，直接将父作用域的变量传递给闭包。[示例 3-19](#closure_with_use)演示了如何动态地将一个作用域的变量传递到另一个作用域中。
- en: Example 3-19\. Passing a variable between scopes with `use()`
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-19\. 使用`use()`在不同作用域之间传递变量
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Anonymous functions are used in many projects to encapsulate a piece of logic
    for application against a collection of data. The next recipe covers exactly that
    use case.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数用于许多项目中，以封装应用于数据集合的逻辑片段。下一个示例正好涵盖了这种用例。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Older versions of PHP used [`create_function()`](https://oreil.ly/RRMgO) for
    similar utility. Developers could create an anonymous function as a string and
    pass that code into `create_function()` to turn it into a closure instance. Unfortunately,
    this method used `eval()` under the hood to evaluate the string—a practice considered
    highly unsafe. While some older projects might still use `create_function()`,
    the function itself was deprecated in PHP 7.2 and removed from the language entirely
    in version 8.0.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的旧版本使用[`create_function()`](https://oreil.ly/RRMgO)实现类似的效果。开发人员可以将匿名函数作为字符串创建，并将该代码传递给`create_function()`，将其转换为闭包实例。不幸的是，这种方法在底层使用了`eval()`来评估字符串，这种做法被认为是非常不安全的。虽然一些旧项目可能仍在使用`create_function()`，但该函数在PHP
    7.2中已被弃用，并在版本8.0中从语言中完全删除。
- en: See Also
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [anonymous functions](https://oreil.ly/W0QPL).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档中关于[匿名函数](https://oreil.ly/W0QPL)的说明。
- en: 3.10 Passing Functions as Parameters to Other Functions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.10 将函数作为参数传递给其他函数
- en: Problem
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define part of a function’s implementation and pass that implementation
    as an argument to another function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望定义函数实现的一部分，并将该实现作为参数传递给另一个函数。
- en: Solution
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Define a closure that implements part of the logic you need and pass that directly
    into another function as if it were any other variable:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个实现所需逻辑部分的闭包，并将其直接传递到另一个函数中，就像任何其他变量一样：
- en: '[PRE34]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Discussion
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP is considered by many to be a *functional language*, as functions are first-class
    elements in the language and can be bound to variable names, passed as arguments,
    or even returned from other functions. PHP supports functions as variables through
    the [callable](https://oreil.ly/m7skJ) type as implemented in the language. Many
    core functions (like `usort()`, `array_map()`, and `array_reduce()`) support passing
    a callable parameter, which is then used internally to define the function’s overall
    implementation.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 许多认为PHP是*功能型语言*，因为函数在语言中是一级元素，可以绑定到变量名，作为参数传递，甚至从其他函数中返回。PHP通过语言中实现的[callable](https://oreil.ly/m7skJ)类型支持函数作为变量。许多核心函数（如`usort()`、`array_map()`和`array_reduce()`）支持传递可调用参数，内部使用它来定义函数的整体实现。
- en: 'The `reduce()` function defined in the Solution example is a user-written implementation
    of PHP’s native `array_reduce()` function. Both have the same behavior, and the
    Solution could be rewritten to pass `$reducer` directly into PHP’s native implementation
    with no change in the result:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例中定义的`reduce()`函数是PHP本地`array_reduce()`函数的用户自定义实现。两者行为相同，解决方案可以重写，直接将`$reducer`传递到PHP本地实现中，结果不变：
- en: '[PRE35]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Since functions can be passed around like any other variable, PHP has the ability
    to define partial implementations of functions. This is achieved by defining a
    function that, in turn, returns another function that can be used elsewhere in
    the program.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于函数可以像任何其他变量一样传递，PHP可以定义函数的部分实现。通过定义一个函数，然后返回另一个函数，可以在程序的其他地方使用它。
- en: For example, you can define a function to set up a basic multiplier routine
    that multiplies any input by a *fixed* base amount, as in [Example 3-20](#partial_function_multiplier).
    The main function returns a new function each time you call it, so you can create
    functions to double or triple arbitrary values and use them however you want.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以定义一个函数来设置一个基本的乘法器例程，该例程将任意输入乘以一个*固定*基数，就像[示例 3-20](#partial_function_multiplier)中那样。主函数每次调用都返回一个新函数，因此您可以创建加倍或三倍任意值的函数，并根据需要使用它们。
- en: Example 3-20\. Partially applied multiplier function
  id: totrans-272
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-20\. 部分应用的乘法器函数
- en: '[PRE36]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Breaking functions apart like this is known as [*https://oreil.ly/-*](https://oreil.ly/-)*a4l[_currying*].
    This is the practice of changing a function with multiple input parameters into
    a series of functions, that each take a *single* parameter, with most of those
    parameters being functions themselves. To fully illustrate how this can work in
    PHP, let’s look at [Example 3-21](#multiplier_currying_walkthrough) and walk through
    a rewrite of the `multiplier()` function.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数分解成这样的形式称为[*https://oreil.ly/-*](https://oreil.ly/-)*a4l[_currying*]。这是将具有多个输入参数的函数改为一系列每个只接受一个*单一*参数的函数，并且其中大多数参数本身也是函数的做法。为了充分说明这在PHP中的工作原理，让我们看看[示例 3-21](#multiplier_currying_walkthrough)并逐步重写`multiplier()`函数。
- en: Example 3-21\. Walk-through of currying in PHP
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-21\. PHP中柯里化的演示
- en: '[PRE37]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_functions_CO7-1)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_CO7-1)'
- en: The most basic form of the function takes two values, multiplies them together,
    and returns a final result.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的最基本形式接受两个值，将它们相乘并返回最终结果。
- en: '[![2](assets/2.png)](#co_functions_CO7-2)'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_CO7-2)'
- en: When you curry the function, you want each component function to only take a
    single value. The new `curried_multiply()` only accepts one parameter but returns
    a function that leverages that parameter internally.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当你柯里化函数时，你希望每个组件函数只接受一个值。新的`curried_multiply()`例如，只接受一个参数，但返回一个在内部利用该参数的函数。
- en: '[![3](assets/3.png)](#co_functions_CO7-3)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_CO7-3)'
- en: The internal function references the value passed by your previous function
    invocation automatically (with the `use` directive).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 内部函数自动引用前一个函数调用传递的值（使用`use`指令）。
- en: '[![4](assets/4.png)](#co_functions_CO7-4)'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_CO7-4)'
- en: The resulting function implements the same business logic as the basic form.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 结果函数实现了与基本形式相同的业务逻辑。
- en: '[![5](assets/5.png)](#co_functions_CO7-5)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_functions_CO7-5)'
- en: Calling a curried function has the appearance of calling *multiple* functions
    in series, but the result is the same.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 调用柯里化函数看起来像是按顺序调用*多个*函数，但结果是相同的。
- en: 'The biggest advantage of currying, as in [Example 3-21](#multiplier_currying_walkthrough),
    is that a partially applied function can be passed around as a variable and used
    elsewhere. Similar to using the `mul⁠tiplier()` function, you can create a doubling
    or tripling function by *partially* applying your curried multiplier as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在[示例 3-21](#multiplier_currying_walkthrough)中的柯里化函数一样，柯里化的最大优势是部分应用的函数可以作为变量传递并在其他地方使用。类似于使用`multiplier()`函数，您可以通过以下方式*部分*应用您的柯里化乘法器来创建一个加倍或三倍的函数：
- en: '[PRE38]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Partially applied, curried functions are themselves callable functions but can
    be passed into other functions as variables and fully invoked later.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 部分应用的柯里化函数本身是可调用的函数，但可以作为变量传递给其他函数，并在稍后完全调用。
- en: See Also
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Details on anonymous functions in [Recipe 3.9](#anonymous_functions).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有关匿名函数的详细信息，请参见[Recipe 3.9](#anonymous_functions)。
- en: 3.11 Using Concise Function Definitions (Arrow Functions)
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.11 使用简洁的函数定义（箭头函数）
- en: Problem
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a simple, anonymous function that references the parent scope
    without verbose `use` declarations.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望创建一个简单的匿名函数，它引用父作用域而不需要冗长的`use`声明。
- en: Solution
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use PHP’s short anonymous function (arrow function) syntax to define a function
    that inherits its parent’s scope automatically:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP的短匿名函数（箭头函数）语法自动定义一个函数，该函数自动继承其父作用域：
- en: '[PRE39]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Discussion
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '*Arrow functions* were introduced in PHP 7.4 as a way to write more concise
    anonymous functions, as in [Recipe 3.9](#anonymous_functions). Arrow functions
    automatically capture any referenced variables and import them (by value rather
    than by reference) into the scope of the function.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '*箭头函数*在PHP 7.4中作为编写更简洁匿名函数的一种方式引入，就像在[Recipe 3.9](#anonymous_functions)中一样。箭头函数自动捕获任何引用的变量并（按值而非按引用）导入到函数的作用域中。'
- en: A more verbose version of the Solution example could be written as shown in
    [Example 3-22](#verbose_anonymous_function) while still achieving the same level
    of functionality.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以更详细的方式编写解决方案示例，如[示例 3-22](#verbose_anonymous_function)，同时仍然实现相同级别的功能。
- en: Example 3-22\. Long form of an anonymous function
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-22\. 匿名函数的长格式
- en: '[PRE40]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Arrow functions always return a value—it is impossible to either implicitly
    or explicitly return `void`. These functions follow a very specific syntax and
    always return the result of their expression: `*fn* (*arguments*) => *expression*`.
    This structure makes arrow functions useful in a wide variety of situations.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数总是返回一个值——不可能隐式或显式返回`void`。这些函数遵循非常特定的语法，并始终返回其表达式的结果：`*fn* (*arguments*)
    => *expression*`。这种结构使得箭头函数在各种情况下都非常有用。
- en: One example is a concise inline definition of a function to be applied to all
    elements in an array via PHP’s native `array_map()`. Assume input user data is
    an array of strings that each represent an integer value and you want to convert
    the array of strings into an array of integers to enforce proper type safety.
    This can easily be accomplished via [Example 3-23](#convert_string_array_to_integers).
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是通过PHP的本地`array_map()`来应用于数组中所有元素的内联函数的简明定义。假设输入用户数据是表示整数值的字符串数组，并且您希望将字符串数组转换为整数数组以强制执行适当的类型安全性。这可以通过[示例
    3-23](#convert_string_array_to_integers)轻松实现。
- en: Example 3-23\. Convert an array of numeric strings to an array of integers
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-23\. 将数值字符串数组转换为整数数组
- en: '[PRE41]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Arrow functions only permit a single-line expression. If your logic is complicated
    enough to require multiple expressions, use a standard anonymous function (see
    [Recipe 3.9](#anonymous_functions)) or define a named function in your code. This
    being said, an arrow function itself is an expression, so one arrow function can
    actually return another.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数仅允许单行表达式。如果您的逻辑复杂到需要多个表达式，请使用标准匿名函数（参见[配方 3.9](#anonymous_functions)）或在代码中定义一个命名函数。尽管如此，箭头函数本身就是一个表达式，因此一个箭头函数实际上可以返回另一个箭头函数。
- en: The ability to return an arrow function as the expression of another arrow function
    leads to a way to use arrow functions in *curried* or partially applied functions
    to encourage code reuse. Assume you want to pass a function in the program that
    performs modulo arithmetic with a fixed modulus. You can do so by defining one
    arrow function to perform the calculation and wrap it in another that specifies
    the modulus, assigning the final, curried function to a variable you can use elsewhere,
    as in [Example 3-24](#curried_arrow_functions).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将箭头函数作为另一个箭头函数的表达式返回的能力，导致可以在*柯里化*或部分应用函数中使用箭头函数以促进代码重用。假设您希望在程序中传递一个函数，该函数使用固定的模数执行模数算术。您可以通过定义一个箭头函数来执行计算并将其包装在另一个函数中以指定模数，将最终的柯里化函数分配给可以在其他地方使用的变量，例如[示例
    3-24](#curried_arrow_functions)。
- en: Note
  id: totrans-309
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Modulo arithmetic is used to create *clock functions* that always return a specific
    set of integer values regardless of the integer input. You take the modulus of
    two integers by dividing them and returning the integer remainder. For example,
    “12 modulo 3” is written as `12 % 3` and returns the remainder of `12/3`, or `0`.
    Similarly, “15 modulo 6” is written as `15 % 6` and returns the remainder of `15/6`,
    or `3`. The return of a modulo operation is never greater than the modulus itself
    (`3` or `6` in the previous two examples, respectively). Modulo arithmetic is
    commonly used to group large collections of input values together or to power
    cryptographic operations, which are discussed further in [Chapter 9](ch09.html#chapter_encryption).
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 模数算术用于创建*时钟函数*，无论输入的整数是什么，它们总是返回一组特定的整数值。通过将两个整数取模，即将它们相除并返回整数余数来完成。例如，“12 模
    3”写作 `12 % 3` 并返回 `12/3` 的余数，即 `0`。类似地，“15 模 6”写作 `15 % 6` 并返回 `15/6` 的余数，即 `3`。模运算的返回值永远不会大于模数本身（在前两个示例中分别为
    `3` 或 `6`）。模数算术通常用于将大量输入值分组或用于支持加密操作，有关详细信息，请参阅[第 9 章](ch09.html#chapter_encryption)。
- en: Example 3-24\. Function currying with arrow functions
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-24\. 使用箭头函数进行函数柯里化
- en: '[PRE42]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, just like regular functions, arrow functions can accept multiple arguments.
    Rather than passing a single variable (or implicitly referencing variables defined
    in the parent scope), you can just as easily define a function with multiple parameters
    and freely use them within the expression. A trivial equality function might use
    an arrow function as follows:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，就像常规函数一样，箭头函数也可以接受多个参数。与传递单个变量（或隐式引用父作用域中定义的变量）不同，您可以轻松地定义一个具有多个参数并在表达式中自由使用它们的函数。一个简单的相等函数可以使用箭头函数如下所示：
- en: '[PRE43]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See Also
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Details on anonymous functions in [Recipe 3.9](#anonymous_functions) and the
    PHP Manual documentation on [arrow functions](https://oreil.ly/MLURC).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在[3.9 节](#anonymous_functions)匿名函数的详细信息和 PHP 手册文档中的[箭头函数](https://oreil.ly/MLURC)。
- en: 3.12 Creating a Function with No Return Value
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.12 创建一个没有返回值的函数
- en: Problem
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to define a function that does not return data to the rest of the program
    after it completes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要定义一个函数，它在完成后不向程序的其余部分返回数据。
- en: Solution
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use explicit type declarations and reference the `void` return type:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式类型声明，并引用`void`返回类型：
- en: '[PRE44]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Discussion
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The Solution example uses PHP’s native `mail()` function to dispatch a simple
    message with a static subject to the specified recipient. PHP’s `mail()` returns
    either `true` (on success) or `false` (when there’s an error). In the Solution
    example, you merely want to throw an exception when something goes wrong but otherwise
    want to return silently.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例使用 PHP 的本机`mail()`函数将静态主题的简单消息发送到指定的接收者。PHP 的`mail()`在成功时返回`true`，出现错误时返回`false`。在解决方案示例中，当出现问题时您仅想抛出异常，但在其他情况下希望静默返回。
- en: Note
  id: totrans-325
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In many cases, you might want to return a flag—a Boolean value or a string or
    `null`—when a function completes to indicate what has happened so the rest of
    your program can behave appropriately. Functions that return *nothing* are relatively
    rare, but they do come up when your program is communicating with an outside party
    and the result of that communication doesn’t impact the rest of the program. Sending
    a fire-and-forget connection to a message queue or logging to the system error
    log are both common use cases for a function that returns `void`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，当函数完成时，您可能希望返回一个标志 —— 布尔值、字符串或`null` —— 以指示发生了什么，这样您程序的其余部分可以适当地行事。返回*nothing*的函数相对较少，但当您的程序与外部进行通信且通信结果不影响程序的其余部分时，它们确实会出现。将消息队列发送到火并忘连接或记录到系统错误日志是返回`void`的函数的常见用例。
- en: The `void` return type is enforced on compile time in PHP, meaning your code
    will trigger a fatal error if the function body returns *anything* at all, even
    if you haven’t executed anything yet. [Example 3-25](#valid_and_invalid_void)
    illustrates both valid and invalid uses of `void`.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中的`void`返回类型在编译时强制执行，这意味着如果函数体返回*任何*内容，即使您尚未执行任何操作，您的代码也将触发致命错误。[示例 3-25](#valid_and_invalid_void)展示了`void`的有效和无效使用。
- en: Example 3-25\. Valid and invalid uses of the `void` return type
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-25\. `void` 返回类型的有效和无效使用
- en: '[PRE45]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_functions_CO8-1)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_functions_CO8-1)'
- en: Returning a scalar type (such as a string, integer, or Boolean) will trigger
    a fatal error.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 返回标量类型（如字符串、整数或布尔值）将触发致命错误。
- en: '[![2](assets/2.png)](#co_functions_CO8-2)'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_functions_CO8-2)'
- en: Omitting any kind of return in a function is valid.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中省略任何返回是有效的。
- en: '[![3](assets/3.png)](#co_functions_CO8-3)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_functions_CO8-3)'
- en: Explicitly returning no data is valid.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 明确地返回没有数据是有效的。
- en: '[![4](assets/4.png)](#co_functions_CO8-4)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_functions_CO8-4)'
- en: Even though `null` is “empty,” it still counts as a return and will trigger
    a fatal error.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`null`是“空的”，它仍然算作返回值，并将触发致命错误。
- en: Unlike most other types in PHP, the `void` type is only valid for returns. It
    cannot be used as a parameter type in a function definition; attempts to do so
    will result in a fatal error at compile time.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 与 PHP 中的大多数其他类型不同，`void`类型仅适用于返回。它不能用作函数定义的参数类型；尝试这样做将导致编译时致命错误。
- en: See Also
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The [original RFC introducing the `void` return type](https://oreil.ly/FvRb_)
    in PHP 7.1.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 7.1 中引入`void`返回类型的[原始 RFC](https://oreil.ly/FvRb_)。
- en: 3.13 Creating a Function That Does Not Return
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3.13 创建一个不返回值的函数
- en: Problem
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to define a function that explicitly exits and to ensure that other
    parts of your application are aware it will never return.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要定义一个显式退出的函数，并确保应用程序的其他部分知道它永远不会返回。
- en: Solution
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use explicit type annotations and reference the `never` return type. For example:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式类型注释并引用 `never` 返回类型。例如：
- en: '[PRE46]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Discussion
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Some operations in PHP are intended to be the last action the engine takes before
    exiting the current process. Calling `header()` to define a specific response
    header must be done prior to printing any body to the response itself. Specifically,
    calling `header()` to trigger a redirect is usually the last thing you want your
    application to do—printing any body text or processing any other operation after
    you’ve told the requesting client to redirect elsewhere has no meaning or value.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中的一些操作意图是在退出当前进程之前引擎执行的最后一个操作。调用 `header()` 定义特定响应头必须在打印响应主体或处理其他操作之前完成。具体来说，调用
    `header()` 触发重定向通常是应用程序执行的最后一步 —— 在告知请求客户端重定向至其他位置后打印任何主体文本或处理任何其他操作没有意义或价值。
- en: The `never` return type signals both to PHP and to other parts of your code
    that the function is *guaranteed* to halt the program’s execution by way of either
    `exit()` or `die()` or throwing an exception.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`never` 返回类型向 PHP 和代码的其他部分都表明函数通过 `exit()`、`die()` 或抛出异常“*保证*”停止程序执行。'
- en: If a function that leverages the `never` return type still returns implicitly,
    as in [Example 3-26](#never_implicit_return), PHP will throw a `TypeError` exception.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `never` 返回类型的函数仍然隐式返回，例如[示例 3-26](#never_implicit_return)，PHP 将抛出 `TypeError`
    异常。
- en: Example 3-26\. Implicit return in a function that should never return
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 3-26\. 一个本不应该返回的函数中的隐式返回
- en: '[PRE47]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Likewise, if a `never`-typed function *explicitly* returns a value, PHP will
    throw a `TypeError` exception. In both situations, whether an implicit or an explicit
    return, this exception is enforced at call time (when the function is invoked)
    rather than when the function is defined.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果 `never` 类型的函数 *显式* 返回一个值，PHP 也会抛出 `TypeError` 异常。无论是隐式还是显式返回，这个异常都是在调用时（函数被调用时）而不是在定义时强制执行的。
- en: See Also
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The [original RFC introducing the `never` return type](https://oreil.ly/wO3zv)
    in PHP 8.1.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[PHP 8.1 中引入 `never` 返回类型的原始 RFC](https://oreil.ly/wO3zv)。'
- en: ^([1](ch03.html#idm45875184619360-marker)) Custom classes and objects are discussed
    at length in [Chapter 8](ch08.html#chapter_classes).
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch03.html#idm45875184619360-marker)) 在[第 8 章](ch08.html#chapter_classes)详细讨论了自定义类和对象。
- en: ^([2](ch03.html#idm45875190957904-marker)) [PHP CodeSniffer](https://oreil.ly/G4tHg)
    is a popular developer tool for automatically scanning a codebase and ensuring
    that all code matches a specific coding standard. It can be trivially extended
    to enforce a strict type declaration in all files as well.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch03.html#idm45875190957904-marker)) [PHP CodeSniffer](https://oreil.ly/G4tHg)
    是一款流行的开发者工具，用于自动扫描代码库并确保所有代码符合特定的编码标准。它可以轻松扩展以在所有文件中强制执行严格的类型声明。
- en: ^([3](ch03.html#idm45875191172432-marker)) The market reach of WordPress was
    about 63% of websites using content management systems and more than 43% of all
    websites as of March 2023 according to [W3Techs](https://oreil.ly/8Y_Zp).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch03.html#idm45875191172432-marker)) 根据[W3Techs](https://oreil.ly/8Y_Zp)，截至
    2023 年 3 月，WordPress 的市场覆盖率约为使用内容管理系统的网站的 63%，以及所有网站的超过 43%。
