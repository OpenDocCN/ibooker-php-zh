- en: Chapter 15\. Expressions and Control Flow in JavaScript
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章\. JavaScript中的表达式和控制流
- en: In the previous chapter, I introduced the basics of JavaScript and the DOM.
    Now it’s time to look at how to construct complex expressions in JavaScript and
    how to control the program flow of your scripts by using conditional statements.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我介绍了JavaScript和DOM的基础知识。现在是时候看看如何在JavaScript中构建复杂的表达式，并通过使用条件语句来控制脚本的程序流了。
- en: Expressions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: JavaScript expressions are very similar to those in PHP. As you learned in [Chapter 4](ch04.xhtml#expressions_and_control_flow_in_php),
    an expression is a combination of values, variables, operators, and functions
    that results in a value; the result can be a number, a string, or a Boolean value
    (which evaluates to either `true` or `false`).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript表达式与PHP中的表达式非常相似。正如您在[第4章](ch04.xhtml#expressions_and_control_flow_in_php)中学到的那样，表达式是值、变量、运算符和函数的组合，其结果是一个值；结果可以是数字、字符串或布尔值（评估为`true`或`false`）。
- en: '[Example 15-1](#four_simple_boolean_expressions-id00059) shows some simple
    expressions. For each line, it prints out a letter between `a` and `d`, followed
    by a colon and the result of the expressions. The `<br>` tag is there to create
    a line break and separate the output into four lines (remember that both `<br>`
    and `<br />` are acceptable in HTML5, so I chose to use the former style for brevity).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-1](#four_simple_boolean_expressions-id00059)展示了一些简单的表达式。对于每一行，它打印出`a`到`d`之间的字母，后跟一个冒号和表达式的结果。`<br>`标签用于创建换行并将输出分隔成四行（请记住，在HTML5中`<br>`和`<br
    />`都是可接受的，因此我选择使用前一种形式以简洁为主）。'
- en: Example 15-1\. Four simple Boolean expressions
  id: totrans-5
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-1\. 四个简单的布尔表达式
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output from this code is as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出如下：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Notice that both expressions `a:` and `d:` evaluate to `true`, but `b:` and
    `c:` evaluate to `false`. Unlike PHP (which would print the number `1` and nothing,
    respectively), the actual strings `true` and `false` are displayed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`a:`和`d:`两个表达式都评估为`true`，但`b:`和`c:`评估为`false`。与PHP不同（它将分别打印数字`1`和空白），实际的字符串`true`和`false`将被显示。
- en: 'In JavaScript, when you are checking whether a value is `true` or `false`,
    all values evaluate to `true` except the following, which evaluate to `false`:
    the string `false` itself, `0`, `–0`, the empty string, `null`, `undefined`, and
    `NaN` (Not a Number, a computer engineering concept for the result of an illegal
    floating-point operation such as division by zero).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，当您检查一个值是否为`true`或`false`时，除了以下值评估为`false`：字符串`false`本身，`0`，`-0`，空字符串，`null`，`undefined`和`NaN`（不是一个数字，计算机工程中用于非法浮点操作的结果，例如除以零）。
- en: 'Note that I am referring to `true` and `false` in lowercase. This is because,
    unlike in PHP, these values *must* be in lowercase in JavaScript. Therefore, only
    the first of the two following statements will display, printing the lowercase
    word `true`, because the second will cause a `''TRUE'' is not defined` error:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在JavaScript中引用的`true`和`false`都是小写。这是因为，与PHP不同，这些值*必须*是小写的。因此，仅以下两个语句的第一个将会显示，打印小写单词`true`，因为第二个将导致`'TRUE'未定义`错误：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that any code snippets you wish to type and try for yourself in an
    HTML file need to be enclosed within `<script>` and `</script>` tags.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，任何您希望在HTML文件中键入并尝试的代码片段都需要包含在`<script>`和`</script>`标签中。
- en: Literals and Variables
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文字和变量
- en: The simplest form of an expression is a *literal*, which means something that
    evaluates to itself, such as the number `22` or the string `Press Enter`. An expression
    could also be a variable, which evaluates to the value that has been assigned
    to it. They are both types of expressions, because they return a value.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的最简单形式是*文字*，这意味着它评估为自身，例如数字`22`或字符串`Press Enter`。表达式也可以是一个变量，它评估为已分配给它的值。它们都是表达式的类型，因为它们返回一个值。
- en: '[Example 15-2](#five_types_of_literals) shows three different literals and
    two variables, all of which return values, albeit of different types.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-2](#five_types_of_literals)展示了三种不同的文字和两个变量，所有这些都返回值，尽管类型不同。'
- en: Example 15-2\. Five types of literals
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-2\. 五种文字类型
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And, as you’d expect, you see a return value from all of these in the following
    output:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 而且，正如您所期望的那样，您将在以下输出中看到所有这些的返回值：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Operators let you create more complex expressions that evaluate to useful results.
    When you combine assignment or control-flow constructs with expressions, the result
    is a *statement*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符允许您创建更复杂的表达式，这些表达式评估为有用的结果。当您将赋值或控制流构造与表达式结合时，结果是一个*语句*。
- en: '[Example 15-3](#two_simple_javascript_statements) shows one of each. The first
    assigns the result of the expression `366 - day_number` to the variable `days_to_new_year`,
    and the second outputs a friendly message only if the expression `days_to_new_year
    < 30` evaluates to `true`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-3](#two_simple_javascript_statements) 展示了其中的一个例子。第一个将表达式 `366 - day_number`
    的结果赋给变量 `days_to_new_year`，第二个仅在表达式 `days_to_new_year < 30` 评估为 `true` 时输出友好消息。'
- en: Example 15-3\. Two simple JavaScript statements
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-3\. 两个简单的 JavaScript 语句
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Operators
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: JavaScript offers a lot of powerful operators, ranging from arithmetic, string,
    and logical operators to assignment, comparison, and more (see [Table 15-1](#javascript_operator_types)).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 提供了许多强大的运算符，从算术、字符串和逻辑运算符到赋值、比较等（参见[表 15-1](#javascript_operator_types)）。
- en: Table 15-1\. JavaScript operator types
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-1\. JavaScript 运算符类型
- en: '| Operator | Description | Example |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Arithmetic | Basic mathematics | `a + b` |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | 基本数学 | `a + b` |'
- en: '| Array | Array manipulation | `a + b` |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | 数组操作 | `a + b` |'
- en: '| Assignment | Assign values | `a = b + 23` |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 赋值 | 赋值 | `a = b + 23` |'
- en: '| Bitwise | Manipulate bits within bytes | `12 ^ 9` |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 位运算 | 在字节内操作位 | `12 ^ 9` |'
- en: '| Comparison | Compare two values | `a < b` |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | 比较两个值 | `a < b` |'
- en: '| Increment/decrement | Add or subtract one | `a++` |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 递增/递减 | 加或减一 | `a++` |'
- en: '| Logical | Boolean | `a && b` |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑 | 布尔 | `a && b` |'
- en: '| String | Concatenation | `a + ''string''` |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 连接 | `a + ''string''` |'
- en: 'Each operator takes a different number of operands:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运算符接受不同数量的操作数：
- en: '*Unary* operators, such as incrementing (`a++`) or negation (`-a`), take a
    single operand.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一元* 运算符，如递增（`a++`）或否定（`-a`），只接受一个操作数。'
- en: '*Binary* operators, which represent the bulk of JavaScript operators—including
    addition, subtraction, multiplication, and division—take two operands.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二元* 运算符占据了 JavaScript 运算符的大部分，包括加法、减法、乘法和除法，需要两个操作数。'
- en: 'The one *ternary* operator, which takes the form `? x : y`, requires three
    operands. It’s a terse single-line `if` statement that chooses between two expressions
    depending on a third one.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*三元* 运算符，形式为 `? x : y`，需要三个操作数。它是一个简洁的单行 `if` 语句，根据第三个表达式选择两个表达式中的一个。'
- en: Operator Precedence
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: Like PHP, JavaScript utilizes operator precedence, in which some operators in
    an expression are processed before others and are therefore evaluated first. [Table 15-2](#precedence_of_javascript_operators_l)
    lists JavaScript’s operators and their precedences.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 像 PHP 一样，JavaScript 使用运算符优先级，其中表达式中的某些运算符先处理，因此首先进行评估。表 15-2 列出了 JavaScript
    的运算符及其优先级。
- en: Table 15-2\. Precedence of JavaScript operators (high to low)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-2\. JavaScript 运算符优先级（从高到低）
- en: '| Operator(s) | Type(s) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 类型 |'
- en: '| --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `() [] .` | Parentheses, call, and member |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `() [] .` | 括号、调用和成员 |'
- en: '| `++ --` | Increment/decrement |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `++ --` | 递增/递减 |'
- en: '| `+ - ~ !` | Unary, bitwise, and logical |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `+ - ~ !` | 一元、位和逻辑 |'
- en: '| `* / %` | Arithmetic |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `* / %` | 算术 |'
- en: '| `+ -` | Arithmetic and string |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `+ -` | 算术和字符串 |'
- en: '| `<< >> >>>` | Bitwise |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `<< >> >>>` | 位运算 |'
- en: '| `< > <= >=` | Comparison |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `< > <= >=` | 比较 |'
- en: '| `== != === !==` | Comparison |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `== != === !==` | 比较 |'
- en: '| `& ^ &#124;` | Bitwise |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `& ^ &#124;` | 位运算 |'
- en: '| `&&` | Logical |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 逻辑 |'
- en: '| `&#124;&#124;` | Logical |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 逻辑 |'
- en: '| `? :` | Ternary |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `? :` | 三元 |'
- en: '| `= += -= *= /= %=` | Assignment |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `= += -= *= /= %=` | 赋值 |'
- en: '| `<<= >>= >>>= &= ^= &#124;=` | Assignment |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `<<= >>= >>>= &= ^= &#124;=` | 赋值 |'
- en: '| `,` | Separator |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 分隔符 |'
- en: Associativity
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合性
- en: Most JavaScript operators are processed in order from left to right in an equation.
    But some operators require processing from right to left instead. The direction
    of processing is called the operator’s *associativity*.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 JavaScript 运算符在等式中按照从左到右的顺序处理。但有些运算符需要从右到左进行处理。处理方向称为运算符的*结合性*。
- en: 'This associativity becomes important where you do not explicitly force precedence
    (which you should always do, by the way, because it makes code more readable and
    less error prone). For example, look at the following assignment operators, by
    which three variables are all set to the value `0`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你没有明确强制运算优先级时，这种结合性变得很重要（顺便说一句，你应该总是这样做，因为它使代码更易读，减少错误）。例如，看看以下赋值运算符，这三个变量都被设置为值`0`：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This multiple assignment is possible only because the rightmost part of the
    expression is evaluated first and then processing continues in a right-to-left
    direction. [Table 15-3](#operators_and_associativity) lists the JavaScript operators
    and their associativity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当表达式的最右部分首先进行评估，然后以从右到左的顺序继续处理时，才能进行多重赋值。表 15-3](#operators_and_associativity)列出了
    JavaScript 运算符及其结合性。
- en: Table 15-3\. Operators and associativity
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-3\. 运算符及其结合性
- en: '| Operator | Description | Associativity |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 | 结合性 |'
- en: '| --- | --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `++ --` | Increment and decrement | None |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `++ --` | 增减 | 无 |'
- en: '| `new` | Create a new object | Right |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `new` | 创建一个新对象 | 右 |'
- en: '| `+ - ~ !` | Unary and bitwise | Right |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `+ - ~ !` | 一元和位运算 | 右 |'
- en: '| `?:` | Ternary | Right |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `?:` | 三元 | 右 |'
- en: '| `= *= /= %= += -=` | Assignment | Right |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `= *= /= %= += -=` | 赋值 | 右 |'
- en: '| `<<= >>= >>>= &= ^= &#124;=` | Assignment | Right |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `<<= >>= >>>= &= ^= &#124;=` | 赋值 | 右 |'
- en: '| `,` | Separator | Left |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 分隔符 | 左 |'
- en: '| `+ - * / %` | Arithmetic | Left |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `+ - * / %` | 算术 | 左 |'
- en: '| `<< >> >>>` | Bitwise | Left |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `<< >> >>>` | 位运算 | 左 |'
- en: '| `< <= > >= == != === !==` | Arithmetic | Left |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `< <= > >= == != === !==` | 算术 | 左 |'
- en: Relational Operators
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系运算符
- en: '*Relational operators* test two operands and return a Boolean result of either
    `true` or `false`. There are three types of relational operators: *equality*,
    *comparison*, and *logical*.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*关系运算符*测试两个操作数并返回布尔结果`true`或`false`。有三种类型的关系运算符：*等式*、*比较*和*逻辑*。'
- en: Equality operators
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相等运算符
- en: The equality operator is `==` (which should not be confused with the `=` assignment
    operator). In [Example 15-4](#assigning_a_value_and_testing_fo-id00065), the first
    statement assigns a value, and the second tests it for equality. As it stands,
    nothing will be printed out, because `month` is assigned the string value `July`,
    and therefore the check for it having a value of `October` will fail.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 等号运算符是`==`（不要与赋值运算符`=`混淆）。在[示例 15-4](#assigning_a_value_and_testing_fo-id00065)中，第一条语句赋值，第二条语句测试其是否相等。目前不会输出任何内容，因为`month`被赋予了字符串值`July`，因此检查其是否为`October`的条件将失败。
- en: Example 15-4\. Assigning a value and testing for equality
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-4\. 赋值和相等测试
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the two operands of an equality expression are of different types, JavaScript
    will convert them to whatever type makes best sense to it. For example, any strings
    composed entirely of numbers will be converted to numbers whenever compared with
    a number. In [Example 15-5](#equality_and_identity_operators-id00066), `a` and
    `b` are two different values (one is a number, and the other is a string), and
    we would therefore normally expect neither of the `if` statements to output a
    result.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果相等表达式的两个操作数类型不同，JavaScript 将它们转换为最合理的类型。例如，任何完全由数字组成的字符串与数字比较时将被转换为数字。在[示例 15-5](#equality_and_identity_operators-id00066)中，`a`
    和 `b` 是两个不同的值（一个是数字，另一个是字符串），因此我们通常不希望任何`if`语句输出结果。
- en: Example 15-5\. The equality and identity operators
  id: totrans-88
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-5\. 相等和恒等运算符
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: However, if you run the example, you will see that it outputs the number `1`,
    which means that the first `if` statement evaluated to `true`. This is because
    the string value of `b` was temporarily converted to a number, and therefore both
    halves of the equation had a numerical value of `3.1415927`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果运行此示例，您将看到它输出数字`1`，这意味着第一个`if`语句评估为`true`。这是因为`b`的字符串值临时转换为数字，因此等式两侧都有数值`3.1415927`。
- en: In contrast, the second `if` statement uses the *identity* operator, three equals
    signs in a row, which prevents JavaScript from automatically converting types.
    `a` and `b` are therefore found to be different, so nothing is output.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，第二个`if`语句使用*恒等*运算符，即连续三个等号，这会阻止 JavaScript 自动转换类型。因此，发现`a`和`b`是不同的，因此不会输出任何内容。
- en: As with forcing operator precedence, whenever you’re in doubt about how JavaScript
    will convert operand types, you can use the identity operator to turn this behavior
    off.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与强制运算符优先级类似，每当您对 JavaScript 如何转换操作数类型感到困惑时，可以使用恒等运算符关闭此行为。
- en: Comparison operators
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Using comparison operators, you can test for more than just equality and inequality.
    JavaScript also gives you `>` (is greater than), `<` (is less than), `>=` (is
    greater than or equal to), and `<=` (is less than or equal to) to play with. [Example 15-6](#four_comparison_operators-id00068)
    shows these operators in use.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比较运算符，你不仅可以测试相等和不等，JavaScript 还为你提供了`>`（大于）、`<`（小于）、`>=`（大于或等于）和`<=`（小于或等于）进行使用。[示例
    15-6](#four_comparison_operators-id00068)展示了这些运算符的使用。
- en: Example 15-6\. The four comparison operators
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-6\. 四个比较运算符
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, where `a` is `7` and `b` is `11`, the following is output
    (because 7 is less than 11 and also less than or equal to 11):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当`a`为`7`且`b`为`11`时，输出如下（因为7小于11且也小于等于11）：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Logical operators
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Logical operators produce true or false results and are also known as *Boolean*
    operators. There are three of them in JavaScript (see [Table 15-4](#javascriptapostrophes_logical_operators)).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符会产生`true`或`false`结果，也被称为*布尔*运算符。JavaScript 中有三种逻辑运算符（见[表 15-4](#javascriptapostrophes_logical_operators)）。
- en: Table 15-4\. JavaScript’s logical operators
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-4\. JavaScript 的逻辑运算符
- en: '| Logical operator | Description |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑运算符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `&&` *(and)* | `true` if both operands are `true` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `&&` *(and)* | 如果两个操作数都为`true`，则返回`true`。 |'
- en: '| `&#124;&#124;` *(or)* | `true` if either operand is `true` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` *(or)* | 如果任一操作数为`true`，则返回`true`。'
- en: '| `!` *(not)* | `true` if the operand is `false`, or `false` if the operand
    is `true` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `!` *(not)* | 如果操作数为`false`，则返回`true`；如果操作数为`true`，则返回`false`。 |'
- en: You can see how these can be used in [Example 15-7](#logical_operators_in_use-id00070),
    which outputs `0`, `1`, and `true`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到这些如何在[示例 15-7](#logical_operators_in_use-id00070)中使用，该示例输出`0`、`1`和`true`。
- en: Example 15-7\. The logical operators in use
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-7\. 逻辑运算符的使用
- en: '[PRE11]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `&&` statement requires both operands to be `true` to return a value of
    `true`, the `||` statement will be `true` if either value is `true`, and the third
    statement performs a `NOT` on the value of `b`, turning it from `0` into a value
    of `true`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&`语句要求两个操作数都为`true`才会返回`true`，`||`语句在任一值为`true`时会返回`true`，第三个语句对`b`的值执行`NOT`操作，将其从`0`转换为`true`。'
- en: The `||` operator can cause unintentional problems, because the second operand
    will not be evaluated if the first is evaluated as `true`. In [Example 15-8](#statement_using_the_vertical_lineverti),
    the `getnext` function will never be called if `finished` has a value of `1` (these
    are purely examples, and the action of `getnext` is irrelevant to this explanation—just
    think of it as a function that does *something* when called).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`||`运算符可能会引起意外问题，因为如果第一个操作数被评估为`true`，则第二个操作数将不会被评估。在[示例 15-8](#statement_using_the_vertical_lineverti)中，如果`finished`的值为`1`，则`getnext`函数将永远不会被调用（这些仅为示例，`getnext`的具体行为与此解释无关——只需将其视为在调用时执行某些操作的函数）。'
- en: Example 15-8\. A statement using the `||` operator
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-8\. 使用`||`运算符的语句
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you *need* `getnext` to be called at each `if` statement, you should rewrite
    the code as shown in [Example 15-9](#ifdotdotdotor_statement_modified_to).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在每个`if`语句中调用`getnext`，你应该按照[示例 15-9](#ifdotdotdotor_statement_modified_to)重新编写代码。
- en: Example 15-9\. The `if...or` statement modified to ensure calling of `getnext`
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-9\. 修改后的`if...or`语句以确保调用`getnext`
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, the code in the function `getnext` will be executed and its return
    value stored in `gn` before the `if` statement.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在`if`语句之前，将执行`getnext`函数的代码，并将其返回值存储在`gn`中。
- en: '[Table 15-5](#all_possible_logical_expressions) shows all the possible variations
    of using the logical operators. You should also note that `!true` equals `false`
    and `!false` equals `true`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 15-5](#all_possible_logical_expressions)展示了使用逻辑运算符的所有可能变体。你还应该注意，`!true`等于`false`，`!false`等于`true`。'
- en: Table 15-5\. All possible logical expressions
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-5\. 所有可能的逻辑表达式
- en: '| Inputs | Operators and results |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 输入 | 运算符及结果 |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `a` | `b` | `&&` | `&#124;&#124;` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `a` | `b` | `&&` | `&#124;&#124;` |'
- en: '| --- | --- | --- | --- |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `true` | `true` | `true` | `true` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `true` | `true` | `true` | `true` |'
- en: '| `true` | `false` | `false` | `true` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `true` | `false` | `false` | `true` |'
- en: '| `false` | `true` | `false` | `true` |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `false` | `true` | `false` | `true` |'
- en: '| `false` | `false` | `false` | `false` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `false` | `false` | `false` | `false` |'
- en: The with Statement
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`with`语句'
- en: The `with` statement is not one that you’ve seen in the earlier chapters on
    PHP, because it’s exclusive to JavaScript, and also one that while you need to
    know it, you should not use (see [???](#a-caution-against-using-with)). With it
    (if you see what I mean), you can simplify some types of JavaScript statements
    by reducing many references to an object to just one reference. References to
    properties and methods within the `with` block are assumed to apply to that object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句不是您在早期关于PHP的章节中看到的语句，因为它是JavaScript专用的，并且是您需要了解但不应使用的语句（见[???](#a-caution-against-using-with)）。使用它，您可以通过减少对一个对象的多次引用来简化某些类型的JavaScript语句，将`with`块内的属性和方法引用视为适用于该对象。'
- en: For example, take the code in [Example 15-10](#using_the_with_statement), in
    which the `document.write` function never references the variable `string` by
    name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看[示例 15-10](#using_the_with_statement)中的代码，其中`document.write`函数从未直接引用`string`变量名。
- en: Example 15-10\. Using the `with` statement
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-10\. 使用`with`语句
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Even though `string` is never directly referenced by `document.write`, this
    code still manages to output the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`string`从未被`document.write`直接引用，此代码仍然成功输出以下内容：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is how the code works: the JavaScript interpreter recognizes that the
    `length` property and `toUpperCase` method have to be applied to some object.
    Because they stand alone, the interpreter assumes they apply to the `string` object
    that you specified in the `with` statement.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 代码工作方式如下：JavaScript解释器识别出`length`属性和`toUpperCase`方法必须应用于某个对象。因为它们单独存在，解释器假定它们适用于您在`with`语句中指定的`string`对象。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Using `with` is no longer recommended and is now forbidden in ECMAScript 5 strict
    mode. The recommended alternative is to assign the object whose properties you
    want to access to a temporary variable. Be sure to note this so you can update
    it (if necessary) when you see it in other people’s code, but do not use it yourself.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在ECMAScript 5严格模式中，不再推荐使用`with`，并且现已禁止。推荐的替代方法是将要访问其属性的对象分配给临时变量。请注意这一点，以便在看到其他人的代码中使用时进行更新（如果需要），但不要自己使用。
- en: Using onerror
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`onerror`
- en: Using either the `onerror` event or a combination of the `try` and `catch` keywords,
    you can catch JavaScript errors and deal with them yourself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`onerror`事件或`try`和`catch`关键字的组合，可以捕获JavaScript错误并自行处理。
- en: '*Events* are actions that can be detected by JavaScript. Every element on a
    web page has certain events that can trigger JavaScript functions. For example,
    the `onclick` event of a button element can be set to call a function and make
    it run whenever a user clicks the button.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*事件*是JavaScript可以检测到的操作。网页上的每个元素都有特定的事件，可以触发JavaScript函数。例如，按钮元素的`onclick`事件可以设置为调用一个函数，并使其在用户点击按钮时运行。'
- en: '[Example 15-11](#script_employing_the_onerror_event) illustrates how to use
    the `onerror` event.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-11](#script_employing_the_onerror_event)说明了如何使用`onerror`事件。'
- en: Example 15-11\. A script employing the onerror event
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-11\. 使用`onerror`事件的脚本
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first line of this script tells the error event to use the new `errorHandler`
    function from now on. This function takes three parameters—a `message`, a `url`,
    and a `line` number—so it’s a simple matter to display all these in an alert pop-up.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的第一行告诉错误事件从现在开始使用新的`errorHandler`函数。此函数接受三个参数——`message`、`url`和`line`编号——因此可以简单地在警报弹出窗口中显示所有这些内容。
- en: Then, to test the new function, we deliberately place a syntax error in the
    code with a call to `document.writ` instead of `document.write` (the final `e`
    is missing). [Figure 15-1](#using_the_onerror_event_with_an_alert_me) shows the
    result of running this script in a browser. Using `onerror` this way can also
    be quite useful during the debugging process.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了测试新函数，我们故意在代码中引入一个语法错误，调用`document.writ`而不是`document.write`（最后一个`e`丢失）。[图 15-1](#using_the_onerror_event_with_an_alert_me)展示了在浏览器中运行此脚本的结果。在调试过程中，使用`onerror`这种方式也非常有用。
- en: '![Using the onerror event with an alert method pop-up](Images/pmj6_1501.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![使用`onerror`事件与警报方法弹出窗口](Images/pmj6_1501.png)'
- en: Figure 15-1\. Using the `onerror` event with an alert method pop-up
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-1\. 使用带有警报方法弹出窗口的`onerror`事件
- en: Using try...catch
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用try...catch
- en: The `try` and `catch` keywords are more standard and more flexible than the
    `onerror` technique shown in the previous section. These keywords let you trap
    errors for a selected section of code, rather than all scripts in a document.
    However, they do not catch syntax errors, for which you need `onerror`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`和`catch`关键字比前一节中展示的`onerror`技术更加标准和灵活。这些关键字允许您捕获代码中特定部分的错误，而不是文档中所有脚本的错误。然而，它们无法捕获语法错误，这种错误需要使用`onerror`。'
- en: The `try...catch` construct is supported by all major browsers and is handy
    when you want to catch a certain condition that you are aware could occur in a
    specific part of your code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`try...catch`结构被所有主要浏览器支持，当您希望捕获特定部分代码中可能发生的某个条件时，它非常方便。'
- en: For example, in [Chapter 18](ch18.xhtml#using_ajax) we’ll be exploring Ajax
    techniques that make use of the `XMLHttpRequest` object. Therefore, we can use
    `try` and `catch` to trap this case and do something else if the function is not
    available. [Example 15-12](#trapping_an_error_with_try_and_catch) shows how.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在[第18章](ch18.xhtml#using_ajax)中，我们将探讨利用`XMLHttpRequest`对象的Ajax技术。因此，我们可以使用`try`和`catch`来捕捉这种情况，并在函数不可用时执行其他操作。[示例15-12](#trapping_an_error_with_try_and_catch)展示了如何操作。
- en: Example 15-12\. Trapping an error with `try` and `catch`
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例15-12\. 使用`try`和`catch`捕获错误
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There’s also another keyword associated with `try` and `catch` called `finally`
    that is always executed, regardless of whether an error occurs in the `try` clause.
    To use it, just add something like the following statements after a `catch` statement:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`和`catch`之外，还有一个与之关联的关键字叫做`finally`，无论在`try`子句中是否发生错误，它都会始终被执行。要使用它，只需在`catch`语句后添加如下语句：'
- en: '[PRE18]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Conditionals
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: 'Conditionals alter program flow. They enable you to ask questions about certain
    things and respond to the answers you get in different ways. There are three types
    of nonlooping conditionals: the `if` statement, the `switch` statement, and the
    `?` operator.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句可以改变程序流程。它们使您能够针对某些事物提出问题，并根据所得到的答案以不同方式做出响应。非循环条件语句有三种类型：`if`语句，`switch`语句和`?`运算符。
- en: The if Statement
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if`语句'
- en: 'Several examples in this chapter have already made use of `if` statements.
    The code within such a statement is executed only if the given expression evaluates
    to `true`. Multiline `if` statements require curly braces around them, but as
    in PHP, you can omit the braces for single statements, although it’s often a good
    idea to use them anyway, especially when writing code in which the number of actions
    within an `if` statement might change as development proceeds. Therefore, the
    following statements are valid:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的几个示例已经使用了`if`语句。只有在给定表达式评估为`true`时，才会执行此类语句中的代码。多行`if`语句需要用大括号括起来，但与PHP一样，对于单个语句，您可以省略大括号，尽管在编写代码时，特别是在`if`语句内部的操作数量可能会随着开发的进行而改变时，使用大括号通常是一个好习惯。因此，以下语句是有效的：
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The else Statement
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`else`语句'
- en: 'When a condition has not been met, you can execute an alternative by using
    an `else` statement, like this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件未被满足时，您可以使用`else`语句执行替代操作，如下所示：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Unlike PHP, JavaScript has no `elseif` statement, but that’s not a problem
    because you can use an `else` followed by another `if` to form the equivalent
    of an `elseif` statement, like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 不像PHP，JavaScript没有`elseif`语句，但这并不是问题，因为您可以使用`else`后面再跟一个`if`来实现类似于`elseif`语句的效果，如下所示：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, you can use another `else` after the new `if`, which could
    equally be followed by another `if` statement, and so on. Although I have shown
    braces on the statements, because each is a single line, the previous example
    could be written as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，您可以在新的`if`后面再使用一个`else`，同样可以跟随另一个`if`语句，以此类推。虽然我在这些语句中使用了大括号，因为每个语句都是单行的，前面的示例也可以写成如下形式：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The switch Statement
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch`语句'
- en: The `switch` statement is useful when one variable or the result of an expression
    can have multiple values and you want to perform a different function for each
    value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量或表达式的结果可以有多个值时，`switch`语句非常有用，您可以针对每个值执行不同的函数。
- en: For example, the following code takes the PHP menu system we put together in
    [Chapter 4](ch04.xhtml#expressions_and_control_flow_in_php) and converts it to
    JavaScript. It works by passing a single string to the main menu code according
    to what the user requests. Let’s say the options are Home, About, News, Login,
    and Links, and we set the variable `page` to one of these according to the user’s
    input.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，下面的代码将我们在[第4章](ch04.xhtml#expressions_and_control_flow_in_php)中组合的PHP菜单系统转换为JavaScript。它通过根据用户的输入传递一个字符串给主菜单代码来工作，并将变量`page`设置为其中之一：Home、About、News、Login和Links。
- en: The code for this written using `if...else if...` might look like [Example 15-13](#multiline_ifdotdotdotelse_if).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if...else if...`编写的代码看起来可能类似于[示例 15-13](#multiline_ifdotdotdotelse_if)。
- en: Example 15-13\. A multiline `if...else if...` statement
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-13\. 多行的`if...else if...`语句
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: But using a `switch` construct, the code could look like [Example 15-14](#switch_construct).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`switch`结构，代码可能看起来像[示例 15-14](#switch_construct)。
- en: Example 15-14\. A `switch` construct
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-14\. 一个`switch`结构
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The variable `page` is mentioned only once at the start of the `switch` statement.
    Thereafter, the `case` command checks for matches. When one occurs, the matching
    conditional statement is executed. Of course, a real program would have code here
    to display or jump to a page, rather than simply telling the user what was selected.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`page`仅在`switch`语句的开头提到一次。此后，`case`命令检查匹配项。当匹配发生时，执行相应的条件语句。当然，一个真实的程序将在这里有代码来显示或跳转到一个页面，而不仅仅是告诉用户选择了什么。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may also supply multiple cases for a single action. For example:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以为单个操作提供多个情况。例如：
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Breaking out
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳出
- en: As you can see in [Example 15-14](#switch_construct), just as with PHP, the
    `break` command allows your code to break out of the `switch` statement once a
    condition has been satisfied. Remember to include the `break` unless you want
    to continue executing the statements under the next `case`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[示例 15-14](#switch_construct)中所看到的，与PHP一样，`break`命令允许你的代码在满足条件后跳出`switch`语句。请记住包含`break`，除非你希望继续执行下一个`case`下的语句。
- en: Default action
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认操作
- en: When no condition is satisfied, you can specify a default action for a `switch`
    statement by using the `default` keyword. [Example 15-15](#default_statement_to_add_to_example_14)
    shows a code snippet that could be inserted into [Example 15-14](#switch_construct).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有任何条件被满足时，你可以使用`default`关键字为`switch`语句指定默认操作。[示例 15-15](#default_statement_to_add_to_example_14)展示了一个可以插入到[示例 15-14](#switch_construct)中的代码片段。
- en: Example 15-15\. A default statement to add to [Example 15-14](#switch_construct)
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-15\. 添加到[示例 15-14](#switch_construct)的默认语句
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The ? Operator
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ？操作符
- en: The `ternary` operator (`?`), combined with the `:` character, provides a quick
    way of doing `if...else` tests. With it you can write an expression to evaluate
    and then follow it with a `?` symbol and the code to execute if the expression
    is `true`. After that, place a `:` and the code to execute if the expression evaluates
    to `false`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`ternary`操作符（`?`），结合`:`字符，提供了一种快速进行`if...else`测试的方式。你可以编写一个表达式进行评估，然后跟随一个`?`符号和在表达式为`true`时要执行的代码。之后，放置一个`:`和在表达式评估为`false`时要执行的代码。'
- en: '[Example 15-16](#using_the_ternary_operator) shows the ternary operator being
    used to print out whether the variable `a` is less than or equal to 5 and prints
    something either way.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-16](#using_the_ternary_operator)展示了使用三元操作符来打印变量`a`是否小于或等于5，并在任何情况下打印出一些内容。'
- en: Example 15-16\. Using the ternary operator
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-16\. 使用三元操作符的例子
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The statement has been broken up into several lines for clarity, but you would
    be more likely to use such a statement on a single line, in this manner:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，该语句已被分成多行，但你更可能在单行中使用这样的语句，如下所示：
- en: '[PRE28]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Looping
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: Again, you will find many close similarities between JavaScript and PHP when
    it comes to looping. Both languages support `while`, `do...while`, and `for` loops.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到循环时，JavaScript和PHP之间有许多相似之处。两种语言都支持`while`、`do...while`和`for`循环。
- en: while Loops
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: while循环
- en: A JavaScript `while` loop first checks the value of an expression and starts
    executing the statements within the loop only if that expression is `true`. If
    it is `false`, execution skips over to the next JavaScript statement (if any).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript的`while`循环首先检查表达式的值，并仅在该表达式为`true`时开始执行循环内的语句。如果为`false`，执行将跳过到下一个JavaScript语句（如果有）。
- en: Upon completing an iteration of the loop, the expression is again tested to
    see if it is `true`, and the process continues until such a time as the expression
    evaluates to `false` or until execution is otherwise halted. [Example 15-17](#while_loop-id00080)
    shows such a loop.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成循环的迭代后，表达式再次被测试以查看它是否为`true`，并且进程将继续直到表达式评估为`false`或执行被另行停止。[示例 15-17](#while_loop-id00080)展示了这样的循环。
- en: Example 15-17\. A `while` loop
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-17\. `while`循环
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This script outputs the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本输出以下内容：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Warning
  id: totrans-203
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If the variable `counter` were not incremented within the loop, it is quite
    possible that some browsers could become unresponsive due to a never-ending loop,
    and the page may not even be easy to terminate with Escape or the Stop button.
    So, be careful with your JavaScript loops.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在循环内部不增加变量`counter`，某些浏览器可能会因为无限循环而变得无响应，甚至可能无法通过Esc键或停止按钮轻松终止页面。所以，请小心处理你的JavaScript循环。
- en: do...while Loops
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`do...while`循环'
- en: When you require a loop to iterate at least once before any tests are made,
    use a `do...while` loop, which is similar to a `while` loop, except that the test
    expression is checked only after each iteration of the loop. So, to output the
    first seven results in the 7 times table, you could use code such as that in [Example 15-18](#do_dotdotdot_while_loop).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要在进行任何测试之前至少执行一次循环时，请使用`do...while`循环，它类似于`while`循环，只是测试表达式仅在每次循环迭代后检查。因此，要输出7的乘法表的前七个结果，你可以使用类似于[示例 15-18](#do_dotdotdot_while_loop)中的代码。
- en: Example 15-18\. A `do...while` loop
  id: totrans-207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-18\. `do...while`循环
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you might expect, this loop outputs the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所预料的，此循环输出以下内容：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: for Loops
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'A `for` loop combines the best of all worlds into a single looping construct
    that allows you to pass three parameters for each statement:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环将所有优点结合到单个循环结构中，允许你为每个语句传递三个参数：'
- en: An initialization expression
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始化表达式
- en: A condition expression
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个条件表达式
- en: A modification expression
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个修改表达式
- en: 'These are separated by semicolons, like this: `for (`*`expr1`* `;` *`expr2`*
    `;` *`expr3`*`)`. The initialization expression is executed at the start of the
    first iteration of the loop. In the case of the code for the multiplication table
    for 7, `count` would be initialized to the value `1`. Then, each time around the
    loop, the condition expression (in this case, `count <= 7`) is tested, and the
    loop is entered only if the condition is `true`. Finally, at the end of each iteration,
    the modification expression is executed. In the case of the multiplication table
    for 7, the variable `count` is incremented. [Example 15-19](#using_a_for_loop)
    shows what the code would look like.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些由分号分隔，如下所示：`for (`*`expr1`* `;` *`expr2`* `;` *`expr3`*`)`。初始化表达式在循环的第一次迭代开始时执行。对于用于输出7的乘法表的代码，`count`将被初始化为值`1`。然后，每次循环时，条件表达式（在本例中为`count
    <= 7`）被测试，只有当条件为`true`时才进入循环。最后，在每次迭代结束时，修改表达式被执行。对于用于输出7的乘法表的代码，变量`count`被递增。[示例 15-19](#using_a_for_loop)展示了代码的样子。
- en: Example 15-19\. Using a `for` loop
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-19\. 使用`for`循环
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As in PHP, you can assign multiple variables in the first parameter of a `for`
    loop by separating them with a comma, like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在PHP中一样，你可以在`for`循环的第一个参数中使用逗号分隔多个变量，如下所示：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Likewise, you can perform multiple modifications in the last parameter, like
    this:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以在最后一个参数中执行多个修改，如下所示：
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Or you can do both at the same time:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以同时执行两者：
- en: '[PRE36]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Breaking Out of a Loop
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出循环
- en: The `break` command, which you’ll recall is important inside a `switch` statement,
    is also available within `for` loops. You might need to use this, for example,
    when searching for a match of some kind. Once the match is found, you know that
    continuing to search will only waste time and make your visitor wait. [Example 15-20](#using_the_break_command_in_a_for_loop)
    shows how to use the `break` command.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`命令，你可能还记得在`switch`语句内部很重要，在`for`循环中也是可用的。例如，当搜索某种匹配时可能需要使用此功能。一旦找到匹配，你就知道继续搜索只会浪费时间并让访问者等待。[示例 15-20](#using_the_break_command_in_a_for_loop)展示了如何使用`break`命令。'
- en: Example 15-20\. Using the `break` command in a `for` loop
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 15-20\. 在`for`循环中使用`break`命令
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This script outputs the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本输出以下内容：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The continue Statement
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: continue语句
- en: Sometimes you don’t want to entirely exit from a loop but instead wish to skip
    the remaining statements just for this iteration of the loop. In such cases, you
    can use the `continue` command. [Example 15-21](#using_the_continue_command_in_a_for_loop)
    shows this in use.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你不想完全退出循环，而是希望跳过本次循环中的其余语句。在这种情况下，你可以使用 `continue` 命令。示例 [15-21](#using_the_continue_command_in_a_for_loop)
    展示了其使用方法。
- en: Example 15-21\. Using the `continue` command in a `for` loop
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-21\. 在 `for` 循环中使用 `continue` 命令
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Notice how the second `document.write` call does not have to be enclosed in
    an `else` statement (as it did before), because the `continue` command will skip
    it if a match has been found. The output from this script is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意第二个 `document.write` 调用不必像以前那样被包含在 `else` 语句中，因为 `continue` 命令将在找到匹配项时跳过它。该脚本的输出如下：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Explicit Casting
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显式类型转换
- en: Unlike PHP, JavaScript has no explicit casting of types such as `(int)` or `(float)`.
    Instead, when you need a value to be of a certain type, use one of JavaScript’s
    built-in functions, shown in [Table 15-6](#javascriptapostrophes_type-changing_func).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 不像 PHP，JavaScript 没有显式类型转换，比如 `(int)` 或 `(float)`。相反，当你需要一个值是特定类型时，使用 JavaScript
    内置的函数之一，如 [表 15-6](#javascriptapostrophes_type-changing_func) 中所示。
- en: Table 15-6\. JavaScript’s type-changing functions
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 表 15-6\. JavaScript 类型转换函数
- en: '| Change to type | Function to use |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| 类型更改 | 使用的函数 |'
- en: '| --- | --- |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Int`, `Integer` | `parseInt()` |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `Int`, `Integer` | `parseInt()` |'
- en: '| `Bool`, `Boolean` | `Boolean()` |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `Bool`, `Boolean` | `Boolean()` |'
- en: '| `Float`, `Double`, `Real` | `parseFloat()` |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `Float`, `Double`, `Real` | `parseFloat()` |'
- en: '| `String` | `String()` |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `String()` |'
- en: '| `Array` | `split()` |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `Array` | `split()` |'
- en: 'So, for example, to change a floating-point number to an integer, you could
    use code such as the following (which displays the value `3`):'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，要将浮点数转换为整数，可以使用以下代码（显示值为 `3`）：
- en: '[PRE41]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Or you can use the compound form:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可以使用复合形式：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: That’s it for control flow and expressions. The next chapter focuses on the
    use of functions, objects, and arrays in JavaScript.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流和表达式就是这些内容。下一章将重点讲解 JavaScript 中函数、对象和数组的使用。
- en: Questions
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How are Boolean values handled differently by PHP and JavaScript?
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PHP 和 JavaScript 如何处理布尔值？
- en: What characters are used to define a JavaScript variable name?
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JavaScript 变量名的定义要用到哪些字符？
- en: What is the difference between unary, binary, and ternary operators?
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一元、二元和三元操作符有什么区别？
- en: What is the best way to force your own operator precedence?
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何强制自己的运算符优先级？
- en: When would you use the `===` (identity) operator?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时会使用 `===`（恒等）运算符？
- en: What are the simplest two forms of expressions?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是最简单的两种表达式形式？
- en: Name the three conditional statement types.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举三种条件语句类型的名称。
- en: How do `if` and `while` statements interpret conditional expressions of different
    data types?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if` 和 `while` 语句如何解释不同数据类型的条件表达式？'
- en: Why is a `for` loop more powerful than a `while` loop?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么 `for` 循环比 `while` 循环更强大？
- en: What is the purpose of the `with` statement?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`with` 语句的目的是什么？'
- en: See [“Chapter 15 Answers”](app01_split_014.xhtml#chapter_15_answers) in the
    [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions) for the
    answers to these questions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [“第 15 章答案”](app01_split_014.xhtml#chapter_15_answers) ，在 [附录 A](app01_split_000.xhtml#solutions_to_the_chapter_questions)
    中找到这些问题的答案。
