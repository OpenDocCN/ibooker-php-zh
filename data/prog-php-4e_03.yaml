- en: Chapter 2\. Language Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章。语言基础
- en: This chapter provides a whirlwind tour of the core PHP language, covering such
    basic topics as data types, variables, operators, and flow-control statements.
    PHP is strongly influenced by other programming languages, such as Perl and C,
    so if you’ve had experience with those languages, PHP should be easy to pick up.
    If PHP is one of your first programming languages, don’t panic. We start with
    the basic units of a PHP program and build up your knowledge from there.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章快速浏览了核心 PHP 语言，涵盖了数据类型、变量、运算符和流控制语句等基本主题。PHP 受其他编程语言（如 Perl 和 C）的强烈影响，因此，如果您有这些语言的经验，学习
    PHP 应该很容易。如果 PHP 是您的第一种编程语言之一，不要惊慌。我们从 PHP 程序的基本单元开始，并逐步构建您的知识。
- en: Lexical Structure
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 词法结构
- en: The lexical structure of a programming language is the set of basic rules that
    governs how you write programs in that language. It is the lowest-level syntax
    of the language and specifies such things as what variable names look like, what
    characters are used for comments, and how program statements are separated from
    each other.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言的词法结构是指控制您在该语言中编写程序的基本规则集。它是语言的最低级语法，指定变量名的外观、用于注释的字符以及如何将程序语句彼此分隔等内容。
- en: Case Sensitivity
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大小写敏感性
- en: 'The names of user-defined classes and functions, as well as built-in constructs
    and keywords (such as `echo`, `while`, `class`, etc.), are case-insensitive. Thus,
    these three lines are equivalent:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的类和函数的名称，以及内置结构和关键字（如`echo`、`while`、`class`等）不区分大小写。因此，以下这三行是等效的：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Variables, on the other hand, are case-sensitive. That is, `$name`, `$NAME`,
    and `$NaME` are three different variables.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，变量是区分大小写的。也就是说，`$name`、`$NAME` 和 `$NaME` 是三个不同的变量。
- en: Statements and Semicolons
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 语句和分号
- en: 'A statement is a collection of PHP code that does something. It can be as simple
    as a variable assignment or as complicated as a loop with multiple exit points.
    Here is a small sample of PHP statements, including function calls, some variable
    data assignments, and an `if` statement:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 语句是执行某些操作的 PHP 代码集合。它可以简单到变量赋值，也可以复杂到有多个退出点的循环。这里是 PHP 语句的一个小示例，包括函数调用、一些变量数据分配以及一个
    `if` 语句：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'PHP uses semicolons to separate simple statements. A compound statement that
    uses curly braces to mark a block of code, such as a conditional test or loop,
    does not need a semicolon after a closing brace. Unlike in other languages, in
    PHP the semicolon before the closing brace is not optional:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 使用分号分隔简单语句。使用花括号标记代码块的复合语句，例如条件测试或循环，不需要在闭括号后加分号。与其他语言不同，在 PHP 中，在闭括号前的分号是不可选的：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The semicolon, however, is optional before a closing PHP tag:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在闭合 PHP 标签前分号是可选的：
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It’s good programming practice to include optional semicolons, as they make
    it easier to add code later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最好在可选的地方包含分号，因为这样可以更轻松地添加代码。
- en: Whitespace and Line Breaks
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空白和换行
- en: 'In general, whitespace doesn’t matter in a PHP program. You can spread a statement
    across any number of lines, or lump a bunch of statements together on a single
    line. For example, this statement:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，PHP 程序中的空白不重要。您可以将语句扩展到任意行数，或将一堆语句放在一行上。例如，这条语句：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'could just as well be written with more whitespace:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可以写得更多空白：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'or with less whitespace:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更少的空白：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can take advantage of this flexible formatting to make your code more readable
    (by lining up assignments, indenting, etc.). Some lazy programmers take advantage
    of this freeform formatting and create completely unreadable code—this is not
    recommended.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以利用这种灵活的格式使您的代码更易读（通过对齐赋值、缩进等）。有些懒惰的程序员利用这种自由格式创建完全不可读的代码——这是不推荐的。
- en: Comments
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: Comments give information to people who read your code, but they are ignored
    by PHP at execution time. Even if you think you’re the only person who will ever
    read your code, it’s a good idea to include comments in your code—in retrospect,
    code you wrote months ago could easily look as though a stranger wrote it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注释提供给阅读您代码的人的信息，但在 PHP 执行时会被忽略。即使您认为只有您会阅读您的代码，也最好在代码中包含注释——回顾几个月前编写的代码可能会觉得好像是陌生人写的。
- en: 'A good practice is to make your comments sparse enough not to get in the way
    of the code itself but plentiful enough that you can use the comments to tell
    what’s happening. Don’t comment obvious things, lest you bury the comments that
    describe tricky things. For example, this is worthless:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一个良好的实践是让您的注释尽量少，不要妨碍代码本身，但足够丰富，以便您可以使用注释告诉发生了什么。不要注释显而易见的事情，以免淹没描述棘手事物的注释。例如，这是毫无价值的：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'whereas the comments on this complex regular expression will help whoever maintains
    your code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 而在这个复杂的正则表达式上的注释将帮助维护代码的人：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: PHP provides several ways to include comments within your code, all of which
    are borrowed from existing languages such as C, C++, and the Unix shell. In general,
    use C-style comments to comment *out* code, and C++-style comments to comment
    *on* code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了几种在代码中包含注释的方法，所有这些方法都借鉴自现有的语言，如C、C++和Unix shell。一般来说，使用C风格的注释来注释*掉*代码，使用C++风格的注释来注释*解*代码。
- en: Shell-style comments
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shell风格的注释
- en: When PHP encounters a hash mark character (`#`) within the code, everything
    from the hash mark to the end of the line or the end of the section of PHP code
    (whichever comes first) is considered a comment. This method of commenting is
    found in Unix shell scripting languages and is useful for annotating single lines
    of code or making short notes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当PHP在代码中遇到井号字符（`#`）时，从井号到行尾或PHP代码段的末尾（以先到者为准）的所有内容都被视为注释。这种注释方法在Unix shell脚本语言中很常见，可用于注释单行代码或做简短的备注。
- en: 'Because the hash mark is visible on the page, shell-style comments are sometimes
    used to mark off blocks of code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于井号在页面上是可见的，有时会使用shell风格的注释来标记代码块：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Sometimes they’re used before a line of code to identify what that code does,
    in which case they’re usually indented to the same level as the code for which
    the comment is intended:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 有时它们用于代码行之前，以标识该代码的功能，此时它们通常缩进到与所用于目标代码相同的级别：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Short comments on a single line of code are often put on the same line as the
    code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 经常将单行代码的简短注释放在同一行上：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you’re tightly mixing HTML and PHP code, it can be useful to have the
    closing PHP tag terminate the comment:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当您紧密混合HTML和PHP代码时，让闭合的PHP标记终止注释会很有用：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: C++ comments
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C++注释
- en: When PHP encounters two slashes (`//`) within the code, everything from the
    slashes to the end of the line or the end of the section of code, whichever comes
    first, is considered a comment. This method of commenting is derived from C++.
    The result is the same as the shell comment style.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当PHP在代码中遇到两个斜杠（`//`）时，从斜杠到行尾或代码段末尾（以先到者为准），都将被视为注释。这种注释方法源于C++。其结果与shell注释样式相同。
- en: 'Here are the shell-style comment examples, rewritten to use C++ comments:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用C++注释重写的shell风格注释示例：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: C comments
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C注释
- en: While shell-style and C++-style comments are useful for annotating code or making
    short notes, longer comments require a different style. Therefore, PHP supports
    block comments whose syntax comes from the C programming language. When PHP encounters
    a slash followed by an asterisk (`/*`), everything after that, until it encounters
    an asterisk followed by a slash (`*/`), is considered a comment. This kind of
    comment, unlike those shown earlier, can span multiple lines.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然shell风格和C++风格的注释可用于注释代码或做简短的备注，但较长的注释需要不同的风格。因此，PHP支持块注释，其语法源自C编程语言。当PHP遇到斜杠后跟一个星号（`/*`）时，从那之后直到遇到一个星号后跟一个斜杠（`*/`）之前的所有内容都被视为注释。这种类型的注释与前面展示的不同，可以跨多行。
- en: 'Here’s an example of a C-style multiline comment:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这是C风格多行注释的示例：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Because C-style comments have specific start and end markers, you can tightly
    integrate them with code. This tends to make your code harder to read and is discouraged:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于C风格的注释具有特定的起始和结束标记，您可以将它们与代码紧密集成。这倾向于使您的代码更难阅读，因此不建议使用：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'C-style comments, unlike the other types, can continue past the end PHP tag
    markers. For example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型不同，C风格的注释可以延续到PHP结束标记后面。例如：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can indent comments as you like:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以根据需要缩进注释：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'C-style comments can be useful for disabling sections of code. In the following
    example, we’ve disabled the second and third statements, as well as the inline
    comment, by including them in a block comment. To enable the code, all we have
    to do is remove the comment markers:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C风格的注释可用于禁用代码的部分。在以下示例中，我们通过将它们包含在块注释中禁用了第二和第三个语句，以及内联注释。要启用代码，我们只需删除注释标记：
- en: '[PRE18]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, you have to be careful not to attempt to nest block comments:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您必须小心不要尝试嵌套块注释：
- en: '[PRE19]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, PHP tries (and fails) to execute the (non)statement `Here is some`
    `comment` `text` and returns an error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，PHP 尝试（但失败）执行（非）语句 `Here is some` `comment` `text` 并返回错误。
- en: Literals
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字面量
- en: 'A literal is a data value that appears directly in a program. The following
    are all literals in PHP:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 字面量是程序中直接出现的数据值。以下是 PHP 中的所有字面量：
- en: '[PRE20]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Identifiers
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符
- en: An identifier is simply a name. In PHP, identifiers are used to name variables,
    functions, constants, and classes. The first character of an identifier must be
    an ASCII letter (uppercase or lowercase), the underscore character (`_`), or any
    of the characters between ASCII 0x7F and ASCII 0xFF. After the initial character,
    these characters and the digits 0–9 are valid.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符简单来说就是一个名称。在 PHP 中，标识符用于命名变量、函数、常量和类。标识符的第一个字符必须是 ASCII 字母（大写或小写）、下划线字符 (`_`)
    或者在 ASCII 0x7F 到 ASCII 0xFF 之间的任何字符。初始字符之后，这些字符和数字 0–9 都是有效的。
- en: Variable names
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量名
- en: 'Variable names always begin with a dollar sign (`$`) and are case-sensitive.
    Here are some valid variable names:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 变量名总是以美元符号（`$`）开头且区分大小写。以下是一些有效的变量名：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here are some illegal variable names:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些非法的变量名：
- en: '[PRE22]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'These variables are all different due to case sensitivity:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于区分大小写，以下变量是不同的：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Function names
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数名
- en: 'Function names are not case-sensitive (functions are discussed in more detail
    in [Chapter 3](ch03.xhtml#functions)). Here are some valid function names:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名不区分大小写（函数详细讨论请参见 [第 3 章](ch03.xhtml#functions)）。以下是一些有效的函数名：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'These function names all refer to the same function:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数名均指向同一个函数：
- en: '[PRE25]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Class names
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类名
- en: 'Class names follow the standard rules for PHP identifiers and are also not
    case-sensitive. Here are some valid class names:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类名遵循 PHP 标识符的标准规则，也不区分大小写。以下是一些有效的类名：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The class name `stdClass` is a reserved class name.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 类名 `stdClass` 是保留类名。
- en: Constants
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常量
- en: 'A constant is an identifier for a value that will not be changed; scalar values
    (Boolean, integer, double, and string) and arrays can be constants. Once set,
    the value of a constant cannot change. Constants are referred to by their identifiers
    and are set using the `define()` function:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 常量是一个值的标识符，其值不会改变；标量值（布尔值、整数、浮点数和字符串）和数组可以是常量。一旦设置，常量的值就不能更改。通过 `define()` 函数设置常量：
- en: '[PRE27]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Keywords
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键字
- en: A keyword (or reserved word) is a word set aside by the language for its core
    functionality—you cannot give a function, class, or constant the same name as
    a keyword. [Table 2-1](#php_core_language_keywords) lists the keywords in PHP,
    which are case-insensitive.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字（或保留字）是语言为其核心功能保留的单词，您不能给函数、类或常量赋予与关键字相同的名称。[表 2-1](#php_core_language_keywords)
    列出了 PHP 中的关键字，这些关键字不区分大小写。
- en: Table 2-1\. PHP core language keywords
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-1\. PHP 核心语言关键字
- en: '| `__CLASS__` `__DIR__`'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '| `__CLASS__` `__DIR__`'
- en: '`__FILE__`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`__FILE__`'
- en: '`__FUNCTION__`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`__FUNCTION__`'
- en: '`__LINE__`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`__LINE__`'
- en: '`__METHOD__`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`__METHOD__`'
- en: '`__NAMESPACE__`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`__NAMESPACE__`'
- en: '`__TRAIT__`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`__TRAIT__`'
- en: '`__halt_compiler()`'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`__halt_compiler()`'
- en: '`abstract`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`abstract`'
- en: '`and`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`'
- en: '`array()`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`array()`'
- en: '`as`'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`as`'
- en: '`break`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`'
- en: '`callable`'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`callable`'
- en: '`case`'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`'
- en: '`catch`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`catch`'
- en: '`class`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`'
- en: '`clone`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`clone`'
- en: '`const`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`const`'
- en: '`continue`'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`'
- en: '`declare`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare`'
- en: '`default`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`default`'
- en: '`die()`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`die()`'
- en: '`do` | `echo` `else`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`do` | `echo` `else`'
- en: '`elseif`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`elseif`'
- en: '`empty()`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`empty()`'
- en: '`enddeclare`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`enddeclare`'
- en: '`endfor`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`endfor`'
- en: '`endforeach`'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`endforeach`'
- en: '`endif`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`endif`'
- en: '`endswitch`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`endswitch`'
- en: '`endwhile`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`endwhile`'
- en: '`eval()`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`eval()`'
- en: '`exit()`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit()`'
- en: '`extends`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`extends`'
- en: '`final`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`'
- en: '`finally`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally`'
- en: '`for`'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`'
- en: '`foreach`'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`'
- en: '`function`'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`function`'
- en: '`global`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`global`'
- en: '`goto`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto`'
- en: '`if`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`'
- en: '`implements`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`implements`'
- en: '`include`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`include`'
- en: '`include_once`'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`include_once`'
- en: '`instanceof` | `insteadof` `interface`'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` | `insteadof` `interface`'
- en: '`isset()`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`isset()`'
- en: '`list()`'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`'
- en: '`namespace`'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`namespace`'
- en: '`new`'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`'
- en: '`or`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`or`'
- en: '`print`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`print`'
- en: '`private`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`private`'
- en: '`protected`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`protected`'
- en: '`public`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`'
- en: '`require`'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`require`'
- en: '`require_once`'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`require_once`'
- en: '`return`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`return`'
- en: '`static`'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`'
- en: '`switch`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`'
- en: '`throw`'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw`'
- en: '`trait`'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`trait`'
- en: '`try`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`'
- en: '`unset()`'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`unset()`'
- en: '`use`'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`use`'
- en: '`var`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`var`'
- en: '`while`'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`'
- en: '`xor`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`xor`'
- en: '`yield`'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield`'
- en: '`yield from` |'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield from` |'
- en: In addition, you cannot use an identifier that is the same as a built-in PHP
    function. For a complete list of these, see the [Appendix](app01.xhtml#function_reference).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您不能使用与内置 PHP 函数同名的标识符。完整列表请参见 [附录](app01.xhtml#function_reference)。
- en: Data Types
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: 'PHP provides eight types of values, or data types. Four are scalar (single-value)
    types: integers, floating-point numbers, strings, and Booleans. Two are compound
    (collection) types: arrays and objects. The remaining two are special types: resource
    and NULL. Numbers, Booleans, resources, and NULL are discussed in full here, while
    strings, arrays, and objects are big enough topics that they get their own chapters
    (Chapters [4](ch04.xhtml#strings), [5](ch05.xhtml#array), and [6](ch06.xhtml#objects-id00032),
    respectively).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供八种值或数据类型。其中四种是标量（单值）类型：整数、浮点数、字符串和布尔值。两种是复合（集合）类型：数组和对象。剩下的两种是特殊类型：资源和
    NULL。数字、布尔值、资源和 NULL 在此详细讨论，而字符串、数组和对象是如此庞大的主题，它们有自己的章节（第 [4](ch04.xhtml#strings)、[5](ch05.xhtml#array)
    和 [6](ch06.xhtml#objects-id00032) 章）。
- en: Integers
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: Integers are whole numbers, such as 1, 12, and 256\. The range of acceptable
    values varies according to the details of your platform but typically extends
    from −2,147,483,648 to +2,147,483,647\. Specifically, the range is equivalent
    to the range of the long data type of your C compiler. Unfortunately, the C standard
    doesn’t specify what range that long type should have, so on some systems you
    might see a different integer range.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 整数是整数，如 1、12 和 256。可接受值的范围根据您平台的详细信息而异，但通常从 −2,147,483,648 到 +2,147,483,647。具体来说，范围相当于您的
    C 编译器的长整型数据类型的范围。不幸的是，C 标准没有指定长整型应具有的范围，因此在某些系统上，整数范围可能会有所不同。
- en: 'Integer literals can be written in decimal, octal, binary, or hexadecimal.
    Decimal values are represented by a sequence of digits, without leading zeros.
    The sequence may begin with a plus (`+`) or minus (`−`) sign. If there is no sign,
    positive is assumed. Examples of decimal integers include the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 整数字面量可以用十进制、八进制、二进制或十六进制表示。十进制值由一系列数字组成，没有前导零。序列可以以加号（`+`）或减号（`−`）开头。如果没有符号，则假定为正数。十进制整数的示例包括以下内容：
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Octal numbers consist of a leading `0` and a sequence of digits from 0 to 7\.
    Like decimal numbers, octal numbers can be prefixed with a plus or minus. Here
    are some example octal values and their equivalent decimal values:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 八进制数由前导 `0` 和由 0 到 7 的一系列数字组成。与十进制数类似，八进制数可以以加号或减号为前缀。以下是一些八进制值及其相应的十进制值示例：
- en: '[PRE29]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Hexadecimal values begin with `0x`, followed by a sequence of digits (0–9)
    or letters (A–F). The letters can be upper- or lowercase but are usually written
    in capitals. As with decimal and octal values, you can include a sign in hexadecimal
    numbers:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制值以 `0x` 开头，后跟一系列数字（0–9）或字母（A–F）。字母可以是大写或小写，但通常用大写字母表示。与十进制和八进制值一样，十六进制数可以包含符号：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Binary numbers begin with `0b`, followed by a sequence of digits (0 and 1).
    As with other values, you can include a sign in binary numbers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数以 `0b` 开头，后跟一系列数字（0 和 1）。与其他值一样，二进制数可以包含符号：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you try to store a variable that is too large to be stored as an integer
    or is not a whole number, it will automatically be turned into a floating-point
    number.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您试图存储一个太大无法存储为整数或不是整数的变量，它将自动转换为浮点数。
- en: 'Use the `is_int()` function (or its `is_integer()` alias) to test whether a
    value is an integer:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `is_int()` 函数（或其 `is_integer()` 别名）来测试一个值是否为整数：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Floating-Point Numbers
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浮点数
- en: Floating-point numbers (often referred to as “real” numbers) represent numeric
    values with decimal digits. Like integers, their limits depend on your machine’s
    details. PHP floating-point numbers are equivalent to the range of the double
    data type of your C compiler. Usually, this allows numbers between 1.7E−308 and
    1.7E+308 with 15 digits of accuracy. If you need more accuracy or a wider range
    of integer values, you can use the BC or GMP extensions.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数（通常称为“实数”）用十进制数字表示数值。与整数类似，其限制取决于您计算机的详细信息。PHP 浮点数相当于您的 C 编译器的双精度数据类型的范围。通常，这允许在
    1.7E−308 到 1.7E+308 之间的数值，具有 15 位精度。如果您需要更高的精度或更广范围的整数值，可以使用 BC 或 GMP 扩展。
- en: 'PHP recognizes floating-point numbers written in two different formats. There’s
    the one we all use every day:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 可识别两种不同格式的浮点数。有一种是我们日常使用的：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'But PHP also recognizes numbers in scientific notation:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 PHP 也能识别科学计数法表示的数字：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Floating-point values are only approximate representations of numbers. For
    example, on many systems 3.5 is actually represented as 3.4999999999\. This means
    you must take care to avoid writing code that assumes floating-point numbers are
    represented completely accurately, such as directly comparing two floating-point
    values using `==`. The normal approach is to compare to several decimal places:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数值只是数字的近似表示。例如，在许多系统上，3.5实际上表示为3.4999999999\. 这意味着您必须小心避免编写假定浮点数完全准确表示的代码，例如直接使用`==`比较两个浮点数值。通常的方法是比较几个小数位数：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Use the `is_float()` function (or its `is_real()` alias) to test whether a
    value is a floating-point number:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is_float()`函数（或其`is_real()`别名）来测试一个值是否为浮点数：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Strings
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Because strings are so common in web applications, PHP includes core-level
    support for creating and manipulating strings. A string is a sequence of characters
    of arbitrary length. String literals are delimited by either single or double
    quotes:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串在Web应用程序中非常常见，PHP包含了在核心级别支持创建和操作字符串的功能。字符串是任意长度的字符序列。字符串字面量由单引号或双引号括起来：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Variables are expanded (interpolated) within double quotes, while within single
    quotes they are not:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在双引号内扩展（插值），而在单引号内不会：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Double quotes also support a variety of string escapes, as listed in [Table 2-2](#escape_sequences_in_double_quoted_stri).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号还支持多种字符串转义，如[表2-2](#escape_sequences_in_double_quoted_stri)中列出的：
- en: Table 2-2\. Escape sequences in double-quoted strings
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2\. 双引号字符串中的转义序列
- en: '| Escape sequence | Character represented |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 表示的字符 |'
- en: '| --- | --- |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\"` | Double quotes |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 |'
- en: '| `\n` | Newline |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 |'
- en: '| `\r` | Carriage return |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符 |'
- en: '| `\t` | Tab |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 |'
- en: '| `\\` | Backslash |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 |'
- en: '| `\$` | Dollar sign |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `\$` | 美元符号 |'
- en: '| `\{` | Left brace |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `\{` | 左大括号 |'
- en: '| `\}` | Right brace |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `\}` | 右大括号 |'
- en: '| `\[` | Left bracket |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `\[` | 左括号 |'
- en: '| `\]` | Right bracket |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `\]` | 右括号 |'
- en: '| `\0` through `\777` | ASCII character represented by octal value |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `\0` 到 `\777` | 由八进制值表示的ASCII字符 |'
- en: '| `\x0` through `\xFF` | ASCII character represented by hex value |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `\x0` 到 `\xFF` | 由十六进制值表示的ASCII字符 |'
- en: 'A single-quoted string recognizes `\\` to get a literal backslash and `\''`
    to get a literal single quote:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号字符串识别`\\`以获取文字反斜杠和`\'`以获取文字单引号：
- en: '[PRE39]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To test whether two strings are equal, use the `==` (double equals) comparison
    operator:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试两个字符串是否相等，请使用`==`（双等号）比较运算符：
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Use the `is_string()` function to test whether a value is a string:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is_string()`函数来测试一个值是否为字符串：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: PHP provides operators and functions to compare, disassemble, assemble, search,
    replace, and trim strings, as well as a host of specialized string functions for
    working with HTTP, HTML, and SQL encodings. Because there are so many string-manipulation
    functions, we’ve devoted a whole chapter ([Chapter 4](ch04.xhtml#strings)) to
    covering all the details.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了运算符和函数来比较、拆解、组装、搜索、替换和修剪字符串，以及一系列专门用于处理HTTP、HTML和SQL编码的字符串函数。由于有许多字符串操作函数，我们已经专门撰写了一个完整的章节（[第4章](ch04.xhtml#strings)）来详细介绍所有细节。
- en: Booleans
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔值
- en: 'A Boolean value represents a *truth value*—it says whether something is true
    or not. Like most programming languages, PHP defines some values as true and others
    as false. Truthfulness and falseness determine the outcome of conditional code
    such as:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值表示一个*真值*——它表示某事是真的还是不真的。像大多数编程语言一样，PHP定义了一些值为真，其他为假。真实性和虚假性决定了条件代码的结果，如：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In PHP, the following values all evaluate to `false`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，以下值都被评估为`false`：
- en: The keyword `false`
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字`false`
- en: The integer `0`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数`0`
- en: The floating-point value `0.0`
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点值`0.0`
- en: The empty string (`""`) and the string `"0"`
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空字符串（`""`）和字符串`"0"`
- en: An array with zero elements
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零元素的数组
- en: The `NULL` value
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值`NULL`
- en: A value that is not false is true, including all resource values (which are
    described later in the section “Resources”).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不为假的值就是真，包括所有资源值（稍后在“资源”部分描述）。
- en: 'PHP provides `true` and `false` keywords for clarity:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了`true`和`false`关键字以确保清晰：
- en: '[PRE43]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Use the `is_bool()` function to test whether a value is a Boolean:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is_bool()`函数来测试一个值是否为布尔值：
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Arrays
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array holds a group of values, which you can identify by position (a number,
    with zero being the first position) or some identifying name (a string), called
    an *associative index*:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 数组保存一组值，可以通过位置（数字，零为第一个位置）或某些标识名称（字符串），称为*关联索引*来标识：
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `array()` construct creates an array. Here are two examples:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`array()`结构创建一个数组。以下是两个例子：'
- en: '[PRE46]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'There are several ways to loop through arrays, but the most common is a `foreach`
    loop:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以遍历数组，但最常见的是`foreach`循环：
- en: '[PRE47]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can sort the elements of an array with the various sort functions:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用不同的排序函数对数组元素进行排序：
- en: '[PRE48]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Use the `is_array()` function to test whether a value is an array:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is_array()`函数来测试一个值是否为数组：
- en: '[PRE49]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: There are functions for returning the number of items in the array, fetching
    every value in the array, and much more. Arrays are covered in depth in [Chapter 5](ch05.xhtml#array).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 有返回数组中项数的函数、获取数组中每个值的函数等。数组在[第 5 章](ch05.xhtml#array)中有详细介绍。
- en: Objects
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: 'PHP also supports *object-oriented programming* (OOP). OOP promotes clean,
    modular design; simplifies debugging and maintenance; and assists with code reuse.
    Classes are the building blocks of object-oriented design. A class is a definition
    of a structure that contains properties (variables) and methods (functions). Classes
    are defined with the `class` keyword:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 也支持*面向对象编程*（OOP）。OOP 促进了清晰的模块化设计；简化了调试和维护；并有助于代码重用。类是面向对象设计的构建块。类是一个包含属性（变量）和方法（函数）定义的结构。类用`class`关键字定义：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once a class is defined, any number of objects can be made from it with the
    `new` keyword, and the object’s properties and methods can be accessed with the
    `->` construct:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类被定义，可以用`new`关键字从中创建任意数量的对象，并且可以通过`->`构造访问对象的属性和方法：
- en: '[PRE51]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use the `is_object()` function to test whether a value is an object:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is_object()`函数来测试一个值是否为对象：
- en: '[PRE52]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[Chapter 6](ch06.xhtml#objects-id00032) describes classes and objects in much
    more detail, including inheritance, encapsulation, and introspection.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6 章](ch06.xhtml#objects-id00032)详细描述了类和对象，包括继承、封装和内省。'
- en: Resources
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源
- en: 'Many modules provide several functions for dealing with the outside world.
    For example, every database extension has at least a function to connect to the
    database, a function to query the database, and a function to close the connection
    to the database. Because you can have multiple database connections open at once,
    the connect function gives you something by which to identify that unique connection
    when you call the query and close functions: a resource (or a *handle*).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 许多模块提供多个处理外部世界的函数。例如，每个数据库扩展至少有一个连接数据库的函数、一个查询数据库的函数和一个关闭数据库连接的函数。因为你可以同时打开多个数据库连接，连接函数在你调用查询和关闭函数时提供了一个用于标识唯一连接的东西：一个资源（或一个*句柄*）。
- en: 'Each active resource has a unique identifier. Each identifier is a numerical
    index into an internal PHP lookup table that holds information about all the active
    resources. PHP maintains information about each resource in this table, including
    the number of references to (or uses of) the resource throughout the code. When
    the last reference to a resource value goes away, the extension that created the
    resource is called to perform tasks such as freeing any memory or closing any
    connection for that resource:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动资源都有一个唯一的标识符。每个标识符都是一个数值索引，指向内部 PHP 查找表中所有活动资源的信息。PHP 在这个表中维护关于每个资源的信息，包括代码中对该资源的引用次数。当对资源值的最后一个引用消失时，调用创建资源的扩展来执行释放内存或关闭连接等任务：
- en: '[PRE53]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The benefit of this automatic cleanup is best seen within functions, when the
    resource is assigned to a local variable. When the function ends, the variable’s
    value is reclaimed by PHP:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自动清理的好处在于函数内部最为明显，当资源被分配给一个局部变量时。当函数结束时，变量的值会被 PHP 回收：
- en: '[PRE54]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When there are no more references to the resource, it’s automatically shut down.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当不再有指向资源的引用时，它会自动关闭。
- en: That said, most extensions provide a specific shutdown or close function, and
    it’s considered good style to call that function explicitly when needed rather
    than to rely on variable scoping to trigger resource cleanup.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，大多数扩展提供了特定的关闭或清理函数，明确调用该函数被认为是良好的风格，而不是依赖变量作用域触发资源清理。
- en: 'Use the `is_resource()` function to test whether a value is a resource:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is_resource()`函数来测试一个值是否为资源：
- en: '[PRE55]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Callbacks
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回调
- en: 'Callbacks are functions or object methods used by some functions, such as `call_user_func()`.
    Callbacks can also be created by the `create_function()` method and through closures
    (described in [Chapter 3](ch03.xhtml#functions)):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 回调是一些函数或对象方法，由某些函数（如`call_user_func()`）使用。回调也可以通过`create_function()`方法和闭包（在[第3章](ch03.xhtml#functions)中描述）创建：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'NULL'
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'NULL'
- en: 'There’s only one value of the NULL data type. That value is available through
    the case-insensitive keyword `NULL`. The `NULL` value represents a variable that
    has no value (similar to Perl’s `undef` or Python’s `None`):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: NULL数据类型只有一个值。通过大小写不敏感的关键字`NULL`可以访问这个值。`NULL`值表示一个没有值的变量（类似于Perl的`undef`或Python的`None`）：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Use the `is_null()` function to test whether a value is `NULL`—for instance,
    to see whether a variable has a value:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`is_null()`函数来测试一个值是否为`NULL`，例如检查一个变量是否有值：
- en: '[PRE58]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Variables
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量
- en: 'Variables in PHP are identifiers prefixed with a dollar sign (`$`). For example:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中的变量是以美元符号（`$`）为前缀的标识符。例如：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'A variable may hold a value of any type. There is no compile-time or runtime
    type checking on variables. You can replace a variable’s value with another of
    a different type:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以保存任何类型的值。在变量上没有编译时或运行时类型检查。可以用不同类型的值替换变量的值：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There is no explicit syntax for declaring variables in PHP. The first time
    the value of a variable is set, the variable is created in memory. In other words,
    setting a value to a variable also functions as a declaration. For example, this
    is a valid complete PHP program:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中没有明确的语法用于声明变量。第一次设置变量的值时，变量就会在内存中创建。换句话说，给变量赋值也是声明变量的方式。例如，这是一个有效的完整PHP程序：
- en: '[PRE61]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'A variable whose value has not been set behaves like the `NULL` value:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量的值尚未设置，则变量的行为类似于`NULL`值：
- en: '[PRE62]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Variable Variables
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量变量
- en: 'You can reference the value of a variable whose name is stored in another variable
    by prefacing the variable reference with an additional dollar sign (`$`). For
    example:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在变量引用前面加一个额外的美元符号（`$`）来引用存储在另一个变量中的变量的值。例如：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: After the second statement executes, the variable `$bar` has the value `"baz"`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条语句执行后，变量`$bar`的值为`"baz"`。
- en: Variable References
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量引用
- en: 'In PHP, references are how you create variable aliases or pointers. To make
    `$black` an alias for the variable `$white`, use:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，引用是创建变量别名或指针的方式。要将`$black`设为变量`$white`的别名，请使用：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The old value of `$black`, if any, is lost. Instead, `$black` is now another
    name for the value that is stored in `$white`:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`$black`的旧值（如果有）会丢失。现在，`$black`是存储在`$white`中的值的另一个名称：'
- en: '[PRE65]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After the assignment, the two variables are alternate names for the same value.
    Unsetting a variable that is aliased does not affect other names for that variable’s
    value, however:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值后，两个变量是同一个值的替代名称。对别名变量取消设置不会影响该变量值的其他名称：
- en: '[PRE66]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Functions can return values by reference (for example, to avoid copying large
    strings or arrays, as discussed in [Chapter 3](ch03.xhtml#functions)):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以通过引用返回值（例如，避免复制大字符串或数组，如[第3章](ch03.xhtml#functions)中所述）：
- en: '[PRE67]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Variable Scope
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域
- en: 'The *scope* of a variable, which is controlled by the location of the variable’s
    declaration, determines those parts of the program that can access it. There are
    four types of variable scope in PHP: local, global, static, and function parameters.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的*作用域*由变量声明的位置控制，决定程序中可以访问它的部分。在PHP中，变量的作用域有四种类型：局部、全局、静态和函数参数。
- en: Local scope
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部作用域
- en: 'A variable declared in a function is local to that function. That is, it is
    visible only to code in that function (excepting nested function definitions);
    it is not accessible outside the function. In addition, by default, variables
    defined outside a function (called *global* variables) are not accessible inside
    the function. For example, here’s a function that updates a local variable instead
    of a global variable:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数中声明的变量只在该函数内部可见。也就是说，它只能被函数内的代码访问（除了嵌套函数定义）；它不能在函数外部访问。此外，默认情况下，在函数外部定义的变量（称为*全局*变量）在函数内部不可访问。例如，下面是一个更新局部变量而不是全局变量的函数示例：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `$counter` inside the function is local to that function because we haven’t
    said otherwise. The function increments its private `$counter` variable, which
    is destroyed when the subroutine ends. The global `$counter` remains set at 10.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 函数内部的`$counter`是局部变量，因为我们没有明确指定。函数递增其私有的`$counter`变量，在子程序结束时销毁。全局的`$counter`保持为10。
- en: Only functions can provide local scope. Unlike in other languages, in PHP you
    can’t create a variable whose scope is a loop, conditional branch, or other type
    of block.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 只有函数能提供局部作用域。与其他语言不同，在PHP中，你不能创建其作用域为循环、条件分支或其他类型块的变量。
- en: Global scope
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域
- en: 'Variables declared outside a function are global. That is, they can be accessed
    from any part of the program. However, by default, they are not available inside
    functions. To allow a function to access a global variable, you can use the `global`
    keyword inside the function to declare the variable within the function. Here’s
    how we can rewrite the `updateCounter()` function to allow it to access the global
    `$counter` variable:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数外声明的变量是全局的。也就是说，它们可以从程序的任何部分访问。但是，默认情况下，它们在函数内部不可用。为了允许函数访问全局变量，你可以在函数内部使用
    `global` 关键字来声明函数内部的变量。下面是我们如何重写 `updateCounter()` 函数，以允许它访问全局 `$counter` 变量的示例：
- en: '[PRE69]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'A more cumbersome way to update the global variable is to use PHP’s `$GLOBALS`
    array instead of accessing the variable directly:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 更新全局变量的一种更麻烦的方法是使用PHP的 `$GLOBALS` 数组，而不是直接访问变量：
- en: '[PRE70]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Static variables
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态变量
- en: 'A static variable retains its value between calls to a function but is visible
    only within that function. You declare a variable static with the `static` keyword.
    For example:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量在函数调用之间保持其值，但仅在该函数内部可见。你可以使用 `static` 关键字声明变量为静态变量。例如：
- en: '[PRE71]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Function parameters
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'As we’ll discuss in more detail in [Chapter 3](ch03.xhtml#functions), a function
    definition can have named parameters:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第三章](ch03.xhtml#functions)中详细讨论的那样，函数定义可以有命名参数：
- en: '[PRE72]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Function parameters are local, meaning that they are available only inside their
    functions. In this case, `$name` is inaccessible from outside `greet()`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 函数参数是局部的，意味着它们仅在其函数内部可用。在这种情况下，`$name` 无法从 `greet()` 外部访问。
- en: Garbage Collection
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: PHP uses *reference counting* and *copy-on-write* to manage memory. Copy-on-write
    ensures that memory isn’t wasted when you copy values between variables, and reference
    counting ensures that memory is returned to the operating system when it is no
    longer needed.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: PHP使用*引用计数*和*写时复制*来管理内存。写时复制确保在变量之间复制值时不会浪费内存，并且引用计数确保在不再需要内存时将内存返回给操作系统。
- en: To understand memory management in PHP, you must first understand the idea of
    a *symbol table*. There are two parts to a variable—its name (e.g., `$name`),
    and its value (e.g., `"Fred"`). A symbol table is an array that maps variable
    names to the positions of their values in memory.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解PHP中的内存管理，你必须首先理解*符号表*的概念。变量有两部分组成——它的名称（例如 `$name`）和它的值（例如 `"Fred"`）。符号表是一个数组，将变量名映射到它们值在内存中位置的数组。
- en: 'When you copy a value from one variable to another, PHP doesn’t get more memory
    for a copy of the value. Instead, it updates the symbol table to indicate that
    “both of these variables are names for the same chunk of memory.” So the following
    code doesn’t actually create a new array:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将一个值从一个变量复制到另一个变量时，PHP不会为该值创建一个新的内存空间。相反，它会更新符号表，指示“这两个变量都是指向同一块内存的名称”。所以下面的代码实际上并不创建一个新的数组：
- en: '[PRE73]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If you subsequently modify either copy, PHP allocates the required memory and
    makes the copy:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果随后修改任一副本，PHP会分配所需的内存并进行复制：
- en: '[PRE74]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: By delaying the allocation and copying, PHP saves time and memory in a lot of
    situations. This is copy-on-write.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通过延迟分配和复制，PHP在许多情况下节省时间和内存。这就是写时复制。
- en: 'Each value pointed to by a symbol table has a *reference count*, a number that
    represents the number of ways there are to get to that piece of memory. After
    the initial assignment of the array to `$worker` and `$worker` to `$other`, the
    array pointed to by the symbol table entries for `$worker` and `$other` has a
    reference count of 2.^([1](ch02.xhtml#ch02fn1)) In other words, that memory can
    be reached two ways: through `$worker` or `$other`. But after `$worker[1]` is
    changed, PHP creates a new array for `$worker`, and the reference count of each
    array is only 1.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 符号表指向的每个值都有一个*引用计数*，这个数字表示到达该内存块的方式数量。在将数组分配给 `$worker` 和将 `$worker` 分配给 `$other`
    后，符号表条目所指向的数组的引用计数为2。^([1](ch02.xhtml#ch02fn1)) 换句话说，这块内存可以通过 `$worker` 或 `$other`
    两种方式访问。但是在修改 `$worker[1]` 后，PHP会为 `$worker` 创建一个新的数组，并且每个数组的引用计数仅为1。
- en: When a variable goes out of scope at the end of a function, such as function
    parameters and local variables, the reference count of its value is decreased
    by one. When a variable is assigned a value in a different area of memory, the
    reference count of the old value is decreased by one. When the reference count
    of a value reaches 0, its memory is released. This is reference counting.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量在函数结束时超出范围时，如函数参数和局部变量，其值的引用计数将减少一次。当变量在内存的不同区域被赋予一个新值时，旧值的引用计数将减少一次。当值的引用计数达到0时，其内存将被释放。这就是引用计数。
- en: Reference counting is the preferred way to manage memory. Keep variables local
    to functions, pass in values that the functions need to work on, and let reference
    counting take care of the memory management. If you do insist on trying to get
    a little more information or control over freeing a variable’s value, use the
    `isset()` and `unset()` functions.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 引用计数是管理内存的首选方法。保持变量局限于函数内部，传递函数需要处理的值，并让引用计数处理内存管理。如果您坚持想要获取有关释放变量值的更多信息或控制，请使用
    `isset()` 和 `unset()` 函数。
- en: 'To see if a variable has been set to something—even the empty string—use `isset()`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 若要查看变量是否设置为某些内容（甚至是空字符串），请使用 `isset()`：
- en: '[PRE75]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Use `unset()` to remove a variable’s value:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `unset()` 来移除变量的值：
- en: '[PRE76]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Expressions and Operators
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式和操作符
- en: An *expression* is a bit of PHP code that can be evaluated to produce a value.
    The simplest expressions are literal values and variables. A literal value evaluates
    to itself, while a variable evaluates to the value stored in the variable. More
    complex expressions can be formed using simple expressions and operators.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '*表达式* 是一段PHP代码，可以求值为一个值。最简单的表达式是文字值和变量。文字值求值为它自身，而变量求值为存储在变量中的值。更复杂的表达式可以使用简单表达式和操作符组成。'
- en: An *operator* takes some values (the operands) and does something (e.g., adds
    them together). Operators are sometimes written as punctuation symbols—for instance,
    the `+` and `–` familiar to us from math. Some operators modify their operands,
    while most do not.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '*操作符* 接受一些值（操作数）并执行某些操作（例如，将它们加在一起）。操作符有时用标点符号表示，例如我们在数学中熟悉的 `+` 和 `-` 。某些操作符会修改它们的操作数，而大多数则不会。'
- en: '[Table 2-3](#php_operators) summarizes the operators in PHP, many of which
    were borrowed from C and Perl. The column labeled “P” gives the operator’s precedence;
    the operators are listed in precedence order, from highest to lowest. The column
    labeled “A” gives the operator’s associativity, which can be L (left-to-right),
    R (right-to-left), or N (nonassociative).'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[表格 2-3](#php_operators) 总结了PHP中的操作符，其中许多操作符来自C和Perl。标有“P”的列显示了操作符的优先级；操作符按照从高到低的优先级顺序列出。标有“A”的列显示了操作符的结合性，可以是L（从左到右）、R（从右到左）或N（非结合性）。'
- en: Table 2-3\. PHP operators
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 2-3\. PHP 操作符
- en: '| P | A | Operator | Operation |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| P | A | 操作符 | 操作 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| 24 | N | `clone`, `new` | Create new object |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| 24 | N | `clone`, `new` | 创建新对象 |'
- en: '| 23 | L | `[` | Array subscript |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| 23 | L | `[` | 数组下标 |'
- en: '| 22 | R | `**` | Exponentiation |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| 22 | R | `**` | 指数运算 |'
- en: '| 21 | R | `~` | Bitwise NOT |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 21 | R | `~` | 按位非 |'
- en: '|   | R | `++` | Increment |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|   | R | `++` | 自增 |'
- en: '|   | R | `−−` | Decrement |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '|   | R | `−−` | 自减 |'
- en: '|   | R | `(int)`, `(bool)`, `(float)`, `(string)`, `(array)`, `(object)`,
    `(unset)` | Cast |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|   | R | `(int)`, `(bool)`, `(float)`, `(string)`, `(array)`, `(object)`,
    `(unset)` | 强制类型转换 |'
- en: '|   | R | `@` | Inhibit errors |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|   | R | `@` | 抑制错误 |'
- en: '| 20 | N | `instanceof` | Type testing |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 20 | N | `instanceof` | 类型检测 |'
- en: '| 19 | R | `!` | Logical NOT |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 19 | R | `!` | 逻辑非 |'
- en: '| 18 | L | `*` | Multiplication |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 18 | L | `*` | 乘法 |'
- en: '|   | L | `/` | Division |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|   | L | `/` | 除法 |'
- en: '|   | L | `%` | Modulus |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '|   | L | `%` | 取模 |'
- en: '| 17 | L | `+` | Addition |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 17 | L | `+` | 加法 |'
- en: '|   | L | `−` | Subtraction |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|   | L | `−` | 减法 |'
- en: '|   | L | `.` | String concatenation |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '|   | L | `.` | 字符串连接 |'
- en: '| 16 | L | `<<` | Bitwise shift left |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 16 | L | `<<` | 左移 |'
- en: '|   | L | `>>` | Bitwise shift right |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|   | L | `>>` | 右移 |'
- en: '| 15 | N | `<`, `<=` | Less than, less than or equal |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| 15 | N | `<`, `<=` | 小于，小于等于 |'
- en: '|   | N | `>`, `>=` | Greater than, greater than or equal |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|   | N | `>`, `>=` | 大于，大于等于 |'
- en: '| 14 | N | `==` | Value equality |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| 14 | N | `==` | 值相等 |'
- en: '|   | N | `!=`, `<>` | Inequality |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|   | N | `!=`, `<>` | 不等于 |'
- en: '|   | N | `===` | Type and value equality |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|   | N | `===` | 类型和值相等 |'
- en: '|   | N | `!==` | Type and value inequality |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|   | N | `!==` | 类型和值不等 |'
- en: '|   | N | `<=>` | Returns an integer based on a comparison of two operands:
    `0` when left and right are equal, `–1` when left is less than right, and `1`
    when left is greater than right. |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|   | N | `<=>` | 基于两个操作数的比较返回一个整数：当左右相等时为 `0`，当左小于右时为 `-1`，当左大于右时为 `1`。|'
- en: '| 13 | L | `&` | Bitwise AND |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| 13 | L | `&` | 按位与 |'
- en: '| 12 | L | `^` | Bitwise XOR |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| 12 | L | `^` | 按位异或 |'
- en: '| 11 | L | `&#124;` | Bitwise OR |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| 11 | L | `&#124;` | 按位或 |'
- en: '| 10 | L | `&&` | Logical AND |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 10 | L | `&&` | 逻辑与 |'
- en: '| 9 | L | `&#124;&#124;` | Logical OR |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 9 | L | `&#124;&#124;` | 逻辑或 |'
- en: '| 8 | R | `??` | Comparison |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 8 | R | `??` | 比较 |'
- en: '| 7 | L | `?:` | Conditional operator |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 7 | L | `?:` | 条件运算符 |'
- en: '| 6 | R | `=` | Assignment |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 6 | R | `=` | 赋值 |'
- en: '|   | R | `+=`, `−=`, `*=`, `/=`, `.=`, `%=`, `&=`, `&#124;=`, `^=`, `~=`,
    `<<=`, `>>=` | Assignment with operation |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|   | R | `+=`, `−=`, `*=`, `/=`, `.=`, `%=`, `&=`, `&#124;=`, `^=`, `~=`,
    `<<=`, `>>=` | 带操作的赋值 |'
- en: '| 5 |   | `yield from` | Yield from |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 5 |   | `yield from` | 从产出 |'
- en: '| 4 |   | `yield` | Yield |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 4 |   | `yield` | 产出 |'
- en: '| 3 | L | `and` | Logical AND |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 3 | L | `and` | 逻辑与 |'
- en: '| 2 | L | `xor` | Logical XOR |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 2 | L | `xor` | 逻辑异或 |'
- en: '| 1 | L | `or` | Logical OR |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| 1 | L | `or` | 逻辑或 |'
- en: Number of Operands
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作数的数量
- en: Most operators in PHP are binary operators; they combine two operands (or expressions)
    into a single, more complex expression. PHP also supports a number of unary operators,
    which convert a single expression into a more complex expression. Finally, PHP
    supports a few ternary operators that combine numerous expressions into a single
    expression.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 PHP 中的操作符是二元操作符；它们将两个操作数（或表达式）组合成一个更复杂的表达式。PHP 也支持几个一元操作符，将单个表达式转换为更复杂的表达式。最后，PHP
    支持一些三元操作符，将多个表达式组合成单个表达式。
- en: Operator Precedence
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符优先级
- en: 'The order in which operators in an expression are evaluated depends on their
    relative precedence. For example, you might write:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式中操作符的求值顺序取决于它们的相对优先级。例如，您可能会写：
- en: '[PRE77]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: As you can see in [Table 2-3](#php_operators), the addition and multiplication
    operators have different precedence, with multiplication higher than addition.
    So the multiplication happens before the addition, giving `2 + 12`, or `14`, as
    the answer. If the precedence of addition and multiplication were reversed, `6
    * 3`, or `18`, would be the answer.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[表 2-3](#php_operators)中所见，加法和乘法运算符具有不同的优先级，其中乘法高于加法。因此，乘法先于加法运算，得出 `2 +
    12`，即 `14`。如果加法和乘法的优先级被反转，`6 * 3`，即 `18`，将成为答案。
- en: 'To force a particular order, you can group operands with the appropriate operator
    in parentheses. In our previous example, to get the value `18`, you can use this
    expression:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要强制执行特定顺序，可以使用括号将操作数分组。在我们之前的例子中，要获取值 `18`，可以使用以下表达式：
- en: '[PRE78]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'It is possible to write all complex expressions (expressions containing more
    than a single operator) simply by putting the operands and operators in the appropriate
    order so that their relative precedence yields the answer you want. Most programmers,
    however, write the operators in the order that they feel makes the most sense
    to them, and add parentheses to ensure it makes sense to PHP as well. Getting
    precedence wrong leads to code like:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将操作数和操作符按照正确的顺序放置，使它们的相对优先级产生您想要的答案，来编写所有复杂的表达式（包含多个操作符的表达式）。然而，大多数程序员按照他们认为最合理的顺序编写操作符，并添加括号以确保
    PHP 也能理解。如果优先级弄错了，会导致类似于以下的代码：
- en: '[PRE79]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: This code is hard to read and is almost definitely not doing what the programmer
    expected it to do.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很难阅读，几乎肯定不会达到程序员的预期。
- en: 'One way many programmers deal with the complex precedence rules in programming
    languages is to reduce precedence down to two rules:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序员处理编程语言中复杂的优先级规则的一种方式是将优先级简化为两个规则：
- en: Multiplication and division have higher precedence than addition and subtraction.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乘法和除法的优先级高于加法和减法。
- en: Use parentheses for anything else.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他情况，请使用括号。
- en: Operator Associativity
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符的结合性
- en: 'Associativity defines the order in which operators with the same order of precedence
    are evaluated. For example, look at:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 结合性定义了在具有相同优先级顺序的操作符中的求值顺序。例如，看一下：
- en: '[PRE80]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The division and multiplication operators have the same precedence, but the
    result of the expression depends on which operation we do first:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 除法和乘法运算符具有相同的优先级，但表达式的结果取决于我们首先执行哪个操作：
- en: '[PRE81]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The division and multiplication operators are *left-associative*; this means
    that in cases of ambiguity, the operators are evaluated from left to right. In
    this example, the correct result is 2.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 除法和乘法运算符是*左结合*的；这意味着在有歧义的情况下，运算符从左到右进行计算。在这个例子中，正确的结果是 2。
- en: Implicit Casting
  id: totrans-387
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式类型转换
- en: Many operators have expectations of their operands—for instance, binary math
    operators typically require both operands to be of the same type. PHP’s variables
    can store integers, floating-point numbers, strings, and more, and to keep as
    much of the type details away from the programmer as possible, PHP converts values
    from one type to another as necessary.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 许多运算符对其操作数有特定的要求，例如，二进制数学运算符通常要求两个操作数是相同的类型。PHP 的变量可以存储整数、浮点数、字符串等，为了尽可能地将类型细节远离程序员，PHP
    会根据需要将值从一种类型转换为另一种类型。
- en: The conversion of a value from one type to another is called *casting*. This
    kind of implicit casting is called *type juggling* in PHP. The rules for the type
    juggling done by arithmetic operators are shown in [Table 2-4](#implicit_casting_rules_for_binary_arith).
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个值从一种类型转换为另一种类型称为*类型转换*。这种隐式转换在 PHP 中称为*类型强制转换*。算术运算符进行的类型强制转换的规则见[表 2-4](#implicit_casting_rules_for_binary_arith)。
- en: Table 2-4\. Implicit casting rules for binary arithmetic operations
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-4\. 二元算术操作的隐式转换规则
- en: '| Type of first operand | Type of second operand | Conversion performed |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 第一个操作数的类型 | 第二个操作数的类型 | 执行的转换 |'
- en: '| --- | --- | --- |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Integer | Floating point | The integer is converted to a floating-point number.
    |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | 浮点数 | 将整数转换为浮点数。 |'
- en: '| Integer | String | The string is converted to a number; if the value after
    conversion is a floating-point number, the integer is converted to a floating-point
    number. |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 整数 | 字符串 | 将字符串转换为数字；如果转换后的值为浮点数，则整数转换为浮点数。 |'
- en: '| Floating point | String | The string is converted to a floating-point number.
    |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 浮点数 | 字符串 | 将字符串转换为浮点数。 |'
- en: 'Some other operators have different expectations of their operands, and thus
    have different rules. For example, the string concatenation operator converts
    both operands to strings before concatenating them:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些运算符对其操作数有不同的期望，因此有不同的规则。例如，字符串连接运算符在连接之前将两个操作数转换为字符串：
- en: '[PRE82]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can use a string anywhere PHP expects a number. The string is presumed
    to start with an integer or floating-point number. If no number is found at the
    start of the string, the numeric value of that string is 0\. If the string contains
    a period (`.`) or upper- or lowercase `e`, evaluating it numerically produces
    a floating-point number. For example:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 期望数字的任何地方都可以使用字符串。假定字符串以整数或浮点数开头。如果在字符串开头找不到数字，则该字符串的数值为 0\. 如果字符串包含句点（`.`）或大写或小写
    `e`，则将其数值化后产生一个浮点数。例如：
- en: '[PRE83]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Arithmetic Operators
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: 'The arithmetic operators are operators you’ll recognize from everyday use.
    Most of the arithmetic operators are binary; however, the arithmetic negation
    and arithmetic assertion operators are unary. These operators require numeric
    values, and nonnumeric values are converted into numeric values by the rules described
    in the section “Casting Operators”. The arithmetic operators are:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符是你在日常使用中会认识到的运算符。大多数算术运算符都是二元的；然而，算术否定和算术断言运算符是一元的。这些运算符需要数值，非数值将按照“强制转换运算符”部分描述的规则转换为数值。算术运算符包括：
- en: Addition (`+`)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 加法 (`+`)
- en: The result of the addition operator is the sum of the two operands.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 加法运算符的结果是两个操作数的和。
- en: Subtraction (`−`)
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 减法 (`−`)
- en: The result of the subtraction operator is the difference between the two operands—that
    is, the value of the second operand subtracted from the first.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 减法运算符的结果是两个操作数之间的差值，即第二个操作数从第一个操作数中减去的值。
- en: Multiplication (`*`)
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法 (`*`)
- en: The result of the multiplication operator is the product of the two operands.
    For example, `3 * 4` is `12`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法运算符的结果是两个操作数的乘积。例如，`3 * 4` 是 `12`。
- en: Division (`/`)
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 除法 (`/`)
- en: The result of the division operator is the quotient of the two operands. Dividing
    two integers can give an integer (e.g., `4 / 2`) or a floating-point result (e.g.,
    `1 / 2`).
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 除法运算的结果是两个操作数的商。两个整数相除可以得到一个整数（例如，`4 / 2`）或者浮点数结果（例如，`1 / 2`）。
- en: Modulus (`%`)
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 取模 (`%`)
- en: The modulus operator converts both operands to integers and returns the remainder
    of the division of the first operand by the second operand. For example, `10 %
    6` gives a remainder of `4`.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 模运算符将两个操作数转换为整数，并返回第一个操作数除以第二个操作数的余数。例如，`10 % 6` 的余数为 `4`。
- en: Arithmetic negation (`−`)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 算术取反 (`−`)
- en: The arithmetic negation operator returns the operand multiplied by −1, effectively
    changing its sign. For example, `−(3 − 4)` evaluates to `1`. Arithmetic negation
    is different from the subtraction operator, even though they both are written
    as a minus sign. Arithmetic negation is always unary and before the operand. Subtraction
    is binary and between its operands.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 算术取反运算符返回操作数乘以−1，有效地改变其符号。例如，`−(3 − 4)` 的计算结果为 `1`。算术取反与减法运算符不同，尽管它们都写成减号。算术取反始终是一元的，并置于操作数之前。减法是二元的，并置于其操作数之间。
- en: Arithmetic assertion (`+`)
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 算术断言 (`+`)
- en: The arithmetic assertion operator returns the operand multiplied by +1, which
    has no effect. It is used only as a visual cue to indicate the sign of a value.
    For example, `+(3 − 4)` evaluates to `−1`, just as `(3 − 4)` does.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 算术断言运算符返回操作数乘以+1，这没有任何效果。它仅用作视觉提示，指示值的符号。例如，`+(3 − 4)` 的计算结果为 `-1`，就像 `(3 −
    4)` 一样。
- en: Exponentiation (`**`)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 指数运算 (`**`)
- en: The exponentiation operator returns the result of raising `$var1` to the power
    of `$var2`.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 指数运算符返回将 `$var1` 的值提高到 `$var2` 次幂的结果。
- en: '[PRE84]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: String Concatenation Operator
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串连接运算符
- en: 'Manipulating strings is such a core part of PHP applications that PHP has a
    separate string concatenation operator (`.`). The concatenation operator appends
    the righthand operand to the lefthand operand and returns the resulting string.
    Operands are first converted to strings, if necessary. For example:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 应用程序中，操作字符串是非常核心的部分，因此 PHP 单独有一个字符串连接运算符 (`.`)。连接运算符将右操作数附加到左操作数并返回结果字符串。必要时，操作数首先会被转换为字符串。例如：
- en: '[PRE85]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The concatenation operator is highly efficient because so much of PHP boils
    down to string concatenation.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接运算符非常高效，因为 PHP 大部分操作都可以归结为字符串连接。
- en: Auto-Increment and Auto-Decrement Operators
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自增和自减运算符
- en: In programming, one of the most common operations is to increase or decrease
    the value of a variable by one. The unary auto-increment (`++`) and auto-decrement
    (`−−`) operators provide shortcuts for these common operations. These operators
    are unique in that they work only on variables; the operators change their operands’
    values and return a value.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，增加或减少变量值是最常见的操作之一。一元自增 (`++`) 和自减 (`−−`) 运算符为这些常见操作提供了快捷方式。这些运算符独特之处在于它们仅适用于变量；运算符会改变它们的操作数的值并返回一个值。
- en: There are two ways to use auto-increment or auto-decrement in expressions. If
    you put the operator in front of the operand, it returns the new value of the
    operand (incremented or decremented). If you put the operator after the operand,
    it returns the original value of the operand (before the increment or decrement).
    [Table 2-5](#auto_increment_and_auto_decrement_oper) lists the different operations.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式中使用自增或自减有两种方法。如果将运算符放在操作数前面，它将返回操作数的新值（增加或减少后）。如果将运算符放在操作数后面，它将返回操作数的原始值（增加或减少前）。[表 2-5](#auto_increment_and_auto_decrement_oper)
    列出了不同的操作。
- en: Table 2-5\. Auto-increment and auto-decrement operations
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-5\. 自增和自减操作
- en: '| Operator | Name | Value returned | Effect on `$var` |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 名称 | 返回的值 | 对 `$var` 的影响 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `$var++` | Post-increment | `$var` | Incremented |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| `$var++` | 后自增 | `$var` | 自增后的值 |'
- en: '| `++$var` | Pre-increment | `$var + 1` | Incremented |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| `++$var` | 前自增 | `$var + 1` | 自增后的值 |'
- en: '| `$var−−` | Post-decrement | `$var` | Decremented |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `$var−−` | 后自减 | `$var` | 自减后的值 |'
- en: '| `−−$var` | Pre-decrement | `$var − 1` | Decremented |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `−−$var` | 前自减 | `$var − 1` | 自减后的值 |'
- en: These operators can be applied to strings as well as numbers. Incrementing an
    alphabetic character turns it into the next letter in the alphabet. As illustrated
    in [Table 2-6](#auto_increment_with_letters), incrementing `"z"` or `"Z"` wraps
    it back to `"a"` or `"A"` and increments the previous character by one (or inserts
    a new `"a"` or `"A"` if at the first character of the string), as though the characters
    were in a base-26 number system.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这些运算符可以应用于字符串和数字。对字母进行自增操作会将其转换为字母表中的下一个字母。正如在 [表 2-6](#auto_increment_with_letters)
    中所示，对 `"z"` 或 `"Z"` 进行自增操作会将其回环到 `"a"` 或 `"A"`，并使前一个字符自增一次（或者在字符串的第一个字符处插入新的 `"a"`
    或 `"A"`），就像字符处于一个26进制数系统中一样。
- en: Table 2-6\. Auto-increment with letters
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-6\. 字母的自增
- en: '| Incrementing this | Gives this |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| 递增此值 | 得到此值 |'
- en: '| --- | --- |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `"a"` | `"b"` |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| `"a"` | `"b"` |'
- en: '| `"z"` | `"aa"` |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| `"z"` | `"aa"` |'
- en: '| `"spaz"` | `"spba"` |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| `"spaz"` | `"spba"` |'
- en: '| `"K9"` | `"L0"` |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| `"K9"` | `"L0"` |'
- en: '| `"42"` | `"43"` |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| `"42"` | `"43"` |'
- en: Comparison Operators
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: As their name suggests, comparison operators compare operands. The result is
    always either `true`, if the comparison is truthful, and `false` otherwise.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 正如它们的名称所示，比较运算符用于比较操作数。结果要么为`true`（如果比较为真），要么为`false`。
- en: Operands to the comparison operators can be both numeric, both string, or one
    numeric and one string. The operators check for truthfulness in slightly different
    ways based on the types and values of the operands, either using strictly numeric
    comparisons or using lexicographic (textual) comparisons. [Table 2-7](#type_of_comparison_performed_by_the_com)
    outlines when each type of check is used.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符的操作数可以是全数字、全字符串或一个数字和一个字符串。根据操作数的类型和值，这些运算符稍有不同地检查真实性，可以使用严格的数值比较或按字典序（文本）比较。[表
    2-7](#type_of_comparison_performed_by_the_com) 概述了每种检查何时使用。
- en: Table 2-7\. Type of comparison performed by the comparison operators
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-7\. 比较运算符执行的比较类型
- en: '| First operand | Second operand | Comparison |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| 第一个操作数 | 第二个操作数 | 比较 |'
- en: '| --- | --- | --- |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Number | Number | Numeric |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| Number | Number | Numeric |'
- en: '| String that is entirely numeric | String that is entirely numeric | Numeric
    |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| 完全是数字的字符串 | 完全是数字的字符串 | 数字型 |'
- en: '| String that is entirely numeric | Number | Numeric |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| 完全是数字的字符串 | 数字 | 数字型 |'
- en: '| String that is entirely numeric | String that is not entirely numeric | Lexicographic
    |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| 完全是数字的字符串 | 不完全是数字的字符串 | 字典序 |'
- en: '| String that is not entirely numeric | Number | Numeric |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| 不完全是数字的字符串 | 数字 | 数字型 |'
- en: '| String that is not entirely numeric | String that is not entirely numeric
    | Lexicographic |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| 不完全是数字的字符串 | 不完全是数字的字符串 | 字典序 |'
- en: One important thing to note is that two numeric strings are compared as if they
    were numbers. If you have two strings that consist entirely of numeric characters
    and you need to compare them lexicographically, use the `strcmp()` function.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的注意事项是，两个数字字符串会被比较为数值。如果你有两个完全由数字字符组成的字符串，并且需要按字典顺序比较它们，请使用`strcmp()`函数。
- en: 'The comparison operators are:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符包括：
- en: Equality (`==`)
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 等于（`==`）
- en: If both operands are equal, this operator returns `true`; otherwise, it returns
    `false`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数相等，则该运算符返回`true`；否则返回`false`。
- en: Identity (`===`)
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 相同（`===`）
- en: If both operands are equal and are of the same type, this operator returns `true`;
    otherwise, it returns `false`. Note that this operator does *not* do implicit
    type casting. This operator is useful when you don’t know if the values you’re
    comparing are of the same type. Simple comparison may involve value conversion.
    For instance, the strings `"0.0"` and `"0"` are not equal. The `==` operator says
    they are, but `===` says they are not.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数相等且类型相同，则该运算符返回`true`；否则返回`false`。请注意，该运算符不会进行隐式类型转换。当你不确定所比较的值是否为相同类型时，此运算符非常有用。简单比较可能涉及值转换。例如，字符串
    `"0.0"` 和 `"0"` 不相等。`==` 运算符说它们相等，但 `===` 运算符说它们不相等。
- en: Inequality (`!=` or `<>`)
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 不等于（`!=` 或 `<>`）
- en: If the operands are not equal, this operator returns `true`; otherwise, it returns
    `false`.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数不相等，则该运算符返回`true`；否则返回`false`。
- en: Not identical (`!==`)
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 不相同（`!==`）
- en: If the operands are not equal, or they are not of the same type, this operator
    returns `true`; otherwise, it returns `false`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数不相等或它们不是相同类型，则该运算符返回`true`；否则返回`false`。
- en: Greater than (`>`)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 大于 (`>`)
- en: If the lefthand operand is greater than the righthand operand, this operator
    returns `true`; otherwise, it returns `false`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左操作数大于右操作数，则该运算符返回`true`；否则返回`false`。
- en: Greater than or equal to (`>=`)
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 大于或等于 (`>=`)
- en: If the lefthand operand is greater than or equal to the righthand operand, this
    operator returns `true`; otherwise, it returns `false`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左操作数大于或等于右操作数，则该运算符返回`true`；否则返回`false`。
- en: Less than (`<`)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 小于 (`<`)
- en: If the lefthand operand is less than the righthand operand, this operator returns
    `true`; otherwise, it returns `false`.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左操作数小于右操作数，则该运算符返回`true`；否则返回`false`。
- en: Less than or equal to (`<=`)
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 小于或等于 (`<=`)
- en: If the lefthand operand is less than or equal to the righthand operand, this
    operator returns `true`; otherwise, it returns `false`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左操作数小于或等于右操作数，则该运算符返回 `true`；否则，返回 `false`。
- en: Spaceship (`<=>`), aka “Darth Vader’s TIE Fighter”
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 太空船运算符（`<=>`），也称为“达斯·维达的TIE战斗机”
- en: When the lefthand and righthand operands are equal, this operator returns `0`;
    when the lefthand operand is less than the righthand, it returns `–1`; and when
    the lefthand operand is greater than the righthand, it returns `1`.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 当左操作数等于右操作数时，该运算符返回 `0`；当左操作数小于右操作数时，返回 `-1`；当左操作数大于右操作数时，返回 `1`。
- en: '[PRE86]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Null coalescing operator (`??`)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 空值合并运算符（`??`）
- en: This operator evaluates to the righthand operand if the lefthand operand is
    `NULL`; otherwise, it evaluates to the lefthand operand.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果左操作数为 `NULL`，则该运算符求值为右操作数；否则，求值为左操作数。
- en: '[PRE87]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Bitwise Operators
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位运算符
- en: 'The bitwise operators act on the binary representation of their operands. Each
    operand is first turned into a binary representation of the value, as described
    in the bitwise negation operator entry in the following list. All the bitwise
    operators work on numbers as well as strings, but they vary in their treatment
    of string operands of different lengths. The bitwise operators are:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 位运算符作用于其操作数的二进制表示。首先将每个操作数转换为其数值的二进制表示，如下面列表中位取反运算符条目所述。所有位运算符都可以作用于数字以及字符串，但它们在处理长度不同的字符串操作数时有所不同。位运算符包括：
- en: Bitwise negation (`~`)
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 位取反（`~`）
- en: The bitwise negation operator changes 1s to 0s and 0s to 1s in the binary representations
    of the operands. Floating-point values are converted to integers before the operation
    takes place. If the operand is a string, the resulting value is a string the same
    length as the original, with each character in the string negated.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 位取反运算符将操作数的二进制表示中的1变为0，0变为1。在执行操作之前，浮点数值会转换为整数。如果操作数是字符串，则结果值是与原始字符串长度相同的字符串，其中字符串中的每个字符都被取反。
- en: Bitwise AND (`&`)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 位与（`&`）
- en: 'The bitwise AND operator compares each corresponding bit in the binary representations
    of the operands. If both bits are 1, the corresponding bit in the result is 1;
    otherwise, the corresponding bit is 0\. For example, `0755 & 0671` is `0651`.
    This is a little easier to understand if we look at the binary representation.
    Octal 0755 is binary 111101101, and octal 0671 is binary 110111001\. We can then
    easily see which bits are in both numbers and visually come up with the answer:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 位与运算符比较操作数的二进制表示中的每个对应位。如果两个位都是1，则结果中的对应位为1；否则，对应位为0。例如，`0755 & 0671` 是 `0651`。如果我们查看二进制表示，会更容易理解。八进制
    `0755` 的二进制是 `111101101`，八进制 `0671` 的二进制是 `110111001`。然后我们可以轻松看出这两个数字中哪些位是相同的，并直观地得出答案：
- en: '[PRE88]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The binary number 110101001 is octal 0651.^([2](ch02.xhtml#ch02fn2)) You can
    use the PHP functions `bindec()`, `decbin()`, `octdec()`, and `decoct()` to convert
    numbers back and forth when you are trying to understand binary arithmetic.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制数 `110101001` 是八进制 `0651`。^([2](ch02.xhtml#ch02fn2)) 在尝试理解二进制算术时，可以使用 PHP
    函数 `bindec()`、`decbin()`、`octdec()` 和 `decoct()` 进行数字的双向转换。
- en: If both operands are strings, the operator returns a string in which each character
    is the result of a bitwise AND operation between the two corresponding characters
    in the operands. The resulting string is the length of the shorter of the two
    operands; trailing extra characters in the longer string are ignored. For example,
    `"wolf" & "cat"` is `"cad"`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数都是字符串，则该运算符返回一个字符串，其中每个字符都是两个操作数中对应字符进行位与操作的结果。结果字符串的长度是两个操作数中较短的那个；在较长字符串的末尾多余字符将被忽略。例如，`"wolf"
    & "cat"` 是 `"cad"`。
- en: Bitwise OR (`|`)
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 位或（`|`）
- en: The bitwise OR operator compares each corresponding bit in the binary representations
    of the operands. If both bits are 0, the resulting bit is 0; otherwise, the resulting
    bit is 1\. For example, `0755 | 020` is `0775`.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 位或运算符比较操作数的二进制表示中的每个对应位。如果两个位都是0，则结果位为0；否则，结果位为1。例如，`0755 | 020` 是 `0775`。
- en: If both operands are strings, the operator returns a string in which each character
    is the result of a bitwise OR operation between the two corresponding characters
    in the operands. The resulting string is the length of the longer of the two operands,
    and the shorter string is padded at the end with binary 0s. For example, `"pussy"
    | "cat"` is `"suwsy"`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数都是字符串，则运算符返回一个字符串，其中每个字符是操作数中对应字符进行位或操作的结果。结果字符串的长度为两个操作数中较长的那个，并且较短的字符串在末尾填充二进制0。例如，`"pussy"
    | "cat"` 是 `"suwsy"`。
- en: Bitwise XOR (`^`)
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 位异或 (`^`)
- en: The bitwise XOR operator compares each corresponding bit in the binary representation
    of the operands. If either of the bits in the pair, but not both, is 1, the resulting
    bit is 1; otherwise, the resulting bit is 0\. For example, `0755 ^ 023` is `776`.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 位异或运算符比较操作数的二进制表示中的每个对应位。如果一对中的任一位（但不是两者都是）为1，则结果位为1；否则，结果位为0。例如，`0755 ^ 023`
    是 `776`。
- en: If both operands are strings, this operator returns a string in which each character
    is the result of a bitwise XOR operation between the two corresponding characters
    in the operands. If the two strings are different lengths, the resulting string
    is the length of the shorter operand, and extra trailing characters in the longer
    string are ignored. For example, `"big drink" ^ "AA"` is `"#("`.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个操作数都是字符串，则此运算符返回一个字符串，其中每个字符是操作数中对应字符进行位异或操作的结果。如果两个字符串长度不同，则结果字符串的长度为较短操作数的长度，并且忽略较长字符串中多余的尾部字符。例如，`"big
    drink" ^ "AA"` 是 `"#("`。
- en: Left shift (`<<`)
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 左移位 (`<<`)
- en: The left-shift operator shifts the bits in the binary representation of the
    lefthand operand left by the number of places given in the righthand operand.
    Both operands will be converted to integers if they aren’t already. Shifting a
    binary number to the left inserts a 0 as the rightmost bit of the number and moves
    all other bits to the left one place. For example, `3 << 1` (or binary 11 shifted
    one place left) results in `6` (binary 110).
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 左移位运算符将左操作数的二进制表示中的位向左移动右操作数指定的位数。如果它们尚未是整数，则两个操作数将被转换为整数。向左移动二进制数会在数字的最右边插入一个0，并将所有其他位向左移动一个位置。例如，`3
    << 1`（或二进制11向左移动一位）的结果是 `6`（二进制110）。
- en: Note that each place to the left that a number is shifted results in a doubling
    of the number. The result of left shifting is multiplying the lefthand operand
    by 2 to the power of the righthand operand.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每次向左移动数字的位置都会导致数字加倍。左移的结果是将左操作数乘以右操作数的2的幂。
- en: Right shift (`>>`)
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 右移位 (`>>`)
- en: The right-shift operator shifts the bits in the binary representation of the
    lefthand operand right by the number of places given in the righthand operand.
    Both operands will be converted to integers if they aren’t already. Shifting a
    positive binary number to the right inserts a 0 as the leftmost bit of the number
    and moves all other bits to the right one place. Shifting a negative binary number
    to the right inserts a 1 as the leftmost bit of the number and moves all other
    bits to the right one place. The rightmost bit is discarded. For example, `13
    >> 1` (or binary 1101) shifted one bit to the right results in `6` (binary 110).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 右移位运算符将左操作数的二进制表示中的位向右移动右操作数指定的位数。如果它们尚未是整数，则两个操作数将被转换为整数。将正数二进制数向右移动会在数字的最左边插入一个0，并将所有其他位向右移动一个位置。将负数二进制数向右移动会在数字的最左边插入一个1，并将所有其他位向右移动一个位置。最右边的位被丢弃。例如，`13
    >> 1`（或二进制1101向右移动一位）的结果是 `6`（二进制110）。
- en: Logical Operators
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: 'Logical operators provide ways for you to build complex logical expressions.
    Logical operators treat their operands as Boolean values and return a Boolean
    value. There are both punctuation and English versions of the operators (`||`
    and `or` are the same operator). The logical operators are:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符提供了构建复杂逻辑表达式的方法。逻辑运算符将其操作数视为布尔值并返回布尔值。运算符有标点和英文版本（`||` 和 `or` 是相同的运算符）。逻辑运算符包括：
- en: Logical AND (`&&`, `and`)
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与 (`&&`, `and`)
- en: 'The result of the logical AND operation is `true` if and only if both operands
    are `true`; otherwise, it is `false`. If the value of the first operand is `false`,
    the logical AND operator knows that the resulting value must also be `false`,
    so the righthand operand is never evaluated. This process is called *short-circuiting*,
    and a common PHP idiom uses it to ensure that a piece of code is evaluated only
    if something is true. For example, you might connect to a database only if some
    flag is not `false`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与操作的结果如果且仅如果两个操作数都为 `true`，则结果为 `true`；否则为 `false`。如果第一个操作数的值为 `false`，逻辑与操作符知道结果值必须也为
    `false`，因此右操作数不会被评估。这个过程称为 *短路*，一个常见的 PHP 习惯用法是确保只有在某些条件为真时才评估代码。例如，你可能只有在某些标志不为
    `false` 时才连接到数据库：
- en: '[PRE89]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `&&` and `and` operators differ only in their precedence: `&&` comes before
    `and`.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`&&` 和 `and` 操作符在它们的优先级上是有所不同的：`&&` 在 `and` 之前。'
- en: Logical OR (`||`, `or`)
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或 (`||`, `or`)
- en: 'The result of the logical OR operation is `true` if either operand is `true`;
    otherwise, the result is `false`. Like the logical AND operator, the logical OR
    operator is short-circuited. If the lefthand operator is `true`, the result of
    the operator must be `true`, so the righthand operator is never evaluated. A common
    PHP idiom uses this to trigger an error condition if something goes wrong. For
    example:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或操作的结果如果任一操作数为 `true`，则结果为 `true`；否则为 `false`。与逻辑与操作符类似，逻辑或操作符也是短路的。如果左操作数为
    `true`，则操作符的结果必须为 `true`，因此右操作数永远不会被评估。一个常见的 PHP 习惯用法是在发生错误时触发错误条件。例如：
- en: '[PRE90]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `||` and `or` operators differ only in their precedence.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '`||` 和 `or` 操作符在它们的优先级上是有所不同的。'
- en: Logical XOR (`xor`)
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑异或 (`xor`)
- en: The result of the logical XOR operation is `true` if either operand, but not
    both, is `true`; otherwise, it is `false`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑异或操作的结果如果任一操作数为 `true` 但不是两个操作数都为 `true`，则结果为 `true`；否则为 `false`。
- en: Logical negation (`!`)
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非 (`!`)
- en: The logical negation operator returns the Boolean value `true` if the operand
    evaluates to `false`, and `false` if the operand evaluates to `true`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非操作符如果操作数评估为 `false`，则返回布尔值 `true`，如果操作数评估为 `true`，则返回布尔值 `false`。
- en: Casting Operators
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强制转换操作符
- en: Although PHP is a weakly typed language, there are occasions when it’s useful
    to consider a value as a specific type. The casting operators, `(int)`, `(float)`,
    `(string)`, `(bool)`, `(array)`, `(object)`, and `(unset)`, allow you to force
    a value into a particular type. To use a casting operator, put the operator to
    the left of the operand. [Table 2-8](#php_casting_operators) lists the casting
    operators, synonymous operators, and the type to which the operator changes the
    value.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 PHP 是一种弱类型语言，但在某些情况下，将值视为特定类型是很有用的。强制转换操作符 `(int)`, `(float)`, `(string)`,
    `(bool)`, `(array)`, `(object)`, 和 `(unset)` 允许你将一个值强制转换为特定类型。要使用强制转换操作符，将操作符放在操作数的左侧。[表 2-8](#php_casting_operators)
    列出了强制转换操作符、同义操作符以及操作符将值转换为的类型。
- en: Table 2-8\. PHP casting operators
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 表 2-8\. PHP 强制转换操作符
- en: '| Operator | Synonymous operators | Changes type to |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 同义操作符 | 转换为 |'
- en: '| --- | --- | --- |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `(int)` | `(integer)` | Integer |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| `(int)` | `(integer)` | 整数 |'
- en: '| `(bool)` | `(boolean)` | Boolean |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| `(bool)` | `(boolean)` | 布尔值 |'
- en: '| `(float)` | `(double)`, `(real)` | Floating point |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| `(float)` | `(double)`, `(real)` | 浮点数 |'
- en: '| `(string)` |   | String |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| `(string)` |   | String |'
- en: '| `(array)` |   | Array |'
  id: totrans-521
  prefs: []
  type: TYPE_TB
  zh: '| `(array)` |   | Array |'
- en: '| `(object)` |   | Object |'
  id: totrans-522
  prefs: []
  type: TYPE_TB
  zh: '| `(object)` |   | Object |'
- en: '| `(unset)` |   | NULL |'
  id: totrans-523
  prefs: []
  type: TYPE_TB
  zh: '| `(unset)` |   | NULL |'
- en: 'Casting affects the way other operators interpret a value rather than changing
    the value in a variable. For example, the code:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 强制转换影响其他操作符解释值的方式，而不是改变变量中的值。例如，代码：
- en: '[PRE91]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'assigns `$b` the integer value of `$a`; `$a` remains the string `"5"`. To cast
    the value of the variable itself, you must assign the result of a cast back to
    the variable:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `$b` 赋予 `$a` 的整数值；`$a` 保持字符串 `"5"`。要将变量本身的值强制转换，必须将强制转换的结果再赋回变量：
- en: '[PRE92]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Not every cast is useful. Casting an array to a numeric type gives `1` (if the
    array is empty, it gives `0`), and casting an array to a string gives `"Array"`
    (seeing this in your output is a sure sign that you’ve printed a variable that
    contains an array).
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每种强制转换都是有用的。将数组强制转换为数值类型会得到 `1`（如果数组为空，则为 `0`），将数组强制转换为字符串会得到 `"Array"`（在输出中看到这个，表明你已经打印了一个包含数组的变量）。
- en: 'Casting an object to an array builds an array of the properties, thus mapping
    property names to values:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 将对象强制转换为数组会构建一个属性数组，从而将属性名映射到值：
- en: '[PRE93]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'You can cast an array to an object to build an object whose properties correspond
    to the array’s keys and values. For example:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将数组转换为对象，以构建一个对象，其属性对应于数组的键和值。例如：
- en: '[PRE94]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Keys that are not valid identifiers are invalid property names and are inaccessible
    when an array is cast to an object, but are restored when the object is cast back
    to an array.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 不是有效标识符的键是无效的属性名称，在将数组转换为对象时不可访问，但在将对象转换回数组时恢复。
- en: Assignment Operators
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: Assignment operators store or update values in variables. The auto-increment
    and auto-decrement operators we saw earlier are highly specialized assignment
    operators—here we see the more general forms. The basic assignment operator is
    `=`, but we’ll also see combinations of assignment and binary operations, such
    as `+=` and `&=`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符用于存储或更新变量中的值。我们之前看到的自增和自减运算符是高度专业化的赋值运算符—在这里我们看到更一般的形式。基本赋值运算符是`=`，但我们还会看到赋值和二进制运算的组合，如`+=`和`&=`。
- en: Assignment
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 赋值
- en: The basic assignment operator (`=`) assigns a value to a variable. The lefthand
    operand is always a variable. The righthand operand can be any expression—any
    simple literal, variable, or complex expression. The righthand operand’s value
    is stored in the variable named by the lefthand operand.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 基本赋值运算符 (`=`) 将一个值分配给一个变量。左操作数始终是一个变量。右操作数可以是任何表达式—任何简单的字面量、变量或复杂的表达式。右操作数的值存储在由左操作数命名的变量中。
- en: 'Because all operators are required to return a value, the assignment operator
    returns the value assigned to the variable. For example, the expression `$a =
    5` not only assigns `5` to `$a`, but also behaves as the value `5` if used in
    a larger expression. Consider the following expressions:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 因为所有运算符都要返回一个值，所以赋值运算符返回分配给变量的值。例如，表达式`$a = 5`不仅将`5`赋给了`$a`，而且在较大的表达式中使用时，也会表现为值`5`。考虑以下表达式：
- en: '[PRE95]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The expression `$a = $b` is evaluated first, because of the parentheses. Now,
    both `$a` and `$b` have the same value, `10`. Finally, `$c` is assigned the result
    of the expression `$a = $b`, which is the value assigned to the lefthand operand
    (in this case, `$a`). When the full expression is done evaluating, all three variables
    contain the same value: `10`.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`$a = $b`首先被评估，因为有括号。现在，`$a`和`$b`都有相同的值`10`。最后，`$c`被赋值为表达式`$a = $b`的结果，即分配给左操作数的值（在本例中为`$a`）。当完整表达式评估完成时，所有三个变量都包含相同的值`10`。
- en: Assignment with operation
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带操作的赋值
- en: 'In addition to the basic assignment operator, there are several assignment
    operators that are convenient shorthand. These operators consist of a binary operator
    followed directly by an equals sign, and their effect is the same as performing
    the operation with the full operands, then assigning the resulting value to the
    lefthand operand. These assignment operators are:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本赋值运算符外，还有几个方便的简写赋值运算符。这些运算符由一个二元运算符直接跟随一个等号组成，它们的效果等同于对完整操作数执行操作，然后将结果值分配给左操作数。这些赋值运算符包括：
- en: Plus-equals (`+=`)
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 加等号 (`+=`)
- en: Adds the righthand operand to the value of the lefthand operand, then assigns
    the result to the lefthand operand. `$a += 5` is the same as `$a = $a + 5`.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 将右操作数加到左操作数的值上，然后将结果分配给左操作数。`$a += 5`与`$a = $a + 5`相同。
- en: Minus-equals (`−=`)
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 减等号 (`−=`)
- en: Subtracts the righthand operand from the value of the lefthand operand, then
    assigns the result to the lefthand operand.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 从左操作数的值减去右操作数，然后将结果分配给左操作数。
- en: Divide-equals (`/=`)
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 除等号 (`/=`)
- en: Divides the value of the lefthand operand by the righthand operand, then assigns
    the result to the lefthand operand.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 将左操作数的值除以右操作数，然后将结果分配给左操作数。
- en: Multiply-equals (`*=`)
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 乘等号 (`*=`)
- en: Multiplies the righthand operand by the value of the lefthand operand, then
    assigns the result to the lefthand operand.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 将右操作数乘以左操作数的值，然后将结果分配给左操作数。
- en: Modulus-equals (`%=`)
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 取模等号 (`%=`)
- en: Performs the modulus operation on the value of the lefthand operand and the
    righthand operand, then assigns the result to the lefthand operand.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 对左操作数和右操作数的值执行模运算，然后将结果分配给左操作数。
- en: Bitwise-XOR-equals (`^=`)
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 按位异或等号 (`^=`)
- en: Performs a bitwise XOR on the lefthand and righthand operands, then assigns
    the result to the lefthand operand.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 对左操作数和右操作数执行按位异或，然后将结果分配给左操作数。
- en: Bitwise-AND-equals (`&=`)
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 按位与等号 (`&=`)
- en: Performs a bitwise AND on the value of the lefthand operand and the righthand
    operand, then assigns the result to the lefthand operand.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 对左操作数的值和右操作数执行按位与操作，然后将结果分配给左操作数。
- en: Bitwise-OR-equals (`|=`)
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 按位或等于（`|=`）
- en: Performs a bitwise OR on the value of the lefthand operand and the righthand
    operand, then assigns the result to the lefthand operand.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 对左操作数的值和右操作数执行按位或操作，然后将结果分配给左操作数。
- en: Concatenate-equals (`.=`)
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 连接等于（`.=`）
- en: Concatenates the righthand operand to the value of the lefthand operand, then
    assigns the result to the lefthand operand.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 将右操作数连接到左操作数的值，然后将结果分配给左操作数。
- en: Miscellaneous Operators
  id: totrans-561
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项运算符
- en: 'The remaining PHP operators are for error suppression, executing an external
    command, and selecting values:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的PHP运算符用于错误抑制、执行外部命令和选择值：
- en: Error suppression (`@`)
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 错误抑制（`@`）
- en: Some operators or functions can generate error messages. The error suppression
    operator, discussed in full in [Chapter 17](ch17.xhtml#debugging_php), is used
    to prevent these messages from being created.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 一些运算符或函数可能会生成错误消息。完整讨论错误抑制运算符，请参阅[第17章](ch17.xhtml#debugging_php)。
- en: Execution (`` `...` ``)
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 执行（`` `...` ``）
- en: 'The backtick operator executes the string contained between the backticks as
    a shell command and returns the output. For example:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号运算符执行包含在反引号之间的字符串作为shell命令并返回输出。例如：
- en: '[PRE96]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Conditional (`? :`)
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 条件（`? :`）
- en: The conditional operator is, depending on the code you look at, either the most
    overused or most underused operator. It is the only ternary (three-operand) operator
    and is therefore sometimes just called the ternary operator.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符是根据您查看的代码而定，可能是最常用或最不常用的运算符之一。它是唯一的三元（三操作数）运算符，因此有时只被称为三元运算符。
- en: 'The conditional operator evaluates the expression before the `?`. If the expression
    is `true`, the operator returns the value of the expression between the `?` and
    `:`; otherwise, the operator returns the value of the expression after the `:`.
    For instance:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 条件运算符在`?`之前评估表达式。如果表达式为`true`，则运算符返回`?`和`:`之间的表达式的值；否则，运算符返回`:`之后的表达式的值。例如：
- en: '[PRE97]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: If text for the link `$url` is present in the variable `$linktext`, it is used
    as the text for the link; otherwise, the URL itself is displayed.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 如果变量`$linktext`中存在链接`$url`的文本，则将其用作链接的文本；否则，显示URL本身。
- en: Type (`instanceof`)
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 类型（`instanceof`）
- en: 'The `instanceof` operator tests whether a variable is an instantiated object
    of a given class or implements an interface (see [Chapter 6](ch06.xhtml#objects-id00032)
    for more information on objects and interfaces):'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof`运算符测试变量是否是给定类的实例化对象或实现接口（有关对象和接口的更多信息，请参阅[第6章](ch06.xhtml#objects-id00032)）：'
- en: '[PRE98]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Flow-Control Statements
  id: totrans-576
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制语句
- en: PHP supports a number of traditional programming constructs for controlling
    the flow of execution of a program.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: PHP支持许多传统的编程构造来控制程序的执行流程。
- en: Conditional statements, such as `if`/`else` and `switch`, allow a program to
    execute different pieces of code, or none at all, depending on some condition.
    Loops, such as `while` and `for`, support the repeated execution of particular
    segments of code.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句，例如`if`/`else`和`switch`，允许程序根据某些条件执行不同的代码片段，或者根本不执行。循环，例如`while`和`for`，支持对代码段的重复执行。
- en: if
  id: totrans-579
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if
- en: 'The `if` statement checks the truthfulness of an expression and, if the expression
    is true, evaluates a statement. An `if` statement looks like:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句检查表达式的真实性，如果表达式为真，则评估一个语句。一个`if`语句看起来像：'
- en: '[PRE99]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'To specify an alternative statement to execute when the expression is false,
    use the `else` keyword:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 若要指定在表达式为假时执行的替代语句，请使用`else`关键字：
- en: '[PRE100]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'For example:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE101]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To include more than one statement within an `if` statement, use a *block*—a
    set of statements enclosed by curly braces:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 若要在`if`语句内包含多个语句，请使用*块*—由花括号括起来的一组语句：
- en: '[PRE102]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'PHP provides another syntax for blocks in tests and loops. Instead of enclosing
    the block of statements in curly braces, end the `if` line with a colon (`:`)
    and use a specific keyword to end the block (`endif`, in this case). For example:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: PHP为测试和循环中的块提供了另一种语法。不是用花括号将语句块括起来，而是在`if`行末尾使用冒号（`:`）并使用特定关键字来结束块（在这种情况下为`endif`）。例如：
- en: '[PRE103]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Other statements described in this chapter also have similar alternate syntax
    styles (and ending keywords); they can be useful if you have large blocks of HTML
    inside your statements. For example:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的其他语句也有类似的备选语法样式（和结束关键字）；如果您的语句内部有大量的HTML块，它们可能非常有用。例如：
- en: '[PRE104]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Because `if` is a statement, you can chain (embed) more than one. This is also
    a good example of how the blocks can be used to help keep things organized:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`if`是一个语句，您可以链接（嵌套）多个。这也是如何使用块来帮助保持组织的一个很好的例子：
- en: '[PRE105]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Such chains of `if` statements are common enough that PHP provides an easier
    syntax: the `elseif` statement. For example, the previous code can be rewritten
    as:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了一个更简单的语法来处理这样的`if`语句链：`elseif`语句。例如，前面的代码可以重写为：
- en: '[PRE106]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The ternary conditional operator (`? :`) can be used to shorten simple true/false
    tests. Take a common situation, such as checking to see if a given variable is
    true and printing something if it is. With a normal `if`/`else` statement, it
    looks like this:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 三元条件运算符（`? :`）可用于缩短简单的真/假测试。考虑一个常见的情况，例如检查给定变量是否为true并在其为true时打印某些内容。使用普通的`if`/`else`语句，看起来像这样：
- en: '[PRE107]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'With the ternary conditional operator, it looks like this:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三元条件运算符时，看起来像这样：
- en: '[PRE108]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Compare the syntax of the two:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两者的语法：
- en: '[PRE109]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The main difference here is that the conditional operator is not a statement
    at all. This means that it is used on expressions, and the result of a complete
    ternary expression is itself an expression. In the previous example, the `echo`
    statement is inside the `if` condition, while when used with the ternary operator,
    it precedes the expression.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要区别在于条件运算符根本不是一个语句。这意味着它用于表达式，完整的三元表达式的结果本身就是一个表达式。在上面的例子中，`echo`语句位于`if`条件内部，而使用三元运算符时，它位于表达式之前。
- en: switch
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开关
- en: The value of a single variable may determine one of a number of different choices
    (e.g., the variable holds the username and you want to do something different
    for each user). The `switch` statement is designed for just this situation.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 单个变量的值可能决定多个不同的选择（例如，变量保存用户名，您希望针对每个用户执行不同的操作）。`switch`语句正是为这种情况设计的。
- en: A `switch` statement is given an expression and compares its value to all cases
    in the switch; all statements in a matching case are executed, up to the first
    `break` keyword it finds. If none match, and a `default` is given, all statements
    following the `default` keyword are executed, up to the first `break` keyword
    encountered.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句给定一个表达式并将其值与switch中的所有case进行比较；匹配case中的所有语句都会执行，直到找到第一个`break`关键字。如果没有匹配，且有`default`，则执行`default`关键字后的所有语句，直到遇到第一个`break`关键字。'
- en: 'For example, suppose you have the following:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有以下内容：
- en: '[PRE110]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'You can replace that statement with the following `switch` statement:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用以下`switch`语句替换该语句：
- en: '[PRE111]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The alternative syntax for this is:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 这种的替代语法是：
- en: '[PRE112]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Because statements are executed from the matching case label to the next `break`
    keyword, you can combine several cases in a *fall-through*. In the following example,
    “yes” is printed when `$name` is equal to `sylvie` or `bruno`:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 因为语句从匹配的case标签到下一个`break`关键字被执行，您可以将多个case结合在一起进行*穿透*。在下面的例子中，当`$name`等于`sylvie`或`bruno`时，会打印出"yes"：
- en: '[PRE113]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Commenting the fact that you are using a fall-through case in a `switch` is
    a good idea, so someone doesn’t come along at some point and add a `break` thinking
    you had forgotten it.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 在`switch`中注释您使用了穿透case是个好主意，这样别人就不会以为您忘记了加上`break`。
- en: You can specify an optional number of levels for the `break` keyword to break
    out of. In this way, a `break` statement can break out of several levels of nested
    `switch` statements. An example of using `break` in this manner is shown in the
    next section.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为`break`关键字指定可选的中断级别数。这样，`break`语句可以跳出多层嵌套的`switch`语句。下一节中展示了使用`break`的示例。
- en: while
  id: totrans-616
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当
- en: 'The simplest form of loop is the `while` statement:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的循环形式是`while`语句：
- en: '[PRE114]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: If the *expression* evaluates to `true`, the *statement* is executed and then
    the *expression* is re-evaluated (if it is still `true`, the body of the loop
    is executed again, and so on). The loop exits when the *expression* is no longer
    true (i.e., evaluates to `false`).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*表达式*计算结果为`true`，则执行*语句*，然后重新评估*表达式*（如果仍为`true`，则再次执行循环体，依此类推）。当*表达式*不再为真时（即计算结果为`false`时），循环退出。
- en: 'As an example, here’s some code that adds the whole numbers from 1 to 10:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，这里是一些将整数从1加到10的代码：
- en: '[PRE115]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The alternative syntax for `while` has this structure:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`的替代语法具有以下结构：'
- en: '[PRE116]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'For example:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE117]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'You can prematurely exit a loop with the `break` keyword. In the following
    code, `$i` never reaches a value of `6`, because the loop is stopped once it reaches
    `5`:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`break`关键字提前退出循环。在以下代码中，一旦`$i`达到`5`，循环就会停止，因此`$i`永远不会达到`6`：
- en: '[PRE118]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Optionally, you can put a number after the `break` keyword indicating how many
    levels of loop structures to break out of. In this way, a statement buried deep
    in nested loops can break out of the outermost loop. For example:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，在`break`关键字后面可以放一个数字，指示要跳出的循环结构级别数。通过这种方式，嵌套循环中深埋的语句可以跳出最外层循环。例如：
- en: '[PRE119]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The `continue` statement skips ahead to the next test of the loop condition.
    As with the `break` keyword, you can continue through an optional number of levels
    of loop structure:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句跳到下一个循环条件测试。与`break`关键字一样，您可以跨可选的循环结构级别继续：'
- en: '[PRE120]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: In this code, `$j` never has a value above `5`, but `$i` goes through all values
    from `0` to `9`.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，`$j`永远不会超过`5`，但`$i`会经历从`0`到`9`的所有值。
- en: 'PHP also supports a `do`/`while` loop, which takes the following form:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: PHP还支持`do`/`while`循环，其形式如下：
- en: '[PRE121]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Use a `do`/`while` loop to ensure that the loop body is executed at least once
    (the first time):'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`do`/`while`循环确保至少执行一次循环体（第一次）：
- en: '[PRE122]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: You can use `break` and `continue` statements in a `do`/`while` statement just
    as in a normal `while` statement.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`do`/`while`语句中像在普通`while`语句中一样使用`break`和`continue`语句。
- en: 'The `do`/`while` statement is sometimes used to break out of a block of code
    when an error condition occurs. For example:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生错误条件时，有时会使用`do`/`while`语句来跳出代码块。例如：
- en: '[PRE123]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Because the condition for the loop is `false`, the loop is executed only once,
    regardless of what happens inside the loop. However, if an error occurs, the code
    after the `break` is not evaluated.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 因为循环的条件为`false`，所以无论循环内部发生什么，循环只执行一次。但是，如果发生错误，则`break`后面的代码不会被评估。
- en: for
  id: totrans-641
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for
- en: The `for` statement is similar to the `while` statement, except it adds counter
    initialization and counter manipulation expressions, and is often shorter and
    easier to read than the equivalent `while` loop.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句类似于`while`语句，但它添加了计数器初始化和计数器操作表达式，通常比等效的`while`循环更短且更易读。'
- en: 'Here’s a `while` loop that counts from 0 to 9, printing each number:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`while`循环，从0到9进行计数，并打印每个数字：
- en: '[PRE124]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Here’s the corresponding, more concise `for` loop:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相应的更简洁的`for`循环：
- en: '[PRE125]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The structure of a `for` statement is:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句的结构是：'
- en: '[PRE126]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The expression *start* is evaluated once, at the beginning of the `for` statement.
    Each time through the loop, the expression *condition* is tested. If it is `true`,
    the body of the loop is executed; if it is `false`, the loop ends. The expression
    *increment* is evaluated after the loop body runs.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式*start*在`for`语句开始时评估一次。每次循环时，表达式*condition*被测试。如果为`true`，则执行循环体；如果为`false`，则循环结束。表达式*increment*在运行循环体后评估。
- en: 'The alternative syntax of a `for` statement is:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`语句的替代语法是：'
- en: '[PRE127]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'This program adds the numbers from 1 to 10 using a `for` loop:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序使用`for`循环将数字从1加到10：
- en: '[PRE128]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Here’s the same loop using the alternate syntax:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替代语法的相同循环如下所示：
- en: '[PRE129]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'You can specify multiple expressions for any of the expressions in a `for`
    statement by separating the expressions with commas. For example:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过用逗号分隔表达式来为`for`语句中的任何表达式指定多个表达式。例如：
- en: '[PRE130]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'You can also leave an expression empty, signaling that nothing should be done
    for that phase. In the most degenerate form, the `for` statement becomes an infinite
    loop. You probably don’t want to run this example, as it never stops printing:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将表达式留空，表示该阶段不执行任何操作。在最简单的情况下，`for`语句变成一个无限循环。您可能不希望运行此示例，因为它永远不会停止打印：
- en: '[PRE131]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: In `for` loops, as in `while` loops, you can use the `break` and `continue`
    keywords to end the loop or the current iteration.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`循环中，与`while`循环一样，您可以使用`break`和`continue`关键字来结束循环或当前迭代。
- en: foreach
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: foreach
- en: 'The `foreach` statement allows you to iterate over elements in an array. The
    two forms of the `foreach` statement are further discussed in [Chapter 5](ch05.xhtml#array),
    where we talk in more depth about arrays. To loop over an array, accessing the
    value at each key, use:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`语句允许您遍历数组中的元素。在[第五章](ch05.xhtml#array)中进一步讨论了`foreach`语句的两种形式，更深入地讨论了数组。要循环访问数组并访问每个键处的值，请使用：'
- en: '[PRE132]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The alternate syntax is:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 替代语法是：
- en: '[PRE133]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'To loop over an array, accessing both key and value, use:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 要循环访问数组并访问键和值，请使用：
- en: '[PRE134]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The alternate syntax is:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 替代语法是：
- en: '[PRE135]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: try...catch
  id: totrans-670
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try...catch
- en: 'The `try...catch` construct is not so much a flow-control structure as it is
    a more graceful way to handle system errors. For example, if you want to ensure
    that your web application has a valid connection to a database before continuing,
    you could write code like this:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '`try...catch`结构不仅仅是一个流程控制结构，它更像是一种更优雅的处理系统错误的方式。例如，如果要确保您的Web应用在继续之前有一个有效的连接到数据库，您可以编写如下代码：'
- en: '[PRE136]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Here the connection is attempted with the `try` portion of the construct and
    if there are any errors with it, the flow of the code automatically falls into
    the `catch` portion, where the `PDOException` class is instantiated into the `$error`
    variable. It can then be displayed on the screen and the code can “gracefully”
    fail, rather than making an abrupt end. You can even redirect to try connecting
    to an alternate database, or respond to the error any other way you wish within
    the `catch` portion.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，连接尝试使用构造的`try`部分，并且如果有任何与之相关的错误，则代码流会自动跳转到`catch`部分，其中`PDOException`类被实例化到`$error`变量中。然后可以在屏幕上显示它，并且代码可以“优雅”地失败，而不是突然结束。甚至可以尝试连接到备用数据库，或者在`catch`部分内以其他任何方式响应错误。
- en: Note
  id: totrans-674
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: See [Chapter 9](ch09.xhtml#databases-id00007) for more examples of `try...catch`
    in relation to PDO (PHP Data Objects) and transaction processing.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[第九章](ch09.xhtml#databases-id00007)，了解与PDO（PHP数据对象）和事务处理相关的更多`try...catch`示例。
- en: declare
  id: totrans-676
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: declare
- en: 'The `declare` statement allows you to specify execution directives for a block
    of code. The structure of a `declare` statement is:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '`declare`语句允许您为代码块指定执行指令。`declare`语句的结构如下：'
- en: '[PRE137]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Currently, there are only three `declare` forms: the `ticks`, `encoding`, and
    `strict_types` directives. You can use the `ticks` directive to specify how frequently
    (measured roughly in number of code statements) a tick function is registered
    when `register_tick_function()` is called. For example:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 目前只有三种`declare`形式：`ticks`、`encoding`和`strict_types`指令。您可以使用`ticks`指令指定在调用`register_tick_function()`时注册tick函数的频率（大致以代码语句数量计算）。例如：
- en: '[PRE138]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: In this code, `someFunction()` is called after every third statement within
    the block is executed.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，在执行块内每三条语句后都调用`someFunction()`。
- en: 'You can use the `encoding` directive to specify a PHP script’s output encoding.
    For example:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`encoding`指令指定PHP脚本的输出编码。例如：
- en: '[PRE139]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: This form of the `declare` statement is ignored unless you compile PHP with
    the `--enable-zend-multibyte` option.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 除非使用`--enable-zend-multibyte`选项编译PHP，否则会忽略此形式的`declare`语句。
- en: Finally, you can use the `strict_types` directive to enforce the use of strict
    data types when defining and using variables.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用`strict_types`指令在定义和使用变量时强制使用严格数据类型。
- en: exit and return
  id: totrans-686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出和返回
- en: As soon as it is reached, the `exit` statement ends the script’s execution.
    The `return` statement returns from a function or, at the top level of the program,
    from the script.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到达，`exit`语句将结束脚本的执行。`return`语句从函数中返回，或者在程序顶层时从脚本返回。
- en: 'The `exit` statement takes an optional value. If this is a number, it is the
    exit status of the process. If it is a string, the value is printed before the
    process terminates. The function `die()` is an alias for this form of the `exit`
    statement:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '`exit`语句接受一个可选值。如果是数字，则为进程的退出状态。如果是字符串，则在进程终止之前打印该值。函数`die()`是此形式`exit`语句的别名：'
- en: '[PRE140]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'This is more commonly written as:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被写成：
- en: '[PRE141]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: See [Chapter 3](ch03.xhtml#functions) for more information on using the `return`
    statement in functions.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[第三章](ch03.xhtml#functions)，了解在函数中使用`return`语句的更多信息。
- en: goto
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转到
- en: 'The `goto` statement allows execution to “jump” to another place in the program.
    You specify execution points by adding a label, which is an identifier followed
    by a colon (`:`). You then jump to the label from another location in the script
    via the `goto` statement:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '`goto` 语句允许执行“跳转”到程序的另一个位置。您通过添加标签来指定执行点，标签是由标识符后跟冒号（`:`）组成。然后，您可以通过 `goto`
    语句从脚本的另一个位置跳转到该标签：'
- en: '[PRE142]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: You can only `goto` a label within the same scope as the `goto` statement itself,
    and you can’t jump into a loop or switch. Generally, anywhere you might use a
    `goto` (or multilevel `break` statement, for that matter), you can rewrite the
    code to be cleaner without it.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能在与 `goto` 语句本身相同的作用域内跳转到标签，并且不能跳转到循环或开关中。通常，您可以重写代码以更清晰地处理 `goto`（或多级 `break`
    语句）的任何地方。
- en: Including Code
  id: totrans-697
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包括代码
- en: 'PHP provides two constructs to load code and HTML from another module: `require`
    and `include`. Both load a file as the PHP script runs, work in conditionals and
    loops, and complain if the file being loaded cannot be found. Files are located
    by an included file path as part of the directive in the use of the function,
    or based on the setting of `include_path` in the *php.ini* file. The `include_path`
    can be overridden by the `set_include_path()` function. If all these avenues fail,
    PHP’s last attempt is to try to find the file in the same directory as the calling
    script. The main difference is that attempting to `require` a nonexistent file
    is a fatal error, while attempting to `include` such a file produces a warning
    but does not stop script execution.'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了两种结构来加载来自另一个模块的代码和HTML：`require` 和 `include`。这两者在 PHP 脚本运行时加载文件，在条件和循环中工作，并在找不到要加载的文件时报错。文件可以通过使用函数中的包含文件路径作为指令的一部分来定位，或者基于
    *php.ini* 文件中 `include_path` 的设置。`include_path` 可以通过 `set_include_path()` 函数进行覆盖。如果所有这些途径都失败了，PHP
    的最后尝试是在调用脚本的同一目录中查找文件。主要区别在于尝试 `require` 一个不存在的文件会导致致命错误，而尝试 `include` 这样一个文件会产生警告但不会停止脚本执行。
- en: 'A common use of `include` is to separate page-specific content from general
    site design. Common elements such as headers and footers go in separate HTML files,
    and each page then looks like:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '`include` 的常见用途是将特定于页面的内容与通用站点设计分离。常见元素（如标题和页脚）放在单独的 HTML 文件中，然后每个页面看起来像：'
- en: '[PRE143]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'We use `include` because it allows PHP to continue to process the page even
    if there’s an error in the site design file(s). The `require` construct is less
    forgiving and is more suited to loading code libraries, where the page cannot
    be displayed if the libraries do not load. For example:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `include` 是因为它允许 PHP 继续处理页面，即使在站点设计文件中存在错误。`require` 结构则不太宽容，更适合加载代码库，如果库未加载，则无法显示页面。例如：
- en: '[PRE144]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'A marginally more efficient way to handle headers and footers is to load a
    single file and then call functions to generate the standardized site elements:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 处理标题和页脚的稍微更有效的方法是加载单个文件，然后调用函数生成标准化的站点元素：
- en: '[PRE145]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: If PHP cannot parse some part of a file added by `include` or `require`, a warning
    is printed and execution continues. You can silence the warning by prepending
    the call with the silence operator (`@`)—for example, `@include`.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 PHP 无法解析通过 `include` 或 `require` 添加的文件的某些部分，则会打印警告并继续执行。您可以在调用前加上静默操作符（`@`）来消除警告
    - 例如，`@include`。
- en: 'If the `allow_url_fopen` option is enabled through PHP’s configuration file,
    *php.ini*, you can include files from a remote site by providing a URL instead
    of a simple local path:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 如果通过 PHP 的配置文件 *php.ini* 启用了 `allow_url_fopen` 选项，则可以通过提供 URL 而不是简单的本地路径来包含来自远程站点的文件：
- en: '[PRE146]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: If the filename begins with *http://*, *https://*, or *ftp://*, the file is
    retrieved from a remote site and loaded.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件名以 *http://*、*https://* 或 *ftp://* 开头，则从远程站点检索并加载文件。
- en: Files included with `include` and `require` can be arbitrarily named. Common
    extensions are *.php*, *.php5*, and *.html*.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `include` 和 `require` 包含的文件可以任意命名。常见的扩展名包括 *.php*、*.php5* 和 *.html*。
- en: Note
  id: totrans-710
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that remotely fetching a file that ends in *.php* from a web server that
    has PHP enabled fetches the *output* of that PHP script—it executes the PHP code
    in that file.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从启用了 PHP 的 Web 服务器获取以 *.php* 结尾的文件将获取该 PHP 脚本的输出 - 它执行该文件中的 PHP 代码。
- en: If a program uses `include` or `require` to include the same file twice (mistakenly
    done in a loop, for example), the file is loaded and the code is run, or the HTML
    is printed twice. This can result in errors about the redefinition of functions,
    or multiple copies of headers or HTML being sent. To prevent these errors from
    occurring, use the `include_once` and `require_once` constructs. They behave the
    same as `include` and `require` the first time a file is loaded, but quietly ignore
    subsequent attempts to load the same file. For example, many page elements, each
    stored in separate files, need to know the current user’s preferences. The element
    libraries should load the user preferences library with `require_once`. The page
    designer can then include a page element without worrying about whether the user
    preference code has already been loaded.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序使用`include`或`require`两次包含同一文件（例如在循环中错误地执行），则加载文件并运行代码，或者HTML打印两次。这可能导致关于函数重定义的错误，或者发送多个标题或HTML副本。为防止这些错误发生，使用`include_once`和`require_once`结构。它们在第一次加载文件时行为与`include`和`require`相同，但会静默地忽略后续尝试加载同一文件。例如，许多页面元素，每个存储在单独文件中，需要知道当前用户的偏好设置。元素库应使用`require_once`加载用户偏好设置库。然后页面设计人员可以包含一个页面元素，而不必担心用户偏好代码是否已加载。
- en: 'Code in an included file is imported at the scope that is in effect where the
    `include` statement is found, so the included code can see and alter your code’s
    variables. This can be useful—for instance, a user-tracking library might store
    the current user’s name in the global `$user` variable:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含文件中的代码被导入到`include`语句所在位置的作用域中，因此包含的代码可以查看和更改您的代码的变量。这可能是有用的——例如，用户跟踪库可能会将当前用户的名称存储在全局`$user`变量中：
- en: '[PRE147]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: The ability of libraries to see and change your variables can also be a problem.
    You have to know every global variable used by a library to ensure that you don’t
    accidentally try to use one of them for your own purposes, thereby overwriting
    the library’s value and disrupting how it works.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 库查看和更改您的变量的能力也可能是一个问题。您必须知道库使用的每个全局变量，以确保不会意外尝试将其中一个用于自己的目的，从而覆盖库的值并扰乱其工作方式。
- en: If the `include` or `require` construct is in a function, the variables in the
    included file become function-scope variables for that function.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`include`或`require`结构位于函数中，则包含文件中的变量成为该函数的函数作用域变量。
- en: 'Because `include` and `require` are keywords, not real statements, you must
    always enclose them in curly braces in conditional and loop statements:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`include`和`require`是关键字，而不是真正的语句，所以在条件和循环语句中，您必须始终将它们括在花括号中：
- en: '[PRE148]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Use the `get_included_files()` function to learn which files your script has
    included or required. It returns an array containing the full system path filenames
    of each included or required file. Files that did not parse are not included in
    this array.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get_included_files()`函数来了解您的脚本包含或需要的文件。它返回一个包含每个已包含或需要的文件的完整系统路径文件名的数组。未解析的文件不包括在此数组中。
- en: Embedding PHP in Web Pages
  id: totrans-720
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Web页面中嵌入PHP
- en: Although it is possible to write and run standalone PHP programs, most PHP code
    is embedded in HTML or XML files. This is, after all, why it was created in the
    first place. Processing such documents involves replacing each chunk of PHP source
    code with the output it produces when executed.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以编写并运行独立的PHP程序，但大多数PHP代码都嵌入在HTML或XML文件中。毕竟，这正是它首次创建的原因。处理这些文档涉及将每个PHP源代码块替换为执行时产生的输出。
- en: Because a single file usually contains PHP and non-PHP source code, we need
    a way to identify the regions of PHP code to be executed. PHP provides four different
    ways to do this.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 因为单个文件通常包含PHP和非PHP源代码，我们需要一种方法来识别要执行的PHP代码区域。PHP提供了四种不同的方法来实现这一点。
- en: As you’ll see, the first, and preferred, method looks like XML. The second method
    looks like SGML. The third method is based on ASP tags. The fourth method uses
    the standard HTML `<script>` tag; this makes it easy to edit pages with enabled
    PHP using a regular HTML editor.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将看到的，第一种和首选的方法看起来像XML。第二种方法看起来像SGML。第三种方法基于ASP标签。第四种方法使用标准的HTML `<script>`
    标签；这使得可以使用常规HTML编辑器轻松编辑启用PHP的页面。
- en: Standard (XML) Style
  id: totrans-724
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准（XML）样式
- en: Because of the advent of the eXtensible Markup Language (XML) and the migration
    of HTML to an XML language (XHTML), the currently preferred technique for embedding
    PHP uses XML-compliant tags to denote PHP instructions.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可扩展标记语言（XML）的出现以及HTML向XML语言（XHTML）的迁移，目前首选的嵌入PHP的技术使用符合XML的标记来表示PHP指令。
- en: 'Coming up with tags to demark PHP commands in XML was easy, because XML allows
    the definition of new tags. To use this style, surround your PHP code with `<?php`
    and `?>`. Everything between these markers is interpreted as PHP, and anything
    outside the markers is not. Although it is not necessary to include spaces between
    the markers and the enclosed text, doing so improves readability. For example,
    to get PHP to print “Hello, world,” you can insert the following line in a web
    page:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在XML中定义PHP命令标签很容易，因为XML允许定义新标签。要使用此样式，请用`<?php`和`?>`包围你的PHP代码。这些标记之间的所有内容都被解释为PHP，标记外的内容则不是。虽然不必在标记和封闭文本之间包含空格，但这样做会增加可读性。例如，要让PHP打印“Hello,
    world”，可以在网页中插入以下行：
- en: '[PRE149]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'The trailing semicolon on the statement is optional, because the end of the
    block also forces the end of the expression. Embedded in a complete HTML file,
    this looks like:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 语句的结尾分号是可选的，因为块的结尾也强制结束表达式。嵌入在完整的HTML文件中时，看起来像这样：
- en: '[PRE150]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Of course, this isn’t very exciting—we could have done it without PHP. The
    real value of PHP comes when we put dynamic information from sources such as databases
    and form values into the web page. That’s for a later chapter, though. Let’s get
    back to our “Hello, world” example. When a user visits this page and views its
    source, it looks like this:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是很令人兴奋——我们可以在没有PHP的情况下完成它。PHP真正的价值在于我们将来会将来自数据库和表单值等来源的动态信息放入网页中。不过，这是后面的章节内容了。让我们回到我们的“Hello,
    world”示例。当用户访问此页面并查看其源代码时，看起来像这样：
- en: '[PRE151]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Notice that there’s no trace of the PHP source code from the original file.
    The user sees only its output.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，原始文件中的PHP源代码已经消失了。用户只看到其输出。
- en: 'Also notice that we switched between PHP and non-PHP, all in the space of a
    single line. PHP instructions can be put anywhere in a file, even within valid
    HTML tags. For example:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们在一行内在PHP和非PHP之间切换。PHP指令可以放在文件中的任何位置，甚至在有效的HTML标记内。例如：
- en: '[PRE152]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'When PHP is done with this text, it will read:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 当PHP完成此文本时，将读取：
- en: '[PRE153]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The PHP code within the opening and closing markers does not have to be on
    the same line. If the closing marker of a PHP instruction is the last thing on
    a line, the line break following the closing tag is removed as well. Thus, we
    can replace the PHP instructions in the “Hello, world” example with:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 开始和结束标记内的PHP代码不必在同一行上。如果PHP指令的结束标记是最后一行的内容，那么跟在结束标记后的换行符也会被移除。因此，我们可以用以下方式替换“Hello,
    world”示例中的PHP指令：
- en: '[PRE154]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: with no change in the resulting HTML.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 结果HTML没有任何变化。
- en: SGML Style
  id: totrans-740
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SGML风格
- en: 'Another style of embedding PHP comes from SGML instruction processing tags.
    To use this method, simply enclose the PHP in `<?` and `?>`. Here’s the “Hello,
    world” example again:'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种嵌入PHP的样式来自SGML指令处理标签。要使用此方法，只需在`<?`和`?>`中包围PHP即可。以下是“Hello, world”示例：
- en: '[PRE155]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: This style, known as *short tags*, is off by default. You can turn on support
    for short tags by building PHP with the `--enable-short-tags` option, or enable
    `short_open_tag` in the PHP configuration file. This is discouraged as it depends
    on the state of this setting; if you export your code to another platform, it
    may or may not work.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格称为*短标签*，默认情况下是关闭的。可以通过使用`--enable-short-tags`选项构建PHP或在PHP配置文件中启用`short_open_tag`来支持短标签。这是不鼓励的，因为它依赖于此设置的状态；如果将代码导出到另一个平台，可能会工作也可能不会。
- en: The short echo tag, `<?= ... ?>`, is available regardless of the availability
    of short tags.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 内联代码，`<?= ... ?>`，即使短标签不可用也可以使用。
- en: Echoing Content Directly
  id: totrans-745
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接回显内容
- en: Perhaps the single most common operation within a PHP application is displaying
    data to the user. In the context of a web application, this means inserting into
    the HTML document information that will become HTML when viewed by the user.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP应用程序中最常见的操作之一可能是向用户显示数据。在Web应用程序的上下文中，这意味着将将在用户查看时变成HTML的信息插入到HTML文档中。
- en: 'To simplify this operation, PHP provides a special version of the SGML tags
    that automatically take the value inside the tag and insert it into the HTML page.
    To use this feature, add an equals sign (`=`) to the opening tag. With this technique,
    we can rewrite our form example as:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个操作，PHP提供了一种特殊版本的SGML标记，它自动获取标记内部的值并将其插入到HTML页面中。要使用此功能，请在开放标记中添加等号（`=`）。使用此技术，我们可以将我们的表单示例重写为：
- en: '[PRE156]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: What’s Next
  id: totrans-749
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: 'Now that you have the basics of the language under your belt—a foundational
    understanding of what variables are and how to name them, what data types are,
    and how code flow control works—we will move on to some finer details of the PHP
    language. Next we’ll cover three topics that are so important to PHP that they
    each have their own dedicated chapters: how to define functions ([Chapter 3](ch03.xhtml#functions)),
    manipulate strings ([Chapter 4](ch04.xhtml#strings)), and manage arrays ([Chapter 5](ch05.xhtml#array)).'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经掌握了语言的基础——变量的基本理解及其命名方式，数据类型的概念，以及代码流控制的工作原理——我们将继续讨论PHP语言的一些细节。接下来，我们将涵盖三个对PHP非常重要的主题，它们各自都有专门的章节：如何定义函数（[第3章](ch03.xhtml#functions)），操作字符串（[第4章](ch04.xhtml#strings)），以及管理数组（[第5章](ch05.xhtml#array)）。
- en: ^([1](ch02.xhtml#ch02fn1-marker)) It is actually 3 if you are looking at the
    reference count from the C API, but for the purposes of this explanation and from
    a user-space perspective, it is easier to think of it as 2.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch02.xhtml#ch02fn1-marker)) 如果您从C API的角度看引用计数，实际上是3，但为了本说明以及从用户空间的角度来看，将其视为2更容易理解。
- en: '^([2](ch02.xhtml#ch02fn2-marker)) Here’s a tip: split the binary number into
    three groups—6 is binary 110, 5 is binary 101, and 1 is binary 001; thus, 0651
    is 110101001.'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch02.xhtml#ch02fn2-marker)) 这里有个小提示：将二进制数分成三组——6是二进制110，5是二进制101，1是二进制001；因此，0651的二进制表示为110101001。
