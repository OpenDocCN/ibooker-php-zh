- en: Chapter 17\. Asynchronous PHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章\. 异步PHP
- en: Many basic PHP scripts handle operations synchronously—meaning the script runs
    one monolithic process from start to finish and only does one thing at a time.
    However, more sophisticated applications have become commonplace in the world
    of PHP, so more advanced modes of operation are required as well. Namely, asynchronous
    programming has quickly become a rising concept for PHP developers. Learning how
    to do two (or more) things at the same time within your scripts is vital to building
    modern applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多基本的PHP脚本处理操作是同步的——意味着脚本从开始到结束运行一个单体过程，并且一次只做一件事情。然而，在PHP世界中，更复杂的应用程序已经变得司空见惯，因此也需要更先进的操作模式。特别是，异步编程迅速成为PHP开发者的新兴概念。学习如何在你的脚本中同时执行两个（或多个）任务对于构建现代化应用程序至关重要。
- en: 'Two words come up frequently when discussing asynchronous programming: *concurrent*
    and *parallel*. When most people talk about parallel programming, what they really
    mean to say is *concurrent programming*. With concurrency, your application does
    two things but not necessarily at the same time. Think of a single barista serving
    multiple customers at once—the barista is multitasking and making several different
    drinks but can really only make one drink at a time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论异步编程时经常会涉及两个词汇：*并发*和*并行*。当大多数人谈论并行编程时，他们实际上指的是*并发编程*。通过并发，您的应用程序可以同时做两件事情，但不一定是同时进行。可以想象一个咖啡师同时为多位顾客提供服务——咖啡师在多任务处理和制作多种饮品，但实际上只能同时制作一种饮品。
- en: With parallel operations, you are doing two different things simultaneously.
    Imagine installing a drip coffee machine on the counter in the cafe. Some patrons
    are still being served by the barista, but others can get their caffeine fix from
    a separate machine in parallel. [Figure 17-1](#concurrent_vs_parallel) depicts
    concurrent and parallel operations through the barista analogy.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并行操作时，您可以同时执行两个不同的任务。想象在咖啡店的柜台上安装了一个滴漏咖啡机。一些顾客仍然由咖啡师服务，但其他顾客可以从另一台机器中并行地得到他们的咖啡因。[图17-1](#concurrent_vs_parallel)通过咖啡师类比描绘了并发和并行操作。
- en: '![Concurrent versus parallel modes of operation](assets/phpc_1701.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![并行与并发操作模式](assets/phpc_1701.png)'
- en: Figure 17-1\. Concurrent versus parallel modes of operation
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图17-1\. 并行与并发操作模式
- en: Note
  id: totrans-6
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: There is also a third concept of *concurrent parallel* operations, which is
    when two work streams operate at the same time (parallel) but also multitask their
    individual work streams (concurrent). While this composite concept is useful,
    this chapter instead focuses on the two separate concepts alone.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三个*并行并发*操作的概念，即两个工作流同时进行（并行），同时还在各自的工作流中进行多任务处理（并发）。虽然这种复合概念很有用，但本章节专注于单独讨论这两个概念。
- en: Most PHP you’ll find in the wild, whether modern or legacy, is written to leverage
    a single thread of execution. The code is written to be neither concurrent nor
    parallel. In fact, many developers avoid PHP entirely when they want to leverage
    concurrent or parallel concepts and turn to languages like JavaScript or Go for
    their applications. Modern PHP, though, fully supports both modes of execution—with
    or without additional libraries.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在野外找到的大多数PHP，无论是现代的还是传统的，都是为了利用单线程执行而编写的。代码既不是并发的也不是并行的。事实上，许多开发人员在想要利用并发或并行概念时完全避开PHP，转而使用像JavaScript或Go这样的语言。不过，现代PHP完全支持执行模式——无论是否使用额外的库。
- en: Libraries and Runtimes
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 库和运行时
- en: PHP’s native support for parallel and concurrent operations is relatively new
    to the language and difficult to use in practice. However, several libraries abstract
    away the difficulty of working in parallel to make truly asynchronous applications
    more straightforward to build.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: PHP对并行和并发操作的原生支持相对较新，并且在实践中使用起来具有一定的难度。然而，有几个库可以抽象出并行工作的难度，使得构建真正的异步应用程序变得更加简单。
- en: AMPHP
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: AMPHP
- en: The [AMPHP project](https://amphp.org) is a Composer-installable framework that
    provides event-driven concurrency for PHP. AMPHP provides a rich set of functions
    and objects empowering you to fully master asynchronous PHP. Specifically, AMPHP
    provides a full event loop as well as efficient abstractions for promises, coroutines,
    asynchronous iterators, and streams.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[AMPHP项目](https://amphp.org)是一个可以通过Composer安装的框架，为PHP提供事件驱动的并发支持。AMPHP提供了丰富的函数和对象，使您能够完全掌握异步PHP。具体而言，AMPHP提供了完整的事件循环以及有效的promise、协程、异步迭代器和流的抽象。'
- en: ReactPHP
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ReactPHP
- en: Similar to AMPHP, [ReactPHP](https://reactphp.org) is a Composer-installable
    library offering event-driven functionality and abstractions to PHP. It provides
    an event loop but also ships fully functional asynchronous server components like
    a socket client and a DNS resolver.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 与 AMPHP 类似，[ReactPHP](https://reactphp.org) 是一个可以通过 Composer 安装的库，提供事件驱动功能和对
    PHP 的抽象。它提供了事件循环，同时还提供了完全功能的异步服务器组件，如套接字客户端和 DNS 解析器。
- en: Open Swoole
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Open Swoole
- en: '[Open Swoole](https://openswoole.com) is a lower-level PHP extension that can
    be installed via PECL. Like AMPHP and ReactPHP, Open Swoole provides an asynchronous
    framework and implementations of both promises and coroutines. Because it is a
    compiled extension (rather than a PHP library), Open Swoole performs significantly
    better than various alternatives. It also supports true parallelism in your code,
    rather than merely concurrent execution of tasks.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[Open Swoole](https://openswoole.com) 是一个可以通过 PECL 安装的低级 PHP 扩展。类似于 AMPHP 和
    ReactPHP，Open Swoole 提供了一个异步框架，并实现了承诺和协程。由于它是一个编译扩展（而不是 PHP 库），Open Swoole 的性能显著优于各种替代方案。它还支持在代码中实现真正的并行性，而不仅仅是任务的并发执行。'
- en: RoadRunner
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RoadRunner
- en: The [RoadRunner project](https://roadrunner.dev) is an alternative PHP runtime
    implemented in Go. It provides the same PHP interface you’re used to but ships
    its own application server and asynchronous process manager. RoadRunner empowers
    you to keep your entire application in memory and invoke atomic processes in parallel
    to the application’s execution whenever needed.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[RoadRunner 项目](https://roadrunner.dev) 是一个用 Go 实现的替代 PHP 运行时环境。它提供了与您熟悉的相同
    PHP 接口，但提供了自己的应用服务器和异步进程管理器。RoadRunner 赋予您能力，可以在内存中保留整个应用程序，并在需要时并行调用应用程序执行的原子进程。'
- en: Octane
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Octane
- en: In 2021, the web application framework Laravel introduced a new project called
    [Octane](https://oreil.ly/bLnkA) that leverages either Open Swoole or Roadrunner
    to “supercharge your application’s performance.” Whereas framework-level tools
    like AMPHP or ReactPHP allow you to intentionally write asynchronous code, Octane
    leverages the asynchronous foundations of Open Swoole or RoadRunner to accelerate
    the operation of an existing Laravel-based application.^([1](ch17.html#idm45875136412672))
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 2021 年，Web 应用程序框架 Laravel 推出了一个名为 [Octane](https://oreil.ly/bLnkA) 的新项目，利用 Open
    Swoole 或 Roadrunner 来“大幅提升您的应用性能”。与像 AMPHP 或 ReactPHP 这样的框架级工具允许您有意识地编写异步代码不同，Octane
    利用 Open Swoole 或 RoadRunner 的异步基础来加速现有基于 Laravel 的应用程序的操作。^([1](ch17.html#idm45875136412672))
- en: Understanding Asynchronous Operations
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解异步操作
- en: 'To fully understand asynchronous PHP, you need to understand at least two specific
    concepts: promises and coroutines.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全理解异步 PHP，您至少需要理解两个具体概念：承诺（promises）和协程（coroutines）。
- en: Promises
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 承诺
- en: In software, a *promise* is an object returned by a function that operates asynchronously.
    Rather than representing a discrete value, though, the promise represents the
    overall state of the operation. When first returned by the function, the promise
    will have no inherent value, as the operation itself is not yet complete. Instead,
    it will be in a *pending* state indicating that the program should do something
    else while an asynchronous operation completes in the background.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件中，*承诺* 是由异步函数返回的对象。不同于表示离散值，承诺代表操作的整体状态。当函数首次返回时，承诺将没有固有值，因为操作本身尚未完成。相反，它将处于*待定*状态，指示程序在后台完成异步操作时应执行其他操作。
- en: When the operation *does* complete, the promise will be either fulfilled or
    rejected. The fulfilled state exists when things went well and a discrete value
    is returned; the rejected state exists when something failed and an error is returned
    instead.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作**完成**时，承诺将被满足或拒绝。当事情顺利进行并返回一个具体值时，承诺将处于满足状态；当某些事情失败并返回错误时，承诺将处于拒绝状态。
- en: 'The AMPHP project implements promises by using generators and bundles both
    the fulfilled and rejected state into an `onResolve()` method on the promise object.
    For example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: AMPHP 项目通过使用生成器实现承诺，并将满足和拒绝状态捆绑到承诺对象的 `onResolve()` 方法中。例如：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Alternatively, the ReactPHP project implements the same [promise specification
    as JavaScript](https://oreil.ly/ZRwcW), enabling you to use the `then()` construct
    that might be familiar to Node.js programmers. For example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，ReactPHP 项目实现了与 JavaScript 相同的 [承诺规范](https://oreil.ly/ZRwcW)，使您可以使用可能对 Node.js
    程序员熟悉的 `then()` 结构。例如：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While the APIs presented for promises by both AMPHP and ReactPHP are somewhat
    unique, they are fairly interoperable. AMPHP explicitly does not conform to JavaScript-style
    promise abstractions in order to fully leverage PHP generators. However, it does
    accept instances of ReactPHP’s `PromiseInterface` wherever it works with its own
    `Promise` instance.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 AMPHP 和 ReactPHP 针对 promises 提供的 API 有些独特，但它们之间是相当可互操作的。AMPHP 明确不遵循 JavaScript
    风格的 promise 抽象，以便充分利用 PHP 生成器。然而，它确实接受 ReactPHP 的`PromiseInterface`实例，在与其自身的`Promise`实例一起使用时。
- en: Both APIs are incredibly powerful, and both projects expose efficient asynchronous
    abstractions for PHP. However, for simplicity, this book focuses on the AMPHP
    implementations of asynchronous code as they’re more native to core PHP functionality.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个 API 都非常强大，两个项目都为 PHP 提供了高效的异步抽象。然而，为了简单起见，本书重点介绍了 AMPHP 实现的异步代码，因为它们更符合核心
    PHP 功能。
- en: Coroutines
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协程
- en: A *coroutine* is a function that can be interrupted to allow another operation
    to proceed. In PHP, particularly with the AMPHP framework, coroutines are implemented
    with generators leveraging the `yield` keyword to suspend operation.^([2](ch17.html#idm45875136332736))
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*协程*是一个可以被中断以允许其他操作继续的函数。特别是在 PHP 中，使用 AMPHP 框架，协程是通过利用`yield`关键字实现的生成器。'
- en: While a traditional generator uses the `yield` keyword to return a value as
    part of an iterator, AMPHP uses the same keyword as a functional interrupt in
    a coroutine. The value is still returned, but execution of the coroutine itself
    is interrupted to allow other operations (like other coroutines) to proceed. When
    a promise is returned in a coroutine, the coroutine keeps track of the promise’s
    state and automatically resumes execution when it’s resolved.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然传统生成器使用`yield`关键字作为迭代器的一部分返回值，但在 AMPHP 中，它使用相同的关键字作为协程中的功能性中断。值仍然被返回，但协程本身的执行被中断以允许其他操作（如其他协程）继续。当在协程中返回一个
    promise 时，协程会跟踪 promise 的状态，并在解决时自动恢复执行。
- en: 'As an example, you can leverage asynchronous server requests via coroutines
    directly in AMPHP. The following code illustrates how coroutines are used both
    to retrieve a page and decode the body of its response, yielding a promise object
    useful elsewhere in your code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以直接在 AMPHP 中利用协程实现异步服务器请求。以下代码示例说明了如何使用协程来获取页面并解码其响应体，生成一个在代码中其他地方有用的 promise
    对象：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Fibers
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Fibers
- en: The newest concurrency feature in PHP, as of version 8.1, is Fiber. Under the
    hood, a Fiber abstracts a completely separate thread of operation that can be
    controlled by your application’s primary process. The Fiber doesn’t run in parallel
    to the main application but presents a separate execution stack with its own variables
    and state.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 PHP 8.1 版本的最新并发特性，Fiber 是一个全新的功能。在内部，Fiber 抽象了一个完全独立的操作线程，可以由应用程序的主进程控制。Fiber
    不会与主应用程序并行运行，但会展示一个具有自己变量和状态的单独执行栈。
- en: Through Fibers, you can essentially run an entirely independent subapplication
    from within your main one and explicitly control how the concurrent operation
    of each is handled.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 Fibers，你可以在主应用程序内运行一个完全独立的子应用程序，并明确控制每个并发操作的处理方式。
- en: 'When a Fiber starts, it runs until it either completes execution or calls `suspend()`
    to yield control back to and return a value to the parent process (thread). It
    can then be restarted by the parent with `resume()`. The official documentation
    example that follows illustrates this concept succinctly:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Fiber 启动时，它会一直运行，直到执行完成或调用`suspend()`将控制权返回给父进程（线程），并向其返回一个值。然后可以通过父进程使用`resume()`来重新启动它。官方文档中的示例清楚地说明了这个概念：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Fibers aren’t meant to be used directly by developer code but are instead a
    low-level interface useful to frameworks like AMPHP and ReactPHP. These frameworks
    can leverage Fibers to fully abstract the execution environments of coroutines,
    keeping your application state clean and better managing its concurrency.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Fiber 并不打算被开发者直接使用，而是一个低级接口，对于像 AMPHP 和 ReactPHP 这样的框架非常有用。这些框架可以利用 Fiber 完全抽象协程的执行环境，保持应用程序状态清晰，并更好地管理并发。
- en: The recipes that follow cover the ins and outs of working with both concurrent
    and parallel code in PHP. You’ll see how to manage multiple concurrent requests,
    how to structure asynchronous coroutines, and even how to leverage PHP’s native
    Fiber implementation.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的配方涵盖了在PHP中处理并发和并行代码的各个方面。您将看到如何管理多个并发请求，如何构造异步协程，甚至如何利用PHP的原生Fiber实现。
- en: 17.1 Fetching Data from Remote APIs Asynchronously
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.1 异步从远程API获取数据
- en: Problem
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to fetch data from multiple remote servers at the same time and act
    on the result once they have all returned data.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望同时从多个远程服务器获取数据，并在它们全部返回数据后对结果进行操作。
- en: Solution
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `http-client` module from the AMPHP project to make multiple concurrent
    requests as individual promises and then act once all of the requests have returned.
    For example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用AMPHP项目中的`http-client`模块，将多个并发请求作为单独的promise发出，然后一旦所有请求都返回，就采取行动。例如：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: In a typical synchronous PHP application, your HTTP client would make one request
    at a time and wait for the server’s response before continuing. This sequential
    pattern is fast enough for most implementations but becomes burdensome when managing
    a large number of requests at once.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的同步PHP应用程序中，您的HTTP客户端会一次发出一次请求，并在继续之前等待服务器的响应。这种顺序模式对于大多数实现来说足够快，但在同时管理大量请求时变得繁琐。
- en: The `http-client` module of the AMPHP framework supports making requests concurrently.^([3](ch17.html#idm45875135961808))
    All requests are dispatched in a nonblocking fashion by using promises to wrap
    the state of the request and the eventual result. The magic behind this approach
    isn’t just the concurrent nature of AMPHP’s client; it’s in the `Amp\call()` wrapper
    used to bundle all of the requests together.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: AMPHP框架的`http-client`模块支持以并发方式发出请求。^([3](ch17.html#idm45875135961808)) 所有请求都通过使用promise将请求的状态和最终结果进行包装而以非阻塞方式分派。这种方法背后的魔法不仅仅是AMPHP客户端的并发性质；它还包括用于将所有请求捆绑在一起的`Amp\call()`包装器。
- en: By wrapping an anonymous function with `Amp\call()`, you turn it into a coroutine.^([4](ch17.html#idm45875135957664))
    Within the body of the coroutine, the `yield` keyword instructs the coroutine
    to wait for the response of an asynchronous function; the overall result of the
    coroutine is returned as a `Promise` instance rather than a scalar value. In the
    Solution example, your coroutine is creating a new `Promise` instance for each
    API request and storing them together in a single array.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用`Amp\call()`封装一个匿名函数，你把它变成了一个协程。^([4](ch17.html#idm45875135957664)) 在协程的主体内部，`yield`关键字指示协程等待异步函数的响应；协程的整体结果作为一个`Promise`实例而不是标量值返回。在解决方案示例中，你的协程为每个API请求创建一个新的`Promise`实例，并将它们一起存储在一个单一的数组中。
- en: 'The AMPHP framework then exposes two useful functions that allow you to wait
    until all of your promises have been resolved:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，AMPHP框架暴露了两个有用的函数，允许你等待直到所有的promise都被解决：
- en: '`all()`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()`'
- en: This function takes an array of promises and returns a single promise that will
    resolve once all of the promises in the array have been resolved. The value wrapped
    by this new promise will be an array of its wrapped promises’ values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个promise数组，并返回一个单一的promise，一旦数组中的所有promise都被解决，就会解决。由这个新promise包装的值将是其包装的promise值的数组。
- en: '`wait()`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait()`'
- en: 'This function is exactly what it sounds like: a way to force your application
    to wait for an otherwise asynchronous process to complete. It effectively converts
    the asynchronous code into synchronous code and unwraps the value contained by
    the promise you pass into it.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数就像它的名字听起来的那样：强制你的应用程序等待一个本来是异步的过程完成。它有效地将异步代码转换为同步代码，并解包你传递给它的promise中包含的值。
- en: The Solution example thus makes several concurrent asynchronous requests to
    differing APIs and then bundles their responses into an array suitable for use
    throughout the rest of your otherwise synchronous application.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，解决方案示例同时向不同的API发出了多个并发的异步请求，然后将它们的响应捆绑到一个数组中，以便在你的其余同步应用程序中使用。
- en: Warning
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: While you make requests in a particular order, they might not complete in the
    same order in which you made them. In the Solution example, these three requests
    might always complete in the same order in which you dispatched them. If you increase
    the number of requests, though, the resultant array might have a different order
    than the one you’d expect. It’s a good idea to keep track of a discrete index
    (e.g., use an associative array) so you aren’t surprised down the road when API
    responses have switched their order on you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按特定顺序发出请求时，它们可能不会按照你发出它们的顺序完成。在解决方案示例中，这三个请求可能总是按照你发送它们的顺序完成。然而，如果增加请求的数量，结果数组可能会与你预期的顺序不同。建议跟踪离散索引（例如使用关联数组），这样当
    API 响应按不同顺序返回时，你不会感到惊讶。
- en: See Also
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation for the [`http-client` module from the AMPHP project](https://oreil.ly/OUE0n).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[AMPHP 项目的 `http-client` 模块文档](https://oreil.ly/OUE0n)。'
- en: 17.2 Waiting on the Results of Multiple Asynchronous Operations
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.2 等待多个异步操作的结果
- en: Problem
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to juggle multiple parallel operations and then act on the overall
    result of all of them.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望同时处理多个并行操作，然后根据所有操作的总体结果执行操作。
- en: Solution
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `parallel-functions` module of the AMPHP framework to execute your operations
    truly in parallel and then act on the final response of your entire collection
    of operations, as shown in [Example 17-1](#parallel_array_map).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AMPHP 框架的 `parallel-functions` 模块来真正并行执行你的操作，然后根据所有操作的最终响应进行操作，如 [示例 17-1](#parallel_array_map)
    中所示。
- en: Example 17-1\. Parallel array map example
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-1\. 并行数组映射示例
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_asynchronous_php_CO1-1)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_php_CO1-1)'
- en: This first echo statement is merely used to demonstrate the order in which the
    parallel mapping operation occurs. You will see statements in your console in
    the same order as the array originally passed into `parallelMap()`—specifically,
    `[3, 1, 5, 2, 6]`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 echo 语句仅用于演示并行映射操作发生的顺序。你将在控制台中看到与最初传递给 `parallelMap()` 的数组顺序相同的语句，具体为 `[3,
    1, 5, 2, 6]`。
- en: '[![2](assets/2.png)](#co_asynchronous_php_CO1-2)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_php_CO1-2)'
- en: PHP’s core `sleep()` function is blocking, meaning it will pause execution of
    your program until the input number of seconds has elapsed. This function call
    could be replaced by any other blocking operation with a similar effect. The goal
    in this example is to demonstrate that each operation is truly run in parallel.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 核心的 `sleep()` 函数是阻塞的，这意味着它将暂停程序的执行，直到经过指定秒数为止。此函数调用可以被任何其他具有类似效果的阻塞操作替换。本示例的目标是演示每个操作确实是并行运行的。
- en: '[![3](assets/3.png)](#co_asynchronous_php_CO1-3)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_php_CO1-3)'
- en: After the application finishes waiting for `sleep()`, it will again print a
    message to demonstrate the order in which the parallel operations completed. Note
    that this will be different from the order in which they were originally called!
    Specifically, numbers will be printed in ascending order because of the amount
    of time before each call to `sleep()` finishes.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序完成等待 `sleep()` 后，将再次打印一条消息，以演示并行操作完成的顺序。注意，这将与最初调用它们的顺序不同！具体来说，数字将按升序打印，因为每次调用
    `sleep()` 完成的时间不同。
- en: '[![4](assets/4.png)](#co_asynchronous_php_CO1-4)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_php_CO1-4)'
- en: Any return value from your function will ultimately be wrapped by a `Promise`
    object until the asynchronous operation completes.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你的函数的任何返回值最终都将被 `Promise` 对象包装，直到异步操作完成。
- en: '[![5](assets/5.png)](#co_asynchronous_php_CO1-5)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_php_CO1-5)'
- en: Outside of `Promise\wait()`, all of your collected promises will be resolved,
    and the final variable will contain a scalar value. In this case, that final variable
    will be an array of the squared values of the input array—in the same order as
    the original inputs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Promise\wait()` 之外，所有收集到的 promise 都将被解析，并且最终的变量将包含一个标量值。在本例中，该最终变量将是输入数组元素的平方值数组，顺序与原始输入一致。
- en: Discussion
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `parallel-functions` module is actually an abstraction layer atop AMPHP’s
    `par⁠allel` module. Both can be installed via Composer, and neither requires any
    special extensions to run. However, both will give you true parallel operations
    in PHP.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel-functions` 模块实际上是 AMPHP 的 `parallel` 模块之上的一个抽象层。这两者都可以通过 Composer
    安装，并且都不需要任何特殊的扩展来运行。然而，两者都将在 PHP 中提供真正的并行操作。'
- en: Without any extensions, `parallel` will spawn additional PHP processes to handle
    your asynchronous operations. It handles the creation and collection of child
    processes for you so you can focus on the actual implementation of your code.
    On systems using the [`parallel` extension](https://oreil.ly/kW0n5), the library
    will instead use lighter-weight threads to house your application.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何扩展，`parallel`将会生成额外的 PHP 进程来处理您的异步操作。它会为您处理子进程的创建和收集，让您可以专注于代码的实际实现。在使用[`parallel`扩展](https://oreil.ly/kW0n5)的系统上，该库会使用轻量级线程来运行您的应用程序。
- en: But in every case, your code will look the same. Whether the system uses processes
    or threads under the hood is abstracted away by AMPHP. This allows you to write
    an application that merely leverages `Promise`-level abstractions and trusts everything
    will work expected.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 但在任何情况下，您的代码看起来都一样。无论系统在幕后使用进程还是线程，AMPHP 都将其抽象化了。这使您能够编写一个仅仅利用`Promise`级别抽象的应用程序，并相信一切都会按预期工作。
- en: In [Example 17-1](#parallel_array_map), you defined a function that contained
    some expensive blocking I/O calls. This example specifically used `sleep()` but
    could have been a remote API call, some expensive hashing operation, or a long-running
    database query. In any case, this is the kind of function that will freeze your
    application until it completes, and sometimes you might need to run it multiple
    times.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 17-1](#parallel_array_map)中，您定义了一个包含一些昂贵的阻塞 I/O 调用的函数。这个示例特别使用了`sleep()`，但也可能是远程
    API 调用、一些昂贵的哈希操作或者长时间运行的数据库查询。无论如何，这种函数会导致您的应用程序冻结，直到完成，有时您可能需要多次运行它。
- en: Rather than using synchronous code, where you pass each element of a collection
    into the function one at a time, you can leverage the AMPHP framework to process
    multiple calls at once.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用同步代码，其中您逐个将集合的每个元素传递到函数中，您可以利用 AMPHP 框架来同时处理多个调用。
- en: The `parallelMap()` function behaves similarly to PHP’s native `array_map()`
    except in parallel (and with the arguments in reverse order).^([5](ch17.html#idm45875135704496))
    It applies the specified function to every member of the array but does so in
    either a separate process or a separate thread of execution. Since the operation
    itself is asynchronous, `parallelMap()` returns a `Promise` to wrap the function’s
    eventual result.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallelMap()` 函数的行为类似于 PHP 的原生`array_map()`，但是以并行方式执行（参数顺序相反）。^([5](ch17.html#idm45875135704496))
    它将指定的函数应用于数组的每个成员，但是在一个单独的进程或线程中执行。由于操作本身是异步的，`parallelMap()` 返回一个`Promise`来包装函数的最终结果。'
- en: You’re left with an array of promises representing the separate, entirely parallel
    computations happening in the background. To move back into the land of synchronous
    code, leverage AMPHP’s `wait()` function as you did in [Recipe 17.1](#remote_apis_async).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您得到一个代表后台完全并行计算的`Promise`数组。为了回到同步代码的领域，像在[配方 17.1](#remote_apis_async)中那样利用
    AMPHP 的`wait()`函数。
- en: See Also
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on the [`parallel`](https://oreil.ly/6Um1H) and [`parallel-functions`](https://oreil.ly/8QfFs)
    modules from the AMPHP framework.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 AMPHP 框架中`parallel`和`parallel-functions`模块的文档。
- en: 17.3 Interrupting One Operation to Run Another
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.3 中断一个操作以运行另一个
- en: Problem
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run two independent operations and move back and forth between them
    on the same thread.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在同一个线程上运行两个独立的操作，并在它们之间来回切换。
- en: Solution
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use coroutines in the AMPHP framework to explicitly yield execution control
    between operations, as shown in [Example 17-2](#concurrent_for_loops).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AMPHP 框架中使用协程，显式地在操作之间让出执行控制，就像[示例 17-2](#concurrent_for_loops)中所示。
- en: Example 17-2\. Concurrent `for` loops with coroutines
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-2\. 使用协程进行并发`for`循环
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_asynchronous_php_CO2-1)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_php_CO2-1)'
- en: The first loop merely counts from 0 to 4, stepping by 1 each time.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个循环仅仅是从0到4计数，每次步进1。
- en: '[![2](assets/2.png)](#co_asynchronous_php_CO2-2)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_php_CO2-2)'
- en: The AMPHP framework’s `Delayed()` object is a promise that resolves itself after
    a given number of milliseconds—in this case, one full second.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: AMPHP 框架的`Delayed()`对象是一个承诺，它在给定的毫秒数后解析自身——在本例中是一整秒。
- en: '[![3](assets/3.png)](#co_asynchronous_php_CO2-3)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_php_CO2-3)'
- en: The second loop also counts from 0 to 4 with a step size of 1.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个循环也是从0到4，步长为1。
- en: '[![4](assets/4.png)](#co_asynchronous_php_CO2-4)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_php_CO2-4)'
- en: The second loop resolves its promise after 0.4 seconds.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个循环在0.4秒后解析其承诺。
- en: '[![5](assets/5.png)](#co_asynchronous_php_CO2-5)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_php_CO2-5)'
- en: Both `asyncCall()` invocations will fire immediately and print a `0` to the
    screen. However, the loops will not continue incrementing until the event loop
    is formally started (so the `Delayed` promises can actually resolve).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`asyncCall()`调用将立即触发并打印`0`到屏幕。然而，循环在正式启动事件循环之前不会继续增加（因此`Delayed`承诺实际上可以解析）。
- en: Discussion
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The Solution example introduces two key concepts important to understand when
    thinking about asynchronous PHP: an event loop and coroutines.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例介绍了两个在思考异步 PHP 时理解重要的关键概念：事件循环和协程。
- en: The event loop is at the core of how AMPHP will process concurrent operations.
    Without an event loop, PHP would have to execute your application or script from
    top to bottom. An event loop, however, gives the interpreter the ability to loop
    back on itself and run additional code in a different way. Specifically, the `Loop::run()`
    function will continue to execute until either there is nothing left in the event
    loop to process or the application itself receives a `SIGINT` signal (e.g., from
    pressing Ctrl+C on your keyboard).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环是 AMPHP 处理并发操作的核心。没有事件循环，PHP 将不得不从头到尾顺序执行应用程序或脚本。然而，事件循环使解释器能够循环回头部，并以不同的方式运行额外的代码。具体来说，`Loop::run()`函数将持续执行，直到事件循环中没有要处理的内容，或应用程序本身接收到`SIGINT`信号（例如从键盘上按下
    Ctrl+C）。
- en: 'There are two functions within the AMPHP framework that create coroutines:
    `call()` and `asyncCall()`. Both functions will immediately invoke the callback
    passed into them; `call()` will return a `Promise` instance, whereas `asyncCall()`
    will not. Within the callback function, any use of the `yield` keyword creates
    a coroutine—a function that can be interrupted and will wait for the resolution
    of a `Promise` object before continuing.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AMPHP 框架中有两个创建协程的函数：`call()`和`asyncCall()`。这两个函数都会立即调用传递给它们的回调函数；`call()`会返回一个`Promise`实例，而`asyncCall()`则不会。在回调函数内部，任何使用`yield`关键字的地方都会创建一个协程——一个可以被中断并在解析`Promise`对象之后继续的函数。
- en: In the Solution example, this promise is a `Delayed` object. This is AMPHP’s
    way of causing a routine to pause execution similar to `sleep()` in vanilla PHP.
    Unlike `sleep()`, though, a `Delayed` object is nonblocking. It will in essence
    “sleep” for a given period of time, then resume execution on the next pass of
    the event loop. While the routine is being delayed (or “sleeping”), PHP is free
    to handle other operations.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在解决方案示例中，这个承诺是一个`Delayed`对象。这是 AMPHP 中导致例程暂停执行类似于原始 PHP 中`sleep()`的方式。不过，`Delayed`对象是非阻塞的。它实质上会“睡眠”一段时间，然后在事件循环的下一次通过时恢复执行。在例程延迟（或“睡眠”）时，PHP
    可以自由处理其他操作。
- en: 'Running the Solution example in your PHP console will produce the following
    output:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 PHP 控制台中运行解决方案示例将产生以下输出：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding output demonstrates that PHP doesn’t need to wait for one loop
    to complete (with its chain of “sleep” or `Deferred` calls) before running the
    other. Both loops execute *concurrently*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前述输出表明，PHP 无需等待一个循环完成（及其“sleep”或`Deferred`调用链）才能运行另一个循环。两个循环都会*并发*执行。
- en: 'Note also that, if the two loops were executed synchronously, this entire script
    would take at least 7 seconds to execute (the first loop waits 1 second each time
    for five loops, and the second loop takes 0.4 seconds each time for five loops).
    Running these loops concurrently only takes 5 seconds in total. To fully demonstrate
    this, store `microtime(true)` in a variable when the process starts and compare
    to the system time after the loop completes. For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，如果两个循环同步执行，这整个脚本至少需要 7 秒才能执行（第一个循环每次等待 1 秒进行五次循环，第二个循环每次等待 0.4 秒进行五次循环）。同时运行这些循环仅需要总共
    5 秒。为了充分证明这一点，在进程启动时将`microtime(true)`存储在一个变量中，并在循环完成后与系统时间进行比较。例如：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating an event loop requires some minor overhead, but repeated executions
    of the Solution example with the preceding changes will reliably produce a result
    of approximately 5 seconds in total. What’s more, you can also increase the loop
    counter in the second `asyncCall()` invocation from 5 to 10\. That loop will still
    only take 4 seconds in total to run. Again, synchronously both loops would take
    9 seconds to complete but, thanks to juggling execution context through coroutines,
    the script will *still* reliably complete in about 5 seconds. [Figure 17-2](#cocurrent_execution)
    illustrates the difference between synchronous and concurrent execution visually.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 创建事件循环需要一些小的开销，但在对前述更改后反复执行解决方案示例将可可靠地产生大约 5 秒钟的结果。而且，您还可以将第二个`asyncCall()`调用中的循环计数器从
    5 增加到 10。该循环总共仍然只需要 4 秒钟才能完成。再次强调，同步执行这两个循环需要 9 秒钟才能完成，但由于通过协程调度执行上下文，脚本仍可可靠在约
    5 秒钟内完成。[图 17-2](#cocurrent_execution)通过视觉方式说明了同步和并发执行的差异。
- en: '![Executing two coroutines concurrently](assets/phpc_1702.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![同时执行两个协程](assets/phpc_1702.png)'
- en: Figure 17-2\. Executing two coroutines concurrently
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 17-2\. 同时执行两个协程
- en: By processing the two separate loops as coroutines within AMPHP’s event loop,
    PHP is able to interrupt the execution flow of one to proceed with the execution
    of the other. By juggling between coroutines, PHP can make maximum use of your
    CPU and allow your application to finish its work faster than if it ran through
    your logic synchronously.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 AMPHP 的事件循环中将这两个单独的循环作为协程处理，PHP 能够中断一个执行流程以进行另一个的执行。通过在协程之间进行调度，PHP 能够最大限度地利用您的
    CPU，并允许应用程序比通过同步逻辑运行更快地完成工作。
- en: The Solution example is a contrived illustration using delays or pauses; however,
    it extends to any situation where you might be leveraging a nonblocking but otherwise
    slow process. You can make a network request and leverage a coroutine so the application
    keeps processing while it waits for the request to complete. You could call out
    to a database or other persistence layer and house the nonblocking call within
    a coroutine. In some systems, you could also shell out to other processes (like
    Sendmail or another system process) and avoid these calls from blocking your application’s
    overall execution.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例是一个使用延迟或暂停的虚构示例；然而，它可以扩展到任何需要利用非阻塞但又较慢的过程的情况。您可以发出网络请求并利用协程，使应用程序在等待请求完成时继续处理。您可以调用数据库或其他持久层，并将非阻塞调用置于协程中。在某些系统中，您还可以外壳到其他进程（如
    Sendmail 或其他系统进程），避免这些调用阻塞应用程序的整体执行。
- en: See Also
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on the AMPHP framework’s [`asyncCall()` function](https://oreil.ly/sFVTx)
    and on [coroutines in general](https://oreil.ly/oC2oW).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: AMPHP 框架的[`asyncCall()`函数](https://oreil.ly/sFVTx)的文档以及[通用协程](https://oreil.ly/oC2oW)的文档。
- en: 17.4 Running Code in a Separate Thread
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.4 在单独线程中运行代码
- en: Problem
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run one or more heavy operations on a separate thread to keep the
    main application free to report progress.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望在单独的线程上运行一个或多个繁重的操作，以便保持主应用程序的空闲状态，以便报告进度。
- en: Solution
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the AMPHP project’s `parallel` package to define a `Task` to be run and
    `Worker` instances to run it. Then invoke one or more workers as separate threads
    or processes. [Example 17-3](#recursive_hash_example) reduces an array of values
    to a single output by using a one-way hash recursively. It does so by wrapping
    the hash operation in an asynchronous `Task` meant to be run as part of a worker
    pool. [Example 17-4](#multi_task_worker_pool) then defines a pool of workers that
    run multiple `Task` operations in separate, coroutine-wrapped threads.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 AMPHP 项目的`parallel`包来定义要运行的`Task`以及运行它的`Worker`实例。然后将一个或多个工作程序作为单独的线程或进程调用。[示例 17-3](#recursive_hash_example)通过递归使用单向哈希将值数组减少到单个输出。它通过将哈希操作封装在异步`Task`中，作为工作池的一部分来运行。[示例 17-4](#multi_task_worker_pool)然后定义了一个工作池，该工作池在单独的协程包装线程中运行多个`Task`操作。
- en: Example 17-3\. Task that uses recursive hashes to reduce an array to a single
    value
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-3\. 使用递归哈希来将数组减少为单个值的任务
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Example 17-4\. A worker pool can run multiple tasks
  id: totrans-133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-4\. 工作池可以运行多个任务
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Discussion
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The advantage of parallel processing is that you are no longer limited to running
    one operation at a time. Modern computers with multiple cores can literally and
    logically run more than one independent operation at a time. Thankfully, modern
    PHP can take advantage of this functionality quite well. It’s efficiently exposed
    by the `parallel` module in the AMPHP framework.^([6](ch17.html#idm45875134782624))
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 并行处理的优势在于您不再受限于一次只运行一个操作。具有多个核心的现代计算机可以实际上和逻辑上同时运行多个独立操作。幸运的是，现代PHP可以很好地利用这种功能。在AMPHP框架中，`parallel`模块有效地将其暴露出来。^([6](ch17.html#idm45875134782624))
- en: The Solution example uses this abstraction to enable the processing of multiple
    hash values in parallel, allowing the parent application to merely report on progress
    and the final result. The first component, a `Reducer` class, takes in an array
    of strings and produces an iterative hash of those values. Concretely, it performs
    a certain number of password-based key derivation hashes of each value in the
    array, passing the result of the derivation into the hash operation for the next
    item of the array.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种抽象的**解决方案示例**能够并行处理多个哈希值，使得父应用程序只需报告进度和最终结果。第一个组件是`Reducer`类，接受一个字符串数组并生成这些值的迭代哈希。具体来说，它对数组中每个值进行了一定数量的基于密码的密钥派生哈希操作，将派生的结果传递给数组下一个项目的哈希操作。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Hash operations are intended to quickly convert a known value into a seemingly
    random one. They’re one-way operations, meaning you can easily go from a seed
    value to a hash, but it’s impractical to reverse a hash to retrieve its seed value.
    Some stronger security stances use multiple rounds of a specific hashing algorithm—in
    many cases, tens of thousands—to *explicitly* slow down the process and prevent
    “guess and check” types of attacks from trying to guess a particular seed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希操作旨在快速将已知值转换为看似随机的值。它们是单向操作，这意味着您可以轻松地从种子值到哈希，但是反向哈希以检索其种子值是不切实际的。一些更强的安全立场使用多轮特定哈希算法（在许多情况下是数万轮），明确地减慢过程并防止“猜测和检查”类型的攻击来猜测特定种子。
- en: Since these hashing operations are costly (in terms of time), you don’t want
    to run them synchronously. Given how long they can take, you don’t even want to
    run them *concurrently*. Instead, you want to run them fully in parallel to leverage
    all available cores on your machine. By embedding the operation into an object
    that extends `Task`, they can run at the same time when invoked within a thread
    pool.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些哈希操作在时间上是昂贵的，您不希望同步运行它们。考虑到它们可能需要的时间，您甚至不希望并发运行它们。相反，您希望完全并行运行它们，以利用机器上所有可用的核心。通过将操作嵌入扩展了`Task`的对象中，它们在线程池中调用时可以同时运行。
- en: AMPHP’s `parallel` package exposes a thread pool with a default configuration,
    and you can easily enqueue as many operations in the pool as you want, so long
    as they implement `Task`. The pool will return a promise instance wrapping the
    task, meaning you can enqueue your tasks within coroutines and await the resolution
    of all of the promises they represent.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: AMPHP的`parallel`包公开了一个带有默认配置的线程池，你可以轻松地在池中排队尽可能多的操作，只要它们实现了`Task`接口。池将返回一个包装任务的Promise实例，这意味着你可以在协程中排队你的任务，并等待它们所代表的所有Promise的解析。
- en: As all operations are asynchronous, the parent application can continue running
    code while the hashing happens in parallel. The Solution example exploits this
    advantage by setting up a repeating `printf()` operation to write a decimal point
    to the screen every 200 milliseconds. This acts somewhat like a progress bar or
    a liveness check, providing you with proactive acknowledgment that a parallel
    process is still running under the surface.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有操作都是异步的，父应用程序可以在哈希操作并行执行时继续运行代码。解决方案示例利用这一优势，设置了一个重复的`printf()`操作，每200毫秒在屏幕上写入一个小数点。这在某种程度上像是一个进度条或活性检查，为您提供了并行进程仍在后台运行的积极确认。
- en: Once all of the parallel hashing jobs are finished, the overall operation prints
    the hashed results to the screen.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有并行哈希作业完成，整个操作将把哈希结果打印到屏幕上。
- en: In reality, you could enqueue any kind of parallel job in such a way to do multiple
    tasks at once. AMPHP exposes an `enqueueCallable()` function that empowers you
    to turn any regular function call into a parallel operation. Let’s say you need
    to retrieve weather reports from the US National Weather Service (NWS). Instead
    of enqueuing multiple hashing jobs as with the Solution example, you can just
    as easily fetch remote weather reports, as demonstrated in [Example 17-5](#weather_reports_async).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可以以这种方式排队任何类型的并行作业以同时执行多个任务。AMPHP公开了一个`enqueueCallable()`函数，使您能够将任何常规函数调用转换为并行操作。假设您需要从美国国家气象局（NWS）检索天气报告。与解决方案示例中排队多个哈希作业不同，您可以轻松地获取远程天气报告，如[示例17-5](#weather_reports_async)中所示。
- en: Example 17-5\. Asynchronous retrieval of weather reports
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例17-5。异步检索天气报告
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_asynchronous_php_CO3-1)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_php_CO3-1)'
- en: Each URL endpoint can be fetched independently with `file_get_contents()`. Using
    AMPHP’s `enqueueCallable()` function will automatically do this as part of an
    independent process in parallel to the main application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个URL端点都可以使用`file_get_contents()`独立获取。使用AMPHP的`enqueueCallable()`函数将自动作为独立进程并行于主应用程序之外执行。
- en: '[![2](assets/2.png)](#co_asynchronous_php_CO3-2)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_php_CO3-2)'
- en: Each parallel request is wrapped in a `Promise` object. In order to return to
    the land of synchronous execution, you must wait until all of these promises are
    resolved. The `all` function collects the different promises into a single `Promise`
    object. The `wait()` function will block execution until this promise is resolved;
    then it unwraps the contained value for use in your synchronous code.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每个并行请求都包装在一个`Promise`对象中。为了返回到同步执行状态，您必须等待所有这些promise都被解决。`all`函数将不同的promise收集到一个单独的`Promise`对象中。`wait()`函数将阻塞执行，直到此promise被解决；然后解开包含的值供同步代码使用。
- en: '[![3](assets/3.png)](#co_asynchronous_php_CO3-3)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_php_CO3-3)'
- en: The NWS API returns a JSON object representing the forecast for a specific weather
    station. You need to first parse the JSON-encoded string before you can leverage
    the data in your application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: NWS API返回一个表示特定气象站预报的JSON对象。在利用应用程序中的数据之前，您需要首先解析JSON编码的字符串。
- en: Warning
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The NWS weather API is entirely free to use but does require you to send a unique
    user agent with your request. By default, PHP will send a simple user agent string
    of `PHP` when you use `file_get_contents()`. To customize this, change the `user_agent`
    configuration in your *php.ini* file to be more unique. Without this change, the
    API will likely reject your request with a `403 Forbidden` error. For more on
    this and other behavior, reference the [general FAQs about the API](https://oreil.ly/4WVI0).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: NWS天气API完全免费使用，但需要您在请求中发送一个唯一的用户代理。默认情况下，当您使用`file_get_contents()`时，PHP将发送一个简单的用户代理字符串`PHP`。要自定义此内容，请在您的*php.ini*文件中更改`user_agent`配置为更独特的内容。如果不进行此更改，API可能会以`403
    Forbidden`错误拒绝您的请求。有关更多信息，请参考[有关API的常见问题解答](https://oreil.ly/4WVI0)。
- en: Whether the AMPHP framework uses separate threads or entirely independent processes
    under the hood is a matter of how your system is configured initially. Your code
    remains the same and, absent any extensions supporting multithreaded PHP, will
    likely use spawned PHP processes by default. In either case, the `enqueueCallable()`
    function requires you to use either a native PHP function or a user-defined function
    that is loadable via Composer. This is because the spawned child process is only
    aware of system functions, Composer-loaded functions, and any serialized data
    sent over by the parent process.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: AMPHP框架在底层使用单独的线程还是完全独立的进程取决于系统最初的配置方式。您的代码保持不变，并且在没有支持多线程PHP的任何扩展的情况下，可能默认使用生成的PHP进程。在任何情况下，`enqueueCallable()`函数要求您使用原生PHP函数或通过Composer可加载的用户定义函数。这是因为生成的子进程只知道系统函数、Composer加载的函数以及父进程发送的任何序列化数据。
- en: This last detail is critical—the data you send from the parent application to
    the background worker will be serialized. Some user-defined objects might break
    when PHP attempts to serialize and deserialize them. Even some core objects (like
    stream contexts) are incompatible with serialization and cannot be passed into
    a child thread or process.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一个细节至关重要——从父应用程序发送到后台工作程序的数据将被序列化。一些用户定义的对象在PHP尝试对其进行序列化和反序列化时可能会出现问题。甚至一些核心对象（如流上下文）与序列化不兼容，无法传递给子线程或进程。
- en: Take care with what tasks you choose to run in the background to ensure that
    the data you send is compatible with serialization and parallel operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择要在后台运行的任务时要小心，确保发送的数据与序列化和并行操作兼容。
- en: See Also
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on the [`parallel` package](https://oreil.ly/C41Rb) from the AMPHP
    framework.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[`parallel`包](https://oreil.ly/C41Rb)的文档，来自AMPHP框架。'
- en: 17.5 Sending and Receiving Messages Between Separate Threads
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.5 在独立线程之间发送和接收消息
- en: Problem
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to communicate with multiple running threads to synchronize state or
    manage the tasks those threads are executing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望与多个运行中的线程进行通信，以同步状态或管理这些线程正在执行的任务。
- en: Solution
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a message queue or bus between your main application and the separate threads
    it’s orchestrating to allow for seamless communication. For example, use RabbitMQ
    as an intermediary between your primary application (as illustrated by [Example 17-7](#rabbit_dispatcher))
    and independent worker threads, as shown in [Example 17-6](#rabbit_worker).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在主应用程序和它编排的独立线程之间使用消息队列或总线，以实现无缝通信。例如，使用RabbitMQ作为主应用程序（如[示例 17-7](#rabbit_dispatcher)所示）和独立工作线程（如[示例
    17-6](#rabbit_worker)所示）之间的中介。
- en: Example 17-6\. Background task used to send mail based on a queue
  id: totrans-165
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-6\. 基于队列发送邮件的后台任务
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_asynchronous_php_CO4-1)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_php_CO4-1)'
- en: Open a connection to a locally running RabbitMQ server by using the default
    port and default credentials. In production, these values will be different and
    should be loaded from the environment itself.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认端口和默认凭据连接到本地运行的RabbitMQ服务器。在生产中，这些值将不同，并且应从环境本身加载。
- en: '[![2](assets/2.png)](#co_asynchronous_php_CO4-2)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_php_CO4-2)'
- en: Declaring a queue to the RabbitMQ server merely opens a channel of communication.
    If the queue already exists, this operation does nothing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 声明队列到RabbitMQ服务器只是打开了一条通信通道。如果队列已存在，则此操作不会执行任何操作。
- en: '[![3](assets/3.png)](#co_asynchronous_php_CO4-3)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_php_CO4-3)'
- en: Data is wrapped in a message object when it comes into the worker from RabbitMQ.
    The actual data you need is in the body of the message.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据从RabbitMQ进入工作程序时，会将数据包装在消息对象中。您所需的实际数据位于消息体中。
- en: '[![4](assets/4.png)](#co_asynchronous_php_CO4-4)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_php_CO4-4)'
- en: Printing data within the worker is a helpful way to diagnose what is happening
    and inspect the data flowing in for any potential errors.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作程序中打印数据是诊断正在发生的情况并检查流入数据中的任何潜在错误的有用方式。
- en: '[![5](assets/5.png)](#co_asynchronous_php_CO4-5)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_php_CO4-5)'
- en: Once your worker has completed acting on a message, it needs to acknowledge
    the message to the RabbitMQ server; otherwise, another worker might pick the message
    up and retry it later.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的工作程序完成对消息的处理，它需要向RabbitMQ服务器确认消息；否则，另一个工作程序可能会接收并稍后重试该消息。
- en: '[![6](assets/6.png)](#co_asynchronous_php_CO4-6)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_php_CO4-6)'
- en: Consuming messages is a synchronous operation. When a message comes in from
    RabbitMQ, the system will invoke the callback passed to this function with the
    message itself as the argument.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 消息的消费是同步操作。当从RabbitMQ接收到消息时，系统将调用传递给此函数的回调函数，并以消息本身作为参数。
- en: '[![7](assets/7.png)](#co_asynchronous_php_CO4-7)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asynchronous_php_CO4-7)'
- en: So long as there are callbacks on a message, this loop will run forever, and
    the `wait()` method will keep the connection open to RabbitMQ so the worker can
    consume and act on any messages in the queue.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 只要消息上有回调，此循环将永远运行，并且`wait()`方法将保持与RabbitMQ的连接打开，以便工作程序可以消耗并处理队列中的任何消息。
- en: Example 17-7\. Main application that sends messages to the queue
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-7\. 发送消息到队列的主应用程序
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_asynchronous_php_CO5-1)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_php_CO5-1)'
- en: As with the worker, you open a connection to the local RabbitMQ server by using
    default parameters.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与工作程序一样，您可以使用默认参数连接到本地的RabbitMQ服务器。
- en: '[![2](assets/2.png)](#co_asynchronous_php_CO5-2)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_php_CO5-2)'
- en: Also as with the worker, you declare a queue. If this queue already exists,
    this method call will not do anything.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与工作程序一样，您也需要声明一个队列。如果此队列已存在，此方法调用将不会执行任何操作。
- en: '[![3](assets/3.png)](#co_asynchronous_php_CO5-3)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_php_CO5-3)'
- en: Before you can send a message, you need to encode it. For the purposes of this
    example, the payload will be serialized as a JSON string.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送消息之前，您需要对其进行编码。在本例中，负载将被序列化为JSON字符串。
- en: '[![4](assets/4.png)](#co_asynchronous_php_CO5-4)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_php_CO5-4)'
- en: For each message, you choose the queue on which to publish and dispatch the
    message to RabbitMQ.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每条消息，您可以选择发布到哪个队列，并将消息发送到 RabbitMQ。
- en: '[![5](assets/5.png)](#co_asynchronous_php_CO5-5)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_php_CO5-5)'
- en: Once you’re done sending your messages, it’s a good idea to explicitly close
    the channel and connection before doing any other work. In this example, there
    is no other work to be done (and the process will exit immediately), but explicit
    resource cleanup is a healthy habit for any developer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 发送完消息后，建议在执行其他工作之前明确关闭通道和连接。在这个示例中，并没有其他工作要做（进程会立即退出），但显式资源清理对于任何开发者来说都是一个健康的习惯。
- en: Discussion
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The Solution example uses multiple, explicit PHP processes to handle large operations.
    The script defined in [Example 17-6](#rabbit_worker) could be named *worker.php*
    and instantiated multiple times individually. If you do so in two separate consoles,
    you will spawn two entirely independent PHP processes that connect to RabbitMQ
    and listen for jobs.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例使用多个显式的 PHP 进程来处理大型操作。在 [示例 17-6](#rabbit_worker) 中定义的脚本可以命名为 *worker.php*，并单独多次实例化。如果您在两个独立的控制台中执行这样做，将会产生两个完全独立的
    PHP 进程，它们连接到 RabbitMQ 并监听作业。
- en: Running [Example 17-7](#rabbit_dispatcher) in a third window will start the
    main process and dispatch jobs by sending messages to the `default` queue housed
    by RabbitMQ. The workers will independently pick these jobs up, process them,
    and wait for more work down the road.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个窗口中运行 [示例 17-7](#rabbit_dispatcher) 将启动主进程，并通过向 RabbitMQ 中托管的 `default`
    队列发送消息来分派作业。工作程序将独立地接收这些作业，处理它们，并等待未来更多的工作。
- en: The full interaction between the parent process ([Example 17-7](#rabbit_dispatcher))
    and two fully asynchronous worker processes ([Example 17-6](#rabbit_worker)) using
    RabbitMQ as a message broker is illustrated by the three independent console windows
    shown in [Figure 17-3](#rabbit_workers_and_dispatcher).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 父进程（[示例 17-7](#rabbit_dispatcher)）与两个完全异步的工作进程（[示例 17-6](#rabbit_worker)）之间使用
    RabbitMQ 作为消息代理器的完整交互由 [图 17-3](#rabbit_workers_and_dispatcher) 中展示的三个独立控制台窗口说明。
- en: '![Multiple PHP processes communicating via RabbitMQ](assets/phpc_1703.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![多个 PHP 进程通过 RabbitMQ 进行通信](assets/phpc_1703.png)'
- en: Figure 17-3\. Multiple PHP processes communicating via RabbitMQ
  id: totrans-198
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 17-3\. 多个 PHP 进程通过 RabbitMQ 进行通信
- en: The different processes don’t communicate directly. To do that, you’d need to
    expose an interactive API. Instead, the much simpler means of communication is
    to leverage an intermediate message broker—in this case, [RabbitMQ](https://oreil.ly/GtgI0).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的进程不直接通信。要做到这一点，您需要公开一个交互式 API。相反，更简单的通信方式是利用一个中间消息代理器——在本例中是 [RabbitMQ](https://oreil.ly/GtgI0)。
- en: RabbitMQ is an open source tool that interfaces directly with several different
    programming languages. It allows for the creation of multiple queues that can
    then be read by one or more dedicated workers to process the content of the message.
    In the Solution example, you used workers and PHP’s native `mail()` function to
    dispatch email messages. A more complicated worker might update database records,
    interface with a remote API, or even process computationally expensive operations
    like the hashing performed in [Recipe 17.4](#recipe_separate_thread).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ 是一个开源工具，直接与多种不同的编程语言接口。它允许创建多个队列，然后由一个或多个专用工作程序读取消息内容进行处理。在解决方案示例中，您使用了工作程序和
    PHP 的本机 `mail()` 函数来发送电子邮件消息。一个更复杂的工作程序可能会更新数据库记录，与远程 API 进行接口交互，甚至处理像在 [第 17.4
    节](#recipe_separate_thread) 中执行的哈希操作这样的计算密集型操作。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Since RabbitMQ supports multiple languages, you’re not limited to just PHP in
    your implementation. If there’s a specific library you want to use in a different
    language, you could write your workers in that language, import the library, and
    dispatch work to the worker from your primary PHP application.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 RabbitMQ 支持多种语言，您在实现中不仅限于 PHP。如果您想在不同语言中使用特定库，可以将您的工作程序写成该语言，并导入库，然后从主 PHP
    应用程序向工作程序派发工作。
- en: 'In a production environment, your RabbitMQ server would leverage username/password
    authentication or possibly even explicitly allowlist the servers that can talk
    to it. For development, though, you can effectively leverage your local environment,
    default credentials, and tools like [Docker](https://www.docker.com) to run a
    RabbitMQ server on your local machine. To directly expose RabbitMQ by using the
    default port and default authentication, use the following Docker command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，您的 RabbitMQ 服务器将利用用户名/密码身份验证，或者甚至明确允许列出可以与其通信的服务器。不过，在开发过程中，您可以有效地利用本地环境、默认凭据和诸如[Docker](https://www.docker.com)之类的工具，在本地机器上运行
    RabbitMQ 服务器。要通过默认端口和默认身份验证直接公开 RabbitMQ，请使用以下 Docker 命令：
- en: '[PRE14]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the server is running, you can register as many queues as necessary to
    manage the flow of data within your swarm of applications.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器运行后，您可以注册尽可能多的队列来管理应用程序群中的数据流。
- en: See Also
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The official [documentation](https://oreil.ly/einsN) and [tutorials](https://oreil.ly/lEqc9)
    for configuring and interacting with RabbitMQ.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 官方的[文档](https://oreil.ly/einsN)和[教程](https://oreil.ly/lEqc9)，用于配置和与 RabbitMQ
    交互。
- en: 17.6 Using a Fiber to Manage the Contents from a Stream
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 17.6 使用 Fiber 管理流内容
- en: Problem
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use PHP’s newest concurrency feature to pull data from and operate
    on a stream in parts rather than buffering all of its contents at once.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 PHP 的最新并发功能来部分读取和操作流中的数据，而不是一次缓冲其所有内容。
- en: Solution
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a Fiber to wrap the stream and read its contents one piece at a time. [Example 17-8](#solution_fiber)
    reads the entirety of a web page into a file in 50-byte chunks, tracking the total
    number of bytes consumed as it reads in the content.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Fiber 封装流并逐块读取其内容。[示例 17-8](#solution_fiber) 每次以 50 字节的块读取网页的整体内容，并跟踪读取的总字节数。
- en: Example 17-8\. Reading a remote stream resource through a Fiber one chunk at
    a time
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-8\. 通过 Fiber 每次读取一个块来读取远程流资源
- en: '[PRE15]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_asynchronous_php_CO6-1)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_php_CO6-1)'
- en: The Fiber itself accepts a streaming resource as its only parameter when it
    starts. So long as the stream is not at the end, the Fiber will read the next
    50 bytes from the current position into the application.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Fiber 自身在启动时接受流资源作为唯一参数。只要流没有结束，Fiber 将从当前位置读取下一个 50 字节到应用程序中。
- en: '[![2](assets/2.png)](#co_asynchronous_php_CO6-2)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_php_CO6-2)'
- en: Once the Fiber has read from the stream, it will suspend operation and pass
    control back to the parent application stack. As Fibers can send data back to
    the parent stack, this Fiber will send the 50 bytes it has read from the stream
    when it suspends execution.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Fiber 从流中读取了数据，它将暂停操作并将控制返回给父应用程序堆栈。由于 Fiber 可以将数据发送回父堆栈，因此该 Fiber 在暂停执行时将发送从流中读取的
    50 字节。
- en: '[![3](assets/3.png)](#co_asynchronous_php_CO6-3)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_php_CO6-3)'
- en: Within the parent application stack, the stream is opened and set to not block
    execution of the rest of the application. In nonblocking mode, any calls to `fread()`
    will return right away rather than waiting for data on the stream.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在父应用程序堆栈中，流被打开并设置为不阻塞应用程序的执行。在非阻塞模式下，任何对 `fread()` 的调用都将立即返回，而不是等待流上的数据。
- en: '[![4](assets/4.png)](#co_asynchronous_php_CO6-4)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_php_CO6-4)'
- en: Within the parent application, you can also open other resources, like local
    files into which you can cache the contents of the remote resource.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在父应用程序中，您还可以打开其他资源，比如本地文件，您可以将远程资源的内容缓存到其中。
- en: '[![5](assets/5.png)](#co_asynchronous_php_CO6-5)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_php_CO6-5)'
- en: When starting the Fiber, you pass the main stream resource as a parameter so
    it’s available to the call stack of the Fiber itself. Once the Fiber suspends
    execution, it will also return the 50 bytes it has read back to you.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Fiber 时，将主流资源作为参数传递，以便它在 Fiber 的调用堆栈中可用。一旦 Fiber 暂停执行，它还将返回从流中读取的 50 字节。
- en: '[![6](assets/6.png)](#co_asynchronous_php_CO6-6)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_asynchronous_php_CO6-6)'
- en: To write over the previous line of console output, pass the `ESC` character
    (`chr(27)`) and an ANSI control sequence to move the cursor to the first column
    in the terminal (`[0G]`). Any subsequent text printed to the screen will now overwrite
    anything displayed previously.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖控制台输出的上一行，请传递 `ESC` 字符 (`chr(27)`) 和 ANSI 控制序列以将光标移动到终端的第一列 (`[0G]`)。现在屏幕上打印的任何后续文本都将覆盖先前显示的内容。
- en: '[![7](assets/7.png)](#co_asynchronous_php_CO6-7)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_asynchronous_php_CO6-7)'
- en: Once data is available from the remote stream, you can write that data directly
    to your local cache file.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦远程流中有数据可用，您可以直接将该数据写入本地缓存文件。
- en: '[![8](assets/8.png)](#co_asynchronous_php_CO6-8)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_asynchronous_php_CO6-8)'
- en: A sleep statement is not necessary to this application but is useful to illustrate
    how other computations can happen in the parent application stack while the Fiber
    is suspended.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 对于该应用程序，休眠语句并非必需，但用于说明当Fiber被挂起时，父应用程序堆栈中可以发生其他计算。
- en: '[![9](assets/9.png)](#co_asynchronous_php_CO6-9)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[![9](assets/9.png)](#co_asynchronous_php_CO6-9)'
- en: Resuming the Fiber will retrieve the next 50 bytes from the remote stream resource,
    assuming that any bytes remain. If nothing is left to retrieve, the Fiber will
    terminate, and your program will exit its `while` loop.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复Fiber将从远程流资源中检索接下来的50个字节，假设还有字节可供检索。如果没有剩余内容可供检索，则Fiber将终止，并且您的程序将退出其`while`循环。
- en: '[![10](assets/10.png)](#co_asynchronous_php_CO6-10)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[![10](assets/10.png)](#co_asynchronous_php_CO6-10)'
- en: Once execution is complete and the Fiber is cleaned up, be sure to close any
    streams or other resources you’ve opened.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行完成并且Fiber被清理，确保关闭您打开的所有流或其他资源。
- en: Discussion
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Fibers are similar to coroutines and generators in that their execution can
    be interrupted so that the application can perform other logic before returning
    control. Unlike these other constructs, Fibers have call stacks independent from
    that of the rest of the application. In this way, they empower you to pause their
    execution even within nested function calls without changing the return type of
    the function triggering the pause.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Fibers类似于协程和生成器，其执行可以被中断，使得应用程序在返回控制之前可以执行其他逻辑。与其他结构不同，Fibers具有独立于应用程序其余部分的调用堆栈。这种方式使得它们能够在嵌套函数调用中暂停执行，而无需更改触发暂停的函数的返回类型。
- en: With a generator that uses the `yield` command to suspend execution, you must
    return a `Generator` instance. With a Fiber using the `::suspend()` method, you
    can return any type you desire.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`yield`命令暂停执行的生成器，必须返回一个`Generator`实例。对于使用`::suspend()`方法的Fiber，您可以返回任何您需要的类型。
- en: Once a fiber is suspended, you can resume its execution from anywhere within
    the parent application to restart its separate call stack. This allows you to
    effectively jump between multiple execution contexts without worrying too much
    about controlling application state.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Fiber被挂起，您可以从父应用程序的任何位置恢复其执行，以重新启动其独立的调用堆栈。这使您能够有效地在多个执行上下文之间跳转，而无需过多关注控制应用程序状态的问题。
- en: You can also effectively pass data to and from a Fiber. When a Fiber suspends
    itself, it can choose to send data back to the parent application—again, of any
    type you need. When you resume a Fiber, you can pass any value you want or no
    value at all. You can also choose to throw an exception into the Fiber by using
    the `::throw()` method and then handle that exception within the Fiber itself.
    [Example 17-9](#fiber_exception_handling) demonstrates exactly what it would look
    like to handle an exception from within the Fiber.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以有效地向Fiber传递数据。当Fiber自我挂起时，它可以选择向父应用程序发送数据——无论您需要什么类型的数据。当您恢复Fiber时，您可以传递任何您想要的值，甚至不传递任何值。您还可以选择通过使用`::throw()`方法将异常抛入Fiber，然后在Fiber本身内部处理该异常。
    [示例 17-9](#fiber_exception_handling) 明确展示了如何从Fiber内部处理异常的情况。
- en: Example 17-9\. Handling an exception from within a Fiber
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 17-9\. 处理来自Fiber内部的异常
- en: '[PRE16]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_asynchronous_php_CO7-1)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_asynchronous_php_CO7-1)'
- en: The Fiber will immediately suspend execution once it’s started and return control
    to the parent application stack.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Fiber启动，它将立即暂停执行并返回控制给父应用程序堆栈。
- en: '[![2](assets/2.png)](#co_asynchronous_php_CO7-2)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_asynchronous_php_CO7-2)'
- en: When the Fiber is resumed, assuming it encounters a catchable `Exception`, it
    will extract and print out the error message.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当Fiber被恢复时，如果遇到可捕获的`Exception`，它将提取并打印出错误消息。
- en: '[![3](assets/3.png)](#co_asynchronous_php_CO7-3)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_asynchronous_php_CO7-3)'
- en: Once the Fiber finishes execution, it will print a useful message before ending
    its concurrent execution and returning control to the main application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Fiber执行完成，它将在结束其并发执行并将控制返回给主应用程序之前打印一条有用的消息。
- en: '[![4](assets/4.png)](#co_asynchronous_php_CO7-4)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_asynchronous_php_CO7-4)'
- en: Starting the Fiber merely creates its call stack and, because the Fiber immediately
    suspends, execution continues from the perspective of the parent stack.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 仅启动Fiber仅创建其调用堆栈，并且由于Fiber立即挂起，执行从父堆栈的角度继续。
- en: '[![5](assets/5.png)](#co_asynchronous_php_CO7-5)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_asynchronous_php_CO7-5)'
- en: Throwing an exception from the parent into the Fiber will trigger the `catch`
    condition and print the `Error` message to the console.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将父级抛出的异常传递给Fiber将触发`catch`条件，并将`Error`消息打印到控制台。
- en: Fibers are an effective way to juggle execution contexts between call stacks
    but are still fairly low-level within PHP. While they can be straightforward to
    use with simple operations like that in the Solution example, more complicated
    computations can become difficult to manage. Understanding how Fibers work is
    critical to using them effectively, but just as critical is choosing the proper
    abstraction to manage your Fibers for you. The [Async package](https://oreil.ly/vmkZJ)
    from ReactPHP provides effective abstractions to asynchronous operations, including
    Fibers, and makes engineering a complex concurrent application relatively easy.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Fiber是在调用堆栈之间处理执行上下文的有效方法，但在PHP中仍然属于相对低级别的。虽然它们在像解决方案示例中那样简单操作中使用起来可能很直接，但是在更复杂的计算中可能会变得难以管理。了解Fiber的工作原理对于有效使用它们至关重要，但同样重要的是选择适当的抽象来管理您的Fiber。来自ReactPHP的[Async包](https://oreil.ly/vmkZJ)提供了有效的异步操作抽象，包括Fiber，使得工程化复杂的并发应用相对容易。
- en: See Also
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The PHP Manual covering [Fibers](https://oreil.ly/iU6JH).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: PHP手册涵盖了[Fibers](https://oreil.ly/iU6JH)。
- en: ^([1](ch17.html#idm45875136412672-marker)) The promise behind Octane is that
    it will improve the performance of most applications without any changes to their
    code. However, there will likely be some edge cases in production where changes
    are required, so thoroughly test your code before relying on the project as a
    drop-in runtime replacement in production.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch17.html#idm45875136412672-marker)) Octane的承诺是，它将提高大多数应用程序的性能，而无需更改它们的代码。然而，在生产环境中可能会出现一些边缘情况，需要进行更改，因此在依赖项目作为生产环境中的即插即用运行时替代之前，请彻底测试您的代码。
- en: ^([2](ch17.html#idm45875136332736-marker)) Review [Recipe 7.15](ch07.html#iterating_over_large_arrays)
    for more on generators and the `yield` keyword.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch17.html#idm45875136332736-marker)) 有关生成器和`yield`关键字的更多信息，请参阅[Recipe
    7.15](ch07.html#iterating_over_large_arrays)。
- en: ^([3](ch17.html#idm45875135961808-marker)) As is true with any module and the
    AMPHP framework itself, you can install the `http-client` package by using Composer.
    Review [Recipe 15.3](ch15.html#installing_composer_packages) for more information
    on Composer packages.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch17.html#idm45875135961808-marker)) 与任何模块及AMPHP框架本身一样，您可以通过Composer安装`http-client`包。有关Composer包的更多信息，请参阅[Recipe
    15.3](ch15.html#installing_composer_packages)。
- en: ^([4](ch17.html#idm45875135957664-marker)) For more on anonymous functions,
    or lambdas, review [Recipe 3.9](ch03.html#anonymous_functions).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch17.html#idm45875135957664-marker)) 有关匿名函数或Lambda表达式的更多信息，请参阅[Recipe
    3.9](ch03.html#anonymous_functions)。
- en: ^([5](ch17.html#idm45875135704496-marker)) For more on `array_map()`, review
    [Recipe 7.13](ch07.html#apply_function_to_each_element).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch17.html#idm45875135704496-marker)) 有关`array_map()`的更多信息，请参阅[Recipe 7.13](ch07.html#apply_function_to_each_element)。
- en: ^([6](ch17.html#idm45875134782624-marker)) The AMPHP framework also publishes
    a `parallel-functions` package that exposes several useful helper functions wrapping
    the lower-level `parallel` package. For more on these functions and their usage,
    review [Recipe 17.2](#awaiting_asynchronous_operations).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch17.html#idm45875134782624-marker)) AMPHP框架还发布了一个`parallel-functions`包，公开了几个有用的辅助函数，包装了较低级别的`parallel`包。有关这些函数及其使用方法的更多信息，请参阅[Recipe
    17.2](#awaiting_asynchronous_operations)。
