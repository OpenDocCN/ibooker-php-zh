# 第十七章。PHP 调试

调试是一种获得的技能。正如在开发界经常说的，“你被给予了你所需的所有绳索；只是试图用它打个漂亮的蝴蝶结而不是让自己被绞死。” 很自然地可以推断，您进行的调试越多，您将变得越熟练。当然，当您的代码未能达到预期时，您的服务器环境也会为您提供一些很好的提示。然而，在深入讨论调试概念之前，我们需要看看更大的画面，并讨论这些编程环境。每个开发店铺都有自己的设置和做事方式，因此我们将在此处涵盖的内容反映了理想条件，也称为最佳实践。

在理想的世界中，PHP 开发至少有三种单独的环境进行工作：开发、演示和生产。我们将在接下来的部分逐一探讨每一个。

# 开发环境

开发环境是一个可以在其中创建原始代码而无需担心服务器崩溃或同行嘲笑的地方。这应该是验证或证伪概念和理论、可以实验性地创建代码的地方。因此，错误报告的环境反馈应尽可能详尽。所有错误报告都应记录，并同时发送到输出设备（浏览器）。所有警告应尽可能敏感和详细。

###### 注意

本章稍后的部分，将会比较每个三种环境下关于调试和错误报告相关的推荐服务器设置，表 17-1。

可以辩论这个开发环境的位置。但是，如果您的公司有资源，那么应该建立一个专用服务器，用于这一目的，并建立完整的代码管理（例如 SVN，即 Subversion，或 Git）。如果资源不足，则可以通过`localhost`风格的设置使用开发 PC 来完成此目的。从这个`localhost`环境本身来看，这可以是有利的，因为您可能想尝试一些完全不同寻常的东西，通过在独立的 PC 上编码，您可以完全实验性地进行，而不会影响常用开发服务器或任何其他人的代码库。

您可以使用 Apache Web 服务器或 Microsoft 的 Internet Information Services (IIS)手动创建`localhost`环境。也有一些可以使用的一体化环境；Zend Server CE（社区版）是一个很好的例子。

无论您为原始开发设置了什么，都要确保给予开发人员充分的自由，让他们无需担心受到责备而可以自由发挥。这样可以增强他们创新的信心，而且没有人会“受伤”。

###### 注意

至少有两种在您自己的 PC 上设置本地环境的替代方法。第一种是，从 PHP 5.4 开始，有一个[内置的 Web 服务器](http://bit.ly/TI0xTU)。这个选项节省了下载和安装完整 Apache 或 IIS Web 服务器产品以用于`localhost`目的的时间。

第二，现在有许多允许云端开发的站点（名字有点双关）。[Zend](http://www.phpcloud.com)提供了一个免费的测试和开发环境。

# 暂存环境

暂存环境应尽可能地模仿生产环境。尽管这有时很难实现，但您模仿生产环境越接近，效果就越好。您将能够看到您的代码在一个受保护但也模拟真实生产环境的区域中的反应。暂存环境通常是最终用户或客户可以测试新功能或功能的地方，提供反馈并对代码进行压力测试，而不用担心影响生产代码。

###### 注意

随着测试和实验的进展，您的暂存区域（至少从数据的角度来看）最终会与生产环境变得更加不同。因此，建立定期用生产信息替换暂存区域的程序是一个好习惯。不同公司或开发商的设置时间会因所创建的功能、发布周期等因素而异。

如果资源允许，您应该考虑有两个独立的暂存环境：一个供开发者（编码同行）使用，另一个供客户测试使用。来自这两种用户的反馈往往非常不同且非常有价值。这里的服务器错误报告和反馈也应该尽量减少，以尽可能地模拟生产环境。

# 生产环境

从错误报告的角度来看，生产环境需要尽可能严格地控制。您希望完全控制最终用户看到和体验到的内容。如果可能的话，不应让客户看到像 SQL 失败和代码语法警告这样的东西。当然，您的代码库在此时应该已经做好了充分的缓解措施（假设您已经正确而虔诚地使用了前述的两个环境），但有时错误和漏洞仍可能出现在生产中。如果在生产中出现问题，您希望以尽可能优雅和*安静*的方式失败。

###### 注意

考虑使用 404 页面重定向和`try...catch`结构，将错误和失败重定向到生产环境中的安全着陆区域。参见第二章了解`try...catch`语法的正确编码风格。

至少，所有的错误报告都应该在生产环境中被抑制并发送到日志文件中。

# php.ini 设置

您需要考虑每种服务器类型的全局环境设置以开发您的代码。首先，我们将简要总结这些设置，然后列出每种编码环境的推荐设置。

`display_errors`

控制 PHP 遇到任何错误时显示的开关。在生产环境中应设置为`0`（关闭）。

`error_reporting`

这是一组预定义常量的设置，将向错误日志和/或 Web 浏览器报告 PHP 遇到的任何错误。此指令可以设置 16 种不同的单独常量，并且某些常量可以集体使用。最常见的是 `E_ALL`，用于报告所有类型的错误和警告；`E_WARNING`，仅向浏览器显示警告（非致命错误）；以及 `E_DEPRECATED`，用于显示关于将来版本中将会失败的代码的运行时通知警告（例如 `register_globals`）。这些常量的组合使用示例是 `E_ALL & ~E_NOTICE`，它告诉 PHP 报告除生成通知外的所有错误。可以在 [PHP 网站](https://oreil.ly/N2AaV) 找到所有这些定义常量的完整列表。

`error_log`

错误日志的存储位置路径。错误日志是位于服务器上的文本文件，记录以文本形式出现的所有错误。例如，在 Apache 服务器中可能是 *apache2/logs*。

`variables_order`

设置超全局数组加载信息的优先顺序。默认顺序为 `EGPCS`，即首先加载环境（`$_ENV`）数组，然后是 `GET`（`$_GET`）数组，接着是 `POST`（`$_POST`）数组，然后是 cookie（`$_COOKIE`）数组，最后是服务器（`$_SERVER`）数组。

`request_order`

描述 PHP 将 `GET`、`POST` 和 cookie 变量注册到 `$_REQUEST` 数组中的顺序。注册是从左到右进行的，较新的值会覆盖较旧的值。

`zend.assertions`

确定是否运行断言并抛出错误。当禁用时，调用 `assert()` 中的条件永不运行（因此，它们可能产生的任何副作用都不会发生）。

`assert.exception`

确定是否启用异常系统。默认情况下，在开发和生产环境中都是开启的，并且通常是处理错误条件的首选方式。

还可以使用其他设置；例如，如果担心日志文件过大，可以使用`ignore_repeated_errors`。该指令可以抑制相同代码行中重复记录的错误，但仅限于同一文件中的同一行。如果您正在调试代码的循环部分并且其中某处发生错误，这可能会很有用。

PHP 还允许您在代码执行期间修改某些 INI 设置，从而改变其服务器范围的设置。这是在一个疑难文件中打开某些错误报告并将结果显示在屏幕上的快速方法，但在生产环境中仍不建议使用。如果需要，可以在暂存环境中执行此操作。例如，打开所有错误报告并在浏览器中显示任何报告的错误。要执行此操作，请在文件顶部插入以下两个命令：

```php
error_reporting(E_ALL);
ini_set("display_errors", 1);
```

`error_reporting()` 函数允许您覆盖报告的错误级别，而 `ini_set()` 函数允许您更改 *php.ini* 设置。再次强调，并非所有 INI 设置都可以更改，请务必查看 [PHP 网站](https://oreil.ly/ILGqh) 了解可以和不可以在运行时更改的内容。

如前所述，Table 17-1 列出了 PHP 指令及其在三种基本服务器环境中的建议。 

Table 17-1\. PHP 服务器环境的错误指令

| PHP 指令 | 开发 | 暂存 | 生产 |
| --- | --- | --- | --- |
| `display_errors` | 打开 | 根据期望结果选择其中一个设置 | 关闭 |
| `error_reporting` | `E_ALL` | `E_ALL & ~E_WARNING & ~E_DEPRECATED` | `E_ALL & ~E_DEPRECATED & ~E_STRICT` |
| `error_log` | */logs* 文件夹 | */logs* 文件夹 | */logs* 文件夹 |
| `variables_order` | EGPCS | GPCS | GPCS |
| `request_order` | GP | GP | GP |

# 错误处理

错误处理是任何实际应用的重要部分。PHP 提供了多种机制，可用于处理错误，无论是在开发过程中还是应用在生产环境中。

## 错误报告

通常情况下，当 PHP 脚本发生错误时，错误消息会插入到脚本的输出中。如果错误是致命的，则脚本执行会停止。

条件有三个级别：通知、警告和错误。脚本执行中发生的 *通知* 可能表明错误，但也可能在正常执行过程中发生（例如，脚本尝试访问尚未设置的变量）。*警告* 表示非致命错误条件；通常在调用具有无效参数的函数时显示警告。发出警告后，脚本将继续执行。*错误* 表示脚本无法恢复的致命条件。*解析错误* 是一种特定类型的错误，当脚本语法错误时发生。除解析错误外，所有错误均为运行时错误。

建议将所有通知、警告和错误视为错误处理；这有助于防止诸如在变量具有合法值之前使用它们等错误。

默认情况下，除了运行时通知外的所有条件都会被捕获并显示给用户。您可以在*php.ini*文件中全局更改此行为，使用`error_reporting`选项。您还可以在脚本中使用`error_reporting()`函数局部更改错误报告行为。

使用`error_reporting`选项和`error_reporting()`函数，您可以使用不同的位操作符将各种常量值组合起来指定要捕获和显示的条件，如表 17-2 中所列。例如，这表示所有错误级别选项：

```php
(E_ERROR | E_PARSE | E_CORE_ERROR | E_COMPILE_ERROR | E_USER_ERROR)
```

虽然这表示除运行时通知外的所有选项：

```php
(E_ALL & ~E_NOTICE)
```

如果在你的*php.ini*文件中设置了`track_errors`选项，当前错误的描述将存储在`$PHP_ERRORMSG`中。

表 17-2\. 错误报告值

| Value | Meaning |
| --- | --- |
| `E_ERROR` | 运行时错误 |
| `E_WARNING` | 运行时警告 |
| `E_PARSE` | 编译时解析错误 |
| `E_NOTICE` | 运行时通知 |
| `E_CORE_ERROR` | PHP 内部生成的错误 |
| `E_CORE_WARNING` | PHP 内部生成的警告 |
| `E_COMPILE_ERROR` | Zend 脚本引擎内部生成的错误 |
| `E_COMPILE_WARNING` | Zend 脚本引擎内部生成的警告 |
| `E_USER_ERROR` | 通过调用`trigger_error()`生成的运行时错误 |
| `E_USER_WARNING` | 通过调用`trigger_error()`生成的运行时警告 |
| `E_USER_NOTICE` | 通过调用`trigger_error()`生成的运行时通知 |
| `E_ALL` | 上述所有选项 |

## 异常

现在，许多 PHP 函数抛出异常而不是致命退出操作。异常允许脚本在出现错误后继续执行——当异常发生时，会创建一个`BaseException`类的子类对象，然后抛出。抛出的异常必须由跟随抛出代码的代码“捕获”。

```php
try {
 $result = eval($code);
} catch {\ParseException $exception) {
 // handle the exception
}
```

你应该包含一个异常处理程序来捕获任何抛出异常的方法中的异常。任何未捕获的异常都会导致脚本停止执行。

## 错误抑制

您可以通过在表达式之前放置错误抑制运算符`@`来禁用单个表达式的错误消息。例如：

```php
$value = @(2 / 0);
```

没有错误抑制运算符，表达式通常会因“除以零”错误而停止脚本的执行。如下所示，该表达式什么也不做，尽管在其他情况下，如果简单地忽略本应使程序停止的错误，则你的程序可能处于未知状态。错误抑制运算符不能捕获解析错误，只能捕获各种类型的运行时错误。

当然，抑制错误的缺点是你不会知道它们的存在。最好正确处理潜在的错误条件；例如，查看“触发错误”中的示例。

要完全关闭错误报告，请使用：

```php
error_reporting(0);
```

该函数确保无论 PHP 在处理和执行脚本时遇到什么错误，都不会将错误发送给客户端（除了无法被抑制的解析错误）。当然，这并不能阻止这些错误的发生。更好的控制客户端显示哪些错误消息的选项在“定义错误处理程序”部分中展示。

## 触发错误

您可以使用`assertion()`函数从脚本中抛出错误：

```php
assert (mixed *`$expression`* [, mixed *`$message`*]);
```

第一个参数是必须为`true`以不触发断言的条件；第二个（可选）参数是消息。

当您编写自己的函数来检查参数的健全性时，触发错误是很有用的。例如，这里有一个函数，它将一个数字除以另一个数字，并在第二个参数为`0`时抛出错误：

```php
function divider($a, $b) {
 assert($b != 0, '$b cannot be 0');

 return($a / $b);
}

echo divider(200, 3);
echo divider(10, 0);
66.666666666667
Fatal error: $b cannot be 0 in page.php on line 5
```

当调用`assert()`时触发时，会抛出一个`AssertionException`——一个扩展了`ErrorException`且严重性为`E_ERROR`的异常。在某些情况下，您可能希望抛出一个扩展`AssertionException`类型的错误。您可以通过将异常作为消息参数而不是字符串来实现：

```php
class DividerParameterException extends AssertionException { }

function divider($a, $b) {
 assert($b != 0, new DividerParameterException('$b cannot be 0'));

 return($a / $b);
}
```

## 定义错误处理程序

如果您希望比仅仅隐藏任何错误更好地控制错误（通常是这样），您可以提供 PHP 一个错误处理程序。当遇到任何种类的条件时，将调用错误处理程序，并且可以执行您希望执行的任何操作，从将信息记录到文件到漂亮地打印错误消息。基本过程是创建一个错误处理函数并使用`set_error_handler()`注册它。

您声明的函数可以接受两个或五个参数。前两个参数是错误代码和描述错误的字符串。如果您的函数接受它们，最后三个参数是发生错误的文件名、错误发生的行号以及错误发生时的活动符号表的副本。您的错误处理程序应该使用`error_reporting()`检查当前报告的错误级别，并相应地采取行动。

调用`set_error_handler()`会返回当前的错误处理程序。当您的脚本使用完自己的错误处理程序时，可以通过使用返回的值调用`set_error_handler()`来恢复先前的错误处理程序，或者通过调用`restore_error_handler()`函数来恢复。

下面的代码显示了如何使用错误处理程序格式化和打印错误：

```php
function displayError($error, $errorString, $filename, $line, $symbols)
{
 echo "<p>Error '<b>{$errorString}</b>' occurred.<br />";
 echo "-- in file '<i>{$filename}</i>', line $line.</p>";
}

set_error_handler('displayError');
$value = 4 / 0; // divide by zero error

<p>Error '<b>Division by zero</b>' occurred.
-- in file '<i>err-2.php</i>', line 8.</p>
```

### 在错误处理程序中记录

PHP 提供了内置函数`error_log()`来将错误记录到管理员喜欢放置它们的各种地方：

```php
error_log(*`message`*, *`type`* [, *`destination`* [, *`extra_headers`* ]]);
```

第一个参数是错误消息。第二个参数指定错误记录的位置：`0` 的值通过 PHP 的标准错误记录机制记录错误；`1` 的值将错误电邮发送至*目标*地址，可选地添加任何*额外的头部*到消息；`3` 的值将错误追加到*目标*文件中。

要使用 PHP 的日志记录机制保存错误，请调用`error_log()`并使用类型`0`。通过更改*php.ini*文件中的`error_log`值，您可以更改要记录的文件。如果将`error_log`设置为`syslog`，则将使用系统记录器。例如：

```php
error_log('A connection to the database could not be opened.', 0);
```

要通过电子邮件发送错误，请调用`error_log()`并使用类型`1`。第三个参数是要发送错误消息的电子邮件地址，可选的第四个参数可用于指定附加的电子邮件头。以下是通过电子邮件发送错误消息的方法：

```php
error_log('A connection to the database could not be opened.',
 1, 'errors@php.net');
```

最后，要记录到文件中，请调用`error_log()`并使用类型`3`。第三个参数指定要记录的文件名：

```php
error_log('A connection to the database could not be opened.',
 3, '/var/log/php_errors.log');
```

示例 17-1 展示了一个将日志写入文件并在日志文件超过 1 KB 时进行轮换的错误处理程序示例。

##### 示例 17-1\. 日志滚动错误处理程序

```php
function logRoller($error, $errorString) {
 $file = '/var/log/php_errors.log';

 if (filesize($file) > 1024) {
 rename($file, $file . (string) time());
 clearstatcache();
 }

 error_log($errorString, 3, $file);
}

set_error_handler('logRoller');

for ($i = 0; $i < 5000; $i++) {
 trigger_error(time() . ": Just an error, ma'am.\n");
}

restore_error_handler();
```

通常，在您网站上工作时，您希望直接在出错的页面上显示错误。然而，一旦网站上线，向访问者显示内部错误消息就没有太多意义了。一个常见的方法是在您的*php.ini*文件中使用以下内容，一旦您的网站上线：

```php
display_errors = Off
log_errors = On
error_log = /tmp/errors.log
```

这告诉 PHP 永远不显示任何错误，而是将它们记录到`error_log`指令指定的位置。

### 错误处理程序中的输出缓冲

使用输出缓冲和错误处理程序的组合，可以根据各种错误条件发送不同的内容给用户。例如，如果脚本需要连接到数据库，则可以在脚本成功连接到数据库之前抑制页面的输出。

示例 17-2 展示了使用输出缓冲来延迟页面输出，直到成功生成页面为止。

##### 示例 17-2\. 输出缓冲以处理错误

```php
<html>
 <head>
 <title>Results!</title>
 </head>

 <body>
 <?php function handle_errors ($error, $message, $filename, $line) {
 ob_end_clean();
 echo "<b>{$message}</b><br/> in line {$line}<br/> of ";
 echo "<i>{$filename}</i></body></html>";

 exit;
 }

 set_error_handler('handle_errors');
 ob_start(); ?>

 <h1>Results!</h1>

 <p>Here are the results of your search:</p>

 <table border="1">
 <?php require_once('DB.php');
 $db = DB::connect('mysql://gnat:waldus@localhost/webdb');

 if (DB::iserror($db)) {
 die($db->getMessage());
 } ?>
 </table>
 </body>
</html>
```

在示例 17-2 中，我们在开始`<body>`元素后注册错误处理程序并开始输出缓冲。如果无法连接到数据库（或在随后的 PHP 代码中发生任何其他错误），则不显示标题和表格。用户只会看到错误消息。但是，如果 PHP 代码没有引发错误，用户将只看到 HTML 页面。

# 手动调试

一旦您有了几年的开发经验，您应该能够至少通过纯视觉方式完成至少 75%的调试工作。另外的 25%和您需要解决的更困难的代码段呢？您可以通过使用像 Zend Studio for Eclipse 或 Komodo 这样的优秀代码开发环境来解决一些问题。这些先进的 IDE 可以帮助进行语法检查和一些简单的逻辑问题和警告。

您可以通过将值 `echo` 到屏幕上完成下一级别的调试（再次强调，大部分工作将在开发环境中完成）。这将捕捉依赖于变量内容的许多逻辑错误。例如，您如何轻松地查看 `for...next` 循环的第三次迭代的值？考虑以下代码：

```php
for ($j = 0; $j < 10; $j++) {
 $sample[] = $j * 12;
}
```

最简单的方法是在循环有条件地中断并 `echo` 出该时间的值；或者，您可以等待循环完成，就像在本例中一样，因为循环正在构建一个数组。以下是确定第三次迭代值的示例（请记住数组键从 0 开始）：

```php
for ($j = 0; $j < 10; $j++) {
 $sample[] = $j * 12;

 if ($j == 2) {
 echo $sample[2];
 }
}
`24`
```

在这里，我们只是简单地插入一个测试（`if` 语句），当满足条件时，将特定值发送到浏览器。如果您遇到 SQL 语法问题或失败，您还可以将原始语句 `echo` 到浏览器中，并将其复制到 SQL 界面（例如 *phpMyAdmin*）中执行代码，以查看是否返回任何 SQL 错误消息。

如果我们想要在循环结束时查看整个数组以及每个元素包含的值，我们仍然可以使用 `echo` 语句，但为每个元素编写 `echo` 语句会很麻烦和复杂。相反，我们可以使用 `var_dump()` 函数。`var_dump()` 的额外优势是它还告诉我们数组每个元素的数据类型。输出不一定漂亮，但信息丰富。您可以将输出复制到文本编辑器中，并用其清理输出的外观。

当然，你可以根据需要同时使用 `echo` 和 `var_dump()`。以下是 `var_dump()` 原始输出的示例：

```php
for ($j = 0; $j < 10; $j++) {
 $sample[] = $j * 12;
}

var_dump($sample);
`array``(``10``)` `{` `[``0``]` `=>` `int``(``0``)` `[``1``]` `=>` `int``(``12``)` `[``2``]` `=>` `int``(``24``)` `[``3``]` `=>` `int``(``36``)` `[``4``]` `=>` 
`int``(``48``)` `[``5``]` `=>` `int``(``60``)` `[``6``]` `=>` `int``(``72``)` `[``7``]` `=>` `int``(``84``)` `[``8``]` `=>` `int``(``96``)` `[``9``]` `=>` 
`int``(``108``)}`
```

###### 注意

发送简单数据到浏览器有另外两种方法：`print` 语言结构和 `print_r()` 函数。`print` 只是 `echo` 的另一种选择（除了返回 `1` 的值），而 `print_r()` 以人类可读的格式将信息发送到浏览器。可以将 `print_r()` 看作是 `var_dump()` 的替代品，不过在数组的输出时不会显示每个元素的数据类型。此代码的输出如下：

```php
<?php
for ($j = 0; $j < 10; $j++) {
 $sample[] = $j * 12;
}
?>
<pre><?php print_r($sample); ?></pre>
```

如下所示（请注意由 `<pre>` 标签完成的格式化）：

```php
`Array``(` `[``0``]` `=>` `0` `[``1``]` `=>` `12` `[``2``]` `=>` `24` `[``3``]` `=>` `36` `[``4``]` `=>` `48`
`[``5``]` `=>` `60` `[``6``]` `=>` `72` `[``7``]` `=>` `84` `[``8``]` `=>` `96` `[``9``]` `=>` `108``)`
```

# 错误日志

您将在错误日志文件中找到许多有用的描述。如前所述，您应该能够在名为 *logs* 的文件夹中找到位于 Web 服务器安装文件夹下的文件。将检查此文件作为调试例行程序的一部分，以获取有关可能出现问题的提示。以下是错误日志文件详细信息的样本：

```php
[20-Apr-2012 15:10:55] PHP Notice: Undefined variable: size in C:\Program Files
(x86)
[20-Apr-2012 15:10:55] PHP Notice: Undefined index: p in C:\Program Files
(x86)\Zend
[20-Apr-2012 15:10:55] PHP Warning: number_format() expects parameter 1 to be 
double
[20-Apr-2012 15:10:55] PHP Warning: number_format() expects parameter 1 to be 
double
[20-Apr-2012 15:10:55] PHP Deprecated: Function split() is deprecated in 
C:\Program
[20-Apr-2012 15:10:55] PHP Deprecated: Function split() is deprecated in 
C:\Program
[26-Apr-2012 13:18:38] PHP Fatal error: Maximum execution time of 30 seconds
exceeded
```

如您所见，此处报告了几种不同类型的错误：通知、警告、弃用通知和致命错误，以及它们各自的时间戳、文件位置和发生错误的行数。

###### 注意

根据您的环境，一些商业服务器空间提供商出于安全原因不允许访问，因此您可能无法访问日志文件。请确保选择一个可以访问日志文件的生产提供商。此外，请注意日志可能被移出 Web 服务器的安装文件夹。例如，在 Ubuntu 上，默认路径是 */var/logs/apache2/*.log*。如果找不到日志，请检查 Web 服务器的配置。

# IDE 调试

对于更复杂的调试问题，最好使用可以在良好的集成开发环境（IDE）中找到的调试器。我们将展示使用 Zend Studio for Eclipse 的调试会话示例。其他如 Komodo 和 PhpED 的 IDE 也内置了调试器，因此也可以用于此目的。

Zend Studio 针对调试目的设置了完整的调试透视图，如图 17-1 所示。

![Zend Studio 中的默认调试透视图](img/php4_1701.png)

###### 图 17-1\. Zend Studio 中的默认调试透视图

要熟悉此调试器，请打开运行菜单。它显示了在调试过程中可以尝试的所有选项——步入和跳过代码段，运行到光标位置，从头重新启动会话，或者简单地让您的代码运行直到失败或结束，等等。

###### 注

在 Eclipse 中的 Zend Studio 中，您甚至可以通过正确的设置来调试 JavaScript 代码！

请确保查看本产品中的多个调试视图；您可以在代码执行过程中观察变量（包括超全局变量和用户定义的变量）的变化。

在 PHP 代码中，还可以设置（和暂停）断点，因此您可以运行到代码中的某个位置并查看该特定时刻的整体情况。另外还有两个便利的视图是调试输出和浏览器输出，它们展示了调试器运行时代码的输出情况。调试输出视图以您在浏览器中选择“查看源代码”的格式呈现输出，显示生成的原始 HTML。浏览器输出视图显示了代码在浏览器中执行的样子。这两个视图的好处在于它们在代码执行时填充数据，因此如果您在代码文件的中间某处停在断点上，它们只显示生成到那一点的信息。

图 17-2 展示了本章早些时候示例代码（在 `for` 循环中添加了 `echo` 语句，以便您看到生成的输出）在调试器中运行的示例。主要变量 `$j` 和 `$sample` 在表达式视图中被跟踪，并且浏览器输出和调试输出视图显示了它们在代码中停止位置的内容。

![调试器使用监视表达式定义](img/php4_1702.png)

###### 图 17-2\. 调试器在执行时定义的监视表达式

# 其他调试技术

有更高级的技术可以用于调试，但超出了本章的范围。两种这样的技术是性能分析和单元测试。如果你有一个需要大量服务器资源的大型网络系统，你应该深入了解这两种技术的好处，因为它们可以使你的代码库更具容错性和效率。

# 下一步

接下来，我们将探讨编写 Unix 和 Windows 跨平台脚本，并简要介绍如何在 Windows 服务器上托管你的 PHP 网站。
