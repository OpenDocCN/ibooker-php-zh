- en: Chapter 8\. Introduction to MySQL
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章。MySQL 简介
- en: With well over 10 million installations, MySQL is probably the most popular
    database management system for web servers. Developed in the mid-1990s, it’s now
    a mature technology that powers many of today’s most-visited internet destinations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 已经安装了超过一千万个实例，可能是最流行的用于 Web 服务器的数据库管理系统。在1990年代中期开发，现在是一种成熟的技术，支持如今最受欢迎的互联网目的地之一。
- en: One reason for its success is that, like PHP, it’s free to use. But it’s also
    extremely powerful and exceptionally fast. MySQL is also highly scalable, which
    means that it can grow with your website; the latest benchmarks are kept [up to
    date online](https://tinyurl.com/mysqlbm).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 其成功之一是与 PHP 一样，它是免费使用的。但它也非常强大且速度异常快。MySQL 也具有高度可扩展性，这意味着它可以随着您的网站增长；最新的基准测试结果可以[在线更新](https://tinyurl.com/mysqlbm)。
- en: MySQL Basics
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL 基础知识
- en: A *database* is a structured collection of records or data stored in a computer
    system and organized in such a way that it can be quickly searched and information
    can be rapidly retrieved.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据库*是存储在计算机系统中的结构化记录或数据的集合，并以可以快速搜索并能迅速检索信息的方式组织。'
- en: 'The *SQL* in MySQL stands for *Structured Query Language*. This language is
    loosely based on English and also used in other databases such as Oracle and Microsoft
    SQL Server. It is designed to allow simple requests from a database via commands
    such as:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 中的 *SQL* 代表 *Structured Query Language*。这种语言基于英语并且也用于其他数据库，如 Oracle 和
    Microsoft SQL Server。它旨在通过命令允许从数据库中发出简单请求，例如：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A MySQL database contains one or more *tables*, each of which contains *records*
    or *rows*. Within these rows are various *columns* or *fields* that contain the
    data itself. [Table 8-1](#example_of_a_simple_database) shows the contents of
    an example database of five publications, detailing the author, title, type, and
    year of publication.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 MySQL 数据库包含一个或多个*表*，每个表包含*记录*或*行*。在这些行中有各种*列*或*字段*，包含数据本身。[表 8-1](#example_of_a_simple_database)
    展示了一个包含五个出版物的示例数据库，详细说明了作者、标题、类型和出版年份。
- en: Table 8-1\. Example of a simple database
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-1。简单数据库示例
- en: '| Author | Title | Type | Year |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| 作者 | 标题 | 类型 | 年份 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Mark Twain | The Adventures of Tom Sawyer | Fiction | 1876 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 马克·吐温 | 汤姆·索亚历险记 | 小说 | 1876 |'
- en: '| Jane Austen | Pride and Prejudice | Fiction | 1811 |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 简·奥斯汀 | 傲慢与偏见 | 小说 | 1811 |'
- en: '| Charles Darwin | The Origin of Species | Nonfiction | 1856 |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 查尔斯·达尔文 | 物种起源 | 非虚构 | 1856 |'
- en: '| Charles Dickens | The Old Curiosity Shop | Fiction | 1841 |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 查尔斯·狄更斯 | 古玩店 | 小说 | 1841 |'
- en: '| William Shakespeare | Romeo and Juliet | Play | 1594 |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 威廉·莎士比亚 | 罗密欧与朱丽叶 | 戏剧 | 1594 |'
- en: Each row in the table is the same as a row in a MySQL table, a column in the
    table corresponds to a column in MySQL, and each element within a row is the same
    as a MySQL field.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的每一行与 MySQL 表中的一行相同，表中的每一列对应 MySQL 中的一列，行内的每个元素与 MySQL 中的字段相同。
- en: To uniquely identify this database, I’ll refer to it as the *publications* database
    in the examples that follow. And, as you will have observed, all these publications
    are considered to be classics of literature, so I’ll call the table within the
    database that holds the details *classics*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了唯一标识此数据库，我将在接下来的示例中称其为*出版物*数据库。同时，正如您已经注意到的，所有这些出版物都被认为是文学经典，所以我将称表中保存详细信息的表为*经典文学*。
- en: Summary of Database Terms
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库术语总结
- en: 'The main terms you need to acquaint yourself with for now are as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在需要熟悉的主要术语如下：
- en: <dfn class="keep-together">Database</dfn>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">数据库</dfn>
- en: The overall container for a collection of MySQL data
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 包含 MySQL 数据集合的整体容器
- en: <dfn class="keep-together">Table</dfn>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">表</dfn>
- en: A subcontainer within a database that stores the actual data
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中存储实际数据的子容器
- en: <dfn class="keep-together">Row</dfn>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">行</dfn>
- en: A single record within a table, which may contain several fields
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表内的单个记录，可能包含多个字段
- en: <dfn class="keep-together">Column</dfn>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">列</dfn>
- en: The name of a field within a row
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一行中的字段名称
- en: I should note that I’m not trying to reproduce the precise terminology used
    about relational databases but just to provide simple, everyday terms to help
    you quickly grasp basic concepts and get started with a database.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该指出，我并不试图复制关于关系数据库使用的精确术语，而只是提供简单、日常的术语，以帮助您快速掌握基本概念并开始使用数据库。
- en: Accessing MySQL via the Command Line
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过命令行访问 MySQL
- en: 'There are three main ways you can interact with MySQL: using a command line,
    via a web interface such as phpMyAdmin, and through a programming language like
    PHP. We’ll start doing the third of these in [Chapter 11](ch11.xhtml#accessing_mysql_using_php),
    but for now, let’s look at the first two.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要方式可以与MySQL交互：使用命令行、通过诸如phpMyAdmin的Web界面以及通过PHP等编程语言。我们将从[第 11 章](ch11.xhtml#accessing_mysql_using_php)开始进行这些操作的第三种方法，但现在让我们先看看前两种方法。
- en: Starting the Command-Line Interface
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动命令行界面
- en: The following sections describe relevant instructions for Windows, macOS, and
    Linux.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分描述了Windows、macOS和Linux的相关说明。
- en: Windows users
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows用户
- en: 'If you installed AMPPS (as explained in [Chapter 2](ch02.xhtml#setting_up_a_development_server))
    in the usual way, you will be able to access the MySQL executable from the following
    directory:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您按照[第 2 章](ch02.xhtml#setting_up_a_development_server)中解释的方式安装了AMPPS，您将能够从以下目录访问MySQL可执行文件：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you installed AMPPS in any other place, you will need to use that directory
    instead, such as the following for 32-bit installations of AMPPS:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在其他位置安装了AMPPS，则需要使用该目录，例如32位安装的AMPPS如下：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'By default, the initial MySQL user is *root*, and it will have a default password
    of *mysql*. So, to enter MySQL’s command-line interface, select Start→Run, enter
    `CMD` into the Run box, and press Return. This will call up a Windows command
    prompt. From there, enter the following (making any appropriate changes as just
    discussed):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，初始MySQL用户是*root*，默认密码是*mysql*。因此，要进入MySQL的命令行界面，请选择开始→运行，输入`CMD`到运行框中，然后按回车。这将调用Windows命令提示符。从那里，输入以下内容（根据刚才讨论做出适当更改）：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first command changes to the MySQL directory, and the second tells MySQL
    to log you in as user *root*, with the password *mysql*. You will now be logged
    in to MySQL and can start entering commands.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条命令切换到MySQL目录，第二条告诉MySQL使用用户*root*和密码*mysql*登录。您现在已登录到MySQL，可以开始输入命令了。
- en: 'If you are using Windows PowerShell (rather than a command prompt), it will
    not load commands from the current location as you must explicitly specify where
    to load a program  from, in which case you would, instead, enter the following
    (note the preceding `./` before the `mysql` command):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是Windows PowerShell（而不是命令提示符），它不会从当前位置加载命令，因此您必须明确指定要从何处加载程序，这种情况下，您应输入以下内容（注意在`mysql`命令之前加上前缀 `./`）：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To be sure everything is working as it should be, enter the following—the results
    should be similar to [Figure 8-1](#accessing_mysql_from_a_windows_command_p):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保一切都按预期工作，请输入以下内容，结果应类似于[图 8-1](#accessing_mysql_from_a_windows_command_p)：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](Images/pmj6_0801.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pmj6_0801.png)'
- en: Figure 8-1\. Accessing MySQL from a Windows command prompt
  id: totrans-47
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-1\. 从Windows命令提示符访问MySQL
- en: You are now ready to move on to the next section, [“Using the Command-Line Interface”](#using_the_command-line_interface).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以继续下一节，[“使用命令行界面”](#using_the_command-line_interface)。
- en: macOS users
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: macOS用户
- en: To proceed with this chapter, you should have installed AMPPS as detailed in
    [Chapter 2](ch02.xhtml#setting_up_a_development_server). You should also have
    the web server running and the MySQL server started.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要继续本章，您应按照[第 2 章](ch02.xhtml#setting_up_a_development_server)中详细介绍的方式安装AMPPS。您还应该运行Web服务器并启动MySQL服务器。
- en: To enter the MySQL command-line interface, start the Terminal program (which
    should be available in Finder→Utilities). Then call up the MySQL program, which
    will have been installed in the directory */Applications/ampps/mysql/bin*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入MySQL命令行界面，请启动Terminal程序（Finder→Utilities中应该有）。然后调用已安装在目录*/Applications/ampps/mysql/bin*中的MySQL程序。
- en: 'By default, the initial MySQL user is *root*, and it will have a password of
    *mysql*. So, to start the program, type the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，初始MySQL用户是*root*，密码为*mysql*。因此，要启动程序，请输入以下内容：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This command tells MySQL to log you in as user *root* using the password *mysql*.
    To verify that all is well, type the following ([Figure 8-2](#accessing_mysql_from_the_os_x_terminal_p)
    should be the result):'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉MySQL使用用户*root*和密码*mysql*登录。为了验证一切正常，请输入以下内容（应该会得到[图 8-2](#accessing_mysql_from_the_os_x_terminal_p)的结果）：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![Accessing MySQL from the macOS Terminal program](Images/pmj6_0802.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![从macOS终端程序访问MySQL](Images/pmj6_0802.png)'
- en: Figure 8-2\. Accessing MySQL from the macOS Terminal program
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-2\. 从macOS终端程序访问MySQL
- en: If you receive an error such as `Can't connect to local MySQL server through
    socket`, you may need to first start the MySQL server as described in [Chapter 2](ch02.xhtml#setting_up_a_development_server).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果收到类似`Can't connect to local MySQL server through socket`的错误，请首先按照[第二章](ch02.xhtml#setting_up_a_development_server)中描述的步骤启动MySQL服务器。
- en: You should now be ready to move on to the next section, [“Using the Command-Line
    Interface”](#using_the_command-line_interface).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该准备好进入下一节，[“使用命令行界面”](#using_the_command-line_interface)。
- en: Linux users
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Linux用户
- en: 'On a system running a Unix-like operating system such as Linux, you may already
    have PHP and MySQL installed and running, and be able to enter the examples in
    the next section (if not, you can follow the procedure outlined in [Chapter 2](ch02.xhtml#setting_up_a_development_server)
    to install AMPPS). First, you should type the following to log in to your MySQL
    system:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行类似Linux的Unix操作系统的系统上，您可能已经安装并运行了PHP和MySQL，并且能够进入下一节的示例（如果没有，则可以按照[第二章](ch02.xhtml#setting_up_a_development_server)中的步骤安装AMPPS）。首先，您应该输入以下内容以登录到您的MySQL系统：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This tells MySQL to log you in as the user *root* and to request your password.
    If you have a password, enter it; otherwise, just press Return.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉MySQL使用用户*root*登录，并要求输入密码。如果有密码，请输入；否则，只需按回车键即可。
- en: 'Once you are logged in, type the following to test the program—you should see
    something like [Figure 8-3](#accessing_mysql_using_linux) in response:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录成功，请输入以下内容来测试程序——您应该会看到类似[图 8-3](#accessing_mysql_using_linux)的响应：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Accessing MySQL using Linux](Images/pmj6_0803.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用Linux访问MySQL](Images/pmj6_0803.png)'
- en: Figure 8-3\. Accessing MySQL using Linux
  id: totrans-67
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-3\. 使用Linux访问MySQL
- en: If this procedure fails at any point, please refer to [Chapter 2](ch02.xhtml#setting_up_a_development_server)
    to ensure that you have MySQL properly installed. Otherwise, you should now be
    ready to move on to the next section, [“Using the Command-Line Interface”](#using_the_command-line_interface).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此过程在任何时候失败，请参考[第二章](ch02.xhtml#setting_up_a_development_server)确保您已正确安装MySQL。否则，您现在应该准备好进入下一节，[“使用命令行界面”](#using_the_command-line_interface)。
- en: MySQL on a remote server
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 远程服务器上的MySQL
- en: 'If you are accessing MySQL on a remote server, it will probably be a Linux/FreeBSD/Unix
    type of box, and you should connect to it via the secure SSH protocol (avoid using
    the insecure Telnet protocol at all costs). Once in there, you might find that
    things are a little different, depending on how the system administrator has set
    the server up—especially if it’s a shared hosting server. Therefore, you need
    to ensure that you have been given access to MySQL and that you have your username
    and password. Armed with these, you can then type the following, where *`username`*
    is the name supplied:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在访问远程服务器上的MySQL，它可能是Linux/FreeBSD/Unix类型的服务器，您应该通过安全的SSH协议连接到它（切勿使用不安全的Telnet协议）。一旦连接成功，您可能会发现事情有些不同，这取决于系统管理员如何设置服务器——尤其是如果它是共享主机服务器。因此，您需要确保已获得MySQL的访问权限，并且拥有您的用户名和密码。有了这些信息，您可以输入以下内容，其中*`username`*是您提供的用户名：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Enter your password when prompted. You can then try the following command,
    which should result in something like [Figure 8-3](#accessing_mysql_using_linux):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 提示输入密码。然后，您可以尝试以下命令，这应该会得到类似[图 8-3](#accessing_mysql_using_linux)的结果：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There may be other databases already created, and the *test* database may not
    be there.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可能已经存在其他数据库，而*test*数据库可能不存在。
- en: Bear in mind also that system administrators have ultimate control over everything
    and that you can encounter some unexpected setups. For example, you may find that
    you are required to preface all database names that you create with a unique identifying
    string to ensure that your names do not conflict with those of databases created
    by other users.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住系统管理员对所有事物有最终控制权，您可能会遇到一些意外的设置。例如，您可能会发现需要在创建的所有数据库名称之前加上唯一的标识字符串，以确保您的名称不会与其他用户创建的数据库名称发生冲突。
- en: Therefore, if you have any problems, talk with your system administrator, who
    will get you sorted out. Just let the sysadmin know that you need a username and
    password. You should also ask for the ability to create new databases or, at a
    minimum, to have at least one database created for you ready to use. You can then
    create all the tables you require within that database.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您遇到任何问题，请与系统管理员交谈，他们将会帮助您解决问题。只需告诉系统管理员您需要用户名和密码。您还应该要求能够创建新的数据库或者至少为您创建一个准备好使用的数据库。然后，您可以在该数据库中创建所有需要的表格。
- en: Using the Command-Line Interface
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令行界面
- en: From here on out, it makes no difference whether you are using Windows, macOS,
    or Linux to access MySQL directly, as all the commands used (and errors you may
    receive) are identical.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，无论您使用Windows、macOS还是Linux直接访问MySQL，使用的所有命令（以及可能出现的错误）都是相同的。
- en: The semicolon
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分号
- en: Let’s start with the basics. Did you notice the semicolon (`;`) at the end of
    the `SHOW databases;` command that you typed? The semicolon is used by MySQL to
    separate or end commands. If you forget to enter it, MySQL will issue a prompt
    and wait for you to do so. The required semicolon was made part of the syntax
    to let you enter multiline commands, which can be convenient because some commands
    get quite long. It also allows you to issue more than one command at a time by
    placing a semicolon after each one. The interpreter gets them all in a batch when
    you press the Enter (or Return) key and executes them in order.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从基础知识开始。您注意到您键入的`SHOW databases;`命令末尾的分号（`;`）了吗？分号由MySQL用于分隔或结束命令。如果您忘记输入它，MySQL将发出提示并等待您输入。所需的分号被纳入语法中，以便您输入多行命令，这可能很方便，因为有些命令变得相当长。它还允许您在每个命令后放置分号，一次输入多个命令。当您按下Enter（或Return）键时，解释器会将它们全部接收并按顺序执行。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s very common to receive a MySQL prompt instead of the results of your command;
    it means that you forgot the final semicolon. Just enter the semicolon and press
    the Enter key, and you’ll get what you want.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 很常见的是，您会收到MySQL提示符而不是您命令的结果；这意味着您忘记了最后的分号。只需输入分号并按Enter键，您将得到您想要的结果。
- en: There are six different prompts that MySQL may present you with (see [Table 8-2](#mysqlapostrophes_six_command_prompts)),
    so you will always know where you are during a multiline input.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL可能会向您展示六种不同的提示符（参见[表 8-2](#mysqlapostrophes_six_command_prompts)），因此您始终会知道在多行输入时的位置。
- en: Table 8-2\. MySQL’s six command prompts
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-2\. MySQL的六个命令提示符
- en: '| MySQL prompt | Meaning |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| MySQL提示符 | 意义 |'
- en: '| --- | --- |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mysql>` | Ready and waiting for a command |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `mysql>` | 准备并等待命令 |'
- en: '| `->` | Waiting for the next line of a command |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `->` | 等待下一行命令 |'
- en: '| `''>` | Waiting for the next line of a string started with a single quote
    |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `''>` | 等待下一行以单引号开头的字符串 |'
- en: '| `">` | Waiting for the next line of a string started with a double quote
    |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `">` | 等待下一行以双引号开头的字符串 |'
- en: '| `` `> `` | Waiting for the next line of a string started with a backtick
    |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `` `> `` | 等待下一行以反引号开头的字符串 |'
- en: '| `/*>` | Waiting for the next line of a comment started with `/*` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `/*>` | 等待下一行以`/*`开头的注释 |'
- en: Canceling a command
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 取消命令
- en: If you are partway through entering a command and decide you don’t wish to execute
    it after all, you can enter `\c` and press Return. [Example 8-1](#canceling_a_line_of_input)
    shows how to use the command.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在输入命令的过程中决定不执行它，可以输入`\c`并按回车键。[示例 8-1](#canceling_a_line_of_input)展示了如何使用该命令。
- en: Example 8-1\. Canceling a line of input
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. 取消输入行
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When you type that line, MySQL will ignore everything you typed and issue a
    new prompt. Without the `\c`, it would have displayed an error message. Be careful,
    though: if you have opened a string or comment, close it first before using the
    `\c` or MySQL will think the `\c` is just part of the string. [Example 8-2](#canceling_input_from_inside_a_string)
    shows the right way to do this.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当您键入该行时，MySQL将忽略您键入的所有内容并发出新的提示符。如果没有`\c`，它将显示错误消息。但要小心：如果您已打开字符串或注释，请先关闭它，然后再使用`\c`，否则MySQL会认为`\c`只是字符串的一部分。[示例 8-2](#canceling_input_from_inside_a_string)展示了正确的做法。
- en: Example 8-2\. Canceling input from inside a string
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. 从字符串内部取消输入
- en: '[PRE13]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also note that using `\c` after a semicolon will not cancel the preceding command,
    as it is then a new statement.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在分号后使用`\c`将不会取消之前的命令，因为这是一个新的语句。
- en: MySQL Commands
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL命令
- en: You’ve already seen the `SHOW` command, which lists tables, databases, and many
    other items. The commands you’ll use most often are listed in [Table 8-3](#selection_of_common_mysql_commands).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了`SHOW`命令，它列出了表、数据库和许多其他项目。您最常使用的命令列在[表 8-3](#selection_of_common_mysql_commands)中。
- en: Table 8-3\. Common MySQL commands
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-3\. 常见的MySQL命令
- en: '| Command | Action |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 动作 |'
- en: '| --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `ALTER` | Alter a database or table |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `ALTER` | 修改数据库或表 |'
- en: '| `BACKUP` | Back up a table |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `BACKUP` | 备份表 |'
- en: '| `\c` | Cancel input |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `\c` | 取消输入 |'
- en: '| `CREATE` | Create a database |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `CREATE` | 创建数据库 |'
- en: '| `DELETE` | Delete a row from a table |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 从表中删除一行 |'
- en: '| `DESCRIBE` | Describe a table’s columns |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `DESCRIBE` | 描述表的列 |'
- en: '| `DROP` | Delete a database or table |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `DROP` | 删除数据库或表 |'
- en: '| `EXIT` (Ctrl-C) | Exit (on some systems) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `EXIT` (Ctrl-C) | 退出（某些系统上） |'
- en: '| `GRANT` | Change user privileges |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `GRANT` | 更改用户权限 |'
- en: '| `HELP` (`\h`, `\?`) | Display help |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `HELP` (`\h`, `\?`) | 显示帮助 |'
- en: '| `INSERT` | Insert data |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `INSERT` | 插入数据 |'
- en: '| `LOCK` | Lock table(s) |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `LOCK` | 锁定表 |'
- en: '| `` QUIT `(`\q`)` `` | Same as `EXIT` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `` QUIT `(`\q`)` `` | 同`EXIT` |'
- en: '| `RENAME` | Rename a table |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `RENAME` | 重命名表 |'
- en: '| `SHOW` | List details about an object |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `SHOW` | 列出对象的详细信息 |'
- en: '| `SOURCE` | Execute a file |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `SOURCE` | 执行文件 |'
- en: '| `STATUS` (`\s`) | Display the current status |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `STATUS` (`\s`) | 显示当前状态 |'
- en: '| `TRUNCATE` | Empty a table |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `TRUNCATE` | 清空表 |'
- en: '| `UNLOCK` | Unlock table(s) |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `UNLOCK` | 解锁表 |'
- en: '| `UPDATE` | Update an existing record |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `UPDATE` | 更新现有记录 |'
- en: '| `USE` | Use a database |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `USE` | 使用数据库 |'
- en: 'I’ll cover most of these as we proceed, but first, you need to remember a couple
    of points about MySQL commands:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我将涵盖其中大部分内容，但首先，您需要记住MySQL命令的几个要点：
- en: SQL commands and keywords are case-insensitive. `CREATE`, `create`, and `CrEaTe`
    all mean the same thing. However, for the sake of clarity, you may prefer to use
    uppercase.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL命令和关键字不区分大小写。`CREATE`、`create`和`CrEaTe`都表示同一意思。然而，为了清晰起见，您可能更喜欢使用大写。
- en: Table names are case-sensitive on Linux and macOS but case-insensitive on Windows.
    So, for the sake of portability, you should always choose a case and stick to
    it. The recommended style is to use lowercase for table names.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Linux和macOS上，表名区分大小写，但在Windows上不区分大小写。因此，为了可移植性，请始终选择一种大小写风格并坚持使用。推荐的风格是对表名使用小写。
- en: Creating a database
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建数据库
- en: 'If you are working on a remote server and have only a single user account and
    access to a single database that was created for you, move on to the section [“Creating
    a table”](#creating_a_table). Otherwise, get the ball rolling by issuing the following
    command to create a new database called *publications*:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在远程服务器上工作，并且只有一个用户帐户和访问为您创建的单个数据库，请继续到“创建表”部分（#creating_a_table）。否则，通过执行以下命令来创建一个名为*publications*的新数据库：
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A successful command will return a message that doesn’t mean much yet—`Query
    OK, 1 row affected (0.00 sec)`—but will make sense soon. Now that you’ve created
    the database, you want to work with it, so issue the following command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一条成功的命令将返回一条目前意义不大的消息—`Query OK, 1 row affected (0.00 sec)`—但很快就会变得合理。现在您已经创建了数据库，想要使用它，请执行以下命令：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should now see the message `Database changed` and will then be set to proceed
    with the following examples.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该看到消息`Database changed`，然后可以继续执行以下示例。
- en: Creating users
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户
- en: Now that you’ve seen how easy it is to use MySQL and created your first database,
    it’s time to look at how you create users, as you probably won’t want to grant
    your PHP scripts root access to MySQL—it could cause a real headache should you
    get hacked.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何轻松使用MySQL并创建了您的第一个数据库，是时候看看如何创建用户了，因为您可能不想将PHP脚本授予MySQL的root访问权限——如果被黑客入侵将会带来真正的麻烦。
- en: 'To create a user, issue the `CREATE USER` command, which takes the following
    form (don’t type this in; it’s not an actual working command):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建用户，请发出`CREATE USER`命令，其形式如下（不要输入此命令；这不是一个实际的工作命令）：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This should all look pretty straightforward, with the possible exception of
    the `*database.object*` part, which refers to the database itself and the objects
    it contains, such as tables (see [Table 8-4](#example_parameters_for_the_grant_command)).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来都很简单，可能除了`*database.object*`部分，它指的是数据库本身及其包含的对象，如表（参见[表 8-4](#example_parameters_for_the_grant_command)）。
- en: Table 8-4\. Example parameters for the `GRANT` command
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-4\. `GRANT`命令的示例参数
- en: '| Arguments | Meaning |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 意义 |'
- en: '| --- | --- |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*.*` | All databases and all their objects |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `*.*` | 所有数据库及其所有对象 |'
- en: '| ``*`database`*.*`` | Only the database called *`database`* and all its objects
    |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| ``*`database`*.*`` | 仅限名为*`database`*的数据库及其所有对象 |'
- en: '| ``*`database`*.*`object`*`` | Only the database called *`database`* and its
    object called *`object`* |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '``*`database`*.*`object`*`` | 仅限名为*`database`*的数据库及其名为*`object`*的对象 |'
- en: 'So, let’s create a user who can access just the new *publications* database
    and all its objects, by entering the following commands (replacing the username
    *jim* and also the password *password* with ones of your choosing):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们创建一个用户，他可以访问新的*publications*数据库及其所有对象，输入以下命令（用您选择的用户名*jim*和密码*password*替换）：
- en: '[PRE17]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: What this does is allow the user *jim@localhost* full access to the *publications*
    database using the password *password*. You can test whether this step has worked
    by entering `quit` to exit and then rerunning MySQL the way you did before, but
    instead of logging in as root, log in with whatever username you created (e.g.,
    jim). See [Table 8-5](#starting_mysql_and_logging_in_as_jimcomm) for the correct
    command for your operating system. Modify it as necessary if the *mysql* client
    program is installed in a different directory on your system.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的效果是允许用户*jim@localhost*使用密码*password*完全访问*publications*数据库。你可以通过输入`quit`退出并重新运行MySQL来测试此步骤是否有效，但不要像以前那样以root身份登录，而是使用你创建的用户名登录（例如，jim）。参见[Table 8-5](#starting_mysql_and_logging_in_as_jimcomm)获取适合你操作系统的正确命令。如果*mysql*客户端程序安装在系统的不同目录中，则需要根据需要修改。
- en: Table 8-5\. Starting MySQL and logging in as jim@localhost
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-5\. 启动MySQL并作为jim@localhost登录
- en: '| OS | Example command |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 操作系统 | 示例命令 |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Windows | `C:\"Program Files\Ampps\mysql\bin\mysql" -u jim -p` |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| Windows | `C:\"Program Files\Ampps\mysql\bin\mysql" -u jim -p` |'
- en: '| macOS | `/Applications/ampps/mysql/bin/mysql -u jim -p` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| macOS | `/Applications/ampps/mysql/bin/mysql -u jim -p` |'
- en: '| Linux | `mysql -u jim –p` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| Linux | `mysql -u jim –p` |'
- en: All you have to do now is enter your password when prompted and you will be
    logged in.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你只需要在提示时输入密码，就可以登录了。
- en: If you choose to, you can place your password immediately following the `-p`
    (without any spaces) to avoid having to enter it when prompted, but this is considered
    poor practice because if other people are logged in to your system, there may
    be ways for them to look at the command you entered and find out your password.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你可以在`-p`后立即输入你的密码（无需任何空格），以避免在提示时输入密码，但这被认为是不良实践，因为如果其他人登录到你的系统，可能有方法查看你输入的命令并找出你的密码。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can grant only privileges that you already have, and you must also have
    the privilege to issue `GRANT` commands. There are a whole range of privileges
    you can choose to grant if you are not granting all privileges. For further details
    on the `GRANT` command and the `REVOKE` command, which can remove privileges once
    granted, see the [documentation](https://tinyurl.com/mysqlgrant). Also, be aware
    that if you create a new user but do not specify an `IDENTIFIED BY` clause, the
    user will have no password, a situation that is very insecure and should be avoided.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你只能授予你已经拥有的权限，并且你必须有权限执行`GRANT`命令。如果你不打算授予所有权限，你可以选择授予一系列的权限。有关`GRANT`命令和一旦授予就可以撤销的`REVOKE`命令的更多详细信息，请参阅[文档](https://tinyurl.com/mysqlgrant)。此外，请注意，如果你创建一个新用户但没有指定`IDENTIFIED
    BY`子句，该用户将没有密码，这是非常不安全的情况，应该避免。
- en: Creating a table
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建表格
- en: 'At this point, you should now be logged in to MySQL with `ALL` privileges granted
    for the database *publications* (or a database that was created for you), so you’re
    ready to create your first table. Make sure the correct database is in use by
    typing the following (replacing `publications` with the name of your database
    if it is different):'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，你应该已经登录到MySQL，为*publications*数据库（或为你创建的数据库）授予了`ALL`权限，因此你可以开始创建你的第一个表格了。确保输入以下内容以使用正确的数据库（如果名称不同，请替换`publications`）：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now enter the command in [Example 8-3](#creating_a_table_called_classics) one
    line at a time.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在逐行输入[Example 8-3](#creating_a_table_called_classics)中的命令。
- en: Example 8-3\. Creating a table called classics
  id: totrans-164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-3\. 创建名为classics的表
- en: '[PRE19]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The final two words in this command require a little explanation. MySQL can
    process queries in many different ways internally, and these different ways are
    supported by different *engines*. From version 5.6 onward *InnoDB* is the default
    storage engine for MySQL, and we use it here because it supports `FULLTEXT` searches.
    As long as you have a relatively up-to-date version of MySQL, you can omit the
    `ENGINE InnoDB` section of the command when creating a table, but I have kept
    it in for now to emphasize that this is the engine being used.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令中的最后两个词需要稍作解释。MySQL可以以多种不同的方式内部处理查询，这些不同的方式由不同的*引擎*支持。从版本5.6开始，*InnoDB*是MySQL的默认存储引擎，我们在这里使用它是因为它支持`FULLTEXT`搜索。只要你有一个相对最新的MySQL版本，你可以在创建表时省略命令中的`ENGINE
    InnoDB`部分，但我现在保留它以强调正在使用的引擎。
- en: If you are running a version of MySQL prior to 5.6, the InnoDB engine will not
    support `FULLTEXT` indexes, so you will have to replace `InnoDB` in the command
    with `MyISAM` to indicate that you want to use that engine (see [“Creating a FULLTEXT
    index”](#creating_a_fulltext_index)).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是MySQL 5.6之前的版本，则InnoDB引擎不支持`FULLTEXT`索引，因此您需要在命令中将`InnoDB`替换为`MyISAM`以指示您希望使用该引擎（参见[“创建FULLTEXT索引”](#creating_a_fulltext_index)）。
- en: InnoDB is generally more efficient and the recommended option. If you installed
    the AMPPS stack as detailed in [Chapter 2](ch02.xhtml#setting_up_a_development_server),
    you should have at least version 5.6.35 of MySQL.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: InnoDB通常更高效且是推荐的选项。如果您按照[第2章](ch02.xhtml#setting_up_a_development_server)中详细说明的方法安装了AMPPS堆栈，则应至少具有MySQL的5.6.35版本。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'You could also issue the previous command on a single line, like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将上一个命令一次性在一行上执行，就像这样：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: But MySQL commands can be long and complicated, so I recommend using the format
    shown in [Example 8-3](#creating_a_table_called_classics) until you are comfortable
    with longer ones.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 但是MySQL命令可能会很长和复杂，因此我建议在您熟悉较长命令之前使用[示例 8-3](#creating_a_table_called_classics)中显示的格式。
- en: MySQL should then issue the response `Query OK, 0 rows affected`, along with
    how long it took to execute the command. If you see an error message instead,
    check your syntax carefully. Every parenthesis and comma counts, and typing errors
    are easy to make.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 然后MySQL应显示响应`Query OK, 0 rows affected`，以及执行命令所花费的时间。如果您看到错误消息，请仔细检查您的语法。每个括号和逗号都很重要，打字错误很容易出现。
- en: 'To check whether your new table has been created, type the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查新表是否已创建，请输入以下内容：
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: All being well, you will see the sequence of commands and responses shown in
    [Example 8-4](#mysql_session_creating_and_checking_a), where you should particularly
    note the table format displayed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一切顺利的话，您将看到[示例 8-4](#mysql_session_creating_and_checking_a)中显示的一系列命令和响应，特别注意显示的表格式。
- en: 'Example 8-4\. A MySQL session: creating and checking a new table'
  id: totrans-178
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-4\. MySQL会话：创建和检查新表
- en: '[PRE22]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `DESCRIBE` command is an invaluable debugging aid when you need to ensure
    that you have correctly created a MySQL table. You can also use it to remind yourself
    about a table’s field or column names and the types of data in each one. Let’s
    look at each of the headings in detail:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要确保已正确创建MySQL表时，`DESCRIBE`命令是一种无价的调试辅助工具。您还可以使用它来回顾表的字段或列名称以及每个字段中的数据类型。让我们详细查看每个标题：
- en: <dfn class="keep-together">`Field`</dfn>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Field`</dfn>
- en: The name of each field or column within a table
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 表内每个字段或列的名称
- en: <dfn class="keep-together">`Type`</dfn>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Type`</dfn>
- en: The type of data being stored in the field
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 字段中存储的数据类型
- en: <dfn class="keep-together">`Null`</dfn>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Null`</dfn>
- en: Whether the field is allowed to contain a value of `NULL`
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 字段是否允许包含`NULL`值
- en: <dfn class="keep-together">`Key`</dfn>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Key`</dfn>
- en: What type of key, if any, has been applied (*keys* or *indexes* in MySQL are
    quick ways to look up and search for data)
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 已应用的键的类型（在MySQL中，*键*或*索引*是快速查找和搜索数据的一种方式）
- en: <dfn class="keep-together">`Default`</dfn>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Default`</dfn>
- en: The default value that will be assigned to the field if no value is specified
    when a new row is created
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建新行时未指定值，则将分配给字段的默认值
- en: <dfn class="keep-together">`Extra`</dfn>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`Extra`</dfn>
- en: Additional information, such as whether a field is set to auto-increment
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 附加信息，例如字段是否设置为自动增量
- en: Data Types
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据类型
- en: In [Example 8-3](#creating_a_table_called_classics), you may have noticed that
    three of the table’s fields were given the data type of `VARCHAR`, and one was
    given the type `CHAR`. The term `VARCHAR` stands for *VARiable length* *CHARacter
    string*, and the command takes a numeric value that tells MySQL the maximum length
    allowed for a string stored in this field.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 8-3](#creating_a_table_called_classics)中，您可能已经注意到表的三个字段被赋予了`VARCHAR`数据类型，而一个字段被赋予了`CHAR`类型。术语`VARCHAR`代表*可变长度字符*串，并且该命令接受一个数值，告诉MySQL在此字段中存储的字符串的最大长度。
- en: Both `CHAR` and `VARCHAR` accept text strings and impose a limit on the size
    of the field. The difference is that every string in a `CHAR` field has the specified
    size. If you put in a smaller string, it is padded with spaces. A `VARCHAR` field
    does not pad the text; it lets the size of the field vary to fit the text that
    is inserted. But `VARCHAR` requires a small amount of overhead to keep track of
    the size of each value. So, `CHAR` is slightly more efficient if the sizes are
    similar in all records, whereas `VARCHAR` is more efficient if sizes can vary
    a lot and get large. In addition, the overhead causes access to `VARCHAR` data
    to be slightly slower than to `CHAR` data.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`CHAR`和`VARCHAR`都接受文本字符串，并对字段大小施加限制。不同之处在于，`CHAR`字段中的每个字符串都具有指定的大小。如果插入较小的字符串，它将填充空格。`VARCHAR`字段不会填充文本；它允许字段的大小根据插入的文本变化。但是，`VARCHAR`需要一些开销来跟踪每个值的大小。因此，如果所有记录中的大小类似，`CHAR`稍微更有效率，而如果大小差异很大并且可能很大，则`VARCHAR`更有效率。此外，这种开销导致对`VARCHAR`数据的访问比对`CHAR`数据稍慢。'
- en: Another feature of character and text columns, important for today’s global
    web reach, is *character sets*. These assign particular binary values to particular
    characters. The character set you use for English is obviously different from
    the one you’d use for Russian. You can assign the character set to a character
    or text column when you create it.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 字符和文本列的另一个特性，对今天的全球网络覆盖非常重要的是*字符集*。这些为特定字符分配特定的二进制值。你用于英语的字符集显然与用于俄语的不同。你可以在创建字符或文本列时为其指定字符集。
- en: '`VARCHAR` is useful in our example, because it can accommodate author names
    and titles of different lengths while helping MySQL plan the size of the database
    and perform lookups and searches more easily. Just be aware that if you ever attempt
    to assign a string value longer than the length allowed, it will be truncated
    to the maximum length declared in the table definition.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`VARCHAR`非常有用，因为它可以容纳不同长度的作者名和标题，同时帮助MySQL规划数据库的大小，并更轻松地执行查找和搜索。只需注意，如果您尝试分配超过允许长度的字符串值，它将被截断为表定义中声明的最大长度。
- en: The `year` field, however, has predictable values, so instead of `VARCHAR` we
    use the more efficient `CHAR(4)` data type. The parameter of `4` allows for 4
    bytes of data, supporting all years from –999 to 9999; a byte comprises 8 bits
    and can have the values 00000000 through 11111111, which are 0 to 255 in decimal.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`year`字段具有可预测的值，因此我们使用更高效的`CHAR(4)`数据类型而不是`VARCHAR`。参数为`4`允许4个字节的数据，支持从–999到9999年的所有年份；一个字节包括8位，可以具有00000000到11111111的值，即0到255的十进制数值。
- en: You could, of course, just store two-digit values for the year, but if your
    data is still going to be needed in the following century, or may otherwise wrap
    around, it will have to be sanitized first—think of the “millennium bug” that
    would have caused dates beginning on January 1, 2000, to be treated as 1900 on
    many of the world’s biggest computer installations.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以只存储两位数值来表示年份，但如果你的数据在下个世纪仍然需要使用，或者可能会发生环绕，那么就需要先进行清理—考虑到可能导致日期从2000年1月1日开始被视为1900年的“千年虫”问题，在全球最大的计算机设施中都存在这个问题。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I didn’t use the `YEAR` data type in the *classics* table because it supports
    only the years 0000 and 1901 through 2155\. This is because MySQL stores the year
    in a single byte for reasons of efficiency, but it means that only 256 years are
    available, and the publication years of the titles in the *classics* table are
    well before 1901.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我在*classics*表中没有使用`YEAR`数据类型，因为它仅支持0000年和1901年至2155年的年份。这是因为MySQL为了效率的原因将年份存储在单个字节中，但这意味着只有256年可用，并且*classics*表中的标题出版年份远在1901年之前。
- en: The `CHAR` data type
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`CHAR`数据类型'
- en: '[Table 8-6](#mysqlapostrophes_char_data_types) lists the `CHAR` data types.
    Both types offer a parameter that sets the maximum (or exact) length of the string
    allowed in the field. As the table shows, each type has a built-in maximum number
    of bytes it can occupy.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-6](#mysqlapostrophes_char_data_types) 列出了`CHAR`数据类型。这两种类型都有一个参数，用于设置字段允许的字符串最大（或确切）长度。正如表所示，每种类型都有一个内置的最大字节数。'
- en: Table 8-6\. MySQL’s CHAR data types
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-6\. MySQL的CHAR数据类型
- en: '| Data type | Bytes used | Examples |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 使用的字节 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ``CHAR(*`n`*)`` | Exactly *`n`* (<= 255) | `CHAR(5)` *“Hello” uses 5 bytes*
    `CHAR(57)` *“Goodbye” uses 57 bytes* |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| ``CHAR(*`n`*)`` | 精确 *`n`*（<= 255） | `CHAR(5)` *“Hello” uses 5 bytes* `CHAR(57)`
    *“Goodbye” uses 57 bytes* |'
- en: '| ``VARCHAR(*`n`*)`` | Up to *`n`* (<= 65535) | `VARCHAR(7)` *“Hello” uses
    5* *bytes* `VARCHAR(100)` *“Goodbye” uses 7 bytes* |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| ``VARCHAR(*`n`*)`` | 最多 *`n`* (<= 65535) | `VARCHAR(7)` *“Hello” 使用 5* *字节*
    `VARCHAR(100)` *“Goodbye” 使用 7 字节* |'
- en: The BINARY data type
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: BINARY 数据类型
- en: The `BINARY` data types (see [Table 8-7](#mysqlapostrophes_binary_data_types))
    store strings of bytes that do not have an associated character set. For example,
    you might use the `BINARY` data type to store a GIF image.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`BINARY` 数据类型（参见 [表 8-7](#mysqlapostrophes_binary_data_types)）存储没有相关字符集的字节字符串。例如，你可以使用
    `BINARY` 数据类型来存储 GIF 图像。'
- en: Table 8-7\. MySQL’s BINARY data types
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-7\. MySQL 的 BINARY 数据类型
- en: '| Data type | Bytes used | Examples |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 使用字节 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `BINARY(`*`n`*`)` | Exactly *`n`* (<= 255) | As `CHAR` but contains binary
    data |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `BINARY(`*`n`*`)` | 恰好 *`n`* (<= 255) | 与 `CHAR` 相似但包含二进制数据 |'
- en: '| `VARBINARY(`*`n`*`)` | Up to *`n`* (<= 65535) | As `VARCHAR` but contains
    binary data |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `VARBINARY(`*`n`*`)` | 最多 *`n`* (<= 65535) | 与 `VARCHAR` 相似但包含二进制数据 |'
- en: The TEXT data types
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TEXT` 数据类型'
- en: 'Character data can also be stored in one of the `TEXT` fields. The differences
    between these fields and `VARCHAR` fields are small:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 字符数据也可以存储在一个 `TEXT` 字段中。这些字段与 `VARCHAR` 字段之间的差异很小：
- en: Prior to version 5.0.3, MySQL would remove leading and trailing spaces from
    `VARCHAR` fields.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在版本 5.0.3 之前，MySQL 会从 `VARCHAR` 字段中删除前导和尾随空格。
- en: '`TEXT` fields cannot have default values.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TEXT` 字段不能有默认值。'
- en: MySQL indexes only the first *n* characters of a `TEXT` column (you specify
    *n* when you create the index).
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL 仅索引 `TEXT` 列的前 *n* 个字符（创建索引时指定 *n*）。
- en: What this means is that `VARCHAR` is the better and faster data type to use
    if you need to search the entire contents of a field. If you will never search
    more than a certain number of leading characters in a field, you should probably
    use a `TEXT` data type (see [Table 8-8](#mysqlapostrophes_text_data_types)).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你需要搜索字段的整个内容，`VARCHAR` 是更好和更快的数据类型。如果你永远不会搜索字段中超过某个前导字符数，那么你可能应该使用 `TEXT`
    数据类型（参见 [表 8-8](#mysqlapostrophes_text_data_types)）。
- en: Table 8-8\. MySQL’s `TEXT` data types
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-8\. MySQL 的 `TEXT` 数据类型
- en: '| Data type | Bytes used | Attributes |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 使用字节 | 属性 |'
- en: '| --- | --- | --- |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ``TINYTEXT(*`n`*)`` | Up to *`n`* (<= 255) | Treated as a string with a character
    set |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| ``TINYTEXT(*`n`*)`` | 最多 *`n`* (<= 255) | 被视为带有字符集的字符串 |'
- en: '| ``TEXT(*`n`*)`` | Up to *`n`* (<= 65535) | Treated as a string with a character
    set |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| ``TEXT(*`n`*)`` | 最多 *`n`* (<= 65535) | 被视为带有字符集的字符串 |'
- en: '| ``MEDIUMTEXT(*`n`*)`` | Up to *`n`* (<= 1.67e + 7) | Treated as a string
    with a character set |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| ``MEDIUMTEXT(*`n`*)`` | 最多 *`n`* (<= 1.67e + 7) | 被视为带有字符集的字符串 |'
- en: '| ``LONGTEXT(*`n`*)`` | Up to *`n`* (<= 4.29e + 9) | Treated as a string with
    a character set |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| ``LONGTEXT(*`n`*)`` | 最多 *`n`* (<= 4.29e + 9) | 被视为带有字符集的字符串 |'
- en: The data types that have smaller maximums are also more efficient; therefore,
    you should use the one with the smallest maximum that you know is enough for any
    string you will be storing in the field.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的最大值越小，效率也越高；因此，你应该使用你知道对于字段中存储的任何字符串都足够的最小最大值。
- en: The BLOB data types
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`BLOB` 数据类型'
- en: The term `BLOB` stands for *Binary Large Object*, and therefore, as you would
    think, the `BLOB` data type is most useful for binary data in excess of 65,536
    bytes in size. The main other difference between the `BLOB` and `BINARY` data
    types is that `BLOB`s cannot have default values. The `BLOB` data types are listed
    in [Table 8-9](#mysqlapostrophes_blob_data_types).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 `BLOB` 代表 *二进制大对象*，因此，正如你想的那样，`BLOB` 数据类型对于超过 65,536 字节大小的二进制数据最为有用。`BLOB`
    和 `BINARY` 数据类型之间的主要区别是 `BLOB` 不能有默认值。`BLOB` 数据类型列在 [表 8-9](#mysqlapostrophes_blob_data_types)
    中。
- en: Table 8-9\. MySQL’s `BLOB` data types
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-9\. MySQL 的 `BLOB` 数据类型
- en: '| Data type | Bytes used | Attributes |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 使用字节 | 属性 |'
- en: '| --- | --- | --- |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| ``TINYBLOB(*`n`*)`` | Up to *`n`* (<= 255) | Treated as binary data—no character
    set |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| ``TINYBLOB(*`n`*)`` | 最多 *`n`* (<= 255) | 被视为二进制数据—无字符集 |'
- en: '| ``BLOB(*`n`*)`` | Up to *`n`* (<= 65535) | Treated as binary data—no character
    set |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| ``BLOB(*`n`*)`` | 最多 *`n`* (<= 65535) | 被视为二进制数据—无字符集 |'
- en: '| ``MEDIUMBLOB(*`n`*)`` | Up to *`n`* (<= 1.67e + 7) | Treated as binary data—no
    character set |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| ``MEDIUMBLOB(*`n`*)`` | 最多 *`n`* (<= 1.67e + 7) | 被视为二进制数据—无字符集 |'
- en: '| ``LONGBLOB(*`n`*)`` | Up to *`n`* (<= 4.29e + 9) | Treated as binary data—no
    character set |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| ``LONGBLOB(*`n`*)`` | 最多 *`n`* (<= 4.29e + 9) | 被视为二进制数据—无字符集 |'
- en: Numeric data types
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值数据类型
- en: MySQL supports various numeric data types, from a single byte up to double-precision
    floating-point numbers. Although the most memory that a numeric field can use
    up is 8 bytes, you are well advised to choose the smallest data type that will
    adequately handle the largest value you expect. This will help keep your databases
    small and quickly accessible.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持各种数值数据类型，从单字节到双精度浮点数。尽管数值字段可以使用的最大内存为8字节，但建议您选择能够充分处理您期望的最大值的最小数据类型。这有助于保持数据库小并快速访问。
- en: '[Table 8-10](#mysqlapostrophes_numeric_data_types) lists the numeric data types
    supported by MySQL and the ranges of values they can contain. In case you are
    not acquainted with the terms, a *signed number* is one with a possible range
    from a minus value, through 0, to a positive one; and an *unsigned number* has
    a value ranging from 0 to a positive one. They can both hold the same number of
    values; just picture a signed number as being shifted halfway to the left so that
    half its values are negative and half are positive. Note that floating-point values
    (of any precision) may only be signed.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 8-10](#mysqlapostrophes_numeric_data_types) 列出了MySQL支持的数值数据类型及其可包含的值范围。如果您对术语不熟悉，*有符号数*的可能范围从负值通过0到正值；*无符号数*的值范围从0到正值。它们都可以保存相同数量的值；可以想象有符号数被左移一半，使其一半的值为负数，另一半为正数。请注意，浮点数值（任何精度）可能只是有符号的。'
- en: Table 8-10\. MySQL’s numeric data types
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-10\. MySQL的数值数据类型
- en: '| Data type | Bytes used | Minimum value | Maximum value |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 使用字节 | 最小值 | 最大值 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Signed | Unsigned | Signed | Unsigned |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 有符号 | 无符号 | 有符号 | 无符号 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `TINYINT` | `1` | `–128` | `0` | `127` | `255` |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `TINYINT` | `1` | `–128` | `0` | `127` | `255` |'
- en: '| `SMALLINT` | `2` | `–32768` | `0` | `32767` | `65535` |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `SMALLINT` | `2` | `–32768` | `0` | `32767` | `65535` |'
- en: '| `MEDIUMINT` | `3` | `–8.38e + 6` | `0` | `8.38e + 6` | `1.67e + 7` |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `MEDIUMINT` | `3` | `–8.38e + 6` | `0` | `8.38e + 6` | `1.67e + 7` |'
- en: '| `INT` / `INTEGER` | `4` | `–2.15e + 9` | `0` | `2.15e + 9` | `4.29e + 9`
    |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `INT` / `INTEGER` | `4` | `–2.15e + 9` | `0` | `2.15e + 9` | `4.29e + 9`
    |'
- en: '| `BIGINT` | `8` | `–9.22e + 18` | `0` | `9.22e + 18` | `1.84e + 19` |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `BIGINT` | `8` | `–9.22e + 18` | `0` | `9.22e + 18` | `1.84e + 19` |'
- en: '| `FLOAT` | `4` | `–3.40e + 38` | *n/a* | `3.4e + 38` | *n/a* |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `FLOAT` | `4` | `–3.40e + 38` | *n/a* | `3.4e + 38` | *n/a* |'
- en: '| `DOUBLE` / `REAL` | `8` | `–1.80e + 308` | *n/a* | `1.80e + 308` | *n/a*
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `DOUBLE` / `REAL` | `8` | `–1.80e + 308` | *n/a* | `1.80e + 308` | *n/a*
    |'
- en: 'To specify whether a data type is unsigned, use the `UNSIGNED` qualifier. The
    following example creates a table called *tablename* with a field in it called
    *fieldname* of the data type `UNSIGNED INTEGER`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定数据类型是否为无符号，请使用`UNSIGNED`限定词。以下示例创建了一个名为*tablename*的表，其中包含一个名为*fieldname*的`UNSIGNED
    INTEGER`数据类型的字段：
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When creating a numeric field, you can also pass an optional number as a parameter,
    like this:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数值字段时，您还可以传递一个可选的数字作为参数，如下所示：
- en: '[PRE24]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'But you must remember that, unlike with the `BINARY` and `CHAR` data types,
    this parameter does not indicate the number of bytes of storage to use. It may
    seem counterintuitive, but what the number actually represents is the display
    width of the data in the field when it is retrieved. It is commonly used with
    the `ZEROFILL` qualifier, like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 但您必须记住，与`BINARY`和`CHAR`数据类型不同，此参数并不表示要使用的存储字节数。这似乎是反直觉的，但该数字实际上表示的是在检索字段中的数据时的显示宽度。它通常与`ZEROFILL`限定词一起使用，如下所示：
- en: '[PRE25]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: What this does is cause any numbers with a width of less than four characters
    to be padded with one or more zeros, sufficient to make the display width of the
    field four characters long. When a field is already of the specified width or
    greater, no padding takes place.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的效果是使任何宽度小于四个字符的数字填充一个或多个零，以使字段的显示宽度为四个字符长度。当字段已经达到或超过指定宽度时，不会进行填充。
- en: DATE and TIME types
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日期和时间类型
- en: The main remaining data types supported by MySQL relate to the date and time
    and can be seen in [Table 8-11](#mysqlapostrophes_date_and_time_data_type).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL支持的主要剩余数据类型涉及日期和时间，可以在[表 8-11](#mysqlapostrophes_date_and_time_data_type)中查看。
- en: Table 8-11\. MySQL’s `DATE` and `TIME` data types
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8-11\. MySQL的`DATE`和`TIME`数据类型
- en: '| Data type | Time/date format |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 时间/日期格式 |'
- en: '| --- | --- |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DATETIME` | `''0000-00-00 00:00:00''` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `DATETIME` | `''0000-00-00 00:00:00''` |'
- en: '| `DATE` | `''0000-00-00''` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `DATE` | `''0000-00-00''` |'
- en: '| `TIMESTAMP` | `''0000-00-00 00:00:00''` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `TIMESTAMP` | `''0000-00-00 00:00:00''` |'
- en: '| `TIME` | `''00:00:00''` |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `TIME` | `''00:00:00''` |'
- en: '| `YEAR` | `0000` (Only years 0000 and 1901–2155) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `YEAR` | `0000`（仅年份0000和1901–2155） |'
- en: The `DATETIME` and `TIMESTAMP` data types display the same way. The main difference
    is that `TIMESTAMP` has a very narrow range (from the years 1970 through 2037),
    whereas `DATETIME` will hold just about any date you’re likely to specify, unless
    you’re interested in ancient history or science fiction.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`DATETIME`和`TIMESTAMP`数据类型显示方式相同。主要区别在于`TIMESTAMP`具有非常狭窄的范围（从1970年到2037年），而`DATETIME`将保存几乎您可能指定的任何日期，除非您对古代历史或科幻感兴趣。'
- en: '`TIMESTAMP` is useful, however, because you can let MySQL set the value for
    you. If you don’t specify the value when adding a row, the current time is automatically
    inserted. You can also have MySQL update a `TIMESTAMP` column each time you change
    a row.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`TIMESTAMP`很有用，因为你可以让MySQL为你设置值。如果在添加行时未指定值，则自动插入当前时间。你还可以让MySQL在每次更改行时更新`TIMESTAMP`列。'
- en: The AUTO_INCREMENT attribute
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动增量属性
- en: Sometimes you need to ensure that every row in your database is guaranteed to
    be unique. You could do this in your program by carefully checking the data you
    enter and making sure that there is at least one value that differs in any two
    rows, but this approach is error-prone and works only in certain circumstances.
    In the *classics* table, for instance, an author may appear multiple times. Likewise,
    the year of publication will also be frequently duplicated, and so on. It would
    be hard to guarantee that you have no duplicate rows.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您需要确保数据库中每一行都保证是唯一的。您可以通过仔细检查输入的数据并确保至少有一个值在任何两行中不同来在程序中执行此操作，但这种方法容易出错，并且仅在某些情况下有效。例如，在*classics*表中，作者可能多次出现。同样，出版年份也会频繁重复，等等。很难保证没有重复行。
- en: The general solution is to use an extra column just for this purpose. In a while,
    we’ll look at using a publication’s ISBN (International Standard Book Number),
    but first I’d like to introduce the `AUTO_INCREMENT` data type.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通用解决方案是专门为此目的使用额外的列。一会儿我们将讨论使用出版物的ISBN（国际标准书号），但首先我想介绍`AUTO_INCREMENT`数据类型。
- en: As its name implies, a column given this data type will set the value of its
    contents to that of the column entry in the previously inserted row, plus 1\.
    [Example 8-5](#adding_the_auto-incrementing_column_id) shows how to add a new
    column called *id* to the table *classics* with auto-incrementing.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，赋予此数据类型的列将将其内容的值设置为先前插入行中的列条目值加1。[示例 8-5](#adding_the_auto-incrementing_column_id)显示了如何向表*classics*添加名为*id*的新列，该列具有自增功能。
- en: Example 8-5\. Adding the auto-incrementing column id
  id: totrans-277
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. 添加自增列id
- en: '[PRE26]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is your introduction to the `ALTER` command, which is very similar to
    `CREATE`. `ALTER` operates on an existing table and can add, change, or delete
    columns. Our example adds a column named *id* with the following characteristics:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你对`ALTER`命令的介绍，它与`CREATE`非常相似。`ALTER`操作现有表，可以添加、更改或删除列。我们的示例添加了一个名为*id*的列，具有以下特性：
- en: <dfn class="keep-together">`INT UNSIGNED`</dfn>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`INT UNSIGNED`</dfn>
- en: Makes the column take an integer large enough for us to store more than 4 billion
    records in the table.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使该列采用足够大的整数，以便我们在表中存储超过40亿条记录。
- en: <dfn class="keep-together">`NOT NULL`</dfn>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`NOT NULL`</dfn>
- en: Ensures that every column has a value. Many programmers use `NULL` in a field
    to indicate that it doesn’t have any value. But that would allow duplicates, which
    would violate the whole reason for this column’s existence, so we disallow `NULL`
    values.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 确保每一列都有值。许多程序员在字段中使用`NULL`来指示其没有任何值。但这样做会允许重复，这将违反该列存在的整体原因，因此我们禁止`NULL`值。
- en: <dfn class="keep-together">`AUTO_INCREMENT`</dfn>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`AUTO_INCREMENT`</dfn>
- en: 'Causes MySQL to set a unique value for this column in every row, as described
    earlier. We don’t really have control over the value that this column will take
    in each row, but we don’t care: all we care about is that we are guaranteed a
    unique value.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这会导致MySQL为每一行的该列设置一个唯一值。我们实际上无法控制该列在每行中将取得的值，但我们并不在乎：我们关心的是我们可以保证一个唯一的值。
- en: <dfn class="keep-together">`KEY`</dfn>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`KEY`</dfn>
- en: An auto-increment column is useful as a key, because you will tend to search
    for rows based on this column. This will be explained in the section [“Indexes”](#indexes).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 自增列作为键很有用，因为你往往会基于这一列搜索行。这将在[“索引”](#indexes)部分进行解释。
- en: Each entry in the column *id* will now have a unique number, with the first
    starting at 1 and the others counting upward from there. And whenever a new row
    is inserted, its *id* column will automatically be given the next number in the
    sequence.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 每个*id*列的条目现在都将具有唯一的编号，第一个从1开始，其他的依次递增。每次插入新行时，其*id*列将自动获得序列中的下一个数字。
- en: Rather than applying the column retroactively, you could have included it by
    issuing the `CREATE` command in a slightly different format. In that case, the
    command in [Example 8-3](#creating_a_table_called_classics) would be replaced
    with [Example 8-6](#adding_the_auto-incrementing_id_column_a). Check the final
    line in particular.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是事后应用列，您可以通过以稍微不同的格式发布`CREATE`命令来包含它。在这种情况下，[示例 8-3](#creating_a_table_called_classics)中的命令将替换为[示例 8-6](#adding_the_auto-incrementing_id_column_a)。特别要注意最后一行。
- en: Example 8-6\. Adding the auto-incrementing id column at table creation
  id: totrans-290
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. 在表创建时添加自增id列
- en: '[PRE27]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you wish to check whether the column has been added, use the following command
    to view the table’s columns and data types:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查列是否已添加，请使用以下命令查看表的列和数据类型：
- en: '[PRE28]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that we’ve finished with it, the *id* column is no longer needed, so if
    you created it using [Example 8-5](#adding_the_auto-incrementing_column_id), you
    should now remove the column using the command in [Example 8-7](#removing_the_id_column).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了，*id*列不再需要了，因此如果您是通过[示例 8-5](#adding_the_auto-incrementing_column_id)创建它的，现在应该使用[示例 8-7](#removing_the_id_column)中的命令来删除该列。
- en: Example 8-7\. Removing the id column
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-7\. 删除id列
- en: '[PRE29]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Adding data to a table
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向表添加数据
- en: To add data to a table, use the `INSERT` command. Let’s see this in action by
    populating the table *classics* with the data from [Table 8-1](#example_of_a_simple_database),
    using one form of the `INSERT` command repeatedly ([Example 8-8](#populating_the_classics_table)).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 要向表中添加数据，请使用`INSERT`命令。让我们通过使用`INSERT`命令的一种形式，重复将来自[表 8-1](#example_of_a_simple_database)的数据填充到表*classics*中来看看它的效果（[示例 8-8](#populating_the_classics_table)）。
- en: Example 8-8\. Populating the classics table
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. 填充经典表
- en: '[PRE30]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After every second line, you should see a `Query OK` message. Once all lines
    have been entered, type the following command, which will display the table’s
    contents. The result should look like [Figure 8-4](#populating_the_classics_table_and_viewin):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 每输入完两行之后，您应该看到一个`Query OK`消息。一旦所有行都已输入，请输入以下命令，它将显示表的内容。结果应该类似于[图 8-4](#populating_the_classics_table_and_viewin)。
- en: '[PRE31]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Don’t worry about the `SELECT` command for now—we’ll come to it in the section
    [“Querying a MySQL Database”](#querying_a_mysql_database). Suffice it to say that,
    as typed, it will display all the data you just entered.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在暂时不必担心`SELECT`命令——我们将在[“查询 MySQL 数据库”](#querying_a_mysql_database)一节中讨论它。简单来说，按照现在的方式输入，它将显示您刚刚输入的所有数据。
- en: Also, don’t worry if you see the returned results in a different order as this
    is normal, because the order is unspecified at this point. Later in this chapter
    we will learn how to use `ORDER BY` to choose the order in which we wish results
    to be returned, but for now, they may appear in any order.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到返回的结果顺序不同也不要担心，这是正常的，因为此时的顺序是未指定的。在本章后面我们将学习如何使用`ORDER BY`来选择希望结果返回的顺序，但目前它们可能以任何顺序显示。
- en: '![Populating the classics table and viewing its contents](Images/pmj6_0804.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![填充经典表并查看其内容](Images/pmj6_0804.png)'
- en: Figure 8-4\. Populating the classics table and viewing its contents
  id: totrans-306
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-4\. 填充经典表并查看其内容
- en: Let’s go back and look at how we used the `INSERT` command. The first part,
    `INSERT INTO classics`, tells MySQL where to insert the following data. Then,
    within parentheses, the four column names are listed—*author*, *title*, *type*,
    and *year*—all separated by commas. This tells MySQL that these are the fields
    into which the data is to be inserted.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回头看看我们如何使用`INSERT`命令。首先部分`INSERT INTO classics`告诉MySQL在哪里插入以下数据。然后在括号内，列出了四个列名——*author*、*title*、*type*和*year*——所有列名之间用逗号分隔。这告诉MySQL这些是要插入数据的字段。
- en: The second line of each `INSERT` command contains the keyword `VALUES` followed
    by four strings within parentheses, separated by commas. This supplies MySQL with
    the four values to be inserted into the four columns previously specified. (As
    always, my choice of where to break the lines was arbitrary.)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`INSERT`命令的第二行包含关键字`VALUES`，后面跟着括号内用逗号分隔的四个字符串。这向MySQL提供了要插入到先前指定的四个列中的四个值。（一如既往，我在哪里断行是任意选择的。）
- en: Each item of data will be inserted into the corresponding column, in a one-to-one
    correspondence. If you accidentally listed the columns in a different order from
    the data, the data would go into the wrong columns. Also, the number of columns
    must match the number of data items. (There are safer ways of using `INSERT`,
    which we’ll see soon.)
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据项将插入到相应的列中，一一对应。如果您意外地按不同于数据的顺序列出列，则数据将进入错误的列中。此外，列的数量必须与数据项的数量匹配。（有更安全的`INSERT`使用方法，我们很快就会看到。）
- en: Renaming a table
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重命名表
- en: 'Renaming a table, like any other change to the structure or meta-information
    about a table, is achieved via the `ALTER` command. So, for example, to change
    the name of the table *classics* to *pre1900*, you would use the following command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 重命名表，如通过`ALTER`命令对表的结构或元信息进行的任何其他更改。因此，例如，要将表名*classics*更改为*pre1900*，您将使用以下命令：
- en: '[PRE32]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you tried that command, you should revert the table name by entering the
    following so that later examples in this chapter will work as printed:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试过该命令，则应该通过输入以下内容恢复表名，以便本章后面的示例按照打印的方式运行：
- en: '[PRE33]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Changing the data type of a column
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改列的数据类型
- en: 'Changing a column’s data type also makes use of the `ALTER` command, this time
    in conjunction with the `MODIFY` keyword. To change the data type of the column
    *year* from `CHAR(4)` to `SMALLINT` (which requires only 2 bytes of storage and
    so will save disk space), enter the following:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 更改列的数据类型还需使用`ALTER`命令，这次配合`MODIFY`关键字。要将列*year*的数据类型从`CHAR(4)`更改为`SMALLINT`（仅需要2个字节的存储空间，因此可以节省磁盘空间），请输入以下内容：
- en: '[PRE34]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When you do this, if the conversion of data type makes sense to MySQL, it will
    automatically change the data while keeping the meaning. In this case, it will
    change each string to a comparable integer, so long as the string is recognizable
    as referring to an integer.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当您执行此操作时，如果数据类型的转换对MySQL有意义，它将自动更改数据并保持含义。在这种情况下，它将每个字符串转换为可比较的整数，只要该字符串可识别为指代整数。
- en: Adding a new column
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新列
- en: 'Let’s suppose that you have created a table and populated it with plenty of
    data, only to discover you need an additional column. Not to worry. Here’s how
    to add the new column *pages*, which will be used to store the number of pages
    in a publication:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已创建了一个表并填充了大量数据，但后来发现需要增加一个额外的列。别担心。以下是如何添加新列*pages*的方法，用于存储出版物的页数：
- en: '[PRE35]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This adds the new column with the name *pages* using the `UNSIGNED SMALLINT`
    data type, sufficient to hold a value of up to 65,535—hopefully that’s more than
    enough for any book ever published!
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UNSIGNED SMALLINT`数据类型添加名为*pages*的新列，足以容纳最多65535的值——希望这足够存储任何已发表的书籍！
- en: 'And, if you ask MySQL to describe the updated table by using the `DESCRIBE`
    command, as follows, you will see the change has been made (see [Figure 8-5](#adding_the_new_pages_column_and_viewing)):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您要求MySQL使用`DESCRIBE`命令描述更新后的表，如下所示，您将看到已进行了更改（参见[图8-5](#adding_the_new_pages_column_and_viewing)）：
- en: '[PRE36]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![Adding the new pages column and viewing the table](Images/pmj6_0805.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![添加新页面列并查看表](Images/pmj6_0805.png)'
- en: Figure 8-5\. Adding the new pages column and viewing the table
  id: totrans-326
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-5。添加新页面列并查看表
- en: Renaming a column
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重命名列
- en: 'Looking again at [Figure 8-5](#adding_the_new_pages_column_and_viewing), you
    may decide that having a column named *type* is confusing, because that is the
    name used by MySQL to identify data types. Again, no problem—let’s change its
    name to *category*, like this:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看[图8-5](#adding_the_new_pages_column_and_viewing)，您可能会发现，拥有一个名为*type*的列很令人困惑，因为这是MySQL用来标识数据类型的名称。再次强调——没问题——让我们将其名称更改为*category*，如下所示：
- en: '[PRE37]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note the addition of `VARCHAR(16)` on the end of this command. That’s because
    the `CHANGE` keyword requires the data type to be specified, even if you don’t
    intend to change it, and `VARCHAR(16)` was the data type specified when that column
    was initially created as *type*.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在此命令的末尾添加了`VARCHAR(16)`。这是因为`CHANGE`关键字要求指定数据类型，即使您不打算更改它，并且在最初创建该列时指定了`VARCHAR(16)`作为*类型*。
- en: Removing a column
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除列
- en: 'Actually, upon reflection, you might decide that the page count column *pages*
    isn’t all that useful for this particular database, so here’s how to remove that
    column by using the `DROP` keyword:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在反思之后，您可能会决定这个特定数据库中的页数列*pages*并不那么有用，因此下面是如何通过使用`DROP`关键字删除该列的方法：
- en: '[PRE38]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Warning
  id: totrans-334
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Remember that `DROP` is irreversible. You should always use it with caution,
    because you could inadvertently delete entire tables (and even databases) with
    it if you are not careful!
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`DROP`是不可逆的。您应该始终谨慎使用它，因为如果不小心，它可能会意外删除整个表（甚至整个数据库）！
- en: Deleting a table
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除表
- en: Deleting a table is very easy indeed. But, because I don’t want you to have
    to reenter all the data for the *classics* table, let’s quickly create a new table,
    verify its existence, and then delete it. You can do this by typing the commands
    in [Example 8-9](#creatingcomma_viewingcomma_and_deleting). The result of these
    four commands should look like [Figure 8-6](#creatingcomma_viewingcomma_and_d-id00023).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 删除表确实非常简单。但是，因为我不希望您不得不重新输入*classics*表的所有数据，让我们快速创建一个新表，验证其存在，然后再删除它。您可以通过键入[示例 8-9](#creatingcomma_viewingcomma_and_deleting)中的命令来执行此操作。这四个命令的结果应如[图 8-6](#creatingcomma_viewingcomma_and_d-id00023)所示。
- en: Example 8-9\. Creating, viewing, and deleting a table
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-9\. 创建、查看和删除表
- en: '[PRE39]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '![Creating, viewing, and deleting a table](Images/pmj6_0806.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![创建、查看和删除表](Images/pmj6_0806.png)'
- en: Figure 8-6\. Creating, viewing, and deleting a table
  id: totrans-341
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-6\. 创建、查看和删除表
- en: Indexes
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引
- en: As things stand, the table *classics* works and can be searched without problem
    by MySQL—until it grows to more than a couple of hundred rows. At that point,
    database accesses will get slower and slower with every new row added, because
    MySQL has to search through every row whenever a query is issued. This is like
    searching through every book in a library whenever you need to look something
    up.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前而言，*classics*表可以在MySQL中无问题地工作和搜索，直到它的行数超过几百行。此时，随着每新增一行，数据库访问速度会变得越来越慢，因为MySQL在发出查询时必须搜索每一行。这就像在需要查找某物时搜索图书馆中的每一本书一样。
- en: Of course, you don’t have to search libraries that way, because they have either
    a card index system or, most likely, a database of their own. And the same goes
    for MySQL, because at the expense of a slight overhead in memory and disk space,
    you can create a “card index” for a table that MySQL will use to conduct lightning-fast
    searches.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不必像这样搜索图书馆，因为它们要么有一个卡片索引系统，要么更可能有自己的数据库。对MySQL也是如此，因为通过稍微增加内存和磁盘空间的开销，您可以为MySQL创建一个“卡片索引”，用于进行极快的搜索。
- en: Creating an Index
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建索引
- en: The way to achieve fast searches is to add an *index*, either when creating
    a table or at any time afterward. But the decision is not so simple. For example,
    there are different index types, such as a regular `INDEX`, a `PRIMARY KEY`, or
    a `FULLTEXT` index. Also, you must decide which columns require an index, a judgment
    that requires you to predict whether you will be searching any of the data in
    each column. Indexes can get more complicated too, because you can combine multiple
    columns in one index. And even when you’ve decided that, you still have the option
    of reducing index size by limiting the amount of each column to be indexed.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 实现快速搜索的方法是在创建表时或随时以后添加*索引*。但是，决策并不那么简单。例如，有不同的索引类型，如常规`INDEX`、`PRIMARY KEY`或`FULLTEXT`索引。此外，您必须决定哪些列需要索引，这需要您预测是否会搜索每列的任何数据。索引也可以变得更加复杂，因为您可以将多个列组合到一个索引中。即使在做出了决策后，您仍然可以通过限制要索引的每列的数量来减少索引大小。
- en: If we imagine the searches that may be made on the *classics* table, it becomes
    apparent that all of the columns may need to be searched. However, if the *pages*
    column created in the section [“Adding a new column”](#adding_a_new_column) had
    not been deleted, it would probably not have needed an index, as most people would
    be unlikely to search for books by the number of pages they have. Anyway, go ahead
    and add an index to each of the columns, using the commands in [Example 8-10](#adding_indexes_to_the_classics_table).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想象一下可能在*classics*表上进行的搜索，就会发现所有列都可能需要进行搜索。但是，如果在[“添加新列”](#adding_a_new_column)部分创建的*pages*列没有被删除，那么可能不需要索引，因为大多数人不太可能通过页面数来搜索书籍。不管怎样，继续为每个列添加索引，使用[示例 8-10](#adding_indexes_to_the_classics_table)中的命令。
- en: Example 8-10\. Adding indexes to the classics table
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-10\. 为classics表添加索引
- en: '[PRE40]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The first two commands create indexes on the *author* and *title* columns,
    limiting each index to only the first 20 characters. For instance, when MySQL
    indexes the following title:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个命令在*author*和*title*列上创建索引，将每个索引限制为仅前20个字符。例如，当MySQL索引以下标题时：
- en: '[PRE41]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'it will actually store in the index only the first 20 characters:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 它实际上只会存储索引的前20个字符：
- en: '[PRE42]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is done to minimize the size of the index and to optimize database access
    speed. I chose 20 because it’s likely to be sufficient to ensure uniqueness for
    most strings in these columns. If MySQL finds two indexes with the same contents,
    it will have to waste time going to the table itself and checking the column that
    was indexed to find out which rows really matched.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了减小索引的大小并优化数据库访问速度。我选择了20，因为对于这些列中的大多数字符串来说，这可能足以确保唯一性。如果MySQL发现两个内容相同的索引，它将不得不浪费时间访问表本身，并检查索引的列，以找出真正匹配的行。
- en: With the *category* column, currently only the first character is required to
    identify a string as unique (F for Fiction, N for Nonfiction, and P for Play),
    but I chose an index of four characters to allow for future categories that may
    share the first three characters. You can also reindex this column later, when
    you have a more complete set of categories. And finally, I set no limit to the
    *year* column’s index, because it has a clearly defined length of four characters.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*category*列，目前只需要第一个字符来识别字符串的唯一性（F表示Fiction，N表示Nonfiction，P表示Play），但我选择了四个字符的索引，以便未来可能共享前三个字符的类别。当您有更完整的类别集时，还可以稍后重新索引此列。最后，我对*year*列的索引没有设置限制，因为它的长度明确定义为四个字符。
- en: The results of issuing these commands (and a `DESCRIBE` command to confirm that
    they worked) can be seen in [Figure 8-7](#adding_indexes_to_the_classics_t-id00024),
    which shows the key `MUL` for each column. This key means that multiple occurrences
    of a value may occur within that column, which is exactly what we want, as authors
    may appear many times, the same book title could be used by multiple authors,
    and so on.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 发出这些命令的结果（以及确认它们是否有效的`DESCRIBE`命令）可以在[图 8-7](#adding_indexes_to_the_classics_t-id00024)中看到，该图显示了每列的`MUL`关键字。此关键字表示该列中可能存在多个值的多次出现，这正是我们想要的，因为作者可能出现多次，同一书名可能由多位作者使用，等等。
- en: '![Adding indexes to the classics table](Images/pmj6_0807.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![为经典表添加索引](Images/pmj6_0807.png)'
- en: Figure 8-7\. Adding indexes to the classics table
  id: totrans-358
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-7\. 为经典表添加索引
- en: Using CREATE INDEX
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用CREATE INDEX
- en: An alternative to using `ALTER TABLE` to add an index is to use the `CREATE
    INDEX` command. They are equivalent, except that `CREATE INDEX` cannot be used
    for creating a `PRIMARY KEY` (see the section [“Primary keys”](#primary_keys)).
    The format of this command is shown in the second line of [Example 8-11](#these_two_commands_are_equivalent).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 添加索引的另一种方法是使用`ALTER TABLE`命令。它们是等效的，但`CREATE INDEX`不能用于创建`PRIMARY KEY`（参见“主键”一节）。此命令的格式显示在[例子
    8-11](#these_two_commands_are_equivalent)的第二行中。
- en: Example 8-11\. These two commands are equivalent
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 8-11\. 这两个命令是等效的
- en: '[PRE43]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Adding indexes when creating tables
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在创建表时添加索引
- en: You don’t have to wait until after creating a table to add indexes. In fact,
    doing so can be time-consuming, as adding an index to a large table can take a
    very long time. Therefore, let’s look at a command that creates the table *classics*
    with indexes already in place.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需等到创建表后才添加索引。事实上，这样做可能会很耗时，因为向大表添加索引可能需要很长时间。因此，让我们看一下一个命令，它创建了带有索引的*classics*表。
- en: '[Example 8-12](#creating_the_table_classics_with_indexes) is a reworking of
    [Example 8-3](#creating_a_table_called_classics) in which the indexes are created
    at the same time as the table. Note that to incorporate the modifications made
    in this chapter, this version uses the new column name *category* instead of *type*
    and sets the data type of *year* to `SMALLINT` instead of `CHAR(4)`. If you want
    to try it out without first deleting your current *classics* table, change the
    word *classics* in line 1 to something else like *classics1*, and then drop *classics1*
    after you have finished with it.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[例子 8-12](#creating_the_table_classics_with_indexes) 是[例子 8-3](#creating_a_table_called_classics)
    的重新制作，在这个版本中，索引与表同时创建。请注意，为了融入本章所做的修改，此版本使用了新的列名*category*代替*type*，并将*year*的数据类型设置为`SMALLINT`，而不是`CHAR(4)`。如果您想在首先删除当前*classics*表之前尝试它，请将第1行中的*classics*改为其他名称，如*classics1*，然后在完成后删除*classics1*。'
- en: Example 8-12\. Creating the table classics with indexes
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 8-12\. 创建带索引的经典表
- en: '[PRE44]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Primary keys
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主键
- en: So far, you’ve created the table *classics* and ensured that MySQL can search
    it quickly by adding indexes, but there’s still something missing. All the publications
    in the table can be searched, but there is no single unique key for each publication
    to enable instant accessing of a row. The importance of having a key with a unique
    value for each row will come up when we start to combine data from different tables.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了表*classics*并确保MySQL可以通过添加索引快速搜索它，但仍然有一些缺失。表中的所有出版物都可以进行搜索，但没有单个唯一的键用于即时访问行。当我们开始从不同的表中组合数据时，拥有具有唯一值的键的重要性将显现出来。
- en: 'The section [“The AUTO_INCREMENT attribute”](#auto_increment_data_type) briefly
    introduced the idea of a primary key when creating the auto-incrementing column
    *id*, which could have been used as a primary key for this table. However, I wanted
    to reserve that task for a more appropriate column: the internationally recognized
    ISBN.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在[“AUTO_INCREMENT属性”](#auto_increment_data_type)一节中简要介绍了在创建自增列*id*时主键的概念，该列本可以用作此表的主键。然而，我希望将该任务保留给更合适的列：国际公认的ISBN。
- en: 'So let’s go ahead and create a new column for this key. Now, bearing in mind
    that ISBNs are 13 characters long, you might think that the following command
    would do the job:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们继续为此键创建一个新的列。请记住，ISBN号码长度为13个字符，您可能认为以下命令将起作用：
- en: '[PRE45]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: But it doesn’t. If you try it, you’ll get an error similar to `Duplicate entry`
    for key 1\. The reason is that the table is already populated with some data,
    and this command is trying to add a column with the value `NULL` to each row,
    which is not allowed, as all values must be unique in any column having a primary
    key index. If there were no data already in the table, this command would work
    just fine, as would adding the primary key index upon table creation.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 但并非如此。如果您尝试，您将收到类似于`Duplicate entry` for key 1的错误。原因是表已经填充了一些数据，并且此命令试图向每一行添加具有值`NULL`的列，这是不允许的，因为在具有主键索引的任何列中，所有值必须是唯一的。如果表中还没有数据，此命令将正常工作，就像在表创建时添加主键索引一样。
- en: In our current situation, we have to be a bit sneaky and create the new column
    without an index, populate it with data, and then add the index retrospectively
    using the commands in [Example 8-13](#populating_the_isbn_column_with_data_and).
    Luckily, each of the years is unique in the current set of data, so we can use
    the *year* column to identify each row for updating. Note that this example uses
    the `UPDATE` command and `WHERE` keyword, which are explained in more detail in
    the section [“Querying a MySQL Database”](#querying_a_mysql_database).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的情况下，我们必须稍微狡猾地创建新列，而不添加索引，填充数据，然后使用[示例8-13](#populating_the_isbn_column_with_data_and)中的命令回顾性地添加索引。幸运的是，当前数据集中每年都是唯一的，因此我们可以使用*year*列来标识每一行进行更新。请注意，此示例使用了`UPDATE`命令和`WHERE`关键字，在[“查询MySQL数据库”](#querying_a_mysql_database)一节中有更详细的解释。
- en: Example 8-13\. Populating the isbn column with data and using a primary key
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-13\. 使用数据填充isbn列并使用主键
- en: '[PRE46]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Once you have typed these commands, the results should look like [Figure 8-8](#retrospectively_adding_a_primary_key_to).
    Note that the keywords `PRIMARY KEY` replace the keyword `INDEX` in the `ALTER
    TABLE` syntax (compare Examples [8-10](#adding_indexes_to_the_classics_table)
    and [8-13](#populating_the_isbn_column_with_data_and)).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 输入这些命令后，结果应该如[图8-8](#retrospectively_adding_a_primary_key_to)所示。请注意，关键字`PRIMARY
    KEY`在`ALTER TABLE`语法中替代了关键字`INDEX`（比较示例[8-10](#adding_indexes_to_the_classics_table)和[8-13](#populating_the_isbn_column_with_data_and)）。
- en: '![Retrospectively adding a primary key to the classics table](Images/pmj6_0808.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![回顾性地向经典表添加主键](Images/pmj6_0808.png)'
- en: Figure 8-8\. Retrospectively adding a primary key to the classics table
  id: totrans-379
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图8-8\. 回顾性地向经典表添加主键
- en: To have created a primary key when the table *classics* was created, you could
    have used the commands in [Example 8-14](#creating_the_table_classics_with_a_prima).
    Again, rename *classics* in line 1 to something else if you wish to try this example,
    and then delete the test table afterward.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建*classics*表时已经创建了主键，您可以使用[示例8-14](#creating_the_table_classics_with_a_prima)中的命令。同样，如果您希望尝试此示例，请在第1行中将*classics*重命名为其他名称，然后删除测试表。
- en: Example 8-14\. Creating the table classics with a primary key
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-14\. 创建具有主键的经典表
- en: '[PRE47]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Creating a FULLTEXT index
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建FULLTEXT索引
- en: Unlike a regular index, MySQL’s `FULLTEXT` allows super-fast searches of entire
    columns of text. It stores every word in every data string in a special index
    that you can search using “natural language,” in a similar manner to using a search
    engine.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 不同于常规索引，MySQL的`FULLTEXT`允许对整个文本列进行超快速的搜索。它会将每个数据字符串中的每个单词存储在特殊索引中，您可以使用“自然语言”进行搜索，类似于使用搜索引擎。
- en: Note
  id: totrans-385
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It’s not strictly true that MySQL stores *all* the words in a `FULLTEXT` index,
    because it has a built-in list of more than 500 words that it chooses to ignore
    because they are so common that they aren’t very helpful for searching anyway—so-called
    *stopwords*. This list includes *the*, *as*, *is*, *of*, and so on. The list helps
    MySQL run much more quickly when performing a `FULLTEXT` search and keeps database
    sizes down.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL并不严格地存储`FULLTEXT`索引中的*所有*单词，因为它有一个内置的停用词列表，包含超过500个常见词汇，它们会被忽略，因为它们对搜索并不是非常有用。这些词称为*停用词*，列表包括*the*、*as*、*is*、*of*等。该列表有助于MySQL在执行`FULLTEXT`搜索时运行更快，并保持数据库的大小。
- en: 'Here are some things that you should know about `FULLTEXT` indexes:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关于`FULLTEXT`索引的一些事项，您应该知道：
- en: Since MySQL 5.6, InnoDB tables can use `FULLTEXT` indexes, but prior to that
    `FULLTEXT` indexes could be used only with MyISAM tables. If you need to convert
    a table to MyISAM, you can usually use the MySQL command `ALTER TABLE tablename
    ENGINE = MyISAM;`.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自MySQL 5.6起，InnoDB表可以使用`FULLTEXT`索引，但在此之前，`FULLTEXT`索引只能用于MyISAM表。如果需要将表转换为MyISAM，通常可以使用MySQL命令`ALTER
    TABLE tablename ENGINE = MyISAM;`。
- en: '`FULLTEXT` indexes can be created for `CHAR`, `VARCHAR`, and `TEXT` columns
    only.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能为`CHAR`、`VARCHAR`和`TEXT`列创建`FULLTEXT`索引。
- en: A `FULLTEXT` index definition can be given in the `CREATE TABLE` statement when
    a table is created or added later using `ALTER TABLE` (or `CREATE INDEX`).
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建表时，可以在`CREATE TABLE`语句中定义`FULLTEXT`索引，也可以稍后使用`ALTER TABLE`（或`CREATE INDEX`）添加。
- en: For large data sets, it is *much* faster to load your data into a table that
    has no `FULLTEXT` index and then create the index.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大型数据集，将数据加载到没有`FULLTEXT`索引的表中，然后再创建索引，速度会*快得多*。
- en: To create a `FULLTEXT` index, apply it to one or more records, as in [Example 8-15](#adding_a_fulltext_index_to_the_table_cla),
    which adds a `FULLTEXT` index to the pair of columns *author* and *title* in the
    *classics* table (this index is in addition to the ones already created and does
    not affect them).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`FULLTEXT`索引，请将其应用于一个或多个记录，如[示例8-15](#adding_a_fulltext_index_to_the_table_cla)中所示，在*classics*表中的*author*和*title*列对上添加了一个`FULLTEXT`索引（此索引是额外创建的，并不影响已创建的索引）。
- en: Example 8-15\. Adding a `FULLTEXT` index to the table classics
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-15\. 在经典表中添加`FULLTEXT`索引
- en: '[PRE48]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: You can now perform `FULLTEXT` searches across this pair of columns. This feature
    could really come into its own if you could now add the entire text of these publications
    to the database (particularly as they’re out of copyright protection) and they
    would be fully searchable. See the section [“MATCH...AGAINST”](#match_dotdotdot_against)
    for a description of searches using `FULLTEXT`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在这对列上执行`FULLTEXT`搜索。如果现在将这些出版物的整篇文章添加到数据库中（尤其是它们已经脱离版权保护期），那么它们将成为完全可搜索的。查看“MATCH...AGAINST”一节，了解使用`FULLTEXT`进行搜索的描述。
- en: Note
  id: totrans-396
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you find that MySQL is running slower than you think it should be when accessing
    your database, the problem is usually related to your indexes. Either you don’t
    have an index where you need one or the indexes are not optimally designed. Tweaking
    a table’s indexes will often solve such a problem. Performance is beyond the scope
    of this book, but in [Chapter 9](ch09.xhtml#mastering_mysql) I’ll give you a few
    tips so you know what to look for.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现MySQL在访问数据库时运行速度比预期慢，问题通常与索引有关。要么你在需要索引的地方没有索引，要么索引设计不够优化。调整表的索引通常可以解决这类问题。性能超出本书的范围，但在[第9章](ch09.xhtml#mastering_mysql)中，我会给出一些提示，让你知道应该注意什么。
- en: Querying a MySQL Database
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询MySQL数据库
- en: So far, we’ve created a MySQL database and tables, populated them with data,
    and added indexes to make them fast to search. Now it’s time to look at how these
    searches are performed and the various commands and qualifiers available.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个MySQL数据库和表，填充了数据，并添加了索引以加快搜索速度。现在是时候看看这些搜索是如何执行的，以及可用的各种命令和限定符。
- en: SELECT
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SELECT
- en: 'As you saw in [Figure 8-4](#populating_the_classics_table_and_viewin), the
    `SELECT` command is used to extract data from a table. In that section, I used
    its simplest form to select all data and display it—something you will never want
    to do on anything but the smallest tables, because all the data will scroll by
    at an unreadable pace. Alternatively, on Unix/Linux computers, you can tell MySQL
    to page output a screen at a time by issuing the following command:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 [图 8-4](#populating_the_classics_table_and_viewin) 中看到的，`SELECT` 命令用于从表中提取数据。在该部分中，我使用了最简单的形式来选择所有数据并显示它们——这是您除了最小的表外永远不希望做的事情，因为所有数据将以不可读的速度滚动。或者，在
    Unix/Linux 计算机上，您可以通过发出以下命令告诉 MySQL 每次一页地分页输出屏幕：
- en: '[PRE49]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This pipes output to the `less` program. To restore standard output and turn
    paging off, you can issue this command:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出传输到 `less` 程序。要恢复标准输出并关闭分页，您可以发出以下命令：
- en: '[PRE50]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let’s now examine `SELECT` in more detail. The basic syntax is:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地研究 `SELECT`。其基本语法是：
- en: '[PRE51]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The *`something`* can be an `*` (asterisk) as you saw before, which means *every
    column*, or you can choose to select only certain columns. For instance, [Example 8-16](#two_different_select_statements)
    shows how to select just the *author* and *title* and just the *title* and *isbn*.
    The result of typing these commands can be seen in [Figure 8-9](#output_from_two_different_select_sta).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '*`something`* 可以是 `*`（星号），如前所示，表示 *每一列*，或者您可以选择仅选择特定列。例如，[示例 8-16](#two_different_select_statements)
    显示了如何仅选择 *作者* 和 *标题*，以及仅选择 *标题* 和 *ISBN*。输入这些命令的结果可以在 [图 8-9](#output_from_two_different_select_sta)
    中看到。'
- en: Example 8-16\. Two different `SELECT` statements
  id: totrans-408
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-16\. 两个不同的 `SELECT` 语句
- en: '[PRE52]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '![The output from two different SELECT statements](Images/pmj6_0809.png)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![两个不同 SELECT 语句的输出](Images/pmj6_0809.png)'
- en: Figure 8-9\. The output from two different `SELECT` statements
  id: totrans-411
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-9\. 两个不同 `SELECT` 语句的输出
- en: SELECT COUNT
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SELECT COUNT
- en: Another replacement for the *`something`* parameter is `COUNT`, which can be
    used in many ways. In [Example 8-17](#counting_rows), it displays the number of
    rows in the table by passing `*` as a parameter, which means *all rows*. As you’d
    expect, the result returned is `5`, as there are five publications in the table.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '*`something`* 参数的另一个替代品是 `COUNT`，它可以以多种方式使用。在 [示例 8-17](#counting_rows) 中，它通过将
    `*` 作为参数来显示表中的行数，这意味着 *所有行*。正如您所期望的那样，返回的结果是 `5`，因为表中有五个出版物。'
- en: Example 8-17\. Counting rows
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-17\. 计数行
- en: '[PRE53]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: SELECT DISTINCT
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SELECT DISTINCT
- en: The `DISTINCT` qualifier (and its partner `DISTINCTROW`) allows you to weed
    out multiple entries when they contain the same data. For instance, suppose that
    you want a list of all authors in the table. If you select just the *author* column
    from a table containing multiple books by the same author, you’ll normally see
    a long list with the same author names over and over. But by adding the `DISTINCT`
    keyword, you can show each author just once. So, let’s test that out by adding
    another row that repeats one of our existing authors ([Example 8-18](#duplicating_data)).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`DISTINCT` 修饰符（及其合作伙伴 `DISTINCTROW`）允许您在包含相同数据的多个条目时清除多个条目。例如，假设您想要列出表中所有的作者。如果您仅从包含同一作者多本书的表中选择
    *作者* 列，通常会看到一个长列表，其中包含一遍又一遍相同的作者名字。但通过添加 `DISTINCT` 关键字，您可以仅显示每个作者一次。所以，让我们通过添加另一行来测试这一点，这行重复了我们现有的某个作者（[示例 8-18](#duplicating_data)）。'
- en: Example 8-18\. Duplicating data
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-18\. 复制数据
- en: '[PRE54]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Now that Charles Dickens appears twice in the table, we can compare the results
    of using `SELECT` with and without the `DISTINCT` qualifier. [Example 8-19](#with_and_without_the_distinct_qualifier)
    and [Figure 8-10](#selecting_data_with_and_without_distinct) show that the simple
    `SELECT` lists Dickens twice, and the command with the `DISTINCT` qualifier shows
    him only once.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查尔斯·狄更斯在表中出现了两次，我们可以比较使用 `SELECT` 带有和不带有 `DISTINCT` 修饰符的结果。[示例 8-19](#with_and_without_the_distinct_qualifier)
    和 [图 8-10](#selecting_data_with_and_without_distinct) 显示，简单的 `SELECT` 列表将狄更斯列出两次，而带有
    `DISTINCT` 修饰符的命令只显示一次。
- en: Example 8-19\. With and without the `DISTINCT` qualifier
  id: totrans-421
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-19\. 带有和不带有 `DISTINCT` 修饰符
- en: '[PRE55]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '![Selecting data with and without DISTINCT](Images/pmj6_0810.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![带有和不带有 DISTINCT 的选择数据](Images/pmj6_0810.png)'
- en: Figure 8-10\. Selecting data with and without `DISTINCT`
  id: totrans-424
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-10\. 带有和不带有 `DISTINCT` 的选择数据
- en: DELETE
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DELETE
- en: When you need to remove a row from a table, use the `DELETE` command. Its syntax
    is similar to the `SELECT` command and allows you to narrow down the exact row
    or rows to delete using qualifiers such as `WHERE` and `LIMIT`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要从表中删除行时，请使用 `DELETE` 命令。其语法与 `SELECT` 命令类似，并允许您使用 `WHERE` 和 `LIMIT` 等限定符来缩小要删除的确切行或行的范围。
- en: Now that you’ve seen the effects of the `DISTINCT` qualifier, if you typed [Example 8-18](#duplicating_data),
    you should remove *Little Dorrit* by entering the commands in [Example 8-20](#removing_the_new_entry).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了`DISTINCT`限定词的效果，如果您输入了[Example 8-18](#duplicating_data)，则应该通过输入[Example 8-20](#removing_the_new_entry)中的命令来移除*小杜丽*。
- en: Example 8-20\. Removing the new entry
  id: totrans-428
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-20\. 移除新条目
- en: '[PRE56]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This example issues a `DELETE` command for all rows whose *title* column contains
    the exact string `Little Dorrit`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例为所有*标题*列包含确切字符串`小杜丽`的行发出`DELETE`命令。
- en: The `WHERE` keyword is very powerful, and important to enter correctly; an error
    could lead a command to the wrong rows (or have no effect in cases where nothing
    matches the `WHERE` clause). So now we’ll spend some time on that clause, which
    is the heart and soul of SQL.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`关键字非常强大，正确输入非常重要；错误可能导致命令应用于错误的行（或在没有匹配`WHERE`子句的情况下无效）。因此，我们现在将花一些时间来详细介绍这个子句，这是SQL的核心。'
- en: WHERE
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WHERE
- en: The `WHERE` keyword enables you to narrow down queries by returning only those
    where a certain expression is true. [Example 8-20](#removing_the_new_entry) returns
    only the rows where the column exactly matches the string `Little Dorrit`, using
    the equality operator `=`. [Example 8-21](#using_the_where_keyword) shows a couple
    more examples of using `WHERE` with the `=` operator.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`关键字使您能够通过返回仅当某个表达式为真时的查询结果来缩小查询范围。[Example 8-20](#removing_the_new_entry)仅返回列完全匹配字符串`Little
    Dorrit`的行，使用等号操作符`=。[Example 8-21](#using_the_where_keyword)显示了使用`WHERE`与`=操作符的更多示例。'
- en: Example 8-21\. Using the `WHERE` keyword
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-21\. 使用`WHERE`关键字
- en: '[PRE57]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Given our current table, the two commands in [Example 8-21](#using_the_where_keyword)
    display the same results. But we could easily add more books by Mark Twain, in
    which case the first line would display all the titles he wrote and the second
    line would continue (because we know the ISBN is unique) to display `The Adventures
    of Tom Sawyer`. In other words, searches using a unique key are more predictable,
    and you’ll see further evidence later of the value of unique and primary keys.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们当前的表格，在[Example 8-21](#using_the_where_keyword)中的两个命令显示相同的结果。但是如果我们可以轻松地添加更多马克·吐温的书籍，那么第一行将显示他写的所有书名，第二行将继续（因为我们知道ISBN是唯一的）显示`汤姆·索亚历险记`。换句话说，使用唯一键进行搜索更加可预测，稍后您将看到唯一和主键的价值。
- en: You can also do pattern matching for your searches using the `LIKE` qualifier,
    which allows searches on parts of strings. This qualifier should be used with
    a `%` character before or after some text. When placed before a keyword, `%` means
    *anything before*. After a keyword, it means *anything after*. [Example 8-22](#using_the_like_qualifier)
    performs three different queries, one for the start of a string, one for the end,
    and one for anywhere in a string.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`LIKE`限定词进行搜索模式匹配，允许对字符串的部分进行搜索。此限定词应与`%`字符一起使用。当放置在关键字之前时，`%`表示*任何内容在前面*。放置在关键字之后时，表示*任何内容在后面*。[Example 8-22](#using_the_like_qualifier)执行了三种不同的查询，分别是字符串开头的查询、字符串结尾的查询以及字符串中的任意位置的查询。
- en: Example 8-22\. Using the `LIKE` qualifier
  id: totrans-438
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-22\. 使用`LIKE`限定词
- en: '[PRE58]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can see the results of these commands in [Figure 8-11](#using_where_with_the_like_qualifier).
    The first command outputs the publications by both Charles Darwin and Charles
    Dickens because the `LIKE` qualifier was set to return anything matching the string
    `Charles` followed by any other text. Then just `The Origin of Species` is returned,
    because it’s the only row whose column ends with the string `Species`. Last, both
    `Pride and Prejudice` and `Romeo and Juliet` are returned, because they both matched
    the string `and` anywhere in the column. The `%` will also match if there is nothing
    in the position it occupies; in other words, it can match an empty string.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Figure 8-11](#using_where_with_the_like_qualifier)中看到这些命令的结果。第一个命令输出了查尔斯·达尔文和查尔斯·狄更斯的出版物，因为`LIKE`限定词设置为返回与字符串`Charles`后跟任何其他文本匹配的内容。然后只返回了`物种起源`，因为这是唯一一行的列以`Species`结尾。最后，`傲慢与偏见`和`罗密欧与朱丽叶`都被返回，因为它们在列中任何位置匹配字符串`and`。如果占位符中没有内容，`%`也会匹配空字符串。
- en: '![Using WHERE with the LIKE qualifier](Images/pmj6_0811.png)'
  id: totrans-441
  prefs: []
  type: TYPE_IMG
  zh: '![使用 WHERE 与 LIKE 限定词](Images/pmj6_0811.png)'
- en: Figure 8-11\. Using `WHERE` with the `LIKE` qualifier
  id: totrans-442
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-11\. 使用`WHERE`与`LIKE`限定词
- en: LIMIT
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LIMIT
- en: The `LIMIT` qualifier enables you to choose how many rows to return in a query
    and where in the table to start returning them. When passed a single parameter,
    it tells MySQL to start at the beginning of the results and just return the number
    of rows given in that parameter. If you pass it two parameters, the first indicates
    the offset from the start of the results where MySQL should start the display,
    and the second indicates how many to return. You can think of the first parameter
    as saying, “Skip this number of results at the start.”
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`LIMIT`限定符使您能够选择在查询中返回多少行以及从表中的哪个位置开始返回它们。当传递一个参数时，它告诉MySQL从结果的开头开始，并仅返回该参数中给定的行数。如果传递两个参数，则第一个指示MySQL从结果开头的偏移量开始显示，第二个指示要返回的行数。您可以将第一个参数视为指示“跳过开头这些结果行数”的内容。'
- en: '[Example 8-23](#limiting_the_number_of_results_returned) includes three commands.
    The first returns the first three rows from the table. The second returns two
    rows starting at position 1 (skipping the first row). The last command returns
    a single row starting at position 3 (skipping the first three rows). [Figure 8-12](#restricting_the_rows_returned_with_limit)
    shows the results of issuing these three commands.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 8-23](#limiting_the_number_of_results_returned)包括三条命令。第一条返回表中的前三行。第二条从位置1开始返回两行（跳过第一行）。最后一条命令从位置3开始返回单行（跳过前三行）。[Figure 8-12](#restricting_the_rows_returned_with_limit)显示了执行这三条命令的结果。'
- en: Example 8-23\. Limiting the number of results returned
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-23\. 限制返回的结果数
- en: '[PRE59]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Warning
  id: totrans-448
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Be careful with the `LIMIT` keyword, because offsets start at 0, but the number
    of rows to return starts at 1\. So, `LIMIT 1,3` means return *three* rows starting
    from the *second* row. You could look at the first argument as stating how many
    rows to skip, so that in English the instruction would be “Return 3 rows, skipping
    the first 1.”
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要注意`LIMIT`关键字，因为偏移量从0开始，但要返回的行数从1开始。因此，`LIMIT 1,3`意味着从*第二*行开始返回*三*行。您可以将第一个参数视为指定要跳过多少行，因此英文指令将是“返回3行，跳过第1行”。
- en: '![Restricting the rows returned with LIMIT](Images/pmj6_0812.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![限制返回的行数](Images/pmj6_0812.png)'
- en: Figure 8-12\. Restricting the rows returned with `LIMIT`
  id: totrans-451
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 8-12\. 限制使用`LIMIT`返回的行
- en: MATCH...AGAINST
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MATCH...AGAINST
- en: The `MATCH...AGAINST` construct can be used on columns that have been given
    a `FULLTEXT` index (see the section [“Creating a FULLTEXT index”](#creating_a_fulltext_index)).
    With it, you can make natural-language searches as you would in an internet search
    engine. Unlike the use of `WHERE...=` or `WHERE...LIKE`, `MATCH...AGAINST` lets
    you enter multiple words in a search query and checks them against all words in
    the `FULLTEXT` columns. `FULLTEXT` indexes are case-insensitive, so it makes no
    difference what case is used in your queries.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`MATCH...AGAINST`结构可以用于已经添加了`FULLTEXT`索引的列（参见“创建`FULLTEXT`索引”部分）。使用它，您可以像在互联网搜索引擎中一样进行自然语言搜索。与使用`WHERE...=`或`WHERE...LIKE`不同，`MATCH...AGAINST`允许您在搜索查询中输入多个单词，并将它们与`FULLTEXT`列中的所有单词进行匹配。`FULLTEXT`索引不区分大小写，因此查询中使用的大小写不重要。'
- en: Assuming that you have added a `FULLTEXT` index to the *author* and *title*
    columns, enter the three queries shown in [Example 8-24](#using_match_dotdotdot_against_on_fulltex).
    The first asks for any rows that contain the word *and* to be returned. If you
    are using the MyISAM storage engine, then because *and* is a stopword in that
    engine, MySQL will ignore it and the query will always produce an empty set—no
    matter what is stored in the column. Otherwise, if you are using InnoDB, *and*
    is an allowed word. The second query asks for any rows that contain both of the
    words *curiosity* and *shop* anywhere in them, in any order, to be returned. And
    the last query applies the same kind of search for the words *tom* and *sawyer*.
    [Figure 8-13](#using_match_dotdotdot_against_on_a_fullt) shows the results of
    these queries.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经在*author*和*title*列上添加了`FULLTEXT`索引，请输入[Example 8-24](#using_match_dotdotdot_against_on_fulltex)中显示的三个查询。第一个查询要求返回包含单词*and*的任何行。如果您使用的是MyISAM存储引擎，由于*and*是该引擎中的停用词，MySQL会忽略它，该查询将始终生成一个空集——无论列中存储的内容是什么。否则，如果您使用的是InnoDB，*and*是一个允许的单词。第二个查询要求返回包含单词*curiosity*和*shop*的任何行，无论顺序如何。最后一个查询对单词*tom*和*sawyer*执行相同类型的搜索。[Figure 8-13](#using_match_dotdotdot_against_on_a_fullt)显示了这些查询的结果。
- en: Example 8-24\. Using `MATCH...AGAINST` on `FULLTEXT` indexes
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-24\. 在`FULLTEXT`索引上使用`MATCH...AGAINST`
- en: '[PRE60]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '![Using MATCH ... AGAINST on FULLTEXT indexes](Images/pmj6_0813.png)'
  id: totrans-457
  prefs: []
  type: TYPE_IMG
  zh: '![在FULLTEXT索引上使用MATCH ... AGAINST](Images/pmj6_0813.png)'
- en: Figure 8-13\. Using `MATCH...AGAINST` on `FULLTEXT` indexes
  id: totrans-458
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-13\. 在 `FULLTEXT` 索引上使用 `MATCH...AGAINST`
- en: '`MATCH...AGAINST` in Boolean mode'
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在布尔模式中使用 `MATCH...AGAINST`
- en: If you wish to give your `MATCH...AGAINST` queries even more power, use *Boolean
    mode*. This changes the effect of the standard `FULLTEXT` query so that it searches
    for any combination of search words, instead of requiring all search words to
    be in the text. The presence of a single word in a column causes the search to
    return the row.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望使您的 `MATCH...AGAINST` 查询具有更大的能力，可以使用 *布尔模式*。这将改变标准 `FULLTEXT` 查询的效果，使其搜索任何搜索词的组合，而不是要求所有搜索词都在文本中。列中的单个词的存在会导致搜索返回该行。
- en: Boolean mode also allows you to preface search words with a `+` or `–` sign
    to indicate whether they must be included or excluded. If normal Boolean mode
    says, “Any of these words will do,” a plus sign means, “This word must be present;
    otherwise, don’t return the row.” A minus sign means, “This word must not be present;
    its presence disqualifies the row from being returned.”
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔模式还允许您在搜索词前加上 `+` 或 `-` 符号，以指示它们是必须包含还是排除的。如果普通布尔模式表示，“这些词中的任何一个都可以”，加号表示，“这个词必须存在；否则，不返回该行。”
    减号表示，“这个词不能存在；其存在则使该行被排除在返回结果之外。”
- en: '[Example 8-25](#using_match_dotdotdot_against) illustrates Boolean mode through
    two queries. The first asks for all rows containing the word *charles* and not
    the word *species* to be returned. The second uses double quotes to request that
    all rows containing the exact phrase *origin of* be returned. [Figure 8-14](#using_match_dotdotdot_against-id00025)
    shows the results of these queries.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 8-25](#using_match_dotdotdot_against) 通过两个查询展示了布尔模式。第一个查询要求返回所有包含单词 *charles*
    而不包含单词 *species* 的行。第二个使用双引号请求返回所有包含确切短语 *origin of* 的行。[图 8-14](#using_match_dotdotdot_against-id00025)
    显示了这些查询的结果。'
- en: Example 8-25\. Using MATCH...AGAINST in Boolean mode
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-25\. 在布尔模式下使用 MATCH...AGAINST
- en: '[PRE61]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '![Using MATCH...AGAINST in Boolean mode](Images/pmj6_0814.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![在布尔模式下使用 MATCH...AGAINST](Images/pmj6_0814.png)'
- en: Figure 8-14\. Using `MATCH...AGAINST` in Boolean mode
  id: totrans-466
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-14\. 在布尔模式下使用 `MATCH...AGAINST`
- en: As you would expect, the first request returns only `The Old Curiosity Shop`
    by Charles Dickens; any rows containing the word *species* have been excluded,
    so Charles Darwin’s publication is ignored.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所料，第一个请求只返回查尔斯·狄更斯的《老古玩店》；任何包含单词 *species* 的行均已排除，因此忽略了查尔斯·达尔文的出版物。
- en: Note
  id: totrans-468
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: 'There is something of interest to note in the second query: the stopword *of*
    is part of the search string, but it is still used by the search because the double
    quotation marks override stopwords.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询中有一点值得注意：停用词 *of* 是搜索字符串的一部分，但仍然被搜索使用，因为双引号覆盖了停用词。
- en: UPDATE...SET
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UPDATE...SET
- en: This construct allows you to update the contents of a field. If you wish to
    change the contents of one or more fields, you need to first narrow in on just
    the field or fields to be changed, in much the same way you use the `SELECT` command.
    [Example 8-26](#using_update_dotdotdot_set) shows the use of `UPDATE...SET` in
    two different ways. You can see the results in [Figure 8-15](#updating_columns_in_the_classics_table).
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构允许您更新字段的内容。如果要更改一个或多个字段的内容，首先需要缩小范围，就像使用 `SELECT` 命令一样。[示例 8-26](#using_update_dotdotdot_set)
    展示了两种不同方式使用 `UPDATE...SET`。您可以在 [图 8-15](#updating_columns_in_the_classics_table)
    中查看结果。
- en: Example 8-26\. Using `UPDATE...SET`
  id: totrans-472
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-26\. 使用 `UPDATE...SET`
- en: '[PRE62]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '![Updating columns in the classics table](Images/pmj6_0815.png)'
  id: totrans-474
  prefs: []
  type: TYPE_IMG
  zh: '![更新经典表中的列](Images/pmj6_0815.png)'
- en: Figure 8-15\. Updating columns in the classics table
  id: totrans-475
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-15\. 更新经典表中的列
- en: In the first query, Mark Twain’s real name of Samuel Langhorne Clemens was appended
    to his pen name in parentheses, which affected only one row. The second query,
    however, affected three rows, because it changed all occurrences of the word *Fiction*
    in the *category* column to the term *Classic Fiction*.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个查询中，马克·吐温的真名塞缪尔·兰霍恩·克莱蒙斯被添加到他的笔名后面的括号中，这只影响了一行。然而，第二个查询影响了三行，因为它将 *category*
    列中所有 *Fiction* 一词更改为 *Classic Fiction*。
- en: When performing an update, you can also make use of the qualifiers you have
    already seen, such as `LIMIT`, and the following `ORDER BY` and `GROUP BY` keywords.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行更新时，您还可以利用已经见过的限定词，比如 `LIMIT`，以及后续的 `ORDER BY` 和 `GROUP BY` 关键字。
- en: ORDER BY
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORDER BY
- en: '`ORDER BY` sorts returned results by one or more columns in ascending or descending
    order. [Example 8-27](#using_order_by) shows two such queries, the results of
    which can be seen in [Figure 8-16](#sorting_the_results_of_requests).'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`ORDER BY` sorts returned results by one or more columns in ascending or descending
    order. [示例 8-27](#using_order_by) shows two such queries, the results of which
    can be seen in [图 8-16](#sorting_the_results_of_requests).'
- en: Example 8-27\. Using `ORDER BY`
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-27\. 使用 `ORDER BY`
- en: '[PRE63]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '![Sorting the results of requests](Images/pmj6_0816.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![Sorting the results of requests](Images/pmj6_0816.png)'
- en: Figure 8-16\. Sorting the results of requests
  id: totrans-483
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-16\. 请求结果排序
- en: As you can see, the first query returns the publications by *author* in ascending
    alphabetical order (the default), and the second returns them by *title* in descending
    order.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: As you can see, the first query returns the publications by *author* in ascending
    alphabetical order (the default), and the second returns them by *title* in descending
    order.
- en: 'If you wanted to sort all the rows by *author* and then by descending *year*
    of publication (to view the most recent first), you would issue the following
    query:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 'If you wanted to sort all the rows by *author* and then by descending *year*
    of publication (to view the most recent first), you would issue the following
    query:'
- en: '[PRE64]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This shows that each ascending and descending qualifier applies to a single
    column. The `DESC` keyword applies only to the preceding column, *year*. Because
    you allow *author* to use the default sort order, it is sorted in ascending order.
    You could also have explicitly specified ascending order for that column, with
    the same results:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 'This shows that each ascending and descending qualifier applies to a single
    column. The `DESC` keyword applies only to the preceding column, *year*. Because
    you allow *author* to use the default sort order, it is sorted in ascending order.
    You could also have explicitly specified ascending order for that column, with
    the same results:'
- en: '[PRE65]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: GROUP BY
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GROUP BY
- en: 'In a similar fashion to `ORDER BY`, you can group results returned from queries
    using `GROUP BY`, which is good for retrieving information about a group of data.
    For example, if you want to know how many publications there are of each category
    in the *classics* table, you can issue the following query:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 'In a similar fashion to `ORDER BY`, you can group results returned from queries
    using `GROUP BY`, which is good for retrieving information about a group of data.
    For example, if you want to know how many publications there are of each category
    in the *classics* table, you can issue the following query:'
- en: '[PRE66]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'which returns the following output:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 'which returns the following output:'
- en: '[PRE67]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Joining Tables Together
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Joining Tables Together
- en: It is quite normal to maintain multiple tables within a database, each holding
    a different type of information. For example, consider the case of a *customers*
    table that needs to be able to be cross-referenced with publications purchased
    from the *classics* table. Enter the commands in [Example 8-28](#creating_and_populating_the_customers_ta)
    to create this new table and populate it with three customers and their purchases.
    [Figure 8-17](#creating_the_customers_table) shows the result.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: It is quite normal to maintain multiple tables within a database, each holding
    a different type of information. For example, consider the case of a *customers*
    table that needs to be able to be cross-referenced with publications purchased
    from the *classics* table. Enter the commands in [示例 8-28](#creating_and_populating_the_customers_ta)
    to create this new table and populate it with three customers and their purchases.
    [图 8-17](#creating_the_customers_table) shows the result.
- en: Example 8-28\. Creating and populating the customers table
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-28\. 创建和填充 customers 表
- en: '[PRE68]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '![Creating the customers table](Images/pmj6_0817.png)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![Creating the customers table](Images/pmj6_0817.png)'
- en: Figure 8-17\. Creating the customers table
  id: totrans-499
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-17\. 创建 customers 表
- en: Note
  id: totrans-500
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'There’s also a shortcut for inserting multiple rows of data, as in [Example 8-28](#creating_and_populating_the_customers_ta),
    in which you can replace the three separate `INSERT INTO` queries with a single
    one listing the data to be inserted, separated by commas, like this:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 'There’s also a shortcut for inserting multiple rows of data, as in [示例 8-28](#creating_and_populating_the_customers_ta),
    in which you can replace the three separate `INSERT INTO` queries with a single
    one listing the data to be inserted, separated by commas, like this:'
- en: '[PRE69]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Of course, in a proper table containing customers’ details there would also
    be addresses, phone numbers, email addresses, and so on, but they aren’t necessary
    for this explanation. While creating the new table, you should have noticed that
    it has something in common with the *classics* table: a column called *isbn*.
    Because it has the same meaning in both tables (an ISBN refers to a book, and
    always the same book), we can use this column to tie the two tables together into
    a single query, as in [Example 8-29](#joining_two_tables_into_a_single_select).'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 'Of course, in a proper table containing customers’ details there would also
    be addresses, phone numbers, email addresses, and so on, but they aren’t necessary
    for this explanation. While creating the new table, you should have noticed that
    it has something in common with the *classics* table: a column called *isbn*.
    Because it has the same meaning in both tables (an ISBN refers to a book, and
    always the same book), we can use this column to tie the two tables together into
    a single query, as in [示例 8-29](#joining_two_tables_into_a_single_select).'
- en: Example 8-29\. Joining two tables into a single `SELECT`
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-29\. 合并两个表为一个 `SELECT`
- en: '[PRE70]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The result of this operation is the following:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的结果如下所示：
- en: '[PRE71]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: See how this query has neatly linked the tables together to show the publications
    purchased from the *classics* table by the people in the *customers* table?
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个查询是如何巧妙地将表格链接在一起，展示了从*classics*表格中由*customers*表格中的人购买的出版物？
- en: NATURAL JOIN
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自然连接
- en: 'Using `NATURAL JOIN`, you can save yourself some typing and make queries a
    little clearer. This kind of join takes two tables and automatically joins columns
    that have the same name. So, to achieve the same results as from [Example 8-29](#joining_two_tables_into_a_single_select),
    you would enter the following:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NATURAL JOIN`，您可以节省一些输入时间并使查询更加清晰。这种连接方式会自动连接具有相同名称的列。因此，要达到与[示例 8-29](#joining_two_tables_into_a_single_select)相同的结果，您可以输入以下内容：
- en: '[PRE72]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: JOIN...ON
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JOIN...ON
- en: 'If you wish to specify the column on which to join two tables, use the `JOIN...ON`
    construct, as follows, to achieve results identical to those of [Example 8-29](#joining_two_tables_into_a_single_select):'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望指定连接两个表的列，请使用`JOIN...ON`结构，如下所示，以获得与[示例 8-29](#joining_two_tables_into_a_single_select)相同的结果：
- en: '[PRE73]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Using AS
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用AS
- en: 'You can also save yourself some typing and improve query readability by creating
    aliases using the `AS` keyword. Simply follow a table name with `AS` and the alias
    to use. The following code, therefore, is also identical in action to [Example 8-29](#joining_two_tables_into_a_single_select):'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过使用`AS`关键字创建别名来节省输入时间并提高查询的可读性。因此，下面的代码也与[示例 8-29](#joining_two_tables_into_a_single_select)的操作相同：
- en: '[PRE74]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The result of this operation is the following:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作的结果如下所示：
- en: '[PRE75]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'You can also use `AS` to rename a column (whether or not joining tables), like
    this:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`AS`来重命名列（无论是否连接表），如下所示：
- en: '[PRE76]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'which results in the following output:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下输出：
- en: '[PRE77]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Aliases can be particularly useful when you have long queries that reference
    the same table names many times.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的查询中多次引用相同的表名时，别名特别有用。
- en: Using Logical Operators
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用逻辑运算符
- en: You can also use the logical operators `AND`, `OR`, and `NOT` in your MySQL
    `WHERE` queries to further narrow down your selections. [Example 8-30](#using_logical_operators-id00026)
    shows one instance of each, but you can mix and match them in any way you need.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在MySQL的`WHERE`查询中使用逻辑运算符`AND`、`OR`和`NOT`来进一步缩小选择范围。[示例 8-30](#using_logical_operators-id00026)展示了每个运算符的一个实例，但您可以根据需要混合使用它们。
- en: Example 8-30\. Using logical operators
  id: totrans-527
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-30\. 使用逻辑运算符
- en: '[PRE78]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: I’ve chosen the first query because Charles Darwin might be listed in some rows
    by his full name, Charles Robert Darwin. The query returns any publications for
    which the *author* column starts with *Charles* and ends with *Darwin*. The second
    query searches for publications written using either Mark Twain’s pen name or
    his real name, Samuel Langhorne Clemens. The third query returns publications
    written by authors with the first name Charles but not the surname Darwin.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择了第一个查询，因为查尔斯·达尔文有可能以他的全名查尔斯·罗伯特·达尔文出现在某些行中。该查询返回任何*author*列以*Charles*开头并以*Darwin*结尾的出版物。第二个查询搜索使用马克·吐温的笔名或他的真实姓名萨缪尔·兰霍恩·克莱门斯写的出版物。第三个查询返回由名为查尔斯但姓不是达尔文的作者写的出版物。
- en: MySQL Functions
  id: totrans-530
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL函数
- en: 'You might wonder why anyone would want to use MySQL functions when PHP comes
    with a whole bunch of powerful functions of its own. The answer is very simple:
    the MySQL functions work on the data right there in the database. If you were
    to use PHP, you would first have to extract raw data from MySQL, manipulate it,
    and then perform the database query you wanted.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么有人要在PHP中使用MySQL函数，因为PHP本身带有大量强大的函数。答案非常简单：MySQL函数直接在数据库中处理数据。如果使用PHP，您首先必须从MySQL提取原始数据，然后操作它，并执行所需的数据库查询。
- en: Having functions built into MySQL substantially reduces the time needed for
    performing complex queries, as well as their complexity. You can learn more about
    all the available [string](http://tinyurl.com/mysqlstrings) and [date/time](http://tinyurl.com/mysqldates)
    functions from the documentation.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 在MySQL中内置的函数大大减少了执行复杂查询所需的时间及其复杂性。您可以从文档中了解更多有关所有可用的[string](http://tinyurl.com/mysqlstrings)和[date/time](http://tinyurl.com/mysqldates)函数的信息。
- en: Accessing MySQL via phpMyAdmin
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过phpMyAdmin访问MySQL
- en: Although to use MySQL you have to learn these main commands and how they work,
    once you understand them, it can be much quicker and simpler to use a program
    such as *phpMyAdmin* to manage your databases and tables.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用MySQL需要学习这些主要命令及其工作原理，但一旦理解它们，使用诸如*phpMyAdmin*之类的程序来管理您的数据库和表将会更快更简单。
- en: 'To do this, assuming you have installed AMPPS as described in [Chapter 2](ch02.xhtml#setting_up_a_development_server),
    type the following to open up the program (see [Figure 8-18](#phpmyadmin_main_screen)):'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，请假设您已按照[第 2 章](ch02.xhtml#setting_up_a_development_server)中描述的方式安装了AMPPS，输入以下内容打开程序（参见[图
    8-18](#phpmyadmin_main_screen)）：
- en: '[PRE79]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![](Images/pmj6_0818.png)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pmj6_0818.png)'
- en: Figure 8-18\. The phpMyAdmin main screen
  id: totrans-538
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 8-18\. phpMyAdmin 主界面
- en: In the left-hand pane of the main phpMyAdmin screen, you can click to select
    any tables you wish to work with (although none will be available until created).
    You can also click New to create a new database.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在phpMyAdmin主界面的左侧窗格中，您可以单击以选择要操作的任何表（尽管在创建之前不会有可用的表）。您还可以单击“新建”以创建新数据库。
- en: From here, you can perform all the main operations, such as creating new databases,
    adding tables, creating indexes, and much more. To find out more about phpMyAdmin,
    consult the [documentation](https://docs.phpmyadmin.net).
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，您可以执行所有主要操作，例如创建新数据库、添加表、创建索引等等。要了解更多关于phpMyAdmin的信息，请查阅[文档](https://docs.phpmyadmin.net)。
- en: If you worked with me through the examples in this chapter, congratulations—it
    has been quite a long journey. You’ve come all the way from learning how to create
    a MySQL database, through issuing complex queries that combine multiple tables,
    to using Boolean operators and leveraging MySQL’s various qualifiers.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您通过本章中的示例与我一起工作，那么恭喜您——这是一段相当漫长的旅程。您已经从学习如何创建MySQL数据库开始，通过发出结合多个表的复杂查询，到使用布尔运算符并利用MySQL的各种限定符。
- en: In the next chapter, we’ll start looking at how to approach efficient database
    design, advanced SQL techniques, and MySQL functions and transactions.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始学习如何进行高效的数据库设计、高级SQL技术以及MySQL函数和事务。
- en: Questions
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the purpose of the semicolon in MySQL queries?
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MySQL查询中，分号的作用是什么？
- en: Which command would you use to view the available databases or tables?
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用哪个命令来查看可用的数据库或表？
- en: How would you create a new MySQL user on the local host called *newuser* with
    a password of *newpass* and with access to everything in the database *newdatabase*?
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在本地主机上创建一个名为*newuser*、密码为*newpass*并具有对数据库*newdatabase*中所有内容访问权限的新MySQL用户？
- en: How can you view the structure of a table?
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何查看表的结构？
- en: What is the purpose of a MySQL index?
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: MySQL索引的目的是什么？
- en: What benefit does a `FULLTEXT` index provide?
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FULLTEXT`索引提供了哪些好处？'
- en: What is a stopword?
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是停用词？
- en: Both `SELECT DISTINCT` and `GROUP BY` cause the display to show only one output
    row for each value in a column, even if multiple rows contain that value. What
    are the main differences between `SELECT DISTINCT` and `GROUP BY`?
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SELECT DISTINCT`和`GROUP BY`都导致显示只显示每个列中值的一个输出行，即使多行包含该值。`SELECT DISTINCT`和`GROUP
    BY`之间的主要区别是什么？'
- en: Using the `SELECT...WHERE` construct, how would you return only rows containing
    the word *Langhorne* somewhere in the *author* column of the *classics* table
    used in this chapter?
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`SELECT...WHERE`结构，如何返回只包含*author*列中的*classics*表中某处包含单词*Langhorne*的行？
- en: What needs to be defined in two tables to make it possible for you to join them
    together?
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要在两个表中定义什么才能使它们可以连接在一起？
- en: See [“Chapter 8 Answers”](app01_split_007.xhtml#chapter_8_answers) in the [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions)
    for the answers to these questions.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 参见附录A中的[“第 8 章答案”](app01_split_007.xhtml#chapter_8_answers)，获取这些问题的答案。
