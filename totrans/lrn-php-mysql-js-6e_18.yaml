- en: Chapter 15\. Expressions and Control Flow in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, I introduced the basics of JavaScript and the DOM.
    Now it’s time to look at how to construct complex expressions in JavaScript and
    how to control the program flow of your scripts by using conditional statements.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript expressions are very similar to those in PHP. As you learned in [Chapter 4](ch04.xhtml#expressions_and_control_flow_in_php),
    an expression is a combination of values, variables, operators, and functions
    that results in a value; the result can be a number, a string, or a Boolean value
    (which evaluates to either `true` or `false`).
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 15-1](#four_simple_boolean_expressions-id00059) shows some simple
    expressions. For each line, it prints out a letter between `a` and `d`, followed
    by a colon and the result of the expressions. The `<br>` tag is there to create
    a line break and separate the output into four lines (remember that both `<br>`
    and `<br />` are acceptable in HTML5, so I chose to use the former style for brevity).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-1\. Four simple Boolean expressions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Notice that both expressions `a:` and `d:` evaluate to `true`, but `b:` and
    `c:` evaluate to `false`. Unlike PHP (which would print the number `1` and nothing,
    respectively), the actual strings `true` and `false` are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, when you are checking whether a value is `true` or `false`,
    all values evaluate to `true` except the following, which evaluate to `false`:
    the string `false` itself, `0`, `–0`, the empty string, `null`, `undefined`, and
    `NaN` (Not a Number, a computer engineering concept for the result of an illegal
    floating-point operation such as division by zero).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that I am referring to `true` and `false` in lowercase. This is because,
    unlike in PHP, these values *must* be in lowercase in JavaScript. Therefore, only
    the first of the two following statements will display, printing the lowercase
    word `true`, because the second will cause a `''TRUE'' is not defined` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that any code snippets you wish to type and try for yourself in an
    HTML file need to be enclosed within `<script>` and `</script>` tags.
  prefs: []
  type: TYPE_NORMAL
- en: Literals and Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simplest form of an expression is a *literal*, which means something that
    evaluates to itself, such as the number `22` or the string `Press Enter`. An expression
    could also be a variable, which evaluates to the value that has been assigned
    to it. They are both types of expressions, because they return a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 15-2](#five_types_of_literals) shows three different literals and
    two variables, all of which return values, albeit of different types.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-2\. Five types of literals
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And, as you’d expect, you see a return value from all of these in the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Operators let you create more complex expressions that evaluate to useful results.
    When you combine assignment or control-flow constructs with expressions, the result
    is a *statement*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 15-3](#two_simple_javascript_statements) shows one of each. The first
    assigns the result of the expression `366 - day_number` to the variable `days_to_new_year`,
    and the second outputs a friendly message only if the expression `days_to_new_year
    < 30` evaluates to `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-3\. Two simple JavaScript statements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript offers a lot of powerful operators, ranging from arithmetic, string,
    and logical operators to assignment, comparison, and more (see [Table 15-1](#javascript_operator_types)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-1\. JavaScript operator types
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | Basic mathematics | `a + b` |'
  prefs: []
  type: TYPE_TB
- en: '| Array | Array manipulation | `a + b` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | Assign values | `a = b + 23` |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise | Manipulate bits within bytes | `12 ^ 9` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparison | Compare two values | `a < b` |'
  prefs: []
  type: TYPE_TB
- en: '| Increment/decrement | Add or subtract one | `a++` |'
  prefs: []
  type: TYPE_TB
- en: '| Logical | Boolean | `a && b` |'
  prefs: []
  type: TYPE_TB
- en: '| String | Concatenation | `a + ''string''` |'
  prefs: []
  type: TYPE_TB
- en: 'Each operator takes a different number of operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unary* operators, such as incrementing (`a++`) or negation (`-a`), take a
    single operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binary* operators, which represent the bulk of JavaScript operators—including
    addition, subtraction, multiplication, and division—take two operands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The one *ternary* operator, which takes the form `? x : y`, requires three
    operands. It’s a terse single-line `if` statement that chooses between two expressions
    depending on a third one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator Precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like PHP, JavaScript utilizes operator precedence, in which some operators in
    an expression are processed before others and are therefore evaluated first. [Table 15-2](#precedence_of_javascript_operators_l)
    lists JavaScript’s operators and their precedences.
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-2\. Precedence of JavaScript operators (high to low)
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator(s) | Type(s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `() [] .` | Parentheses, call, and member |'
  prefs: []
  type: TYPE_TB
- en: '| `++ --` | Increment/decrement |'
  prefs: []
  type: TYPE_TB
- en: '| `+ - ~ !` | Unary, bitwise, and logical |'
  prefs: []
  type: TYPE_TB
- en: '| `* / %` | Arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `+ -` | Arithmetic and string |'
  prefs: []
  type: TYPE_TB
- en: '| `<< >> >>>` | Bitwise |'
  prefs: []
  type: TYPE_TB
- en: '| `< > <= >=` | Comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `== != === !==` | Comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `& ^ &#124;` | Bitwise |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `? :` | Ternary |'
  prefs: []
  type: TYPE_TB
- en: '| `= += -= *= /= %=` | Assignment |'
  prefs: []
  type: TYPE_TB
- en: '| `<<= >>= >>>= &= ^= &#124;=` | Assignment |'
  prefs: []
  type: TYPE_TB
- en: '| `,` | Separator |'
  prefs: []
  type: TYPE_TB
- en: Associativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most JavaScript operators are processed in order from left to right in an equation.
    But some operators require processing from right to left instead. The direction
    of processing is called the operator’s *associativity*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This associativity becomes important where you do not explicitly force precedence
    (which you should always do, by the way, because it makes code more readable and
    less error prone). For example, look at the following assignment operators, by
    which three variables are all set to the value `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This multiple assignment is possible only because the rightmost part of the
    expression is evaluated first and then processing continues in a right-to-left
    direction. [Table 15-3](#operators_and_associativity) lists the JavaScript operators
    and their associativity.
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-3\. Operators and associativity
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description | Associativity |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `++ --` | Increment and decrement | None |'
  prefs: []
  type: TYPE_TB
- en: '| `new` | Create a new object | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `+ - ~ !` | Unary and bitwise | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `?:` | Ternary | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `= *= /= %= += -=` | Assignment | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `<<= >>= >>>= &= ^= &#124;=` | Assignment | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `,` | Separator | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `+ - * / %` | Arithmetic | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `<< >> >>>` | Bitwise | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `< <= > >= == != === !==` | Arithmetic | Left |'
  prefs: []
  type: TYPE_TB
- en: Relational Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Relational operators* test two operands and return a Boolean result of either
    `true` or `false`. There are three types of relational operators: *equality*,
    *comparison*, and *logical*.'
  prefs: []
  type: TYPE_NORMAL
- en: Equality operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The equality operator is `==` (which should not be confused with the `=` assignment
    operator). In [Example 15-4](#assigning_a_value_and_testing_fo-id00065), the first
    statement assigns a value, and the second tests it for equality. As it stands,
    nothing will be printed out, because `month` is assigned the string value `July`,
    and therefore the check for it having a value of `October` will fail.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-4\. Assigning a value and testing for equality
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the two operands of an equality expression are of different types, JavaScript
    will convert them to whatever type makes best sense to it. For example, any strings
    composed entirely of numbers will be converted to numbers whenever compared with
    a number. In [Example 15-5](#equality_and_identity_operators-id00066), `a` and
    `b` are two different values (one is a number, and the other is a string), and
    we would therefore normally expect neither of the `if` statements to output a
    result.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-5\. The equality and identity operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: However, if you run the example, you will see that it outputs the number `1`,
    which means that the first `if` statement evaluated to `true`. This is because
    the string value of `b` was temporarily converted to a number, and therefore both
    halves of the equation had a numerical value of `3.1415927`.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, the second `if` statement uses the *identity* operator, three equals
    signs in a row, which prevents JavaScript from automatically converting types.
    `a` and `b` are therefore found to be different, so nothing is output.
  prefs: []
  type: TYPE_NORMAL
- en: As with forcing operator precedence, whenever you’re in doubt about how JavaScript
    will convert operand types, you can use the identity operator to turn this behavior
    off.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using comparison operators, you can test for more than just equality and inequality.
    JavaScript also gives you `>` (is greater than), `<` (is less than), `>=` (is
    greater than or equal to), and `<=` (is less than or equal to) to play with. [Example 15-6](#four_comparison_operators-id00068)
    shows these operators in use.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-6\. The four comparison operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, where `a` is `7` and `b` is `11`, the following is output
    (because 7 is less than 11 and also less than or equal to 11):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Logical operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logical operators produce true or false results and are also known as *Boolean*
    operators. There are three of them in JavaScript (see [Table 15-4](#javascriptapostrophes_logical_operators)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-4\. JavaScript’s logical operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Logical operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` *(and)* | `true` if both operands are `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` *(or)* | `true` if either operand is `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `!` *(not)* | `true` if the operand is `false`, or `false` if the operand
    is `true` |'
  prefs: []
  type: TYPE_TB
- en: You can see how these can be used in [Example 15-7](#logical_operators_in_use-id00070),
    which outputs `0`, `1`, and `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-7\. The logical operators in use
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `&&` statement requires both operands to be `true` to return a value of
    `true`, the `||` statement will be `true` if either value is `true`, and the third
    statement performs a `NOT` on the value of `b`, turning it from `0` into a value
    of `true`.
  prefs: []
  type: TYPE_NORMAL
- en: The `||` operator can cause unintentional problems, because the second operand
    will not be evaluated if the first is evaluated as `true`. In [Example 15-8](#statement_using_the_vertical_lineverti),
    the `getnext` function will never be called if `finished` has a value of `1` (these
    are purely examples, and the action of `getnext` is irrelevant to this explanation—just
    think of it as a function that does *something* when called).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-8\. A statement using the `||` operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you *need* `getnext` to be called at each `if` statement, you should rewrite
    the code as shown in [Example 15-9](#ifdotdotdotor_statement_modified_to).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-9\. The `if...or` statement modified to ensure calling of `getnext`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the code in the function `getnext` will be executed and its return
    value stored in `gn` before the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 15-5](#all_possible_logical_expressions) shows all the possible variations
    of using the logical operators. You should also note that `!true` equals `false`
    and `!false` equals `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-5\. All possible logical expressions
  prefs: []
  type: TYPE_NORMAL
- en: '| Inputs | Operators and results |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `a` | `b` | `&&` | `&#124;&#124;` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `true` | `true` | `true` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `true` | `false` | `false` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `false` | `true` | `false` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `false` | `false` | `false` | `false` |'
  prefs: []
  type: TYPE_TB
- en: The with Statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `with` statement is not one that you’ve seen in the earlier chapters on
    PHP, because it’s exclusive to JavaScript, and also one that while you need to
    know it, you should not use (see [???](#a-caution-against-using-with)). With it
    (if you see what I mean), you can simplify some types of JavaScript statements
    by reducing many references to an object to just one reference. References to
    properties and methods within the `with` block are assumed to apply to that object.
  prefs: []
  type: TYPE_NORMAL
- en: For example, take the code in [Example 15-10](#using_the_with_statement), in
    which the `document.write` function never references the variable `string` by
    name.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-10\. Using the `with` statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though `string` is never directly referenced by `document.write`, this
    code still manages to output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the code works: the JavaScript interpreter recognizes that the
    `length` property and `toUpperCase` method have to be applied to some object.
    Because they stand alone, the interpreter assumes they apply to the `string` object
    that you specified in the `with` statement.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using `with` is no longer recommended and is now forbidden in ECMAScript 5 strict
    mode. The recommended alternative is to assign the object whose properties you
    want to access to a temporary variable. Be sure to note this so you can update
    it (if necessary) when you see it in other people’s code, but do not use it yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Using onerror
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using either the `onerror` event or a combination of the `try` and `catch` keywords,
    you can catch JavaScript errors and deal with them yourself.
  prefs: []
  type: TYPE_NORMAL
- en: '*Events* are actions that can be detected by JavaScript. Every element on a
    web page has certain events that can trigger JavaScript functions. For example,
    the `onclick` event of a button element can be set to call a function and make
    it run whenever a user clicks the button.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 15-11](#script_employing_the_onerror_event) illustrates how to use
    the `onerror` event.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-11\. A script employing the onerror event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first line of this script tells the error event to use the new `errorHandler`
    function from now on. This function takes three parameters—a `message`, a `url`,
    and a `line` number—so it’s a simple matter to display all these in an alert pop-up.
  prefs: []
  type: TYPE_NORMAL
- en: Then, to test the new function, we deliberately place a syntax error in the
    code with a call to `document.writ` instead of `document.write` (the final `e`
    is missing). [Figure 15-1](#using_the_onerror_event_with_an_alert_me) shows the
    result of running this script in a browser. Using `onerror` this way can also
    be quite useful during the debugging process.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the onerror event with an alert method pop-up](Images/pmj6_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. Using the `onerror` event with an alert method pop-up
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using try...catch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `try` and `catch` keywords are more standard and more flexible than the
    `onerror` technique shown in the previous section. These keywords let you trap
    errors for a selected section of code, rather than all scripts in a document.
    However, they do not catch syntax errors, for which you need `onerror`.
  prefs: []
  type: TYPE_NORMAL
- en: The `try...catch` construct is supported by all major browsers and is handy
    when you want to catch a certain condition that you are aware could occur in a
    specific part of your code.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in [Chapter 18](ch18.xhtml#using_ajax) we’ll be exploring Ajax
    techniques that make use of the `XMLHttpRequest` object. Therefore, we can use
    `try` and `catch` to trap this case and do something else if the function is not
    available. [Example 15-12](#trapping_an_error_with_try_and_catch) shows how.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-12\. Trapping an error with `try` and `catch`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s also another keyword associated with `try` and `catch` called `finally`
    that is always executed, regardless of whether an error occurs in the `try` clause.
    To use it, just add something like the following statements after a `catch` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conditionals alter program flow. They enable you to ask questions about certain
    things and respond to the answers you get in different ways. There are three types
    of nonlooping conditionals: the `if` statement, the `switch` statement, and the
    `?` operator.'
  prefs: []
  type: TYPE_NORMAL
- en: The if Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Several examples in this chapter have already made use of `if` statements.
    The code within such a statement is executed only if the given expression evaluates
    to `true`. Multiline `if` statements require curly braces around them, but as
    in PHP, you can omit the braces for single statements, although it’s often a good
    idea to use them anyway, especially when writing code in which the number of actions
    within an `if` statement might change as development proceeds. Therefore, the
    following statements are valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The else Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a condition has not been met, you can execute an alternative by using
    an `else` statement, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike PHP, JavaScript has no `elseif` statement, but that’s not a problem
    because you can use an `else` followed by another `if` to form the equivalent
    of an `elseif` statement, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, you can use another `else` after the new `if`, which could
    equally be followed by another `if` statement, and so on. Although I have shown
    braces on the statements, because each is a single line, the previous example
    could be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The switch Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `switch` statement is useful when one variable or the result of an expression
    can have multiple values and you want to perform a different function for each
    value.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the following code takes the PHP menu system we put together in
    [Chapter 4](ch04.xhtml#expressions_and_control_flow_in_php) and converts it to
    JavaScript. It works by passing a single string to the main menu code according
    to what the user requests. Let’s say the options are Home, About, News, Login,
    and Links, and we set the variable `page` to one of these according to the user’s
    input.
  prefs: []
  type: TYPE_NORMAL
- en: The code for this written using `if...else if...` might look like [Example 15-13](#multiline_ifdotdotdotelse_if).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-13\. A multiline `if...else if...` statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: But using a `switch` construct, the code could look like [Example 15-14](#switch_construct).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-14\. A `switch` construct
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The variable `page` is mentioned only once at the start of the `switch` statement.
    Thereafter, the `case` command checks for matches. When one occurs, the matching
    conditional statement is executed. Of course, a real program would have code here
    to display or jump to a page, rather than simply telling the user what was selected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You may also supply multiple cases for a single action. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Breaking out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see in [Example 15-14](#switch_construct), just as with PHP, the
    `break` command allows your code to break out of the `switch` statement once a
    condition has been satisfied. Remember to include the `break` unless you want
    to continue executing the statements under the next `case`.
  prefs: []
  type: TYPE_NORMAL
- en: Default action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When no condition is satisfied, you can specify a default action for a `switch`
    statement by using the `default` keyword. [Example 15-15](#default_statement_to_add_to_example_14)
    shows a code snippet that could be inserted into [Example 15-14](#switch_construct).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-15\. A default statement to add to [Example 15-14](#switch_construct)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The ? Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ternary` operator (`?`), combined with the `:` character, provides a quick
    way of doing `if...else` tests. With it you can write an expression to evaluate
    and then follow it with a `?` symbol and the code to execute if the expression
    is `true`. After that, place a `:` and the code to execute if the expression evaluates
    to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 15-16](#using_the_ternary_operator) shows the ternary operator being
    used to print out whether the variable `a` is less than or equal to 5 and prints
    something either way.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-16\. Using the ternary operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The statement has been broken up into several lines for clarity, but you would
    be more likely to use such a statement on a single line, in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, you will find many close similarities between JavaScript and PHP when
    it comes to looping. Both languages support `while`, `do...while`, and `for` loops.
  prefs: []
  type: TYPE_NORMAL
- en: while Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A JavaScript `while` loop first checks the value of an expression and starts
    executing the statements within the loop only if that expression is `true`. If
    it is `false`, execution skips over to the next JavaScript statement (if any).
  prefs: []
  type: TYPE_NORMAL
- en: Upon completing an iteration of the loop, the expression is again tested to
    see if it is `true`, and the process continues until such a time as the expression
    evaluates to `false` or until execution is otherwise halted. [Example 15-17](#while_loop-id00080)
    shows such a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-17\. A `while` loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This script outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the variable `counter` were not incremented within the loop, it is quite
    possible that some browsers could become unresponsive due to a never-ending loop,
    and the page may not even be easy to terminate with Escape or the Stop button.
    So, be careful with your JavaScript loops.
  prefs: []
  type: TYPE_NORMAL
- en: do...while Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you require a loop to iterate at least once before any tests are made,
    use a `do...while` loop, which is similar to a `while` loop, except that the test
    expression is checked only after each iteration of the loop. So, to output the
    first seven results in the 7 times table, you could use code such as that in [Example 15-18](#do_dotdotdot_while_loop).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-18\. A `do...while` loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might expect, this loop outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: for Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `for` loop combines the best of all worlds into a single looping construct
    that allows you to pass three parameters for each statement:'
  prefs: []
  type: TYPE_NORMAL
- en: An initialization expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A condition expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modification expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are separated by semicolons, like this: `for (`*`expr1`* `;` *`expr2`*
    `;` *`expr3`*`)`. The initialization expression is executed at the start of the
    first iteration of the loop. In the case of the code for the multiplication table
    for 7, `count` would be initialized to the value `1`. Then, each time around the
    loop, the condition expression (in this case, `count <= 7`) is tested, and the
    loop is entered only if the condition is `true`. Finally, at the end of each iteration,
    the modification expression is executed. In the case of the multiplication table
    for 7, the variable `count` is incremented. [Example 15-19](#using_a_for_loop)
    shows what the code would look like.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-19\. Using a `for` loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As in PHP, you can assign multiple variables in the first parameter of a `for`
    loop by separating them with a comma, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, you can perform multiple modifications in the last parameter, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can do both at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Breaking Out of a Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `break` command, which you’ll recall is important inside a `switch` statement,
    is also available within `for` loops. You might need to use this, for example,
    when searching for a match of some kind. Once the match is found, you know that
    continuing to search will only waste time and make your visitor wait. [Example 15-20](#using_the_break_command_in_a_for_loop)
    shows how to use the `break` command.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-20\. Using the `break` command in a `for` loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This script outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The continue Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you don’t want to entirely exit from a loop but instead wish to skip
    the remaining statements just for this iteration of the loop. In such cases, you
    can use the `continue` command. [Example 15-21](#using_the_continue_command_in_a_for_loop)
    shows this in use.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-21\. Using the `continue` command in a `for` loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the second `document.write` call does not have to be enclosed in
    an `else` statement (as it did before), because the `continue` command will skip
    it if a match has been found. The output from this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Explicit Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike PHP, JavaScript has no explicit casting of types such as `(int)` or `(float)`.
    Instead, when you need a value to be of a certain type, use one of JavaScript’s
    built-in functions, shown in [Table 15-6](#javascriptapostrophes_type-changing_func).
  prefs: []
  type: TYPE_NORMAL
- en: Table 15-6\. JavaScript’s type-changing functions
  prefs: []
  type: TYPE_NORMAL
- en: '| Change to type | Function to use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Int`, `Integer` | `parseInt()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Bool`, `Boolean` | `Boolean()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Float`, `Double`, `Real` | `parseFloat()` |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | `String()` |'
  prefs: []
  type: TYPE_TB
- en: '| `Array` | `split()` |'
  prefs: []
  type: TYPE_TB
- en: 'So, for example, to change a floating-point number to an integer, you could
    use code such as the following (which displays the value `3`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use the compound form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: That’s it for control flow and expressions. The next chapter focuses on the
    use of functions, objects, and arrays in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How are Boolean values handled differently by PHP and JavaScript?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What characters are used to define a JavaScript variable name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between unary, binary, and ternary operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way to force your own operator precedence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you use the `===` (identity) operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the simplest two forms of expressions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the three conditional statement types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do `if` and `while` statements interpret conditional expressions of different
    data types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is a `for` loop more powerful than a `while` loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the `with` statement?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See [“Chapter 15 Answers”](app01_split_014.xhtml#chapter_15_answers) in the
    [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions) for the
    answers to these questions.
  prefs: []
  type: TYPE_NORMAL
