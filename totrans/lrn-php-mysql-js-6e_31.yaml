- en: Chapter 28\. Other HTML5 Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二十八章 其他 HTML5 功能
- en: In this final chapter on HTML5, I explain how to use geolocation and local storage
    and demonstrate the use of in-browser dragging and dropping, as well as how to
    set up and use web workers and make use of cross-document messaging.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 HTML5 的最后一章中，我将解释如何使用地理位置和本地存储，并演示如何在浏览器中进行拖放操作，以及如何设置和使用 Web Workers 并利用跨文档消息传递。
- en: Strictly speaking, most of these features (like much of HTML5) aren’t really
    extensions to HTML, because you access them with JavaScript rather than with HTML
    markup. They are simply technologies that are being embraced by browser developers
    and have been given the handy umbrella name of HTML5.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，大多数这些特性（如 HTML5 的大部分）实际上并不是 HTML 的扩展，因为您是通过 JavaScript 而不是 HTML 标记访问它们。它们只是被浏览器开发人员采纳并被赋予便捷的
    HTML5 统称。
- en: This means, though, that you need to have fully understood the JavaScript tutorial
    in this book in order to use them properly. That said, once you get the hang of
    them, you’ll wonder how you ever did without these powerful new features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，您需要彻底理解本书中的 JavaScript 教程，才能正确使用它们。话虽如此，一旦掌握了它们，您会想知道在没有这些强大新功能之前，您是如何生活的。
- en: Geolocation and the GPS Service
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理位置和 GPS 服务
- en: The Global Positioning System (GPS) service consists of multiple satellites
    orbiting the Earth whose positions are very precisely known. When a GPS-enabled
    device tunes into them, the different times at which signals from these various
    satellites arrive enable the device to quite accurately determine where it is;
    because the speed of light (and therefore radio waves) is a known constant, the
    time it takes a signal to get from a satellite to a GPS device indicates the satellite’s
    distance.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 全球定位系统（GPS）服务由多颗围绕地球轨道的卫星组成，它们的位置非常精确。当启用 GPS 的设备连接到这些卫星时，来自各个卫星的信号到达时间的不同，使得设备能够相当精确地确定自己的位置；因为光速（因而是无线电波）是已知的恒定值，信号从卫星到
    GPS 设备的传输时间表明卫星的距离。
- en: By noting the different times at which signals arrive from different satellites,
    which are in precisely known orbital locations at any one time, a simple triangulation
    calculation gives the device its position relative to the satellites within a
    few meters or less.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过记录来自不同卫星的信号到达时间，这些卫星在任何时候的轨道位置都已精确确定，一个简单的三角测量计算就能让设备相对于卫星的位置精确到几米甚至更少。
- en: Many mobile devices, such as phones and tablets, have GPS chips and can provide
    this information. But some don’t, others have them turned off, and others may
    be used indoors where they are shielded from the GPS satellites and therefore
    cannot receive any signals. In these cases, additional techniques may be used
    to attempt to determine the device’s location.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 许多移动设备，如手机和平板电脑，配备有 GPS 芯片并能提供此信息。但有些设备没有，有些设备已关闭，还有些设备可能在室内使用，被屏蔽了 GPS 卫星信号，因此无法接收任何信号。在这些情况下，可能会使用其他技术来尝试确定设备的位置。
- en: Warning
  id: totrans-8
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: I should also caution you to consider the privacy implications of geolocation,
    especially if the coordinates are transmitted back to the server as part of an
    application’s function. Any application that has geolocation functionality should
    have an explicit privacy policy. Oh, and by the way, technically geolocation is
    not actually in the HTML5 standard. In fact, it’s a standalone feature defined
    by the W3C/WHATWG, but most people think of it as part of HTML5.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我还要提醒您考虑地理位置信息的隐私影响，特别是如果坐标作为应用程序功能的一部分传输回服务器时。任何具有地理位置功能的应用程序都应有明确的隐私政策。哦，顺便说一句，技术上地理位置信息实际上并不在
    HTML5 标准中。事实上，它是由 W3C/WHATWG 定义的独立功能，但大多数人将其视为 HTML5 的一部分。
- en: Other Location Methods
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他定位方法
- en: If your device has mobile phone hardware but no GPS chip, it may attempt to
    triangulate its location by checking the timing of signals received from the various
    communication towers with which it can communicate (and whose positions are very
    precisely known). If there are a few towers, this can get almost as close to your
    location as GPS. But where there’s only a single tower, the signal strength can
    be used to determine a rough radius around the tower, and the circle it creates
    represents the area in which you are likely to be located. This could place you
    anywhere within a mile or two of your actual location, down to within a few tens
    of meters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备具有手机硬件但没有GPS芯片，它可以尝试通过检查从各种通信塔接收到的信号的时序来三角测量其位置（这些塔可以通信，并且它们的位置非常精确）。如果有几座塔，这几乎可以达到GPS定位的精度。但如果只有一座塔，信号强度可以用来确定围绕塔周围的粗略半径，形成的圆表示您可能位于的区域。这可能会将您的位置定位在离实际位置一英里或两英里的范围内，甚至到几十米内。
- en: Failing that, there may be WiFi access points whose positions are known within
    range of your device, and since all access points have a unique identifying address
    called a Media Access Control (MAC) address, a reasonably good approximation of
    your location can be obtained, perhaps to within a street or two. This is the
    type of information that Google Street View vehicles have been collecting (some
    of which it has since been made to discard due to potential breaches of data privacy
    rights).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果那样还失败了，可能会有WiFi接入点的位置在您设备的范围内是已知的，由于所有接入点都有称为媒体访问控制（MAC）地址的唯一标识地址，可以得到您位置的一个合理良好的近似值，也许可以缩小到一两条街道。这就是Google街景车辆一直在收集的信息类型（其中一些信息由于可能侵犯数据隐私权而被要求丢弃）。
- en: And if that fails, the Internet Protocol (IP) address used by your device can
    be queried and used as a rough indicator of your location. Often, though, this
    provides only the location of a major switch belonging to your internet provider,
    which could be dozens or even hundreds of miles away. But at the very least, your
    IP address can (usually) narrow down the country and sometimes the region you
    are in.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些方法都失败了，您可以查询并使用您的设备使用的Internet Protocol（IP）地址作为粗略位置指示器。但通常情况下，这只能提供您的互联网提供商拥有的一个主要交换机的位置，该位置可能有数十甚至数百英里之遥。但至少，您的IP地址（通常）可以缩小您所在国家的范围，有时甚至可以缩小到您所在地区。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: IP addresses are commonly used by media companies for restricting playback of
    their content by territory. However, it’s a simple matter to set up proxy servers
    that use a forwarding IP address (in the territory that is blocking outside access)
    to fetch and pass content through the blockade directly to a “foreign” browser.
    Proxy servers are also often employed to disguise a user’s real IP address or
    bypass censorship restrictions and can be shared across many users on a WiFi hotspot
    (for example). Therefore, if you locate someone by IP address, you can’t be completely
    sure that you have identified the right location, or even country, and should
    treat this information as only a best guess.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 媒体公司通常使用IP地址来限制其内容的播放地域。但是，可以简单地设置使用转发IP地址的代理服务器（位于阻止外部访问的领土内），直接将内容通过封锁传递到“外国”浏览器。代理服务器也经常用于伪装用户的真实IP地址或绕过审查限制，并可以在WiFi热点上共享给许多用户使用。因此，如果通过IP地址定位某人，您不能完全确定已经准确识别了正确的位置，甚至国家，应将此信息视为仅作最佳猜测。
- en: Geolocation and HTML5
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理位置和HTML5
- en: In [Chapter 25](ch25.xhtml#introduction_to_html5), I briefly introduced HTML5
    geolocation. Now it’s time to look at it in depth, shown again in [Example 28-1](#displaying_a_map_of_your_current_locatio).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第25章](ch25.xhtml#introduction_to_html5)中，我简要介绍了HTML5地理位置。现在是时候深入了解它，再次显示在[示例28-1](#displaying_a_map_of_your_current_locatio)中。
- en: Example 28-1\. Displaying a map of your current location
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例28-1\. 显示您当前位置的地图
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s walk through this code and see how it works, starting with the `<head>`
    section, which displays a title. The `<body>` of the document is made up entirely
    of JavaScript, which immediately starts by interrogating the `navigator.geolocation`
    property. If the value returned is `undefined`, then geolocation is not supported
    by the browser and an error alert window is popped up.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览这段代码，看看它是如何工作的，从显示标题的`<head>`部分开始。文档的`<body>`完全由JavaScript组成，立即开始查询`navigator.geolocation`属性。如果返回的值是`undefined`，则浏览器不支持地理位置，并弹出错误警告窗口。
- en: 'Otherwise, we call the `getCurrentPosition` method of the property, passing
    it the names of two functions: `granted` and `denied` (remember that by passing
    only the function names, we pass the actual function code, not the result of calling
    the function, which would be the case if the function names had parentheses attached):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们调用属性的`getCurrentPosition`方法，并向其传递两个函数的名称：`granted`和`denied`（请记住，通过仅传递函数名称，我们传递的是实际的函数代码，而不是调用函数的结果，如果函数名称附带括号，则会是后者）：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'These functions appear later in the script and are for handling the two possibilities
    of permission to provide the user’s location data: `granted` or `denied`.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数稍后在脚本中出现，用于处理提供用户位置数据的两种可能性：`granted`或`denied`。
- en: The `granted` function comes first and is entered only if the data can be accessed.
    If so, the variables `lat` and `long` are given the values returned by the geolocation
    routines in the browser.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`granted`首先被调用，仅当可以访问数据时才会进入。如果可以访问，变量`lat`和`long`将被赋予浏览器中地理位置例程返回的值。
- en: An alert window is then popped up containing details about the user’s current
    location. When they click OK, the alert is closed and the current web page is
    replaced by one at Google Maps. It’s passed the latitude and longitude returned
    from the geolocation call, using a zoom setting of 8\. You can set a different
    zoom level by changing the value `8z` to another numeric value followed by a `z`,
    at the end of the `window.location.replace` call.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后会弹出一个警告窗口，显示有关用户当前位置的详细信息。当用户点击“确定”时，警告窗口将关闭，并且当前网页将被一个指向 Google 地图的网页替换。它通过使用地理位置调用返回的纬度和经度来传递，使用8作为缩放设置。您可以通过将`8z`的值更改为另一个数值后跟一个`z`，在`window.location.replace`调用的末尾设置不同的缩放级别。
- en: Displaying the map is achieved with a call to `window.location.replace`. The
    result looks like [Figure 28-1](#an-interactive-map-of).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`window.location.replace`来实现地图的显示。结果看起来像[图28-1](#an-interactive-map-of)。
- en: '![](Images/pmj6_2502.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pmj6_2502.png)'
- en: Figure 28-1\. Interactive map of user’s location is displayed
  id: totrans-28
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图28-1\. 显示用户位置的交互地图
- en: 'If permission is denied (or there is another issue), an error message is displayed
    by the `denied` function, which pops up its own alert window to inform the user
    of the error:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果权限被拒绝（或存在其他问题），则由`denied`函数显示错误消息，并弹出自己的警告窗口通知用户错误信息：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注
- en: When a browser requests geolocation data from the host, it will prompt the user
    for permission. The user can grant or deny permission. Denial results in the *Permission
    Denied* state, *Position Unavailable* results when the user grants permission
    but the host system cannot determine their location, and *Timeout* happens when
    the user grants permission and the host attempts to get their location but the
    request times out.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器从主机请求地理位置数据时，它将提示用户进行授权。用户可以选择授权或拒绝。拒绝授权会导致*权限被拒绝*状态，如果用户授权但主机系统无法确定其位置，则会显示*位置不可用*，而*超时*则发生在用户授权并且主机尝试获取其位置但请求超时的情况。
- en: There’s also another error condition in which some platform and browser combinations
    allow the user to dismiss the permission request dialog without either granting
    or denying permission. This results in the application “hanging” while waiting
    for a callback to occur.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一种错误情况，即某些平台和浏览器组合允许用户在不授予或拒绝权限的情况下关闭权限请求对话框。这会导致应用程序在等待回调时“挂起”。
- en: In previous editions of this book, I used to call the Google Maps API to embed
    a map directly within the web page, but the service now requires a unique API
    key that you must apply for yourself, and usage over a certain amount can incur
    a fee. This is why the example now simply generates a Google Maps link. If you’d
    like to embed Google Maps in your web pages and web apps, everything you need
    to know is on the [website](https://developers.google.com/maps). Of course, there
    are also many other mapping options, such as [Bing Maps](https://www.bing.com/maps)
    and [OpenStreetMap](https://www.openstreetmap.org), that have APIs you can access.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的早期版本中，我曾调用 Google Maps API 在网页内直接嵌入地图，但现在该服务需要您自行申请唯一的 API 密钥，并且超过一定使用量可能会产生费用。这就是为什么现在的示例仅生成一个
    Google 地图链接。如果您希望在您的网页和应用中嵌入 Google 地图，所有必要的信息都在[网站](https://developers.google.com/maps)上。当然，还有许多其他的地图选项，如[Bing
    地图](https://www.bing.com/maps)和[OpenStreetMap](https://www.openstreetmap.org)，它们都有可以访问的
    API。
- en: Local Storage
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地存储
- en: Cookies are an essential part of the modern internet, because they enable websites
    to save on each user’s machine small snippets of information that can be used
    for tracking purposes. This isn’t as ominous as it sounds, because most of the
    tracking going on helps web surfers by saving usernames and passwords, keeping
    them logged in to websites and social networks such as Twitter, Facebook, and
    more.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Cookies can also locally save your preferences for the way you access a website
    (rather than having those settings stored on the website’s server) or can be used
    to keep track of a shopping cart as you build up an order on an ecommerce website.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: But yes, they can also be used more aggressively to track the websites you frequent
    and gain a picture of your interests to try to target advertising more effectively.
    That’s why the [European Union](https://tinyurl.com/cookielaweu) now “requires
    prior informed consent for storage or for access to information stored on a user’s
    terminal equipment.”
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: But, as a web developer, think how useful it might be to keep data on users’
    devices, especially if you have a small budget for computer servers and disk space.
    For example, you could create in-browser web apps and services for editing word
    processing documents, spreadsheets, and graphic images, saving all this data offsite
    on users’ computers and keeping your server purchasing budget as low as possible.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: And from the user’s point of view, think about how much faster a document can
    be loaded up locally than from across the web, especially on a slow connection.
    Plus, there’s more security if you know that a website is not storing copies of
    your documents. Of course, you can never guarantee that a website or web app is
    totally secure, and you should never work on highly sensitive documents using
    software (or hardware) that can go online. But for minimally private documents
    such as family photographs, you might feel more comfortable using a web app that
    saves locally than one that saves files to an external server.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Using Local Storage
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest problem with using cookies for local storage is that each cookie
    can save only a maximum of 4 KB of data. Cookies also have to be passed back and
    forth on every page reload. And, unless your server uses Transport Layer Security
    (TLS) encryption—the more secure successor to the Secure Sockets Layer (SSL)—each
    time a cookie is transmitted, it travels in the clear.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: But with HTML5, you have access to a much larger local storage space (typically
    between 5 MB and 10 MB per domain, depending on the browser) that persists over
    page loads and between website visits (and even after powering a computer down
    and back up again). Also, the local storage data is not sent to the server on
    each page load, and it can be cleared by the user, so you usually want to keep
    the data on the servers as well; otherwise the user may find their data gone and
    be upset, even if they were the one who cleared the data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Local storage data is handled through key/value pairs. The key is the name assigned
    for referencing the data, and the value can hold any type of data, but it is saved
    as a string. All data is unique to the current domain, and for security reasons
    any local storage created by websites with different domains is separate from
    the current local storage and is not accessible by any domain other than the one
    that stored the data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本地存储数据通过键/值对处理。键是为引用数据分配的名称，值可以保存任何类型的数据，但保存为字符串。所有数据都是唯一的，限定在当前域内，出于安全原因，由具有不同域的网站创建的任何本地存储都与当前本地存储分开，并且不能被存储数据的域之外的任何域访问。
- en: The localStorage Object
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: localStorage 对象
- en: 'You gain access to local storage by means of the `localStorage` object. To
    test whether this object is available, query its type to check whether or not
    it has been defined, like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查询其类型来测试是否可以通过`localStorage`对象访问本地存储，如下所示：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How you handle the lack of local storage being available will depend on what
    you intend to use it for, so the code you place inside the `if` statement will
    be up to you.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要处理本地存储不可用的情况，这将取决于您打算使用它的方式，因此您放置在`if`语句内的代码将由您决定。
- en: 'Once you’ve ascertained that local storage is available, you can start making
    use of it with the `setItem` and `getItem` methods of the `localStorage` object,
    like this:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定本地存储可用，您就可以开始使用`localStorage`对象的`setItem`和`getItem`方法，如下所示：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To later retrieve this data, pass the keys to the `getItem` method, like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要稍后检索此数据，请将键传递给`getItem`方法，如下所示：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Unlike saving and reading cookies, you can call these methods at any time you
    like, not simply before any headers have been sent by the web server. The saved
    values will remain in local storage until erased in the following manner:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与保存和读取 cookie 不同，您可以在任何时候调用这些方法，而不仅仅是在 Web 服务器发送任何标头之前。保存的值将保留在本地存储中，直到以以下方式擦除：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or, you can totally wipe the local storage for the current domain by calling
    the `clear` method, like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过调用`clear`方法彻底清除当前域的本地存储，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[Example 28-2](#gettingcomma_settingcomma_and_removing_l) combines the preceding
    examples into a single document that displays the current values of the two keys
    in a pop-up alert message, which initially will be `null`. Then the keys and values
    are saved to local storage, retrieved, and redisplayed, this time having assigned
    values. Finally, the keys are removed, and then an attempt at retrieving these
    values is again made, but the returned values are once again `null`. [Figure 28-2](#two-keys-and-their-values)
    shows the second of these three alert messages.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 28-2](#gettingcomma_settingcomma_and_removing_l) 将前述示例组合到一个单独的文档中，显示当前两个键的值在弹出的警告消息中，最初将为`null`。然后将键和值保存到本地存储中，检索并重新显示，这次分配了值。最后，删除键，然后再次尝试检索这些值，但返回的值再次为`null`。[图 28-2](#two-keys-and-their-values)
    显示这三个警告消息中的第二个。'
- en: Example 28-2\. Getting, setting, and removing local storage data
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 28-2\. 获取、设置和删除本地存储数据
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](Images/pmj6_2802.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pmj6_2802.png)'
- en: Figure 28-2\. Two keys and their values are read from local storage
  id: totrans-61
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 28-2\. 从本地存储中读取两个键及其值
- en: Note
  id: totrans-62
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In local storage you can include virtually any and all data and as many key/value
    pairs as you like, up to the available storage limit for your domain.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地存储中，您可以包含几乎任何和所有数据，并且可以包含多个键/值对，最多达到您域的可用存储限制。
- en: Web Workers
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web Workers
- en: '*Web workers* run background jobs and are useful for calculations that take
    a long time and should not be allowed to hold the user back from doing other things.
    To use a web worker, you can create sections of JavaScript code that will run
    in the background. This code doesn’t have to set up and monitor interrupts, as
    jobs have to do in some asynchronous systems. Instead, whenever it has something
    to report, your background process communicates with the main JavaScript through
    the use of an event.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Web workers* 运行后台作业，适用于需要长时间计算且不应阻止用户进行其他操作的情况。要使用 web worker，您可以创建 JavaScript
    代码段，这些代码将在后台运行。这段代码不必像某些异步系统中的作业那样设置和监控中断。相反，每当它有报告的内容时，您的后台进程通过事件与主 JavaScript
    进行通信。'
- en: This means the JavaScript interpreter gets to decide how to allocate time slices
    most efficiently, and your code only needs to worry about communicating with the
    background task whenever there’s information to convey.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 JavaScript 解释器决定如何最有效地分配时间片，并且您的代码只需在需要传递信息时与后台任务通信。
- en: '[Example 28-3](#setting_up_and_communicating_with_a_web) shows how you can
    set up web workers to perform a repetitive task in the background—in this instance,
    calculating prime numbers.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 28-3](#setting_up_and_communicating_with_a_web) 展示了如何设置 Web Worker 在后台执行重复任务，本例中是计算质数。'
- en: Example 28-3\. Setting up and communicating with a web worker
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 28-3\. 设置和与 Web Worker 通信
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This example first creates a `<span>` element with the ID of `result` in which
    output from the web worker will be placed. Then, in the `<script>` section, `window.Worker`
    is tested via a `!!` pair of `not` operators. This has the effect of returning
    a Boolean value of `true` if the `Worker` method exists and `false` otherwise.
    If it is not `true`, a message is displayed in the `else` section, alerting us
    that web workers are not available.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本例首先在 ID 为 `result` 的 `<span>` 元素中创建一个元素，其中将放置来自 Web Worker 的输出。然后，在 `<script>`
    部分，通过 `!!` 连续 `not` 运算符测试 `window.Worker`。如果不是 `true`，则在 `else` 部分显示消息，提示我们 Web
    Worker 不可用。
- en: Otherwise, the program creates a new `worker` object by calling `Worker`, passing
    it the filename *worker.js*. Then the `onmessage` event of the new `worker` object
    is attached to an anonymous function that places any message passed to it by *worker.js*
    into the `innerText` property of the previously created `<span>` element.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，程序通过调用 `Worker` 创建一个新的 `worker` 对象，并将文件名 *worker.js* 传递给它。然后，新的 `worker`
    对象的 `onmessage` 事件附加到一个匿名函数，该函数将由 *worker.js* 传递的任何消息放入先前创建的 `<span>` 元素的 `innerText`
    属性中。
- en: The web worker itself is saved in the file *worker.js*, whose contents are shown
    in [Example 28-4](#workerdotjs_web_worker).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Web Worker 本身保存在文件 *worker.js* 中，其内容显示在 [示例 28-4](#workerdotjs_web_worker) 中。
- en: Example 28-4\. The worker.js web worker
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 28-4\. worker.js Web Worker
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This file assigns the value `1` to the variable `n`. It then loops continuously,
    incrementing `n` and checking it for primality by a brute-force method of testing
    all values from `1` to the square root of `n` to see whether they divide exactly
    into `n`, with no remainder. Should a factor be found, the `continue` command
    stops the brute-force attack immediately because the number is not prime and starts
    processing at the next higher value of `n`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件将值 `1` 赋给变量 `n`。然后，它连续循环，递增 `n` 并通过测试从 `1` 到 `n` 的平方根的所有值，看它们是否能够完全除尽 `n`，没有余数。如果找到因子，`continue`
    命令立即停止暴力攻击，因为该数字不是质数，并从下一个更高的 `n` 值开始处理。
- en: But if all possible factors are tested and none result in a zero remainder,
    `n` must be prime, so its value is passed to `postMessage`, which sends a message
    back to the `onmessage` event of the object that set up this web worker.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果测试了所有可能的因子并且没有导致余数为零，`n` 必须是质数，因此其值被传递给 `postMessage`，它将消息发送回设置此 Web Worker
    的对象的 `onmessage` 事件。
- en: 'The result looks like the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To stop a web worker from running, issue a call to the `terminate` method of
    the `worker` object, like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止 Web Worker 的运行，可以调用 `worker` 对象的 `terminate` 方法，如下所示：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you wish to stop this particular example from running, you can enter the
    following into your browser’s address bar:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望停止运行此特定示例，可以在浏览器的地址栏中输入以下内容：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Also note that due to the way Chrome handles security, you cannot use web workers
    on a filesystem, only from a web server (or running the files from *localhost*
    on a development server such as AMPPS, detailed in [Chapter 2](ch02.xhtml#setting_up_a_development_server)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，由于 Chrome 处理安全性的方式，您不能在文件系统上使用 Web Worker，只能从 Web 服务器（或在类似 AMPPS 的开发服务器上
    *localhost* 运行文件，详见 [第 2 章](ch02.xhtml#setting_up_a_development_server)）。
- en: 'Web workers do have some security limitations that you should be aware of:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Web Worker 确实有一些安全限制需要注意：
- en: Web workers run in their own independent JavaScript context and have no direct
    access to anything in any other execution context, including the main JavaScript
    thread or other web workers.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Worker 在其自己独立的 JavaScript 上下文中运行，并且无法直接访问任何其他执行上下文中的内容，包括主 JavaScript 线程或其他
    Web Worker。
- en: Communication between web worker contexts is done via web messaging (`postMessage`).
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Worker 上下文之间的通信通过 web messaging (`postMessage`) 来完成。
- en: Because web workers have no access to the main JavaScript context, they cannot
    modify the DOM. The only DOM methods available to web workers are `atob`, `btoa`,
    `clearInterval`, `clearTimeout`, `dump`, `setInterval`, and `setTimeout`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为 Web Workers 无法访问主 JavaScript 上下文，它们无法修改 DOM。Web Workers 可用的唯一 DOM 方法包括 `atob`、`btoa`、`clearInterval`、`clearTimeout`、`dump`、`setInterval`
    和 `setTimeout`。
- en: Web workers are bound by the same-origin policy, so you can’t load a web worker
    from a different origin than the original script without going through a cross-site
    methodology.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web Workers 受同源策略的限制，因此不能从与原始脚本不同源的位置加载 Web Worker，除非通过跨站方法。
- en: Drag and Drop
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖放
- en: You can easily support dragging and dropping of objects on a web page by setting
    up event handlers for the `ondragstart`, `ondragover`, and `ondrop` events, as
    in [Example 28-5](#dragging_and_dropping_objects).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置 `ondragstart`、`ondragover` 和 `ondrop` 事件的事件处理程序，你可以轻松支持在网页上拖放对象，例如 [示例 28-5](#dragging_and_dropping_objects)。
- en: Example 28-5\. Dragging and dropping objects
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 28-5\. 拖放对象
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: After setting up the HTML, providing a title, and loading in the *OSC.js* file,
    this document styles the `<div>` element with the ID of `dest`, giving it a background
    color, border, set dimensions, and padding.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置了 HTML、提供了标题并加载了 *OSC.js* 文件之后，该文档对 ID 为 `dest` 的 `<div>` 元素进行样式设置，为其设置了背景颜色、边框、固定尺寸和填充。
- en: Then, the `<body>` section creates the `<div>` element and attaches the event
    handler functions `drop` and `allow` to the `ondrop` and `ondragover` events of
    the `<div>`. After this there’s some text and then three images with their `draggable`
    properties set to `true`. The `drag` function is attached to the `ondragstart`
    event of each.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`<body>` 部分创建了 `<div>` 元素，并将事件处理程序函数 `drop` 和 `allow` 附加到 `<div>` 的 `ondrop`
    和 `ondragover` 事件上。之后是一些文本，然后是三个将其 `draggable` 属性设置为 `true` 的图像。每个图像的 `ondragstart`
    事件附加了 `drag` 函数。
- en: In the `<script>` section, the `allow` event handler function simply prevents
    the default action for dragging (which is to disallow it), while the `drag` event
    handler function calls the `setData` method of the `dataTransfer` object of the
    event, passing it the MIME type `image/png` and the `target.id` of the event (which
    is the object being dragged). The `dataTransfer` object holds the data that is
    being dragged during a drag-and-drop operation.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<script>` 部分，`allow` 事件处理程序函数简单地阻止了拖动的默认操作（即不允许它），而 `drag` 事件处理程序函数调用了事件的
    `dataTransfer` 对象的 `setData` 方法，传递了 MIME 类型 `image/png` 和事件的 `target.id`（即被拖动的对象）。`dataTransfer`
    对象在拖放操作期间保存被拖动的数据。
- en: Finally, the `drop` event handler function also intercepts its default action
    so that dropping is allowed and then it fetches the contents of the object being
    dragged from the `dataTransfer` object, passing it the MIME type of the object.
    Then the dropped data is appended to the target (which is the `dest <div>`) via
    its `appendChild` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`drop` 事件处理程序函数还拦截其默认操作，以便允许拖放，然后从 `dataTransfer` 对象中获取被拖动对象的内容，传递对象的 MIME
    类型。然后通过其 `appendChild` 方法将放置的数据附加到目标（即 `dest <div>`）。
- en: If you try this example for yourself, you’ll be able to drag and drop the images
    into the `<div>` element, where they will stay, as shown in [Figure 28-3](Images/#two-images-have-been).
    The images cannot be dropped elsewhere, only into elements with `drop` and `allow`
    event handlers attached.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你自己尝试这个例子，你可以将图像拖放到 `<div>` 元素中，它们将保留在那里，如 [图 28-3](Images/#two-images-have-been)
    所示。这些图像只能拖放到附加了 `drop` 和 `allow` 事件处理程序的元素中，而不能放置到其他位置。
- en: '![](Images/pmj6_2803.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pmj6_2803.png)'
- en: Figure 28-3\. Two images have been dragged and dropped
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 28-3\. 已拖放两个图像
- en: Other events you can attach to include `ondragenter` (to run when a drag operation
    enters an element), `ondragleave` (to run when one leaves an element), and `ondragend`
    (to run when a dragging operation ends), which you can use, for example, to modify
    the cursor during these operations.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以附加其他事件，如 `ondragenter`（当拖动操作进入元素时运行）、`ondragleave`（当离开元素时运行）和 `ondragend`（当拖动操作结束时运行），例如可以在这些操作期间修改光标。
- en: Cross-Document Messaging
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨文档消息
- en: You’ve already seen messaging in use a little earlier, in the web worker section.
    I didn’t go into any details, however, as it wasn’t the core topic being discussed,
    and the message was being posted only to the same document anyway. But for obvious
    security reasons, cross-document messaging does need to be applied with caution,
    so you need to fully understand its workings if you plan to use it.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您在前面稍早已经看到消息的使用情况，在Web Worker部分。但是由于它并非讨论的核心主题，而且消息仅发布到同一文档，所以我没有详细说明。但出于明显的安全原因，跨文档消息确实需要谨慎使用，因此如果您计划使用它，您需要完全了解其工作原理。
- en: Before HTML5, browser developers disallowed cross-document scripting, but in
    addition to blocking potential attack sites, this prevented communication between
    legitimate pages. Document interaction of any kind generally had to occur through
    Ajax and a third-party web server, which was cumbersome and fiddly to build and
    maintain.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在HTML5之前，浏览器开发人员禁止跨文档脚本，但除了阻止潜在的攻击站点外，这还阻止了合法页面之间的通信。任何形式的文档交互通常必须通过Ajax和第三方Web服务器进行，这很麻烦且难以建立和维护。
- en: But web messaging now allows scripts to interact across these boundaries by
    using some sensible security restraints to prevent malicious hacking attempts.
    It is achieved through use of the `postMessage` method, allowing plain-text messages
    to be sent from one domain to another, always within a single browser.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，Web 消息传递允许脚本通过使用一些合理的安全限制在这些边界之间进行交互，以防止恶意黑客攻击。它通过使用`postMessage`方法实现，允许从一个域向另一个域发送纯文本消息，始终在单个浏览器内进行。
- en: 'This requires that JavaScript first obtain the `window` object of the receiving
    document, letting messages post to a variety of other windows, frames, or iframes
    directly related to the sender’s document. The received message event has the
    following attributes:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求JavaScript首先获取接收文档的`window`对象，从而允许消息直接发布到与发送文档直接相关的各种其他窗口、框架或iframe。接收的消息事件具有以下属性：
- en: <dfn class="keep-together">`data`</dfn>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`数据`</dfn>
- en: The incoming message
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接收到的消息
- en: <dfn class="keep-together">`origin`</dfn>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`来源`</dfn>
- en: The origin of the sender document, including the scheme, hostname, and port
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 发件人文档的来源，包括方案、主机名和端口
- en: <dfn class="keep-together">`source`</dfn>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`源`</dfn>
- en: The source window of the sender document
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 发送文档的源窗口
- en: The code to send messages is just a single instruction, in which you pass the
    message to be sent and the domain to which it applies, as in [Example 28-6](#sending_web_messages_to_an_iframe).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 发送消息的代码只需一条指令，其中您传递要发送的消息以及应用于其的域，如[示例 28-6](#sending_web_messages_to_an_iframe)中所示。
- en: Example 28-6\. Sending web messages to an iframe
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 28-6\. 将Web消息发送到iframe
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here the usual use is made of the *OSC.js* file to pull in the `O` function,
    and then an `<iframe>` element with the ID of `frame` is created, which loads
    in [Example 28-7](#receiving_messages_from_another_document). Then, within the
    `<script>` section, the variable `count` is initialized to `1`, and a repeating
    interval is set up to occur every second to post the string `'Message '` (using
    the `postMessage` method) along with the current value of `count`, which is then
    incremented. The `postMessage` call is attached to the `contentWindow` property
    of the `iframe` object, not the `iframe` object itself. This is important because
    web messaging requires posts to be made to a window, not to an object within a
    window.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，通常使用*OSC.js*文件来拉取`O`函数，然后创建一个ID为`frame`的`<iframe>`元素，加载示例 28-7中的内容。然后，在`<script>`部分中，将变量`count`初始化为`1`，并设置每秒重复一次的间隔，以发布字符串`'Message
    '`（使用`postMessage`方法）以及当前值`count`，然后递增。`postMessage`调用附加到`iframe`对象的`contentWindow`属性，而不是`iframe`对象本身。这很重要，因为Web消息要求将帖子发布到窗口，而不是窗口内的对象。
- en: Example 28-7\. Receiving messages from another document
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 28-7\. 从另一个文档接收消息
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This example sets up a little styling to make the output clearer and then creates
    a `<div>` element with the ID `output`, in which the contents of received messages
    will be placed. The `<script>` section contains a single anonymous function attached
    to the `onmessage` event of the window. In this function, the `event.origin`,
    `event.source`, and `event.data` property values are then displayed, as shown
    in [Figure 28-4](#the-iframe-has-so-far).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/pmj6_2804.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: Figure 28-4\. iframe has so far received 29 messages
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Web messaging works only across domains, so you cannot test it by loading files
    in from a filesystem; you must use a web server (such as the AMPPS stack suggested
    in [Chapter 2](ch02.xhtml#setting_up_a_development_server)). As you can see from
    [Figure 28-4](#the-iframe-has-so-far), the origin is *http://localhost* because
    these examples are running on a local development server. The source is the `window`
    object, and the current message value is `Message 29`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: To run this for yourself, just load *06.html* into your browser using `localhost://`
    and not from a filesystem, and it will talk with *07.html* without you having
    to load it, because it is inserted into an iframe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, [Example 28-6](#sending_web_messages_to_an_iframe) is not at
    all secure because the domain value passed to `postMessage` is the wildcard `*`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To direct messages only to documents originating from a particular domain,
    you can change this parameter. In the current case, a value of `http://localhost`
    would ensure that only documents loaded from the local server will be sent any
    messages:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Likewise, as it stands, the listener program displays any and all messages
    it receives. This is also not a very secure state of affairs, because malicious
    documents also present in the browser can attempt to send messages that unwary
    listener code in other documents might otherwise access. Therefore, you can restrict
    the messages your listeners react to by using an `if` statement, like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Warning
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you always use the proper domain for the site you are working with, your
    web messaging communications will be more secure. However, be aware that since
    messages are sent in the clear, there may be insecurities in some browsers or
    browser plug-ins that might make this kind of communication insecure. One way
    to boost your security, then, is to use an encryption scheme for all your web
    messages and also consider introducing two-way communication protocols to verify
    each message as being authentic.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Normally, you won’t alert the user to the `origin` or `source` values and will
    simply make use of them for security checking. These examples, however, display
    those values to help you experiment with web messaging and see what is going on.
    Instead of using iframes, documents in pop-up windows and other tabs may also
    talk to each other using this method.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Other HTML5 Tags
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A number of other new HTML5 tags are being adopted by the major browsers, including
    `<article>`, `<aside>`, `<details>`, `<figcaption>`, `<figure>`, `<footer>`, `<header>`,
    `<hgroup>`, `<mark>`, `<menuitem>`, `<meter>`, `<nav>`, `<output>`, `<progress>`,
    `<rp>`, `<rt>`, `<ruby>`, `<section>`, `<summary>`, `<time>`, and `<wbr>`. You
    can get more information on these and all other HTML5 tags from [eastmanreference.com](https://tinyurl.com/htmltaglist).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: This concludes your introduction to HTML5\. You now have a number of powerful
    new features with which to make even more dynamic and compelling websites. In
    the final chapter, I’ll show you how you can bring all the different technologies
    in this book together to create a mini–social networking site.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What method do you call to request geolocation data from a web browser?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you determine whether a browser supports local storage?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What method can you call to erase all local storage data for the current domain?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way for web workers to communicate with a main program?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you stop a web worker from running?
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To support drag-and-drop operations, how can you prevent the default action
    of disallowing dragging and dropping for these events?
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you make cross-document messaging more secure?
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See [“Chapter 28 Answers”](app01_split_027.xhtml#chapter_28_answers) in the
    [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions) for the
    answers to these questions.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
