- en: Chapter 2\. Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While [Chapter 1](ch01.html#chapter_variables) introduced the foundational building
    blocks of PHP—variables to store arbitrary values—these building blocks are useless
    without some kind of glue to hold them together. This glue is the set of [*operators*](https://oreil.ly/Vepfg)
    established by PHP. Operators are the way you tell PHP what to do with certain
    values—specifically how to change one or more values into a new, discrete value.
  prefs: []
  type: TYPE_NORMAL
- en: In almost every case, an operator in PHP is represented by a single character
    or by repeated uses of that same character. In a handful of cases, operators can
    also be represented by literal English words, which helps disambiguate what the
    operator is trying to accomplish.
  prefs: []
  type: TYPE_NORMAL
- en: This book does not attempt to cover every operator leveraged by PHP; for exhaustive
    explanations of each, refer to the [PHP Manual itself](https://oreil.ly/YGWyE).
    Instead, the following few sections cover some of the most important logical,
    bitwise, and comparison operators before diving into more concrete problems, solutions,
    and examples.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Logical operations* are the components of PHP that create truth tables and
    define basic and/or/not grouping criteria. [Table 2-1](#table_logical_operators)
    enumerates all of the character-based logical operators supported by PHP.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Logical operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Operator name | Result | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| $x && $y | and | `true` if both `$x` and `$y` are `true` | `true && true
    == true` |'
  prefs: []
  type: TYPE_TB
- en: '| $x &#124;&#124; $y | or | `true` if either `$x` or `$y` is `true` | `true
    &#124;&#124; false == true` |'
  prefs: []
  type: TYPE_TB
- en: '| !$x | not | `true` if `$x` is `false` (and vice versa) | `!true == false`
    |'
  prefs: []
  type: TYPE_TB
- en: 'The logical operators `&&` and `||` have English word counterparts: `and` and
    `or`, respectively. The statement `($x and $y)` is functionally equivalent to
    `($x && $y)`. The word `or` can likewise be used in place of the `||` operator
    without changing the functionality of the expression.'
  prefs: []
  type: TYPE_NORMAL
- en: The word `xor` can also be used to represent a special *exclusive or* operator
    in PHP that evaluates to `true` if one of the two values in the expression is
    `true`, but not when both are `true`. Unfortunately, the logical XOR operation
    has no character equivalent in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP supports operations against specific bits in an integer, a feature that
    makes the language quite versatile. Supporting bitwise operations means PHP is
    not limited to web applications but can operate on binary files and data structures
    with ease! It’s worth mentioning these operators in the same section as the preceding
    logical operators as they appear somewhat similar in terms of terminology with
    `and`, `or`, and `xor`.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas logical operators return `true` or `false` based on the comparison between
    two whole values, bitwise operators actually perform bitwise arithmetic on integers
    and return the result of that full calculation over the integer or integers provided.
    For a specific example of how this can be useful, skip ahead to [Recipe 2.6](#bitwise_arithmetic).
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-2](#table_bitwise_operators) illustrates the various bitwise operators
    in PHP, what they do, and a quick example of how they work on simple integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. Bitwise operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Operator name | Result | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$x & $y` | and | Returns bits set in both `$x` and `$y` | `5 & 1 == 1` |'
  prefs: []
  type: TYPE_TB
- en: '| `$x &#124; $y` | or | Returns bits set in either `$x` or `$y` | `4 &#124;
    1 == 5` |'
  prefs: []
  type: TYPE_TB
- en: '| `$x ^ $y` | xor | Returns bits set in only `$x` or `$y` | `5 ^ 3 == 6` |'
  prefs: []
  type: TYPE_TB
- en: '| `~ $x` | not | Inverts bits that are set in `$x` | `~ 4 == -5` |'
  prefs: []
  type: TYPE_TB
- en: '| `$x << $y` | shift left | Shift the bits of `$x` to the left by `$y` steps
    | `4 << 2 == 16` |'
  prefs: []
  type: TYPE_TB
- en: '| `$x >> $y` | shift right | Shift the bits of `$x` to the right by `$y` steps
    | `4 >> 2 == 1` |'
  prefs: []
  type: TYPE_TB
- en: In PHP, the largest integer you can have depends on the size of the processor
    running the application. In any case, the constant `PHP_INT_MAX` will tell you
    how large integers can be—2147483647 on 32-bit machines and 9223372036854775807
    on 64-bit machines. In both cases, this number is represented, in binary, as a
    long string of 1s equal in length to one less than the bit size. On a 32-bit machine,
    2147483647 is represented by 31 1s. The leading bit (a `0` by default) is used
    to identify the *sign* of the integer. If the bit is `0`, the integer is positive;
    if the bit is `1`, the integer is negative.
  prefs: []
  type: TYPE_NORMAL
- en: On any machine, the number 4 is represented in binary as `100`, with enough
    0s to the left of the most significant digit to fill the bit size of the processor.
    On a 32-bit system, this would be 29 0s. To make the integer *negative*, you would
    represent it instead as a 1 followed by 28 0s followed by `100`.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, consider a 16-bit system. The integer 4 would be represented
    as `0000000000000100`. Likewise, a negative 4 would be represented as `100000000​0000100`.
    If you were to apply the bitwise *not* operator (`~`) on a positive 4 in a 16-bit
    system, all of the 0s would become 1s and vice versa. This would turn your number
    into `1111111111111011`, which on a 16-bit system is −5.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core of any programming language is the level of control that language has
    to branch based on specific conditions. In PHP, much of this branching logic is
    controlled by comparing two or more values with one another. It is the set of
    [comparison operators provided by PHP](https://oreil.ly/QuPhV), provide most of
    the advanced branching functionality used to build complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 2-3](#table_comparison_operators) lists the scalar comparison operators
    considered to be the most vital to understand PHP. The other operators (greater
    than, less than, and variants) are somewhat standard among programming languages
    and are not necessary to any of the recipes in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-3\. Comparison operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Operation | Result |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `$x == $y` | Equal | Returns `true` if both values are the same after coercing
    into the same type |'
  prefs: []
  type: TYPE_TB
- en: '| `$x === $y` | Identical | Returns `true` if both values are the same *and*
    are of the same type |'
  prefs: []
  type: TYPE_TB
- en: '| `$x <=> $y` | Spaceship | Returns `0` is both values are equal, `1` if `$x`
    is greater, or `-1` if `$y` is greater |'
  prefs: []
  type: TYPE_TB
- en: When dealing with objects, the equality and identity operators work somewhat
    differently. Two objects are considered equal (`==`) if they have the same internal
    structure (same attributes and values) and are of the same type (class). Objects
    are considered identical (`===`) if and only if they are references to the same
    instance of a class. These are stricter requirements than those for comparing
    scalar values.
  prefs: []
  type: TYPE_NORMAL
- en: Type Casting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the name of a type is not formally an operator, you can use it to explicitly
    cast a value as that type. Simply write the name of the type within parentheses
    before the value to force a conversion. [Example 2-1](#type_juggling) converts
    a simple integer value to various other types prior to using the value.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Casting values as other types
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP supports the following type casts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(int)`'
  prefs: []
  type: TYPE_NORMAL
- en: Cast to `int`
  prefs: []
  type: TYPE_NORMAL
- en: '`(bool)`'
  prefs: []
  type: TYPE_NORMAL
- en: Cast to `bool`
  prefs: []
  type: TYPE_NORMAL
- en: '`(float)`'
  prefs: []
  type: TYPE_NORMAL
- en: Cast to `float`
  prefs: []
  type: TYPE_NORMAL
- en: '`(string)`'
  prefs: []
  type: TYPE_NORMAL
- en: Cast to `string`
  prefs: []
  type: TYPE_NORMAL
- en: '`(array)`'
  prefs: []
  type: TYPE_NORMAL
- en: Cast to `array`
  prefs: []
  type: TYPE_NORMAL
- en: '`(object)`'
  prefs: []
  type: TYPE_NORMAL
- en: Cast to `object`
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible to use `(integer)` as an alias of `(int)`, `(boolean)` as
    an alias of `(bool)`, `(real)` or `(double)` as aliases of `(float)`, and `(binary)`
    as an alias of `(string)`. These aliases will make the same type casts as in the
    preceding list, but given that they don’t use the name of the type to which you’re
    casting, this approach is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter introduce ways to leverage PHP’s most important
    comparison and logical operators.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Using a Ternary Operator Instead of an If-Else Block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to provide an either-or branching condition to assign a specific value
    to a variable in a single line of code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a *ternary operator* (`*a* ? *b* : *c*`) allows nesting an either-or
    condition and both possible branched values in a single statement. The following
    example shows how to define a variable with a value from the `$_GET` superglobal
    and fall back on a default if it is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A ternary expression has three arguments and is evaluated from left to right,
    checking the *truthiness* of the leftmost statement (whether it evaluates to `true`
    regardless of the types involved in the expression) and returning the next value
    if `true` or the final value if `false`. You can visualize this logical flow with
    the following illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The ternary pattern is a simple way to return a default value when checking
    either system values or even parameters from a web request (those stored in the
    `$_GET` or `$_POST` superglobals). It is also a powerful way to switch logic in
    page templates based on the return of a particular function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example assumes a web application that welcomes logged-in users
    by name (checking their authentication state with a call to `is_logged_in()`)
    or welcomes a guest if the user has yet to authenticate. As this example is coded
    directly into the HTML markup of a web page, using a longer `if`/`else` statement
    would be inappropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Ternary operations can also be simplified if the value being checked is both
    *truthy* (evaluates to `true` when coerced into a Boolean value) and is the value
    you want by default. The Solution example checks that a username is set *and*
    assigns that value to a given variable if so. Since non-empty strings evaluate
    to `true`, you can shorten the solution to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When a ternary is shortened from its `*a* ? *b* : *c*` format to a simple `*a*
    ?: *c*`, PHP will evaluate the expression to check `*a*` as if it were a Boolean
    value. If it’s true, PHP merely returns the expression itself. If it’s false,
    PHP returns the fallback value `*c*` instead.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: PHP compares truthiness similarly to the way it compares emptiness, as discussed
    in [Chapter 1](ch01.html#chapter_variables). Strings that are set (not empty or
    `null`), integers that are nonzero, and arrays that are non-empty are all generally
    considered truthy, which is to say they evaluate to `true` when cast as a Boolean.
    You can read more about the ways types are intermixed and considered equivalent
    in [the PHP Manual section on type comparisons](https://oreil.ly/nXsr8).
  prefs: []
  type: TYPE_NORMAL
- en: The ternary operator is an advanced form of comparison operator that, while
    it provides for concise code, can sometimes be overused to create logic that is
    too difficult to follow. Consider [Example 2-2](#nested_ternary), which nests
    one ternary operation within another.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. Nested ternary expression
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This example should be rewritten as a simple `if`/`else` statement instead
    to provide more clarity as to how the code branches. Nothing is *functionally*
    wrong with the code, but nested ternaries can be difficult to read or reason about
    and often lead to logic errors down the road. The preceding ternary could be rewritten
    as shown in [Example 2-3](#multiple_if_else):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. Multiple `if/else` statements
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While [Example 2-3](#multiple_if_else) is more verbose than [Example 2-2](#nested_ternary),
    you can more easily track where the logic needs to branch. The code is also more
    maintainable, as new branching logic can be added where necessary. Adding another
    logical branch to [Example 2-2](#nested_ternary) would further complicate the
    already complex ternary and make the program even harder to maintain in the long
    run.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the [ternary operator](https://oreil.ly/Y5WCn) and its variations.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Coalescing Potentially Null Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to assign a specific value to a variable only if it’s set and not `null`
    and otherwise use a static default value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using a null-coalescing operator (`??`) as follows will use the first value
    only if it is set and not `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP’s null-coalescing operator is a newer feature introduced in PHP 7.0\. It’s
    been referred to as *syntactic sugar* to replace the shorthand version of PHP’s
    ternary operator, `?:`, discussed in [Recipe 2.1](#ternary_operator).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '*Syntactic sugar* is shorthand for performing a common yet verbose operation
    in code. The developers of languages introduce such features to save keystrokes
    and render routine, oft-repeated blocks of code via simpler and more concise syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of the following lines of code are functionally equivalent, but the ternary
    form will trigger a notice if the expression being evaluated is undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While these preceding two examples are *functionally* identical, a notable difference
    in their behavior occurs if the value being evaluated (`$b`) is not defined. With
    the null-coalescing operator, everything is golden. With the ternary shorthand,
    PHP will trigger a notice during execution that the value is undefined before
    returning the fallback value.
  prefs: []
  type: TYPE_NORMAL
- en: 'With discrete variables, the differing functionality of these operators isn’t
    entirely obvious, but when the evaluated component is, perhaps, an indexed array,
    the potential impact becomes more apparent. Assume that, instead of a discrete
    variable, you are trying to extract an element from the superglobal `$_GET` variable
    that holds request parameters. In the following example, both the ternary and
    the null-coalescing operators will return the fallback value, but the ternary
    version will complain about an undefined index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If errors and notices are suppressed during execution,^([1](ch02.html#idm45875191836944))
    there is no functional difference between either operator option. It is, however,
    best practice to avoid writing code that triggers errors or notices, as these
    can accidentally raise alerts in production or potentially fill system logs and
    make it more difficult to find legitimate issues with your code. While the shorthand
    ternary operator is remarkably useful, the null-coalescing operator is purpose-built
    for this kind of operation and should nearly always be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The announcement of the new operator [when it was first added to PHP 7.0](https://oreil.ly/6vmP_).
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Comparing Identical Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to compare two values of the same type to ensure that they’re identical.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use three equals signs to compare values without dynamically casting their
    types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In PHP, the equals sign has three functions. A single equals sign (`=`) is used
    for *assignment*, which is setting the value of a variable. Two equals signs (`==`)
    are used in an expression to determine whether the values on either side are equal.
    [Table 2-4](#table_equality) shows how certain values are considered equal because
    PHP coerces one type into another while evaluating the statement. Finally, three
    equals signs (`===`) are used in an expression to determine whether the values
    on either side are *identical*.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-4\. Value equality in PHP
  prefs: []
  type: TYPE_NORMAL
- en: '| Expression | Result | Explanation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0 == "a"` | `false` | (Only for PHP 8.0 and above) The string `"a"` is cast
    as an integer, which means it’s cast to `0`. |'
  prefs: []
  type: TYPE_TB
- en: '| `"1" == "01"` | `true` | Both sides of the expression are cast to integers,
    and `1 == 1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `100 = "1e2`" | `true` | The right side of the expression is evaluated as
    an exponential representation of `100` and cast as an integer. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first example in [Table 2-4](#table_equality) evaluates as `true` in PHP
    versions below 8.0\. In those earlier versions, comparing the equality of a string
    (or numeric string) to a number would convert the string first to a number (in
    this case, converting `"a"` to `0`). This behavior changed in PHP 8.0 such that
    only numeric strings are cast to numbers, so the result of that first expression
    is now `false`.
  prefs: []
  type: TYPE_NORMAL
- en: PHP’s ability to dynamically convert between types at runtime can be useful,
    but in some cases it is not what you want to have happen at all. The Boolean literal
    `false` is returned by some methods to represent an error or failure, while an
    integer `0` might be a valid return of a function. Consider the function in [Example 2-4](#count_books_of_type)
    that returns a count of books of a specific category, or `false` if a connection
    to the database holding that data fails.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. Count items in a database or return `false`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If everything in [Example 2-4](#count_books_of_type) runs as expected, the code
    will then return an integer count of the number of books in a particular category.
    [Example 2-5](#print_query_results_to_headline) might leverage this function to
    print a headline on a web page.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Using the results of a database-bound function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Internally, PHP’s `switch` statement is using a loose type comparison (our `==`
    operator). If `count_books_of_type()` returns `false` instead of an actual result,
    this `switch` statement will print out that no fiction books were found rather
    than reporting an error. In this particular use case, that might be acceptable
    behavior—but when your application needs to reflect a material difference between
    `false` and `0`, loose equality comparisons are inadequate.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, PHP permits the use of *three* equals signs (`===`) to check whether
    both values under evaluation are identical—that is, they are both the same value
    and the same type. Even though the integer `5` and the string `"5"` have the same
    value, evaluating `5 === "5"` will result in `false` because the two values are
    not the same type. Thus, while `0 == false` evaluates to `true`, `0 === false`
    will always evaluate to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Determining whether two values are identical becomes more complicated when dealing
    with objects, either defined with custom classes or PHP-provided ones. In the
    case of two objects, `$obj1` and `$obj2`, they will only evaluate as identical
    if they are actually the same *instance* of a class. For more on object instantiation
    and classes, see [Chapter 8](ch08.html#chapter_classes).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP documentation on [comparison operators](https://oreil.ly/T6GXm).
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Using the Spaceship Operator to Sort Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to provide a custom ordering function to sort an arbitrary list of
    objects by using [PHP’s native `usort()`](https://oreil.ly/xGbc9).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assuming you want to sort by multiple properties of the list of objects, use
    PHP’s spaceship operator (`<=>`) to define a custom sorting function and supply
    that as the callback to `usort()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following class definition for a person in your application that
    allows creating records with just first and last names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can then create a list of people, perhaps US presidents, using this class
    and adding each person to your list in turn, as in [Example 2-6](#adding_presidents_to_list).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. Adding multiple object instances to a list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The spaceship operator can then be leveraged to identify how to sort this data,
    assuming you want to order by last name first, then by first name, as shown in
    [Example 2-7](#sorting_with_spaceship).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. Sorting presidents with the spaceship operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The result of the preceding call to `usort()` is that the `$presidents` array
    will be properly sorted in place and ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The spaceship operator is a special addition as of PHP 7.0 that helps identify
    the relationship between the values on either side of it:'
  prefs: []
  type: TYPE_NORMAL
- en: If the first value is less than the second, the expression evaluates to `-1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the first value is greater than the second, the expression evaluates to `+1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If both values are the same, the expression evaluates to `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Like PHP’s equality operator, the spaceship operator will attempt to coerce
    the types of each value in the comparison to be the same. It is possible to support
    a number for one value and a string for the other and get a valid result. Use
    type coercion with special operators like this at your own risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest use of the spaceship operator compares simple types with one another,
    making it easy to order a simple array or list of primitive values (like characters,
    integers, floating-point numbers, or dates). This simple case, if using `usort()`,
    would require a sorting function like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The spaceship operator simplifies the nested ternary in the preceding code by
    replacing the `return` statement entirely with `return $a <=> $b`, but without
    modifying the functionality of the sorting function at all.
  prefs: []
  type: TYPE_NORMAL
- en: More complex examples, like that used in the Solution to sort based on multiple
    properties of a custom object definition, would necessitate rather verbose sorting
    function definitions. The spaceship operator simplifies comparison logic, empowering
    developers to specify otherwise complex logic in a single, easy-to-read line.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [original RFC for PHP’s spaceship operator](https://oreil.ly/O1X8R).
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Suppressing Diagnostic Errors with an Operator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to explicitly ignore or suppress errors triggered by a specific expression
    in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prefix the expression with the `@` operator to temporarily set the error reporting
    level to 0 for that line of code. This might help suppress errors related to missing
    files when attempting to open them directly, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Solution example attempts to open the file *file_that_does_not_exist.txt*
    for reading. In normal operations, a call to `fopen()` would return `false` because
    the file does not exist *and* emit a PHP warning for the purposes of diagnosing
    the issue. Prefixing the expression with the `@` operator doesn’t change the return
    value at all, but it suppresses the emitted warning entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `@` operator suppresses error reporting for the line to which it is applied.
    If a developer attempts to suppress errors on an `include` statement, they will
    very easily hide any warnings, notices, or errors caused by the included file
    not existing (or having improper access controls). The suppression will *also*
    apply to all lines of code within the included file, meaning any errors (syntax-related
    or otherwise) in the included code will be ignored. Thus, while `@include('some-file.php')`
    is perfectly valid code, suppressing errors on `include` statements should be
    avoided!
  prefs: []
  type: TYPE_NORMAL
- en: 'This particular operator is useful when suppressing errors or warnings on file
    access operations (as in the Solution example). It’s also useful in suppressing
    notices in array-access operations, as in the following, where a specific `GET`
    parameter might not be set in a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `$filename` variable will be set to the value of the request’s `filename`
    query parameter if it’s set. Otherwise, it will be a literal `null`. If a developer
    were to omit the `@` operator, the value of `$filename` would still be `null`,
    but PHP would emit a notice that the index of `filename` does not exist in the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: As of [PHP 8.0](https://oreil.ly/4Ec5B), this operator will no longer suppress
    *fatal* errors in PHP that otherwise halt script execution.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Official PHP documentation on [error control operators](https://oreil.ly/bZkLY).
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Comparing Bits Within Integers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use simple flags to identify state and behavior in your application,
    where one member might have multiple flags applied.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use a [bitmask](https://oreil.ly/aevr7) to specify which flags are available
    and bitwise operators on the subsequent flags to identify which are set. The following
    example defines four discrete flags by using a binary notation of the integer
    each represents and combines them to indicate *multiple* flags being set at once.
    PHP’s bitwise operators are then used to identify which flag is set and which
    branch of conditional logic should be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A bitmask is structured by configuring each flag to be a constant integer power
    of 2\. This has the benefit of only setting a single bit in the binary representation
    of the number such that composite flags are then identified by which bits are
    set. In the Solution example, each flag is written explicitly as a binary number
    to illustrate which bits are set (`1`) versus unset (`0`), with the integer representation
    of the same number in a comment at the end of the line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our example’s `FLAG_B` is the integer 2, which is represented in binary as
    `0010` (the third bit is set). Likewise, `FLAG_C` is the integer 4 with a binary
    representation of `0100` (the second bit is set). To specify that *both* flags
    are set, you add the two together to set both the second and third bits: `0110`
    or the integer 6.'
  prefs: []
  type: TYPE_NORMAL
- en: For this specific example, addition is an easy model to keep in mind, but it’s
    not exactly what is going on. To combine flags, you merely want to combine the
    bits that are set, not necessarily add them together. Combining `FLAG_A` with
    itself should result in *only* `FLAG_A`; adding the integer representation (1)
    to itself would change the meaning of the flag entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than addition, use the bitwise operations *or* (`|`) and *and* (`&`)
    to both combine bits and filter on assigned flags. Combining two flags together
    requires using the `|` operator to create a new integer with bits that are set
    in *either* of the flags being used. Consider [Table 2-5](#composite_binary_flags_or)
    to create a composite of `FLAG_A | FLAG_C`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-5\. Composite binary flags with bitwise *or*
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Binary representation | Integer representation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `FLAG_A` | `0001` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `FLAG_C` | `0100` | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| `FLAG_A &#124; FLAG_C` | `0101` | `5` |'
  prefs: []
  type: TYPE_TB
- en: Comparing composite flags against your definitions then requires the `&` operator,
    which returns a new number that has bits set on *both* sides of the operation.
    Comparing a flag to itself will always return 1, which is type cast to `true`
    in conditional checks. Comparing two values that have any of the same bits set
    will return a value *greater* than 0, which is type cast to `true`. Consider the
    simple case of evaluating where `FLAG_A & FLAG_C` in [Table 2-6](#composite_binary_flags_and).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-6\. Composite binary flags with bitwise *and*
  prefs: []
  type: TYPE_NORMAL
- en: '| Flag | Binary representation | Integer representation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `FLAG_A` | `0001` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `FLAG_C` | `0100` | `4` |'
  prefs: []
  type: TYPE_TB
- en: '| `FLAG_A & FLAG_C` | `0000` | `0` |'
  prefs: []
  type: TYPE_TB
- en: 'Instead of comparing primitive flags against one another, you can and should
    build composite values and then compare them to your sets of flags. The following
    example visualizes the role-based access controls of a content management system
    for publishing news articles. Users can view articles, create articles, edit articles,
    or delete articles; their level of access is determined by the program itself
    and the permissions granted to their user account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A typical, anonymous visitor will never be logged in and will then be granted
    a default permission of being able to view content. Logged-in users might be able
    to create articles but not edit them without an editor’s permission. Likewise,
    editors can review and modify content (or delete it) but cannot independently
    create articles. Finally, administrators might be allowed to do everything. Each
    of the roles is composited from the preceding permission primitives as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Once composite roles are defined from primitive permissions, the application
    can structure logic around checking the user’s active role. While permissions
    were composited together with the `|` operator, the `&` operator will allow you
    to switch based on these flags, as demonstrated by the functions defined in [Example 2-8](#leveraging_bitmask_flags).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. Leveraging bitmask flags for access control
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Bitmasks are a powerful way to implement simple flags in any language. Take
    caution, though, if the number of flags needed is ever planned to increase, because
    each new flag represents an additional power of 2, meaning the value of all flags
    grows rapidly in size. However, bitmasks are commonly used in both PHP applications
    and by the language itself. PHP’s own error reporting setting, discussed further
    in [Chapter 12](ch12.html#chapter_errors), leverages bitwise values to identify
    the level of error reporting used by the engine itself.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP documentation on [bitwise operators](https://oreil.ly/JmF85).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#idm45875191836944-marker)) Error handling and suppressing errors,
    warnings, and notices are discussed at length in [Chapter 12](ch12.html#chapter_errors).
  prefs: []
  type: TYPE_NORMAL
