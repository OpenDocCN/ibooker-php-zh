<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
      lang="en"
      xmlns="http://www.w3.org/1999/xhtml"
      xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>PHP Cookbook</title>
<link rel="stylesheet" type="text/css" href="override_v1.css"/>
<link rel="stylesheet" type="text/css" href="epub.css"/>
</head>
<body>
<div id="book-content">
<div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 17. Asynchronous PHP"><div class="chapter" id="chapter_asynchronous">
<h1><span class="label">Chapter 17. </span>Asynchronous PHP</h1>


<p>Many basic PHP scripts handle operations synchronously—meaning the script runs one monolithic process from start to finish and only does one thing at a time. However, more sophisticated applications have become commonplace in the world of PHP, so more advanced modes of operation are required as well. Namely, asynchronous programming has quickly become a rising concept for PHP developers. Learning how to do two (or more) things at the same time within your scripts is vital to building modern applications.</p>

<p>Two words come up frequently when discussing asynchronous programming: <em>concurrent</em> and <em>parallel</em>. When most <a data-type="indexterm" data-primary="concurrent programming" id="idm45875136457136"></a><a data-type="indexterm" data-primary="asynchronous programming" id="idm45875136456400"></a>people talk about parallel programming, what they really mean to say is <em>concurrent programming</em>. With concurrency, your application does two things but not necessarily at the same time. Think of a single barista serving multiple customers at once—the barista is multitasking and making several different drinks but can really only make one drink at a time.</p>

<p>With parallel operations, you are doing two different things simultaneously. Imagine installing a drip coffee machine on the counter in the cafe. Some patrons are still being served by the barista, but others can get their caffeine fix from a separate machine in parallel. <a data-type="xref" href="#concurrent_vs_parallel">Figure 17-1</a> depicts concurrent and parallel operations <a data-type="indexterm" data-primary="concurrent programming" data-secondary="versus parallel" id="idm45875136454000"></a><a data-type="indexterm" data-primary="parallel programming, versus concurrent" id="idm45875136453056"></a>through the barista analogy.</p>

<figure><div id="concurrent_vs_parallel" class="figure">
<img src="assets/phpc_1701.png" alt="Concurrent versus parallel modes of operation" width="600" height="324"/>
<h6><span class="label">Figure 17-1. </span>Concurrent versus parallel modes of operation</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There is also a third <a data-type="indexterm" data-primary="concurrent parallel programming" id="idm45875136437024"></a>concept of <em>concurrent parallel</em> operations, which is when two work streams operate at the same time (parallel) but also multitask their individual work streams (concurrent). While this composite concept is useful, this chapter instead focuses on the two separate concepts alone.</p>
</div>

<p>Most PHP you’ll find in the wild, whether modern or legacy, is written to leverage a single thread of execution. The code is written to be neither concurrent nor parallel. In fact, many developers avoid PHP entirely when they want to leverage concurrent or parallel concepts and turn to languages like JavaScript or Go for their applications. Modern PHP, though, fully supports both modes of execution—with or without additional libraries.</p>








<section data-type="sect2" data-pdf-bookmark="Libraries and Runtimes"><div class="sect2" id="idm45875136435104">
<h2>Libraries and Runtimes</h2>

<p>PHP’s native support for parallel <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="libraries" id="idm45875136433600"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="runtimes" id="idm45875136432656"></a><a data-type="indexterm" data-primary="libraries, asynchronous programming" id="idm45875136431744"></a><a data-type="indexterm" data-primary="runtimes" data-secondary="asynchronous programming" id="idm45875136431104"></a>and concurrent operations is relatively new to the language and difficult to use in practice. However, several libraries abstract away the difficulty of working in parallel to make truly asynchronous applications more straightforward to build.</p>










<section data-type="sect3" data-pdf-bookmark="AMPHP"><div class="sect3" id="idm45875136429888">
<h3>AMPHP</h3>

<p>The <a href="https://amphp.org">AMPHP project</a> is <a data-type="indexterm" data-primary="AMPHP project" id="idm45875136427872"></a>a Composer-installable framework that provides event-driven concurrency for PHP. AMPHP provides a rich set of functions and objects empowering you to fully master asynchronous PHP. Specifically, AMPHP provides a full event loop as well as efficient abstractions for promises, coroutines, asynchronous iterators, and streams.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="ReactPHP"><div class="sect3" id="idm45875136426752">
<h3>ReactPHP</h3>

<p>Similar to AMPHP, <a href="https://reactphp.org">ReactPHP</a> is a <a data-type="indexterm" data-primary="ReactPHP library" id="idm45875136424736"></a>Composer-installable library offering event-driven functionality and abstractions to PHP. It provides an event loop but also ships fully functional asynchronous server components like a socket client and a DNS resolver.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Open Swoole"><div class="sect3" id="idm45875136423616">
<h3>Open Swoole</h3>

<p><a href="https://openswoole.com">Open Swoole</a> is a lower-level PHP <a data-type="indexterm" data-primary="Open Swoole" id="idm45875136421760"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Open Swoole" id="idm45875136421024"></a><a data-type="indexterm" data-primary="extensions" data-secondary="Open Swoole" id="idm45875136420064"></a>extension that can be installed via PECL. Like AMPHP and ReactPHP, Open Swoole provides an asynchronous framework and implementations of both promises and coroutines. Because it is a compiled extension (rather than a PHP library), Open Swoole performs significantly better than various alternatives. It also supports true parallelism in your code, rather than merely concurrent execution of tasks.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="RoadRunner"><div class="sect3" id="idm45875136418736">
<h3>RoadRunner</h3>

<p>The <a href="https://roadrunner.dev">RoadRunner project</a> <a data-type="indexterm" data-primary="runtimes" data-secondary="RoadRunner" id="idm45875136416720"></a><a data-type="indexterm" data-primary="RoadRunner" id="idm45875136415712"></a>is an alternative PHP runtime implemented in Go. It provides the same PHP interface you’re used to but ships its own application server and asynchronous process manager. RoadRunner empowers you to keep your entire application in memory and invoke atomic processes in parallel to the application’s execution whenever needed.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Octane"><div class="sect3" id="idm45875136414656">
<h3>Octane</h3>

<p>In 2021, the web application framework Laravel introduced a new project called <a href="https://oreil.ly/bLnkA">Octane</a> that leverages either Open Swoole or Roadrunner to “supercharge your application’s performance.” Whereas framework-level tools like AMPHP or ReactPHP allow you to intentionally write asynchronous code, Octane leverages the asynchronous foundations of Open Swoole or RoadRunner to accelerate the operation of an existing Laravel-based application.<sup><a data-type="noteref" id="idm45875136412672-marker" href="ch17.html#idm45875136412672">1</a></sup></p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Understanding Asynchronous Operations"><div class="sect2" id="idm45875136411856">
<h2>Understanding Asynchronous Operations</h2>

<p>To fully understand asynchronous PHP, you need to understand at least two specific concepts: promises and coroutines.</p>










<section data-type="sect3" data-pdf-bookmark="Promises"><div class="sect3" id="idm45875136410368">
<h3>Promises</h3>

<p>In software, a <em>promise</em> is an object <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="promises" id="sychgrms"></a><a data-type="indexterm" data-primary="promises" id="prmsses"></a>returned by a function that operates asynchronously. Rather than representing a discrete value, though, the promise represents the overall state of the operation. When first returned by the function, the promise will have no inherent value, as the operation itself is not yet complete. Instead, it will be in a <em>pending</em> state indicating that <a data-type="indexterm" data-primary="promises" data-secondary="pending" id="idm45875136405616"></a>the program should do something else while an asynchronous operation completes in the background.</p>

<p>When the operation <em>does</em> complete, the promise will be either fulfilled or rejected. The fulfilled state exists when things went well and a discrete value is returned; the rejected state exists when something failed and an error is returned instead.</p>

<p>The AMPHP project implements promises by <a data-type="indexterm" data-primary="AMPHP project" data-secondary="promises, implementing" id="idm45875136403056"></a><a data-type="indexterm" data-primary="promises, AMPHP project" id="idm45875136402080"></a>using generators and bundles both the fulfilled and rejected state into an <code>onResolve()</code> method <a data-type="indexterm" data-primary="onResolve() method" id="idm45875136400896"></a>on the promise object. For example:</p>

<pre data-type="programlisting" data-code-language="php"><code class="k">function</code> <code class="nf">doSomethingAsync</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code>
<code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">}</code>

<code class="nx">doSomethingAsync</code><code class="p">()</code><code class="o">-&gt;</code><code class="na">onResolve</code><code class="p">(</code><code class="k">function</code> <code class="p">(</code><code class="nx">Throwable</code> <code class="nv">$error</code> <code class="o">=</code> <code class="k">null</code><code class="p">,</code> <code class="nv">$value</code> <code class="o">=</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nv">$error</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>
<code class="p">});</code></pre>

<p>Alternatively, the ReactPHP project implements the same <a href="https://oreil.ly/ZRwcW">promise specification as JavaScript</a>, enabling you to use the <code>then()</code> construct that might be familiar to Node.js programmers. For example:</p>

<pre data-type="programlisting" data-code-language="php"><code class="k">function</code> <code class="nf">doSomethingAsync</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code>
<code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">}</code>

<code class="nx">doSomethingAsync</code><code class="p">()</code><code class="o">-&gt;</code><code class="na">then</code><code class="p">(</code><code class="k">function</code> <code class="p">(</code><code class="nv">$value</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">},</code> <code class="k">function</code> <code class="p">(</code><code class="nv">$error</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// ...</code>
<code class="p">});</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While the APIs presented for promises by both AMPHP and ReactPHP are somewhat unique, they are fairly interoperable. AMPHP explicitly does not conform to JavaScript-style promise abstractions in order to fully leverage PHP generators. However, it does accept instances of ReactPHP’s <code>PromiseInterface</code> wherever it works with its own <code>Promise</code> instance.</p>
</div>

<p>Both APIs are incredibly powerful, and both projects expose efficient asynchronous abstractions for PHP. However, for simplicity, this book focuses on the AMPHP implementations of asynchronous <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="promises" data-startref="sychgrms" id="idm45875136293504"></a><a data-type="indexterm" data-primary="promises" data-startref="prmsses" id="idm45875136339744"></a>code as they’re more native to core PHP 
<span class="keep-together">functionality</span>.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Coroutines"><div class="sect3" id="idm45875136337888">
<h3>Coroutines</h3>

<p>A <em>coroutine</em> is a function <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="coroutines" id="idm45875136335840"></a><a data-type="indexterm" data-primary="coroutines" id="idm45875136334864"></a><a data-type="indexterm" data-primary="AMPHP project" data-secondary="coroutines" id="idm45875136334192"></a>that can be interrupted to allow another operation to proceed. In PHP, particularly with the AMPHP framework, coroutines are implemented with generators leveraging the <code>yield</code> keyword to suspend operation.<sup><a data-type="noteref" id="idm45875136332736-marker" href="ch17.html#idm45875136332736">2</a></sup></p>

<p>While a traditional generator uses the <code>yield</code> keyword to return a value as part of an iterator, AMPHP uses the same keyword as a functional interrupt in a coroutine. The value is still returned, but execution of the coroutine itself is interrupted to allow other operations (like other coroutines) to proceed. When a promise is returned in a coroutine, the coroutine keeps track of the promise’s state and automatically resumes execution when it’s resolved.</p>

<p>As an example, you can leverage asynchronous server requests via coroutines directly in AMPHP. The following code illustrates how coroutines are used both to retrieve a page and decode the body of its response, yielding a promise object useful elsewhere in your code:</p>

<pre data-type="programlisting" data-code-language="php"><code class="nv">$client</code> <code class="o">=</code> <code class="nx">HttpClientBuilder</code><code class="o">::</code><code class="na">buildDefault</code><code class="p">();</code>

<code class="nv">$promise</code> <code class="o">=</code> <code class="nx">Amp\call</code><code class="p">(</code><code class="k">function</code> <code class="p">()</code> <code class="k">use</code> <code class="p">(</code><code class="nv">$client</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="nv">$response</code> <code class="o">=</code> <code class="k">yield</code> <code class="nv">$client</code><code class="o">-&gt;</code><code class="na">request</code><code class="p">(</code><code class="k">new</code> <code class="nx">Request</code><code class="p">(</code><code class="s2">"https://eamann.com"</code><code class="p">));</code>

        <code class="k">return</code> <code class="nv">$response</code><code class="o">-&gt;</code><code class="na">getBody</code><code class="p">()</code><code class="o">-&gt;</code><code class="na">buffer</code><code class="p">();</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">HttpException</code> <code class="nv">$e</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code>
<code class="p">});</code>

<code class="nv">$promise</code><code class="o">-&gt;</code><code class="na">onResolve</code><code class="p">(</code><code class="k">function</code> <code class="p">(</code><code class="nv">$error</code> <code class="o">=</code> <code class="k">null</code><code class="p">,</code> <code class="nv">$value</code> <code class="o">=</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nv">$error</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// ...</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="nb">var_dump</code><code class="p">(</code><code class="nv">$value</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">});</code></pre>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Fibers"><div class="sect2" id="idm45875136029312">
<h2>Fibers</h2>

<p>The newest concurrency feature<a data-type="indexterm" data-primary="Fibers" id="idm45875136249024"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Fibers" id="idm45875136248320"></a> in PHP, as of version 8.1, is Fiber. Under the hood, a Fiber abstracts a completely separate thread of operation that can be controlled by your application’s primary process. The Fiber doesn’t run in parallel to the main application but presents a separate execution stack with its own variables and state.</p>

<p>Through Fibers, you can essentially run an entirely independent subapplication from within your main one and explicitly control how the concurrent operation of each is handled.</p>

<p>When a Fiber starts, it runs until it either completes execution or calls <code>suspend()</code> to yield control back to and return a value to the parent process (thread). It can then be restarted by the parent with <code>resume()</code>. The official documentation example that follows illustrates this concept succinctly:</p>

<pre data-type="programlisting" data-code-language="php"><code class="nv">$fiber</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Fiber</code><code class="p">(</code><code class="k">function</code> <code class="p">()</code><code class="o">:</code> <code class="nx">void</code> <code class="p">{</code>
    <code class="nv">$value</code> <code class="o">=</code> <code class="nx">Fiber</code><code class="o">::</code><code class="na">suspend</code><code class="p">(</code><code class="s1">'fiber'</code><code class="p">);</code>
    <code class="k">echo</code> <code class="s2">"Value used to resume fiber: "</code><code class="p">,</code> <code class="nv">$value</code><code class="p">,</code> <code class="s2">"</code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code>
<code class="p">});</code>

<code class="nv">$value</code> <code class="o">=</code> <code class="nv">$fiber</code><code class="o">-&gt;</code><code class="na">start</code><code class="p">();</code>

<code class="k">echo</code> <code class="s2">"Value from fiber suspending: "</code><code class="p">,</code> <code class="nv">$value</code><code class="p">,</code> <code class="s2">"</code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code>

<code class="nv">$fiber</code><code class="o">-&gt;</code><code class="na">resume</code><code class="p">(</code><code class="s1">'test'</code><code class="p">);</code></pre>

<p>Fibers aren’t meant to be used directly by developer code but are instead a low-level interface useful to frameworks like AMPHP and ReactPHP. These frameworks can leverage Fibers to fully abstract the execution environments of coroutines, keeping your application state clean and better managing its concurrency.</p>

<p>The recipes that follow cover the ins and outs of working with both concurrent and parallel code in PHP. You’ll see how to manage multiple concurrent requests, how to structure asynchronous coroutines, and even how to leverage PHP’s native Fiber implementation.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="17.1 Fetching Data from Remote APIs Asynchronously"><div class="sect1" id="remote_apis_async">
<h1>17.1 Fetching Data from Remote APIs Asynchronously</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45875136142576">
<h2>Problem</h2>

<p>You want to fetch data from multiple remote <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="fetching from remote servers" id="sypgtmrmv"></a>servers at the same time and act on the result once they have all returned data.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45875136139680">
<h2>Solution</h2>

<p>Use the <code>http-client</code> module from <a data-type="indexterm" data-primary="http-client module, AMPHP project" id="idm45875136137936"></a><a data-type="indexterm" data-primary="AMPHP project" data-secondary="http-client module" id="idm45875136137232"></a>the AMPHP project to make multiple concurrent requests as individual promises and then act once all of the requests have returned. For example:</p>

<pre data-type="programlisting" data-code-language="php"><code class="k">use</code> <code class="nx">Amp\Http\Client\HttpClientBuilder</code><code class="p">;</code>
<code class="k">use</code> <code class="nx">Amp\Http\Client\Request</code><code class="p">;</code>

<code class="k">use</code> <code class="k">function</code> <code class="nf">Amp\Promise\all</code><code class="p">;</code>
<code class="k">use</code> <code class="k">function</code> <code class="nf">Amp\Promise\wait</code><code class="p">;</code>

<code class="nv">$client</code> <code class="o">=</code> <code class="nx">HttpClientBuilder</code><code class="o">::</code><code class="na">buildDefault</code><code class="p">();</code>
<code class="nv">$promises</code> <code class="o">=</code> <code class="p">[];</code>

<code class="nv">$apiUrls</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'\https://github.com'</code><code class="p">,</code> <code class="s1">'\https://gitlab.com'</code><code class="p">,</code> <code class="s1">'\https://bitbucket.org'</code><code class="p">];</code>

<code class="k">foreach</code><code class="p">(</code><code class="nv">$apiUrls</code> <code class="k">as</code> <code class="nv">$url</code><code class="p">)</code> <code class="p">{</code>
    <code class="nv">$promises</code><code class="p">[</code><code class="nv">$url</code><code class="p">]</code> <code class="o">=</code> <code class="nx">Amp\call</code><code class="p">(</code><code class="k">static</code> <code class="k">function</code><code class="p">()</code> <code class="k">use</code> <code class="p">(</code><code class="nv">$client</code><code class="p">,</code> <code class="nv">$url</code><code class="p">)</code> <code class="p">{</code>
        <code class="nv">$request</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Request</code><code class="p">(</code><code class="nv">$url</code><code class="p">);</code>

        <code class="nv">$response</code> <code class="o">=</code> <code class="k">yield</code> <code class="nv">$client</code><code class="o">-&gt;</code><code class="na">request</code><code class="p">(</code><code class="nv">$request</code><code class="p">);</code>

        <code class="nv">$body</code> <code class="o">=</code> <code class="k">yield</code> <code class="nv">$response</code><code class="o">-&gt;</code><code class="na">getBody</code><code class="p">()</code><code class="o">-&gt;</code><code class="na">buffer</code><code class="p">();</code>

        <code class="k">return</code> <code class="nv">$body</code><code class="p">;</code>
    <code class="p">});</code>
<code class="p">}</code>

<code class="nv">$responses</code> <code class="o">=</code> <code class="nx">wait</code><code class="p">(</code><code class="nx">all</code><code class="p">(</code><code class="nv">$promises</code><code class="p">));</code></pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45875135976416">
<h2>Discussion</h2>

<p>In a typical synchronous PHP application, your HTTP client would make one request at a time and wait for the server’s response before continuing. This sequential pattern is fast enough for most implementations but becomes burdensome when managing a large number of requests at once.</p>

<p>The <code>http-client</code> module of the AMPHP framework supports making requests concurrently.<sup><a data-type="noteref" id="idm45875135961808-marker" href="ch17.html#idm45875135961808">3</a></sup> All requests are dispatched in a nonblocking fashion by using promises to wrap the state of the request and the eventual result. The magic behind this approach isn’t just the concurrent nature of AMPHP’s client; it’s in the <code>Amp\call()</code> wrapper used to bundle all of the requests together.</p>

<p>By wrapping an <a data-type="indexterm" data-primary="Amp\call() wrapper" id="idm45875135958912"></a>anonymous function with <code>Amp\call()</code>, you turn it into a coroutine.<sup><a data-type="noteref" id="idm45875135957664-marker" href="ch17.html#idm45875135957664">4</a></sup> Within the body of the coroutine, the <code>yield</code> keyword instructs the coroutine to wait for the response of an asynchronous function; the overall result of the coroutine is returned as a <code>Promise</code> instance rather than a scalar value. In the Solution example, your coroutine is creating a new <code>Promise</code> instance for each API request and storing them together in a single array.</p>

<p>The AMPHP framework then exposes two useful functions that allow you to wait until all of your promises have been resolved:</p>
<dl>
<dt><code>all()</code></dt>
<dd>
<p>This function takes an <a data-type="indexterm" data-primary="AMPHP project" data-secondary="all() function" id="idm45875135952896"></a><a data-type="indexterm" data-primary="all() function" id="idm45875135951888"></a><a data-type="indexterm" data-primary="functions" data-secondary="all()" id="idm45875135951216"></a>array of promises and returns a single promise that will resolve once all of the promises in the array have been resolved. The value wrapped by this new promise will be an array of its wrapped promises’ values.</p>
</dd>
<dt><code>wait()</code></dt>
<dd>
<p>This function is exactly <a data-type="indexterm" data-primary="AMPHP project" data-secondary="wait() function" id="idm45875135948736"></a><a data-type="indexterm" data-primary="wait() function" id="idm45875135947760"></a><a data-type="indexterm" data-primary="functions" data-secondary="wait()" id="idm45875135947088"></a>what it sounds like: a way to force your application to wait for an otherwise asynchronous process to complete. It effectively converts the asynchronous code into synchronous code and unwraps the value contained by the promise you pass into it.</p>
</dd>
</dl>

<p>The Solution example thus makes several concurrent asynchronous requests to differing APIs and then bundles their responses into an array suitable for use throughout the rest of your otherwise synchronous application.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>While you make requests in a particular order, they might not complete in the same order in which you made them. In the Solution example, these three requests might always complete in the same order in which you dispatched them. If you increase the number of requests, though, the resultant array might have a different order than the one you’d expect. It’s a good idea to keep track of a discrete index (e.g., use an associative array) so you aren’t surprised down the road when API responses have switched <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="fetching from remote servers" data-startref="sypgtmrmv" id="idm45875135944368"></a>their order on you.</p>
</div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45875135942656">
<h2>See Also</h2>

<p>Documentation for the <a href="https://oreil.ly/OUE0n"><code>http-client</code> module from the AMPHP project</a>.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="17.2 Waiting on the Results of Multiple Asynchronous Operations"><div class="sect1" id="awaiting_asynchronous_operations">
<h1>17.2 Waiting on the Results of Multiple Asynchronous Operations</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45875135938576">
<h2>Problem</h2>

<p>You want to juggle multiple parallel operations <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="operations results" id="shgmmpr"></a><a data-type="indexterm" data-primary="parallel-functions module, AMPHP" id="plfcmdphp"></a><a data-type="indexterm" data-primary="AMPHP project" data-secondary="parallel-functions module" id="apjrllfc"></a>and then act on the overall result of all of them.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45875135933408">
<h2>Solution</h2>

<p>Use the <code>parallel-functions</code> module of the AMPHP framework to execute your operations truly in parallel and then act on the final response of your entire collection of operations, as shown in <a data-type="xref" href="#parallel_array_map">Example 17-1</a>.</p>
<div id="parallel_array_map" data-type="example">
<h5><span class="label">Example 17-1. </span>Parallel array map example</h5>

<pre data-type="programlisting" data-code-language="php"><code class="k">use</code><code> </code><code class="nx">Amp\Promise</code><code class="p">;</code><code>
</code><code class="k">use</code><code> </code><code class="k">function</code><code> </code><code class="nf">Amp\ParallelFunctions\parallelMap</code><code class="p">;</code><code>

</code><code class="nv">$values</code><code> </code><code class="o">=</code><code> </code><code class="nx">Promise\wait</code><code class="p">(</code><code class="nx">parallelMap</code><code class="p">([</code><code class="mi">3</code><code class="p">,</code><code> </code><code class="mi">1</code><code class="p">,</code><code> </code><code class="mi">5</code><code class="p">,</code><code> </code><code class="mi">2</code><code class="p">,</code><code> </code><code class="mi">6</code><code class="p">],</code><code> </code><code class="k">function</code><code> </code><code class="p">(</code><code class="nv">$i</code><code class="p">)</code><code> </code><code class="p">{</code><code>
    </code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="s2">Sleeping for </code><code class="si">{</code><code class="nv">$i</code><code class="si">}</code><code class="s2"> seconds.</code><code class="s2">"</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code> </code><a class="co" id="co_asynchronous_php_CO1-1" href="#callout_asynchronous_php_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>

    </code><code class="nx">\sleep</code><code class="p">(</code><code class="nv">$i</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO1-2" href="#callout_asynchronous_php_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>

    </code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="s2">Slept for </code><code class="si">{</code><code class="nv">$i</code><code class="si">}</code><code class="s2"> seconds.</code><code class="s2">"</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code> </code><a class="co" id="co_asynchronous_php_CO1-3" href="#callout_asynchronous_php_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>

    </code><code class="k">return</code><code> </code><code class="nv">$i</code><code> </code><code class="o">**</code><code> </code><code class="mi">2</code><code class="p">;</code><code> </code><a class="co" id="co_asynchronous_php_CO1-4" href="#callout_asynchronous_php_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a><code>
</code><code class="p">}));</code><code>

</code><code class="nb">print_r</code><code class="p">(</code><code class="nv">$values</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO1-5" href="#callout_asynchronous_php_CO1-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asynchronous_php_CO1-1" href="#co_asynchronous_php_CO1-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>This first echo statement is merely used to demonstrate the order in which the parallel mapping operation occurs. You will see statements in your console in the same order as the array originally passed into <code>parallelMap()</code>—specifically, 
<span class="keep-together"><code>[3, 1, 5, 2, 6]</code></span>.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO1-2" href="#co_asynchronous_php_CO1-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>PHP’s core <code>sleep()</code> function is blocking, meaning it will pause execution of your program until the input number of seconds has elapsed. This function call could be replaced by any other blocking operation with a similar effect. The goal in this example is to demonstrate that each operation is truly run in parallel.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO1-3" href="#co_asynchronous_php_CO1-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>After the application finishes waiting for <code>sleep()</code>, it will again print a message to demonstrate the order in which the parallel operations completed. Note that this will be different from the order in which they were originally called! Specifically, numbers will be printed in ascending order because of the amount of time before each call to <code>sleep()</code> finishes.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO1-4" href="#co_asynchronous_php_CO1-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Any return value from your function will ultimately be wrapped by a <code>Promise</code> object until the asynchronous operation completes.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO1-5" href="#co_asynchronous_php_CO1-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Outside of <code>Promise\wait()</code>, all of your collected promises will be resolved, and the final variable will contain a scalar value. In this case, that final variable will be an array of the squared values of the input array—in the same order as the original inputs.</p></dd>
</dl></div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45875135715104">
<h2>Discussion</h2>

<p>The <code>parallel-functions</code> module is actually an abstraction layer atop AMPHP’s <code>par⁠allel</code> module. Both can be installed via Composer, and neither requires any special extensions to run. However, both will give you true parallel operations in PHP.</p>

<p>Without any extensions, <code>parallel</code> will spawn additional PHP processes to handle your asynchronous operations. It handles the creation and collection of child processes for you so you can focus on the actual implementation of your code. On systems using the <a href="https://oreil.ly/kW0n5"><code>parallel</code> extension</a>, the library will instead use lighter-weight threads to house your application.</p>

<p>But in every case, your code will look the same. Whether the system uses processes or threads under the hood is abstracted away by AMPHP. This allows you to write an application that merely leverages <code>Promise</code>-level abstractions and trusts everything will work expected.</p>

<p>In <a data-type="xref" href="#parallel_array_map">Example 17-1</a>, you defined a function that contained some expensive blocking I/O calls. This example specifically used <code>sleep()</code> but could have been a remote API call, some expensive hashing operation, or a long-running database query. In any case, this is the kind of function that will freeze your application until it completes, and sometimes you might need to run it multiple times.</p>

<p>Rather than using synchronous code, where you pass each element of a collection into the function one at a time, you can leverage the AMPHP framework to process multiple calls at once.</p>

<p>The <code>parallelMap()</code> function behaves <a data-type="indexterm" data-primary="parallelMap() function" id="idm45875135706736"></a><a data-type="indexterm" data-primary="functions" data-secondary="parallelMap()" id="idm45875135706000"></a>similarly to PHP’s native <code>array_map()</code> except in parallel (and with the arguments in reverse order).<sup><a data-type="noteref" id="idm45875135704496-marker" href="ch17.html#idm45875135704496">5</a></sup> It applies the specified function to every member of the array but does so in either a separate process or a separate thread of execution. Since the operation itself is asynchronous, <code>parallelMap()</code> returns a <code>Promise</code> to wrap the function’s eventual result.</p>

<p>You’re left with an array of promises <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="operations results" data-startref="shgmmpr" id="idm45875135701216"></a><a data-type="indexterm" data-primary="parallel-functions module, AMPHP" data-startref="plfcmdphp" id="idm45875135699968"></a><a data-type="indexterm" data-primary="AMPHP project" data-secondary="parallel-functions module" data-startref="apjrllfc" id="idm45875135699008"></a>representing the separate, entirely parallel computations happening in the background. To move back into the land of synchronous code, leverage AMPHP’s <code>wait()</code> function as you did in <a data-type="xref" href="#remote_apis_async">Recipe 17.1</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45875135696176">
<h2>See Also</h2>

<p>Documentation on the <a href="https://oreil.ly/6Um1H"><code>parallel</code></a> and <a href="https://oreil.ly/8QfFs"><code>parallel-functions</code></a> modules from the AMPHP framework.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="17.3 Interrupting One Operation to Run Another"><div class="sect1" id="idm45875135692816">
<h1>17.3 Interrupting One Operation to Run Another</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45875135691632">
<h2>Problem</h2>

<p>You want to run two independent <a data-type="indexterm" data-primary="operations, moving between" id="ptvgwn"></a><a data-type="indexterm" data-primary="AMPHP project" data-secondary="coroutines" id="pmpjrt"></a><a data-type="indexterm" data-primary="coroutines" data-secondary="AMPHP project" id="crtmpjt"></a>operations and move back and forth between them on the same thread.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45875135686400">
<h2>Solution</h2>

<p>Use coroutines in the AMPHP framework to explicitly yield execution control between operations, as shown in <a data-type="xref" href="#concurrent_for_loops">Example 17-2</a>.</p>
<div id="concurrent_for_loops" data-type="example">
<h5><span class="label">Example 17-2. </span>Concurrent <code>for</code> loops with coroutines</h5>

<pre data-type="programlisting" data-code-language="php"><code class="k">use</code><code> </code><code class="nx">Amp\Delayed</code><code class="p">;</code><code>
</code><code class="k">use</code><code> </code><code class="nx">Amp\Loop</code><code class="p">;</code><code>
</code><code class="k">use</code><code> </code><code class="k">function</code><code> </code><code class="nf">Amp\asyncCall</code><code class="p">;</code><code>

</code><code class="nx">asyncCall</code><code class="p">(</code><code class="k">function</code><code> </code><code class="p">()</code><code> </code><code class="p">{</code><code>
    </code><code class="k">for</code><code> </code><code class="p">(</code><code class="nv">$i</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code class="p">;</code><code> </code><code class="nv">$i</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">5</code><code class="p">;</code><code> </code><code class="nv">$i</code><code class="o">++</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" id="co_asynchronous_php_CO2-1" href="#callout_asynchronous_php_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
        </code><code class="k">print</code><code> </code><code class="s2">"</code><code class="s2">Loop A - </code><code class="s2">"</code><code> </code><code class="o">.</code><code> </code><code class="nv">$i</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code>
        </code><code class="k">yield</code><code> </code><code class="k">new</code><code> </code><code class="nx">Delayed</code><code class="p">(</code><code class="mi">1000</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO2-2" href="#callout_asynchronous_php_CO2-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
    </code><code class="p">}</code><code>
</code><code class="p">});</code><code>

</code><code class="nx">asyncCall</code><code class="p">(</code><code class="k">function</code><code> </code><code class="p">()</code><code> </code><code class="p">{</code><code>
    </code><code class="k">for</code><code> </code><code class="p">(</code><code class="nv">$i</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code class="p">;</code><code> </code><code class="nv">$i</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">5</code><code class="p">;</code><code> </code><code class="nv">$i</code><code class="o">++</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" id="co_asynchronous_php_CO2-3" href="#callout_asynchronous_php_CO2-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
        </code><code class="k">print</code><code> </code><code class="s2">"</code><code class="s2">Loop B - </code><code class="s2">"</code><code> </code><code class="o">.</code><code> </code><code class="nv">$i</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code>
        </code><code class="k">yield</code><code> </code><code class="k">new</code><code> </code><code class="nx">Delayed</code><code class="p">(</code><code class="mi">400</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO2-4" href="#callout_asynchronous_php_CO2-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a><code>
    </code><code class="p">}</code><code>
</code><code class="p">});</code><code>

</code><code class="nx">Loop</code><code class="o">::</code><code class="na">run</code><code class="p">();</code><code> </code><a class="co" id="co_asynchronous_php_CO2-5" href="#callout_asynchronous_php_CO2-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asynchronous_php_CO2-1" href="#co_asynchronous_php_CO2-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The first loop merely counts from 0 to 4, stepping by 1 each time.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO2-2" href="#co_asynchronous_php_CO2-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>The AMPHP framework’s <code>Delayed()</code> object is a promise that resolves itself after a given number of milliseconds—in this case, one full second.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO2-3" href="#co_asynchronous_php_CO2-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The second loop also counts from 0 to 4 with a step size of 1.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO2-4" href="#co_asynchronous_php_CO2-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The second loop resolves its promise after 0.4 seconds.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO2-5" href="#co_asynchronous_php_CO2-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Both <code>asyncCall()</code> invocations will fire immediately and print a <code>0</code> to the screen. However, the loops will not continue incrementing until the event loop is formally started (so the <code>Delayed</code> promises can actually resolve).</p></dd>
</dl></div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45875135506240">
<h2>Discussion</h2>

<p>The Solution example introduces two key <a data-type="indexterm" data-primary="event loops" id="idm45875135504640"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="event loops" id="idm45875135503936"></a>concepts important to understand when thinking about asynchronous PHP: an event loop and coroutines.</p>

<p>The event loop is at the core of how AMPHP will process concurrent operations. Without an event loop, PHP would have to execute your application or script from top to bottom. An event loop, however, gives the interpreter the ability to loop back on itself and run additional code in a different way. Specifically, the <code>Loop::run()</code> function will continue to execute until either there is nothing left in the event loop to process or the application itself receives a <code>SIGINT</code> signal (e.g., from pressing Ctrl+C on your keyboard).</p>

<p>There are two functions within the AMPHP <a data-type="indexterm" data-primary="call() function" id="idm45875135500768"></a><a data-type="indexterm" data-primary="asyncCall() function" id="idm45875135500064"></a><a data-type="indexterm" data-primary="functions" data-secondary="call()" id="idm45875135499392"></a><a data-type="indexterm" data-primary="functions" data-secondary="asyncCall()" id="idm45875135498448"></a>framework that create coroutines: <code>call()</code> and <code>asyncCall()</code>. Both functions will immediately invoke the callback passed into them; <code>call()</code> will return a <code>Promise</code> instance, whereas <code>asyncCall()</code> will not. Within the callback function, any use of the <code>yield</code> keyword creates a coroutine—a function that can be interrupted and will wait for the resolution of a <code>Promise</code> object before continuing.</p>

<p>In the Solution example, this promise is a <code>Delayed</code> object. This is AMPHP’s way of causing a routine to pause execution similar to <code>sleep()</code> in vanilla PHP. Unlike <code>sleep()</code>, though, a <code>Delayed</code> object is nonblocking. It will in essence “sleep” for a given period of time, then resume execution on the next pass of the event loop. While the routine is being delayed (or “sleeping”), PHP is free to handle other operations.</p>

<p>Running the Solution example in your PHP console will produce the following 
<span class="keep-together">output</span>:</p>

<pre data-type="programlisting" data-code-language="sh">%<code class="w"> </code>php<code class="w"> </code>concurrent.php<code class="w"></code>
Loop<code class="w"> </code>A<code class="w"> </code>-<code class="w"> </code><code class="m">0</code><code class="w"></code>
Loop<code class="w"> </code>B<code class="w"> </code>-<code class="w"> </code><code class="m">0</code><code class="w"></code>
Loop<code class="w"> </code>B<code class="w"> </code>-<code class="w"> </code><code class="m">1</code><code class="w"></code>
Loop<code class="w"> </code>B<code class="w"> </code>-<code class="w"> </code><code class="m">2</code><code class="w"></code>
Loop<code class="w"> </code>A<code class="w"> </code>-<code class="w"> </code><code class="m">1</code><code class="w"></code>
Loop<code class="w"> </code>B<code class="w"> </code>-<code class="w"> </code><code class="m">3</code><code class="w"></code>
Loop<code class="w"> </code>B<code class="w"> </code>-<code class="w"> </code><code class="m">4</code><code class="w"></code>
Loop<code class="w"> </code>A<code class="w"> </code>-<code class="w"> </code><code class="m">2</code><code class="w"></code>
Loop<code class="w"> </code>A<code class="w"> </code>-<code class="w"> </code><code class="m">3</code><code class="w"></code>
Loop<code class="w"> </code>A<code class="w"> </code>-<code class="w"> </code><code class="m">4</code><code class="w"></code></pre>

<p>The preceding output demonstrates that PHP doesn’t need to wait <a data-type="indexterm" data-primary="loops" data-secondary="concurrent execution" id="lpccrxc"></a>for one loop to complete (with its chain of “sleep” or <code>Deferred</code> calls) before running the other. Both loops execute <em>concurrently</em>.</p>

<p>Note also that, if the two loops were executed synchronously, this entire script would take at least 7 seconds to execute (the first loop waits 1 second each time for five loops, and the second loop takes 0.4 seconds each time for five loops). Running these loops concurrently only takes 5 seconds in total. To fully demonstrate this, store <code>microtime(true)</code> in a variable when the process starts and compare to the system time after the loop completes. For example:</p>

<pre data-type="programlisting" data-code-language="php"><code class="k">use</code> <code class="nx">Amp\Delayed</code><code class="p">;</code>
<code class="k">use</code> <code class="nx">Amp\Loop</code><code class="p">;</code>
<code class="k">use</code> <code class="k">function</code> <code class="nf">Amp\asyncCall</code><code class="p">;</code>

<code class="nv">$start</code> <code class="o">=</code> <code class="nb">microtime</code><code class="p">(</code><code class="k">true</code><code class="p">);</code>

<code class="c1">// ...</code>

<code class="nx">Loop</code><code class="o">::</code><code class="na">run</code><code class="p">();</code>

<code class="nv">$time</code> <code class="o">=</code> <code class="nb">microtime</code><code class="p">(</code><code class="k">true</code><code class="p">)</code> <code class="o">-</code> <code class="nv">$start</code><code class="p">;</code>
<code class="k">echo</code> <code class="s2">"Executed in </code><code class="si">{</code><code class="nv">$time</code><code class="si">}</code><code class="s2"> seconds"</code> <code class="o">.</code> <code class="nx">PHP_EOL</code><code class="p">;</code></pre>

<p>Creating an event loop requires some minor overhead, but repeated executions of the Solution example with the preceding changes will reliably produce a result of approximately 5 seconds in total. What’s more, you can also increase the loop counter in the second <code>asyncCall()</code> invocation from 5 to 10. That loop will still only take 4 seconds in total to run. Again, synchronously both loops would take 9 seconds to complete but, thanks to juggling execution context through coroutines, the script will <em>still</em> reliably complete in about 5 seconds. <a data-type="xref" href="#cocurrent_execution">Figure 17-2</a> illustrates the difference between synchronous and concurrent execution visually.</p>

<figure><div id="cocurrent_execution" class="figure">
<img src="assets/phpc_1702.png" alt="Executing two coroutines concurrently" width="600" height="283"/>
<h6><span class="label">Figure 17-2. </span>Executing two coroutines concurrently</h6>
</div></figure>

<p>By processing the two separate loops as coroutines within AMPHP’s event loop, PHP is able to interrupt the execution flow of one to proceed with the execution of the other. By juggling between coroutines, PHP can make maximum use of your CPU and allow your application to finish its work faster than if it ran through your logic synchronously.</p>

<p>The Solution example is a contrived <a data-type="indexterm" data-primary="loops" data-secondary="concurrent execution" data-startref="lpccrxc" id="idm45875135194368"></a>illustration using delays or pauses; however, it extends to any situation where you might be leveraging a nonblocking but otherwise slow process. You can make a network request and leverage a coroutine so the application keeps processing while it waits for the request to complete. You could call out to a database or other persistence layer and house the nonblocking call within a coroutine. In some systems, you could also shell out to other processes (like Sendmail or another system process) and avoid these calls from <a data-type="indexterm" data-primary="operations, moving between" data-startref="ptvgwn" id="idm45875135192992"></a><a data-type="indexterm" data-primary="AMPHP project" data-secondary="coroutines" data-startref="pmpjrt" id="idm45875135192080"></a><a data-type="indexterm" data-primary="coroutines" data-secondary="AMPHP project" data-startref="crtmpjt" id="idm45875135190864"></a>blocking your application’s overall execution.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45875135345648">
<h2>See Also</h2>

<p>Documentation on the AMPHP framework’s <a href="https://oreil.ly/sFVTx"><code>asyncCall()</code> function</a> and on <a href="https://oreil.ly/oC2oW">coroutines in general</a>.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="17.4 Running Code in a Separate Thread"><div class="sect1" id="recipe_separate_thread">
<h1>17.4 Running Code in a Separate Thread</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45875135340848">
<h2>Problem</h2>

<p>You want to run one or more heavy <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="code in separate thread" id="schrgmmdpt"></a><a data-type="indexterm" data-primary="AMPHP project" data-secondary="parallel package" id="phjtrllkg"></a><a data-type="indexterm" data-primary="parallel package, AMPHP project" id="prckgpjt"></a>operations on a separate thread to keep the main application free to report progress.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45875135335792">
<h2>Solution</h2>

<p>Use the AMPHP project’s <code>parallel</code> package to define a <code>Task</code> to be run and <code>Worker</code> instances to run it. Then invoke one or more workers as separate threads or 
<span class="keep-together">processes</span>. <a data-type="xref" href="#recursive_hash_example">Example 17-3</a> reduces an array of values to a single output by using a one-way hash <a data-type="indexterm" data-primary="hashes, recursive" id="hshcrsv"></a><a data-type="indexterm" data-primary="recursive hashes" id="rcrsvhsh"></a>recursively. It does so by wrapping the hash operation in an asynchronous <code>Task</code> meant to be run as part of a worker pool. <a data-type="xref" href="#multi_task_worker_pool">Example 17-4</a> then defines a pool of workers that run multiple <code>Task</code> operations in separate, coroutine-wrapped threads.</p>
<div id="recursive_hash_example" data-type="example">
<h5><span class="label">Example 17-3. </span>Task that uses recursive hashes to reduce an array to a single value</h5>

<pre data-type="programlisting" data-code-language="php"><code class="k">class</code> <code class="nc">Reducer</code> <code class="k">implements</code> <code class="nx">Task</code>
<code class="p">{</code>
    <code class="k">private</code> <code class="nv">$array</code><code class="p">;</code>
    <code class="k">private</code> <code class="nv">$preHash</code><code class="p">;</code>
    <code class="k">private</code> <code class="nv">$count</code><code class="p">;</code>

    <code class="k">public</code> <code class="k">function</code> <code class="fm">__construct</code><code class="p">(</code>
        <code class="k">array</code> <code class="nv">$array</code><code class="p">,</code>
        <code class="nx">string</code> <code class="nv">$preHash</code> <code class="o">=</code> <code class="s1">''</code><code class="p">,</code>
        <code class="nx">int</code> <code class="nv">$count</code> <code class="o">=</code> <code class="mi">1000</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">array</code> <code class="o">=</code> <code class="nv">$array</code><code class="p">;</code>
        <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">preHash</code> <code class="o">=</code> <code class="nv">$preHash</code><code class="p">;</code>
        <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">count</code> <code class="o">=</code> <code class="nv">$count</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="k">public</code> <code class="k">function</code> <code class="nf">run</code><code class="p">(</code><code class="nx">Environment</code> <code class="nv">$environment</code><code class="p">)</code>
    <code class="p">{</code>
        <code class="nv">$reduction</code> <code class="o">=</code> <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">preHash</code><code class="p">;</code>

        <code class="k">foreach</code><code class="p">(</code><code class="nv">$this</code><code class="o">-&gt;</code><code class="na">array</code> <code class="k">as</code> <code class="nv">$item</code><code class="p">)</code> <code class="p">{</code>
            <code class="nv">$reduction</code> <code class="o">=</code> <code class="nb">hash_pbkdf2</code><code class="p">(</code><code class="s1">'sha256'</code><code class="p">,</code> <code class="nv">$item</code><code class="p">,</code> <code class="nv">$reduction</code><code class="p">,</code> <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">count</code><code class="p">);</code>
        <code class="p">}</code>

        <code class="k">return</code> <code class="nv">$reduction</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre></div>
<div id="multi_task_worker_pool" data-type="example">
<h5><span class="label">Example 17-4. </span>A worker pool can run multiple tasks</h5>

<pre data-type="programlisting" data-code-language="php"><code class="k">use</code> <code class="nx">Amp\Loop</code><code class="p">;</code>
<code class="k">use</code> <code class="nx">Amp\Parallel\Worker\DefaultPool</code><code class="p">;</code>

<code class="nv">$results</code> <code class="o">=</code> <code class="p">[];</code>

<code class="nv">$tasks</code> <code class="o">=</code> <code class="p">[</code>
    <code class="k">new</code> <code class="nx">Reducer</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'z'</code><code class="p">),</code> <code class="nb">count</code><code class="o">:</code> <code class="mi">100</code><code class="p">),</code>
    <code class="k">new</code> <code class="nx">Reducer</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'z'</code><code class="p">),</code> <code class="nb">count</code><code class="o">:</code> <code class="mi">1000</code><code class="p">),</code>
    <code class="k">new</code> <code class="nx">Reducer</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'z'</code><code class="p">),</code> <code class="nb">count</code><code class="o">:</code> <code class="mi">10000</code><code class="p">),</code>
    <code class="k">new</code> <code class="nx">Reducer</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'z'</code><code class="p">),</code> <code class="nb">count</code><code class="o">:</code> <code class="mi">100000</code><code class="p">),</code>
    <code class="k">new</code> <code class="nx">Reducer</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="s1">'A'</code><code class="p">,</code> <code class="s1">'Z'</code><code class="p">),</code> <code class="nb">count</code><code class="o">:</code> <code class="mi">100</code><code class="p">),</code>
    <code class="k">new</code> <code class="nx">Reducer</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="s1">'A'</code><code class="p">,</code> <code class="s1">'Z'</code><code class="p">),</code> <code class="nb">count</code><code class="o">:</code> <code class="mi">1000</code><code class="p">),</code>
    <code class="k">new</code> <code class="nx">Reducer</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="s1">'A'</code><code class="p">,</code> <code class="s1">'Z'</code><code class="p">),</code> <code class="nb">count</code><code class="o">:</code> <code class="mi">10000</code><code class="p">),</code>
    <code class="k">new</code> <code class="nx">Reducer</code><code class="p">(</code><code class="nb">range</code><code class="p">(</code><code class="s1">'A'</code><code class="p">,</code> <code class="s1">'Z'</code><code class="p">),</code> <code class="nb">count</code><code class="o">:</code> <code class="mi">100000</code><code class="p">),</code>
<code class="p">];</code>

<code class="nx">Loop</code><code class="o">::</code><code class="na">run</code><code class="p">(</code><code class="k">function</code> <code class="p">()</code> <code class="k">use</code> <code class="p">(</code><code class="o">&amp;</code><code class="nv">$results</code><code class="p">,</code> <code class="nv">$tasks</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">require_once</code> <code class="vm">__DIR__</code> <code class="o">.</code> <code class="s1">'/vendor/autoload.php'</code><code class="p">;</code>
    <code class="k">use</code> <code class="nx">PhpAmqpLib\Connection\AMQPStreamConnection</code><code class="p">;</code>
    <code class="k">use</code> <code class="nx">PhpAmqpLib\Message\AMQPMessage</code><code class="p">;</code>
    <code class="nv">$timer</code> <code class="o">=</code> <code class="nx">Loop</code><code class="o">::</code><code class="na">repeat</code><code class="p">(</code><code class="mi">200</code><code class="p">,</code> <code class="k">function</code> <code class="p">()</code> <code class="p">{</code>
        <code class="nb">printf</code><code class="p">(</code><code class="s1">'.'</code><code class="p">);</code>
    <code class="p">});</code>
    <code class="nx">Loop</code><code class="o">::</code><code class="na">unreference</code><code class="p">(</code><code class="nv">$timer</code><code class="p">);</code>

    <code class="nv">$pool</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">DefaultPool</code><code class="p">;</code>

    <code class="nv">$coroutines</code> <code class="o">=</code> <code class="p">[];</code>

    <code class="k">foreach</code> <code class="p">(</code><code class="nv">$tasks</code> <code class="k">as</code> <code class="nv">$index</code> <code class="o">=&gt;</code> <code class="nv">$task</code><code class="p">)</code> <code class="p">{</code>
        <code class="nv">$coroutines</code><code class="p">[]</code> <code class="o">=</code> <code class="nx">Amp\call</code><code class="p">(</code><code class="k">function</code> <code class="p">()</code> <code class="k">use</code> <code class="p">(</code><code class="nv">$pool</code><code class="p">,</code> <code class="nv">$index</code><code class="p">,</code> <code class="nv">$task</code><code class="p">)</code> <code class="p">{</code>
            <code class="nv">$result</code> <code class="o">=</code> <code class="k">yield</code> <code class="nv">$pool</code><code class="o">-&gt;</code><code class="na">enqueue</code><code class="p">(</code><code class="nv">$task</code><code class="p">);</code>

            <code class="k">return</code> <code class="nv">$result</code><code class="p">;</code>
        <code class="p">});</code>
    <code class="p">}</code>

    <code class="nv">$results</code> <code class="o">=</code> <code class="k">yield</code> <code class="nx">Amp\Promise\all</code><code class="p">(</code><code class="nv">$coroutines</code><code class="p">);</code>

    <code class="k">return</code> <code class="k">yield</code> <code class="nv">$pool</code><code class="o">-&gt;</code><code class="na">shutdown</code><code class="p">();</code>
<code class="p">});</code>

<code class="k">echo</code> <code class="nx">PHP_EOL</code> <code class="o">.</code> <code class="s1">'Hash Results:'</code> <code class="o">.</code> <code class="nx">PHP_EOL</code><code class="p">;</code>
<code class="k">echo</code> <code class="nb">var_export</code><code class="p">(</code><code class="nv">$results</code><code class="p">,</code> <code class="k">true</code><code class="p">)</code> <code class="o">.</code> <code class="nx">PHP_EOL</code><code class="p">;</code></pre></div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45875134784576">
<h2>Discussion</h2>

<p>The advantage of parallel processing is that you are no longer limited to running one operation at a time. Modern computers with multiple cores can literally and logically run more than one independent operation at a time. Thankfully, modern PHP can take advantage of this functionality quite well. It’s efficiently exposed by the <code>parallel</code> module in the AMPHP framework.<sup><a data-type="noteref" id="idm45875134782624-marker" href="ch17.html#idm45875134782624">6</a></sup></p>

<p>The Solution example uses this abstraction to enable the processing of multiple hash values in parallel, allowing the parent application to merely report on progress and the final result. The first component, a <code>Reducer</code> class, takes in an array of strings and produces an iterative hash of those values. Concretely, it performs a certain number of password-based key derivation hashes of each value in the array, passing the result of the derivation into the hash operation for the next item of the array.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Hash operations are intended to quickly convert a known value into a seemingly random one. They’re one-way operations, meaning you can easily go from a seed value to a hash, but it’s impractical to reverse a hash to retrieve its seed value. Some stronger security stances use multiple rounds of a specific hashing algorithm—in many cases, tens of thousands—to <em>explicitly</em> slow down the process and prevent “guess and check” types of attacks from trying to guess a particular seed.</p>
</div>

<p>Since these hashing operations are costly (in terms of time), you don’t want to run them synchronously. Given how long they can take, you don’t even want to run them <em>concurrently</em>. Instead, you want to run them fully in parallel to leverage all available cores on your machine. By embedding the operation into an object that extends <code>Task</code>, they can run at the same time when invoked within a thread pool.</p>

<p>AMPHP’s <code>parallel</code> package exposes a thread pool with a default configuration, and you can easily enqueue as many operations in the pool as you want, so long as they implement <code>Task</code>. The pool will return a promise instance wrapping the task, meaning you can enqueue your tasks within coroutines and await the resolution of all of the promises they represent.</p>

<p>As all operations are asynchronous, the parent application can continue running code while the hashing happens in parallel. The Solution example exploits this advantage by setting up a repeating <code>printf()</code> operation to write a decimal point to the screen every 200 milliseconds. This acts somewhat like a progress bar or a liveness check, providing you with proactive acknowledgment that a parallel process is still running under the surface.</p>

<p>Once all of the parallel hashing jobs are finished, the overall operation prints the hashed results to the screen.</p>

<p>In reality, you could enqueue any kind of parallel job in such a way to do multiple tasks at once. AMPHP exposes <a data-type="indexterm" data-primary="AMPHP project" data-secondary="enqueueCallable() function" id="idm45875135012512"></a><a data-type="indexterm" data-primary="enqueueCallable() function" id="idm45875135011520"></a><a data-type="indexterm" data-primary="functions" data-secondary="enqueueCallable()" id="idm45875135010832"></a>an <code>enqueueCallable()</code> function that empowers you to turn any regular function call into a parallel operation. Let’s say you need to retrieve weather reports from the US National Weather Service (NWS). Instead of enqueuing multiple hashing jobs as with the Solution example, you can just as easily fetch remote weather reports, as demonstrated in <a data-type="xref" href="#weather_reports_async">Example 17-5</a>.</p>
<div id="weather_reports_async" data-type="example">
<h5><span class="label">Example 17-5. </span>Asynchronous retrieval of weather reports</h5>

<pre data-type="programlisting" data-code-language="php"><code class="k">use</code><code> </code><code class="nx">Amp\Parallel\Worker</code><code class="p">;</code><code>
</code><code class="k">use</code><code> </code><code class="nx">Amp\Promise</code><code class="p">;</code><code>

</code><code class="nv">$forecasts</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code>
    </code><code class="s1">'Washington, DC'</code><code> </code><code class="o">=&gt;</code><code> </code><code class="s1">'https://api.weather.gov/gridpoints/LWX/97,71/forecast'</code><code class="p">,</code><code>
    </code><code class="s1">'New York, NY'</code><code>   </code><code class="o">=&gt;</code><code> </code><code class="s1">'https://api.weather.gov/gridpoints/OKX/33,37/forecast'</code><code class="p">,</code><code>
    </code><code class="s1">'Tualatin, OR'</code><code>   </code><code class="o">=&gt;</code><code> </code><code class="s1">'https://api.weather.gov/gridpoints/PQR/108,97/forecast'</code><code class="p">,</code><code>
</code><code class="p">];</code><code>

</code><code class="nv">$promises</code><code> </code><code class="o">=</code><code> </code><code class="p">[];</code><code>
</code><code class="k">foreach</code><code> </code><code class="p">(</code><code class="nv">$forecasts</code><code> </code><code class="k">as</code><code> </code><code class="nv">$city</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nv">$forecast</code><code class="p">)</code><code> </code><code class="p">{</code><code>
    </code><code class="nv">$promises</code><code class="p">[</code><code class="nv">$city</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="nx">Worker\enqueueCallable</code><code class="p">(</code><code class="s1">'file_get_contents'</code><code class="p">,</code><code> </code><code class="nv">$forecast</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO3-1" href="#callout_asynchronous_php_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
</code><code class="p">}</code><code>

</code><code class="nv">$responses</code><code> </code><code class="o">=</code><code> </code><code class="nx">Promise\wait</code><code class="p">(</code><code class="nx">Promise\all</code><code class="p">(</code><code class="nv">$promises</code><code class="p">));</code><code> </code><a class="co" id="co_asynchronous_php_CO3-2" href="#callout_asynchronous_php_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>

</code><code class="k">foreach</code><code class="p">(</code><code class="nv">$responses</code><code> </code><code class="k">as</code><code> </code><code class="nv">$city</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nv">$forecast</code><code class="p">)</code><code> </code><code class="p">{</code><code>
    </code><code class="nv">$forecast</code><code> </code><code class="o">=</code><code> </code><code class="nb">json_decode</code><code class="p">(</code><code class="nv">$forecast</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO3-3" href="#callout_asynchronous_php_CO3-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
    </code><code class="nv">$latest</code><code> </code><code class="o">=</code><code> </code><code class="nv">$forecast</code><code class="o">-&gt;</code><code class="na">properties</code><code class="o">-&gt;</code><code class="na">periods</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code><code>

    </code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="s2">Forecast for </code><code class="si">{</code><code class="nv">$city</code><code class="si">}</code><code class="s2">:</code><code class="s2">"</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code>
    </code><code class="nb">print_r</code><code class="p">(</code><code class="nv">$latest</code><code class="p">);</code><code>
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asynchronous_php_CO3-1" href="#co_asynchronous_php_CO3-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Each URL endpoint can be fetched independently with <code>file_get_contents()</code>. Using AMPHP’s <code>enqueueCallable()</code> function will automatically do this as part of an independent process in parallel to the main application.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO3-2" href="#co_asynchronous_php_CO3-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Each parallel request is wrapped in a <code>Promise</code> object. In order to return to the land of synchronous execution, you must wait until all of these promises are resolved. The <code>all</code> function collects the different promises into a single <code>Promise</code> object. The <code>wait()</code> function will block execution until this promise is resolved; then it unwraps the contained value for use in your synchronous code.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO3-3" href="#co_asynchronous_php_CO3-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>The NWS API returns a JSON object <a data-type="indexterm" data-primary="NWS API" id="idm45875134667216"></a>representing the forecast for a specific weather station. You need to first parse the JSON-encoded string before you can leverage the data in your application.</p></dd>
</dl></div>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The NWS weather API is entirely free to use but does require you to send a unique user agent with your request. By default, PHP will send a simple user agent string of <code>PHP</code> when you use <code>file_get_contents()</code>. To customize this, change the <code>user_agent</code> configuration in your <em>php.ini</em> file to be more unique. Without this change, the API will likely reject your request with a <code>403 Forbidden</code> error. For more on this and other behavior, reference the <a href="https://oreil.ly/4WVI0">general FAQs about the API</a>.</p>
</div>

<p>Whether the AMPHP framework uses separate threads or entirely independent processes under the hood is a matter of how your system is configured initially. Your code remains the same and, absent any extensions supporting multithreaded PHP, will likely use spawned PHP processes by default. In either case, the <code>enqueueCallable()</code> function requires you to use either a native PHP function or a user-defined function that is loadable via Composer. This is because the spawned child process is only aware of system functions, Composer-loaded functions, and any serialized data sent over by the parent process.</p>

<p>This last detail is critical—the data you send from the parent application to the background worker will be serialized. Some user-defined objects might break when PHP attempts to serialize and deserialize them. Even some core objects (like stream contexts) are incompatible with serialization and cannot be passed into a child thread or process.</p>

<p>Take care with what tasks you choose to run in the background to ensure that the data you send is compatible with <a data-type="indexterm" data-primary="asynchronous programming" data-secondary="code in separate thread" data-startref="schrgmmdpt" id="idm45875134616976"></a><a data-type="indexterm" data-primary="AMPHP project" data-secondary="parallel package" data-startref="phjtrllkg" id="idm45875134615712"></a><a data-type="indexterm" data-primary="parallel package, AMPHP project" data-startref="prckgpjt" id="idm45875134614496"></a><a data-type="indexterm" data-primary="hashes, recursive" data-startref="hshcrsv" id="idm45875134613536"></a><a data-type="indexterm" data-primary="recursive hashes" data-startref="rcrsvhsh" id="idm45875134612592"></a>serialization and parallel operations.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45875134611264">
<h2>See Also</h2>

<p>Documentation on the <a href="https://oreil.ly/C41Rb"><code>parallel</code> package</a> from the AMPHP framework.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="17.5 Sending and Receiving Messages Between 
Separate Threads"><div class="sect1" id="idm45875134608656">
<h1>17.5 Sending and Receiving Messages Between 
<span class="keep-together">Separate Threads</span></h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45875134606912">
<h2>Problem</h2>

<p>You want to communicate with <a data-type="indexterm" data-primary="message queues" id="mssgqus"></a><a data-type="indexterm" data-primary="threads, message queues" id="trdmssgq"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="message queues" id="ychgmgq"></a>multiple running threads to synchronize state or manage the tasks those threads are executing.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45875134601888">
<h2>Solution</h2>

<p>Use a message queue or bus between your main application and the separate threads it’s orchestrating to allow for seamless communication. For example, use RabbitMQ as an intermediary between <a data-type="indexterm" data-primary="RabbitMQ" id="rbbmque"></a>your primary application (as illustrated by <a data-type="xref" href="#rabbit_dispatcher">Example 17-7</a>) and independent worker threads, as shown in <a data-type="xref" href="#rabbit_worker">Example 17-6</a>.</p>
<div id="rabbit_worker" data-type="example">
<h5><span class="label">Example 17-6. </span>Background task used to send mail based on a queue</h5>

<pre data-type="programlisting" data-code-language="php"><code class="k">use</code><code> </code><code class="nx">PhpAmqpLib\Connection\AMQPStreamConnection</code><code class="p">;</code><code>

</code><code class="nv">$connection</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">AMQPStreamConnection</code><code class="p">(</code><code class="s1">'127.0.0.1'</code><code class="p">,</code><code> </code><code class="mi">5762</code><code class="p">,</code><code> </code><code class="s1">'guest'</code><code class="p">,</code><code> </code><code class="s1">'guest'</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO4-1" href="#callout_asynchronous_php_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>

</code><code class="nv">$channel</code><code> </code><code class="o">=</code><code> </code><code class="nv">$connection</code><code class="o">-&gt;</code><code class="na">channel</code><code class="p">();</code><code>
</code><code class="nv">$channel</code><code class="o">-&gt;</code><code class="na">queue_declare</code><code class="p">(</code><code class="s1">'default'</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO4-2" href="#callout_asynchronous_php_CO4-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>

</code><code class="k">echo</code><code> </code><code class="s1">'... Waiting for messages. To exit press CTRL+C'</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code>

</code><code class="nv">$callback</code><code> </code><code class="o">=</code><code> </code><code class="k">function</code><code class="p">(</code><code class="nv">$msg</code><code class="p">)</code><code> </code><code class="p">{</code><code>
    </code><code class="nv">$data</code><code> </code><code class="o">=</code><code> </code><code class="nb">json_decode</code><code class="p">(</code><code class="nv">$msg</code><code class="o">-&gt;</code><code class="na">body</code><code class="p">,</code><code> </code><code class="k">true</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO4-3" href="#callout_asynchronous_php_CO4-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
    </code><code class="nv">$to</code><code> </code><code class="o">=</code><code> </code><code class="nv">$data</code><code class="p">[</code><code class="s1">'to'</code><code class="p">];</code><code>
    </code><code class="nv">$from</code><code> </code><code class="o">=</code><code> </code><code class="nv">$data</code><code class="p">[</code><code class="s1">'from'</code><code class="p">]</code><code> </code><code class="o">?</code><code class="o">?</code><code> </code><code class="s1">'worker.local'</code><code class="p">;</code><code>
    </code><code class="nv">$subject</code><code> </code><code class="o">=</code><code> </code><code class="nv">$data</code><code class="p">[</code><code class="s1">'subject'</code><code class="p">];</code><code>
    </code><code class="nv">$message</code><code> </code><code class="o">=</code><code> </code><code class="nb">wordwrap</code><code class="p">(</code><code class="nv">$data</code><code class="p">[</code><code class="s1">'message'</code><code class="p">],</code><code> </code><code class="mi">70</code><code class="p">)</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code>

    </code><code class="nv">$headers</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">From: </code><code class="si">{</code><code class="nv">$from</code><code class="si">}</code><code class="s2"> PHP_EOL X-Mailer: PHP Worker</code><code class="s2">"</code><code class="p">;</code><code>

    </code><code class="nb">print_r</code><code class="p">([</code><code class="nv">$to</code><code class="p">,</code><code> </code><code class="nv">$subject</code><code class="p">,</code><code> </code><code class="nv">$message</code><code class="p">,</code><code> </code><code class="nv">$headers</code><code class="p">])</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code> </code><a class="co" id="co_asynchronous_php_CO4-4" href="#callout_asynchronous_php_CO4-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a><code>

    </code><code class="nb">mail</code><code class="p">(</code><code class="nv">$to</code><code class="p">,</code><code> </code><code class="nv">$subject</code><code class="p">,</code><code> </code><code class="nv">$message</code><code class="p">,</code><code> </code><code class="nv">$headers</code><code class="p">);</code><code>

    </code><code class="nv">$msg</code><code class="o">-&gt;</code><code class="na">ack</code><code class="p">();</code><code> </code><a class="co" id="co_asynchronous_php_CO4-5" href="#callout_asynchronous_php_CO4-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a><code>
</code><code class="p">};</code><code>

</code><code class="nv">$channel</code><code class="o">-&gt;</code><code class="na">basic_consume</code><code class="p">(</code><code class="s1">'default'</code><code class="p">,</code><code> </code><code class="s1">''</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="nv">$callback</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO4-6" href="#callout_asynchronous_php_CO4-6"><img src="assets/6.png" alt="6" width="12" height="12"/></a><code>
</code><code class="k">while</code><code class="p">(</code><code class="nb">count</code><code class="p">(</code><code class="nv">$channel</code><code class="o">-&gt;</code><code class="na">callbacks</code><code class="p">))</code><code> </code><code class="p">{</code><code>
    </code><code class="nv">$channel</code><code class="o">-&gt;</code><code class="na">wait</code><code class="p">();</code><code> </code><a class="co" id="co_asynchronous_php_CO4-7" href="#callout_asynchronous_php_CO4-7"><img src="assets/7.png" alt="7" width="12" height="12"/></a><code>
</code><code class="p">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asynchronous_php_CO4-1" href="#co_asynchronous_php_CO4-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>Open a connection to a locally running RabbitMQ server by using the default port and default credentials. In production, these values will be different and should be loaded from the environment itself.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO4-2" href="#co_asynchronous_php_CO4-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Declaring a queue to the RabbitMQ server merely opens a channel of communication. If the queue already exists, this operation does nothing.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO4-3" href="#co_asynchronous_php_CO4-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Data is wrapped in a message object when it comes into the worker from 
<span class="keep-together">RabbitMQ</span>. The actual data you need is in the body of the message.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO4-4" href="#co_asynchronous_php_CO4-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Printing data within the worker is a helpful way to diagnose what is happening and inspect the data flowing in for any potential errors.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO4-5" href="#co_asynchronous_php_CO4-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Once your worker has completed acting on a message, it needs to acknowledge the message to the RabbitMQ server; otherwise, another worker might pick the message up and retry it later.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO4-6" href="#co_asynchronous_php_CO4-6"><img src="assets/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p>Consuming messages is a synchronous operation. When a message comes in from RabbitMQ, the system will invoke the callback passed to this function with the message itself as the argument.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO4-7" href="#co_asynchronous_php_CO4-7"><img src="assets/7.png" alt="7" width="12" height="12"/></a></dt>
<dd><p>So long as there are callbacks on a message, this loop will run forever, and the <code>wait()</code> method will keep the connection open to RabbitMQ so the worker can consume and act on any messages in the queue.</p></dd>
</dl></div>
<div id="rabbit_dispatcher" data-type="example">
<h5><span class="label">Example 17-7. </span>Main application that sends messages to the queue</h5>

<pre data-type="programlisting" data-code-language="php"><code class="k">use</code><code> </code><code class="nx">PhpAmqpLib\Connection\AMQPStreamConnection</code><code class="p">;</code><code>
</code><code class="k">use</code><code> </code><code class="nx">PhpAmqpLib\Message\AMQPMessage</code><code class="p">;</code><code>

</code><code class="nv">$connection</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">AMQPStreamConnection</code><code class="p">(</code><code class="s1">'127.0.0.1'</code><code class="p">,</code><code> </code><code class="mi">5672</code><code class="p">,</code><code> </code><code class="s1">'guest'</code><code class="p">,</code><code> </code><code class="s1">'guest'</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO5-1" href="#callout_asynchronous_php_CO5-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>

</code><code class="nv">$channel</code><code> </code><code class="o">=</code><code> </code><code class="nv">$connection</code><code class="o">-&gt;</code><code class="na">channel</code><code class="p">();</code><code>
</code><code class="nv">$channel</code><code class="o">-&gt;</code><code class="na">queue_declare</code><code class="p">(</code><code class="s1">'default'</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO5-2" href="#callout_asynchronous_php_CO5-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>

</code><code class="nv">$message</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code>
    </code><code class="s1">'subject'</code><code> </code><code class="o">=&gt;</code><code> </code><code class="s1">'Welcome to the team!'</code><code class="p">,</code><code>
    </code><code class="s1">'from'</code><code>    </code><code class="o">=&gt;</code><code> </code><code class="s1">'admin@mail.local'</code><code class="p">,</code><code>
    </code><code class="s1">'message'</code><code> </code><code class="o">=&gt;</code><code> </code><code class="s2">"</code><code class="s2">Welcome to the team!</code><code class="se">\r</code><code class="se">\n</code><code class="s2">We're excited to have you here!</code><code class="s2">"</code><code>
</code><code class="p">];</code><code>

</code><code class="nv">$teammates</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code>
    </code><code class="s1">'adam@eden.local'</code><code class="p">,</code><code>
    </code><code class="s1">'eve@eden.local'</code><code class="p">,</code><code>
    </code><code class="s1">'cain@eden.local'</code><code class="p">,</code><code>
    </code><code class="s1">'abel@eden.local'</code><code class="p">,</code><code>
</code><code class="p">];</code><code>

</code><code class="k">foreach</code><code class="p">(</code><code class="nv">$teammates</code><code> </code><code class="k">as</code><code> </code><code class="nv">$employee</code><code class="p">)</code><code> </code><code class="p">{</code><code>
    </code><code class="nv">$email</code><code> </code><code class="o">=</code><code> </code><code class="nv">$message</code><code class="p">;</code><code>
    </code><code class="nv">$email</code><code class="p">[</code><code class="s1">'to'</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="nv">$employee</code><code class="p">;</code><code>

    </code><code class="nv">$msg</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">AMQPMessage</code><code class="p">(</code><code class="nb">json_encode</code><code class="p">(</code><code class="nv">$email</code><code class="p">));</code><code> </code><a class="co" id="co_asynchronous_php_CO5-3" href="#callout_asynchronous_php_CO5-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
    </code><code class="nv">$channel</code><code class="o">-&gt;</code><code class="na">basic_publish</code><code class="p">(</code><code class="nv">$msg</code><code class="p">,</code><code> </code><code class="s1">''</code><code class="p">,</code><code> </code><code class="s1">'default'</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO5-4" href="#callout_asynchronous_php_CO5-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a><code>
</code><code class="p">}</code><code>

</code><code class="nv">$channel</code><code class="o">-&gt;</code><code class="na">close</code><code class="p">();</code><code> </code><a class="co" id="co_asynchronous_php_CO5-5" href="#callout_asynchronous_php_CO5-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a><code>
</code><code class="nv">$connection</code><code class="o">-&gt;</code><code class="na">close</code><code class="p">();</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asynchronous_php_CO5-1" href="#co_asynchronous_php_CO5-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>As with the worker, you open a connection to the local RabbitMQ server by using default parameters.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO5-2" href="#co_asynchronous_php_CO5-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Also as with the worker, you declare a queue. If this queue already exists, this method call will not do anything.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO5-3" href="#co_asynchronous_php_CO5-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Before you can send a message, you need to encode it. For the purposes of this example, the payload will be serialized as a JSON string.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO5-4" href="#co_asynchronous_php_CO5-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>For each message, you choose the queue on which to publish and dispatch the message to RabbitMQ.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO5-5" href="#co_asynchronous_php_CO5-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Once you’re done sending your messages, it’s a good idea to explicitly close the channel and connection before doing any other work. In this example, there is no other work to be done (and the process will exit immediately), but explicit resource cleanup is a healthy habit for any developer.</p></dd>
</dl></div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45875134152944">
<h2>Discussion</h2>

<p>The Solution example uses multiple, explicit PHP processes to handle large operations. The script defined in <a data-type="xref" href="#rabbit_worker">Example 17-6</a> could be named <em>worker.php</em> and instantiated multiple times individually. If you do so in two separate consoles, you will spawn two entirely independent PHP processes that connect to RabbitMQ and listen for jobs.</p>

<p>Running <a data-type="xref" href="#rabbit_dispatcher">Example 17-7</a> in a third window will start the main process and dispatch jobs by sending messages to the <code>default</code> queue housed by RabbitMQ. The workers will independently pick these jobs up, process them, and wait for more work down the road.</p>

<p>The full interaction between the parent process (<a data-type="xref" href="#rabbit_dispatcher">Example 17-7</a>) and two fully asynchronous worker processes (<a data-type="xref" href="#rabbit_worker">Example 17-6</a>) using RabbitMQ as a message broker is illustrated by the three independent console windows shown in <a data-type="xref" href="#rabbit_workers_and_dispatcher">Figure 17-3</a>.</p>

<figure><div id="rabbit_workers_and_dispatcher" class="figure">
<img src="assets/phpc_1703.png" alt="Multiple PHP processes communicating via RabbitMQ" width="600" height="402"/>
<h6><span class="label">Figure 17-3. </span>Multiple PHP processes communicating via RabbitMQ</h6>
</div></figure>

<p>The different processes don’t communicate directly. To do that, you’d need to expose an interactive API. Instead, the much simpler means of communication is to leverage an intermediate message broker—in this case, <a href="https://oreil.ly/GtgI0">RabbitMQ</a>.</p>

<p>RabbitMQ is an open source tool that interfaces directly with several different programming languages. It allows for the creation of multiple queues that can then be read by one or more dedicated workers to process the content of the message. In the Solution example, you used workers and PHP’s native <code>mail()</code> function to dispatch email messages. A more complicated worker might update database records, interface with a remote API, or even process computationally expensive operations like the hashing performed in <a data-type="xref" href="#recipe_separate_thread">Recipe 17.4</a>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Since RabbitMQ supports multiple languages, you’re not limited to just PHP in your implementation. If there’s a specific library you want to use in a different language, you could write your workers in that language, import the library, and dispatch work to the worker from your primary PHP application.</p>
</div>

<p>In a production environment, your RabbitMQ server would leverage username/password authentication or possibly even explicitly allowlist the servers that can talk to it. For development, though, you can effectively leverage your local environment, default credentials, and tools like <a href="https://www.docker.com">Docker</a> to run a 
<span class="keep-together">RabbitMQ</span> server on your local machine. To directly expose RabbitMQ by using the default port and default authentication, use the following Docker command:</p>

<pre data-type="programlisting">$ docker run -d -h localhost -p 127.0.0.1:5672:5672 --name rabbit rabbitmq:3</pre>

<p>Once the server is running, you <a data-type="indexterm" data-primary="message queues" data-startref="mssgqus" id="idm45875134090608"></a><a data-type="indexterm" data-primary="threads, message queues" data-startref="trdmssgq" id="idm45875134089632"></a><a data-type="indexterm" data-primary="RabbitMQ" data-startref="rbbmque" id="idm45875134088688"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="message queues" data-startref="ychgmgq" id="idm45875134087744"></a>can register as many queues as necessary to manage the flow of data within your swarm of applications.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45875134106208">
<h2>See Also</h2>

<p>The official <a href="https://oreil.ly/einsN">documentation</a> and <a href="https://oreil.ly/lEqc9">tutorials</a> for configuring and interacting with RabbitMQ.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="17.6 Using a Fiber to Manage the Contents from a Stream"><div class="sect1" id="idm45875134083264">
<h1>17.6 Using a Fiber to Manage the Contents from a Stream</h1>








<section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45875134082080">
<h2>Problem</h2>

<p>You want to use PHP’s newest concurrency <a data-type="indexterm" data-primary="Fibers" data-secondary="stream contents and" id="fbrsmt"></a><a data-type="indexterm" data-primary="streams" data-secondary="Fibers and" id="strmfb"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Fibers" id="ychrgrmmfb"></a>feature to pull data from and operate on a stream in parts rather than buffering all of its contents at once.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45875134076592">
<h2>Solution</h2>

<p>Use a Fiber to wrap the stream and read its contents one piece at a time. <a data-type="xref" href="#solution_fiber">Example 17-8</a> reads the entirety of a web page into a file in 50-byte chunks, tracking the total number of bytes consumed as it reads in the content.</p>
<div id="solution_fiber" data-type="example">
<h5><span class="label">Example 17-8. </span>Reading a remote stream resource through a Fiber one chunk at a time</h5>

<pre data-type="programlisting" data-code-language="php"><code class="nv">$fiber</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">Fiber</code><code class="p">(</code><code class="k">function</code><code class="p">(</code><code class="nv">$stream</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">void</code><code> </code><code class="p">{</code><code>
    </code><code class="k">while</code><code> </code><code class="p">(</code><code class="o">!</code><code class="nb">feof</code><code class="p">(</code><code class="nv">$stream</code><code class="p">))</code><code> </code><code class="p">{</code><code>
        </code><code class="nv">$contents</code><code> </code><code class="o">=</code><code> </code><code class="nb">fread</code><code class="p">(</code><code class="nv">$stream</code><code class="p">,</code><code> </code><code class="mi">50</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO6-1" href="#callout_asynchronous_php_CO6-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
        </code><code class="nx">Fiber</code><code class="o">::</code><code class="na">suspend</code><code class="p">(</code><code class="nv">$contents</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO6-2" href="#callout_asynchronous_php_CO6-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
    </code><code class="p">}</code><code>
</code><code class="p">});</code><code>

</code><code class="nv">$stream</code><code> </code><code class="o">=</code><code> </code><code class="nb">fopen</code><code class="p">(</code><code class="s1">'https://www.eamann.com/'</code><code class="p">,</code><code> </code><code class="s1">'r'</code><code class="p">);</code><code>
</code><code class="nb">stream_set_blocking</code><code class="p">(</code><code class="nv">$stream</code><code class="p">,</code><code> </code><code class="k">false</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO6-3" href="#callout_asynchronous_php_CO6-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>

</code><code class="nv">$output</code><code> </code><code class="o">=</code><code> </code><code class="nb">fopen</code><code class="p">(</code><code class="s1">'cache.html'</code><code class="p">,</code><code> </code><code class="s1">'w'</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO6-4" href="#callout_asynchronous_php_CO6-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a><code>

</code><code class="nv">$contents</code><code> </code><code class="o">=</code><code> </code><code class="nv">$fiber</code><code class="o">-&gt;</code><code class="na">start</code><code class="p">(</code><code class="nv">$stream</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO6-5" href="#callout_asynchronous_php_CO6-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a><code>

</code><code class="nv">$num_bytes</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code class="p">;</code><code>
</code><code class="k">while</code><code> </code><code class="p">(</code><code class="o">!</code><code class="nv">$fiber</code><code class="o">-&gt;</code><code class="na">isTerminated</code><code class="p">())</code><code> </code><code class="p">{</code><code>
        </code><code class="k">echo</code><code> </code><code class="nb">chr</code><code class="p">(</code><code class="mi">27</code><code class="p">)</code><code> </code><code class="o">.</code><code> </code><code class="s2">"</code><code class="s2">[0G</code><code class="s2">"</code><code class="p">;</code><code> </code><a class="co" id="co_asynchronous_php_CO6-6" href="#callout_asynchronous_php_CO6-6"><img src="assets/6.png" alt="6" width="12" height="12"/></a><code>

        </code><code class="nv">$num_bytes</code><code> </code><code class="o">+=</code><code> </code><code class="nb">strlen</code><code class="p">(</code><code class="nv">$contents</code><code class="p">);</code><code>
        </code><code class="nb">fwrite</code><code class="p">(</code><code class="nv">$output</code><code class="p">,</code><code> </code><code class="nv">$contents</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO6-7" href="#callout_asynchronous_php_CO6-7"><img src="assets/7.png" alt="7" width="12" height="12"/></a><code>

        </code><code class="k">echo</code><code> </code><code class="nb">str_pad</code><code class="p">(</code><code class="s2">"</code><code class="s2">Wrote </code><code class="si">{</code><code class="nv">$num_bytes</code><code class="si">}</code><code class="s2"> bytes ...</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="mi">24</code><code class="p">,</code><code> </code><code class="s1">' '</code><code class="p">,</code><code> </code><code class="nx">STR_PAD_RIGHT</code><code class="p">);</code><code>
        </code><code class="nb">usleep</code><code class="p">(</code><code class="mi">500</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO6-8" href="#callout_asynchronous_php_CO6-8"><img src="assets/8.png" alt="8" width="12" height="12"/></a><code>

        </code><code class="nv">$contents</code><code> </code><code class="o">=</code><code> </code><code class="nv">$fiber</code><code class="o">-&gt;</code><code class="na">resume</code><code class="p">();</code><code> </code><a class="co" id="co_asynchronous_php_CO6-9" href="#callout_asynchronous_php_CO6-9"><img src="assets/9.png" alt="9" width="12" height="12"/></a><code>
</code><code class="p">}</code><code>

</code><code class="k">echo</code><code> </code><code class="nb">chr</code><code class="p">(</code><code class="mi">27</code><code class="p">)</code><code> </code><code class="o">.</code><code> </code><code class="s2">"</code><code class="s2">[0G</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="s2">Done writing </code><code class="si">{</code><code class="nv">$num_bytes</code><code class="si">}</code><code class="s2"> bytes to cache.html!</code><code class="s2">"</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code>

</code><code class="nb">fclose</code><code class="p">(</code><code class="nv">$stream</code><code class="p">);</code><code> </code><a class="co" id="co_asynchronous_php_CO6-10" href="#callout_asynchronous_php_CO6-10"><img src="assets/10.png" alt="10" width="12" height="12"/></a><code>
</code><code class="nb">fclose</code><code class="p">(</code><code class="nv">$output</code><code class="p">);</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asynchronous_php_CO6-1" href="#co_asynchronous_php_CO6-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The Fiber itself accepts a streaming resource as its only parameter when it starts. So long as the stream is not at the end, the Fiber will read the next 50 bytes from the current position into the application.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO6-2" href="#co_asynchronous_php_CO6-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Once the Fiber has read from the stream, it will suspend operation and pass control back to the parent application stack. As Fibers can send data back to the parent stack, this Fiber will send the 50 bytes it has read from the stream when it suspends execution.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO6-3" href="#co_asynchronous_php_CO6-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Within the parent application stack, the stream is opened and set to not block execution of the rest of the application. In nonblocking mode, any calls to <code>fread()</code> will return right away rather than waiting for data on the stream.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO6-4" href="#co_asynchronous_php_CO6-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Within the parent application, you can also open other resources, like local files into which you can cache the contents of the remote resource.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO6-5" href="#co_asynchronous_php_CO6-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>When starting the Fiber, you pass the main stream resource as a parameter so it’s available to the call stack of the Fiber itself. Once the Fiber suspends execution, it will also return the 50 bytes it has read back to you.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO6-6" href="#co_asynchronous_php_CO6-6"><img src="assets/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p>To write over the previous line of console output, pass the <code>ESC</code> character (<code>chr(27)</code>) and an ANSI control sequence to move the cursor to the first column in the terminal (<code>[0G]</code>). Any subsequent text printed to the screen will now overwrite anything displayed previously.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO6-7" href="#co_asynchronous_php_CO6-7"><img src="assets/7.png" alt="7" width="12" height="12"/></a></dt>
<dd><p>Once data is available from the remote stream, you can write that data directly to your local cache file.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO6-8" href="#co_asynchronous_php_CO6-8"><img src="assets/8.png" alt="8" width="12" height="12"/></a></dt>
<dd><p>A sleep statement is not necessary to this application but is useful to illustrate how other computations can happen in the parent application stack while the Fiber is suspended.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO6-9" href="#co_asynchronous_php_CO6-9"><img src="assets/9.png" alt="9" width="12" height="12"/></a></dt>
<dd><p>Resuming the Fiber will retrieve the next 50 bytes from the remote stream resource, assuming that any bytes remain. If nothing is left to retrieve, the Fiber will terminate, and your program will exit its <code>while</code> loop.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO6-10" href="#co_asynchronous_php_CO6-10"><img src="assets/10.png" alt="10" width="12" height="12"/></a></dt>
<dd><p>Once execution is complete and the Fiber is cleaned up, be sure to close any streams or other resources you’ve opened.</p></dd>
</dl></div>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45875133861728">
<h2>Discussion</h2>

<p>Fibers are similar to coroutines and generators in that their execution can be interrupted so that the application can perform other logic before returning control. Unlike these other constructs, Fibers have call stacks independent from that of the rest of the application. In this way, they empower you to pause their execution even within nested function calls without changing the return type of the function triggering the pause.</p>

<p>With a generator that uses the <code>yield</code> command to suspend execution, you must return a <code>Generator</code> instance. With a Fiber using the <code>::suspend()</code> method, you can return any type you desire.</p>

<p>Once a fiber is suspended, you can resume its execution from anywhere within the parent application to restart its separate call stack. This allows you to effectively jump between multiple execution contexts without worrying too much about controlling application state.</p>

<p>You can also effectively pass data to and from a Fiber. When a Fiber suspends itself, it can choose to send data back to the parent application—again, of any type you need. When you resume a Fiber, you can pass any value you want or no value at all. You can also choose to throw an exception into the Fiber by using the <code>::throw()</code> method and then handle that exception within the Fiber itself. <a data-type="xref" href="#fiber_exception_handling">Example 17-9</a> demonstrates exactly what it would look like to handle an exception from within the Fiber.</p>
<div id="fiber_exception_handling" data-type="example">
<h5><span class="label">Example 17-9. </span>Handling an exception from within a Fiber</h5>

<pre data-type="programlisting" data-code-language="php"><code class="nv">$fiber</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">Fiber</code><code class="p">(</code><code class="k">function</code><code class="p">()</code><code class="o">:</code><code> </code><code class="nx">void</code><code> </code><code class="p">{</code><code>
    </code><code class="k">try</code><code> </code><code class="p">{</code><code>
        </code><code class="nx">Fiber</code><code class="o">::</code><code class="na">suspend</code><code class="p">();</code><code> </code><a class="co" id="co_asynchronous_php_CO7-1" href="#callout_asynchronous_php_CO7-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a><code>
    </code><code class="p">}</code><code>
    </code><code class="k">catch</code><code> </code><code class="p">(</code><code class="nx">Exception</code><code> </code><code class="nv">$e</code><code class="p">)</code><code> </code><code class="p">{</code><code>
        </code><code class="k">echo</code><code> </code><code class="nv">$e</code><code class="o">-&gt;</code><code class="na">getMessage</code><code class="p">()</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code> </code><a class="co" id="co_asynchronous_php_CO7-2" href="#callout_asynchronous_php_CO7-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a><code>
    </code><code class="p">}</code><code>

    </code><code class="k">echo</code><code> </code><code class="s1">'Finished within Fiber'</code><code> </code><code class="o">.</code><code> </code><code class="nx">PHP_EOL</code><code class="p">;</code><code> </code><a class="co" id="co_asynchronous_php_CO7-3" href="#callout_asynchronous_php_CO7-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a><code>
</code><code class="p">});</code><code>

</code><code class="nv">$fiber</code><code class="o">-&gt;</code><code class="na">start</code><code class="p">();</code><code> </code><a class="co" id="co_asynchronous_php_CO7-4" href="#callout_asynchronous_php_CO7-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a><code>
</code><code class="nv">$fiber</code><code class="o">-&gt;</code><code class="na">throw</code><code class="p">(</code><code class="k">new</code><code> </code><code class="nx">Exception</code><code class="p">(</code><code class="s1">'Error'</code><code class="p">));</code><code> </code><a class="co" id="co_asynchronous_php_CO7-5" href="#callout_asynchronous_php_CO7-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_asynchronous_php_CO7-1" href="#co_asynchronous_php_CO7-1"><img src="assets/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The Fiber will immediately suspend execution once it’s started and return control to the parent application stack.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO7-2" href="#co_asynchronous_php_CO7-2"><img src="assets/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>When the Fiber is resumed, assuming it encounters a catchable <code>Exception</code>, it will extract and print out the error message.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO7-3" href="#co_asynchronous_php_CO7-3"><img src="assets/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>Once the Fiber finishes execution, it will print a useful message before ending its concurrent execution and returning control to the main application.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO7-4" href="#co_asynchronous_php_CO7-4"><img src="assets/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>Starting the Fiber merely creates its call stack and, because the Fiber immediately suspends, execution continues from the perspective of the parent stack.</p></dd>
<dt><a class="co" id="callout_asynchronous_php_CO7-5" href="#co_asynchronous_php_CO7-5"><img src="assets/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Throwing an exception from the parent into the Fiber will trigger the <code>catch</code> condition and print the <code>Error</code> message to the console.</p></dd>
</dl></div>

<p>Fibers are an effective way to juggle execution contexts between call stacks but are still fairly low-level within PHP. While they can be straightforward to use with simple operations like that in the Solution example, more complicated computations can become difficult to manage. Understanding how Fibers work is critical to using them effectively, but just as critical is choosing the proper abstraction to manage your Fibers for you. The <a href="https://oreil.ly/vmkZJ">Async package</a> from ReactPHP provides effective abstractions to asynchronous operations, including Fibers, and makes engineering a complex concurrent <a data-type="indexterm" data-primary="Fibers" data-secondary="stream contents and" data-startref="fbrsmt" id="idm45875133653104"></a><a data-type="indexterm" data-primary="streams" data-secondary="Fibers and" data-startref="strmfb" id="idm45875133651856"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Fibers" data-startref="ychrgrmmfb" id="idm45875133650640"></a>application relatively easy.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45875133649024">
<h2>See Also</h2>

<p>The PHP Manual covering <a href="https://oreil.ly/iU6JH">Fibers</a>.</p>
</div></section>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45875136412672"><sup><a href="ch17.html#idm45875136412672-marker">1</a></sup> The promise behind Octane is that it will improve the performance of most applications without any changes to their code. However, there will likely be some edge cases in production where changes are required, so thoroughly test your code before relying on the project as a drop-in runtime replacement in production.</p><p data-type="footnote" id="idm45875136332736"><sup><a href="ch17.html#idm45875136332736-marker">2</a></sup> Review <a data-type="xref" href="ch07.html#iterating_over_large_arrays">Recipe 7.15</a> for more on generators and the <code>yield</code> keyword.</p><p data-type="footnote" id="idm45875135961808"><sup><a href="ch17.html#idm45875135961808-marker">3</a></sup> As is true with any module and the AMPHP framework itself, you can install the <code>http-client</code> package by using Composer. Review <a data-type="xref" href="ch15.html#installing_composer_packages">Recipe 15.3</a> for more information on Composer packages.</p><p data-type="footnote" id="idm45875135957664"><sup><a href="ch17.html#idm45875135957664-marker">4</a></sup> For more on anonymous functions, or lambdas, review <a data-type="xref" href="ch03.html#anonymous_functions">Recipe 3.9</a>.</p><p data-type="footnote" id="idm45875135704496"><sup><a href="ch17.html#idm45875135704496-marker">5</a></sup> For more on <code>array_map()</code>, review <a data-type="xref" href="ch07.html#apply_function_to_each_element">Recipe 7.13</a>.</p><p data-type="footnote" id="idm45875134782624"><sup><a href="ch17.html#idm45875134782624-marker">6</a></sup> The AMPHP framework also publishes a <code>parallel-functions</code> package that exposes several useful helper functions wrapping the lower-level <code>parallel</code> package. For more on these functions and their usage, review <a data-type="xref" href="#awaiting_asynchronous_operations">Recipe 17.2</a>.</p></div></div></section></div>
</div>
</body>
</html>