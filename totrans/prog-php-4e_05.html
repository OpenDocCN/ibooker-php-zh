<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Strings"><div class="chapter" id="strings">
<h1><span class="label">Chapter 4. </span>Strings</h1>

<p><a contenteditable="false" data-primary="strings" data-type="indexterm" id="ix_strings_ch4"/>Most data you encounter as you program will be sequences of characters, or <em>strings</em>. Strings can hold people’s names, passwords, addresses, credit card numbers, links to photographs, purchase histories, and more. For that reason, PHP has an extensive selection of functions for working with strings.</p>

<p>This chapter shows the many ways to create strings in your programs, including the sometimes tricky subject of <em>interpolation</em> (placing a variable’s value into a string), then covers functions for changing, quoting, manipulating, and searching strings. By the end of this chapter, you’ll be a string-handling expert.</p>

<section data-type="sect1" data-pdf-bookmark="Quoting String Constants"><div class="sect1" id="quoting_string_constants">
<h1>Quoting String Constants</h1>

<p><a contenteditable="false" data-primary="literals" data-secondary="strings" data-type="indexterm" id="ix_literals_strings"/><a contenteditable="false" data-primary="strings" data-secondary="literals" data-type="indexterm" id="ix_strings_literals"/><a contenteditable="false" data-primary="strings" data-secondary="quoting string constants" data-type="indexterm" id="ix_strings_quoting_constants"/>There are four ways to write a string literal in your PHP code: using single quotes, double quotes, the <em>here document</em> (<em>heredoc</em>) format derived from the Unix shell, and its “cousin” <em>now document</em> (<em>nowdoc</em>). These methods differ in whether they recognize special <em>escape sequences</em> that let you encode other characters or interpolate variables.</p>

<section data-type="sect2" data-pdf-bookmark="Variable Interpolation"><div class="sect2" id="variable_interpolation">
<h2>Variable Interpolation</h2>

<p><a contenteditable="false" data-primary="variables" data-secondary="interpolation of" data-type="indexterm" id="idm45922791588104"/><a contenteditable="false" data-primary="interpolation of variables" data-type="indexterm" id="idm45922791586728"/>When you define a string literal using double quotes or a heredoc, the string is subject to <em>variable interpolation</em>. Interpolation is the process of replacing variable names in the string with their contained values. There are two ways to interpolate variables into strings.</p>

<p>The simpler of the two ways is to put the variable name in a double-quoted string or in a <a contenteditable="false" data-primary="here documents (heredocs)" data-type="indexterm" id="idm45922791584296"/>heredoc:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$who</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Kilroy'</code><code class="p">;</code><code>
</code><code class="nv">$where</code><code> </code><code class="o">=</code><code> </code><code class="s1">'here'</code><code class="p">;</code><code>
</code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="si">$who</code><code class="s2"> was </code><code class="si">$where</code><code class="s2">"</code><code class="p">;</code><code>
</code><strong><code class="nx">Kilroy</code><code> </code><code class="nx">was</code><code> </code><code class="nx">here</code></strong></pre>

<p>The other way is to surround the variable being interpolated with <a contenteditable="false" data-primary="{…} (curly braces)" data-secondary="enclosing variables to be interpolated" data-type="indexterm" id="idm45922791541448"/><a contenteditable="false" data-primary="curly braces {…}" data-secondary="enclosing variables to be interpolated" data-type="indexterm" id="idm45922791540200"/>curly braces. Using this syntax ensures the correct variable is interpolated. The classic use of curly braces is to disambiguate the variable name from any surrounding text:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$n</code><code> </code><code class="o">=</code><code> </code><code class="mi">12</code><code class="p">;</code><code>
</code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="s2">You are the </code><code class="si">{</code><code class="nv">$n</code><code class="si">}</code><code class="s2">th person</code><code class="s2">"</code><code class="p">;</code><code>
</code><strong><code class="nx">You</code><code> </code><code class="nx">are</code><code> </code><code class="nx">the</code><code> </code><code class="mi">12</code><code class="nx">th</code><code> </code><code class="nx">person</code></strong></pre>

<p>Without the curly braces, PHP would try to print the value of the <code>$nth</code> variable.</p>

<p>Unlike in some shell environments, in PHP, strings are not repeatedly processed for interpolation. Instead, any interpolations in a double-quoted string are processed first and the result is used as the value of the string:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$bar</code><code> </code><code class="o">=</code><code> </code><code class="s1">'this is not printed'</code><code class="p">;</code><code>
</code><code class="nv">$foo</code><code> </code><code class="o">=</code><code> </code><code class="s1">'$bar'</code><code class="p">;</code><code> </code><code class="c1">// single quotes
</code><code class="k">print</code><code class="p">(</code><code class="s2">"</code><code class="si">$foo</code><code class="s2">"</code><code class="p">);</code><code>
</code><strong><code class="nv">$bar</code></strong></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Single-Quoted Strings"><div class="sect2" id="single_quoted_strings">
<h2>Single-Quoted Strings</h2>

<p><a contenteditable="false" data-primary="‘…’ (single quotes)" data-secondary="enclosing string literals" data-type="indexterm" id="idm45922793244968"/><a contenteditable="false" data-primary="single quotes (‘…’)" data-secondary="enclosing string literals" data-type="indexterm" id="idm45922791701384"/>Single-quoted strings and nowdocs do not interpolate variables. Thus, the variable name in the following string is not expanded because the string literal in which it occurs is single-quoted:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Fred'</code><code class="p">;</code><code>
</code><code class="nv">$str</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Hello, $name'</code><code class="p">;</code><code> </code><code class="c1">// single-quoted
</code><code class="k">echo</code><code> </code><code class="nv">$str</code><code class="p">;</code><code>
</code><strong><code class="nx">Hello</code><code class="p">,</code><code> </code><code class="nv">$name</code></strong></pre>

<p><a contenteditable="false" data-primary="escape sequences for C-strings" data-secondary="for strings" data-type="indexterm" id="idm45922791664984"/><a contenteditable="false" data-primary="special characters" data-secondary="string escape sequences for" data-type="indexterm" id="idm45922791663736"/><a contenteditable="false" data-primary="strings" data-secondary="escape sequences for" data-type="indexterm" id="idm45922791662392"/>The only escape sequences that work in single-quoted strings are <code>\'</code>, which puts a single quote in a single-quoted string, and <code>\\</code>, which puts a backslash in a single-quoted string. Any other occurrence of a backslash is interpreted simply as a <span class="keep-together">backslash:</span></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Tim O\'Reilly'</code><code class="p">;</code><code class="c1">// escaped single quote
</code><code class="k">echo</code><code> </code><code class="nv">$name</code><code class="p">;</code><code>
</code><code class="nv">$path</code><code> </code><code class="o">=</code><code> </code><code class="s1">'C:\\WINDOWS'</code><code class="p">;</code><code> </code><code class="c1">// escaped backslash
</code><code class="k">echo</code><code> </code><code class="nv">$path</code><code class="p">;</code><code>
</code><code class="nv">$nope</code><code> </code><code class="o">=</code><code> </code><code class="s1">'\n'</code><code class="p">;</code><code> </code><code class="c1">// not an escape
</code><code class="k">echo</code><code> </code><code class="nv">$nope</code><code class="p">;</code><code>
</code><strong><code class="nx">Tim</code><code> </code><code class="nx">O</code><code class="err">'</code><code class="nx">Reilly</code></strong><code>
</code><strong><code class="nx">C</code><code class="o">:</code><code class="nx">\WINDOWS</code></strong><code>
</code><strong><code class="nx">\n</code></strong></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Double-Quoted Strings"><div class="sect2" id="double_quoted_strings">
<h2>Double-Quoted Strings</h2>

<p><a contenteditable="false" data-primary="“…” (double quotes)" data-secondary="enclosing string literals" data-type="indexterm" id="idm45922791444232"/><a contenteditable="false" data-primary="double quotes (“…”)" data-secondary="enclosing string literals" data-type="indexterm" id="idm45922791442920"/>Double-quoted strings interpolate variables and expand the many PHP escape sequences. <a data-type="xref" href="#escape_sequences_in_double_quoted_strin">Table 4-1</a> lists the escape sequences recognized by PHP in double-quoted strings.</p>

<table class="border" id="escape_sequences_in_double_quoted_strin">
	<caption><span class="label">Table 4-1. </span>Escape sequences in double-quoted strings</caption>
	<thead>
		<tr>
			<th>Escape sequence</th>
			<th>Character represented</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>\"</code></td>
			<td>Double quotes</td>
		</tr>
		<tr>
			<td><code>\n</code></td>
			<td>Newline</td>
		</tr>
		<tr>
			<td><code>\r</code></td>
			<td>Carriage return</td>
		</tr>
		<tr>
			<td><code>\t</code></td>
			<td>Tab</td>
		</tr>
		<tr>
			<td><code>\\</code></td>
			<td>Backslash</td>
		</tr>
		<tr>
			<td><code>\$</code></td>
			<td>Dollar sign</td>
		</tr>
		<tr>
			<td><code>\{</code></td>
			<td>Left curly brace</td>
		</tr>
		<tr>
			<td><code>\}</code></td>
			<td>Right curly brace</td>
		</tr>
		<tr>
			<td><code>\[</code></td>
			<td>Left square bracket</td>
		</tr>
		<tr>
			<td><code>\]</code></td>
			<td>Right square bracket</td>
		</tr>
		<tr>
			<td><code>\0</code> through <code>\777</code></td>
			<td>ASCII character represented by octal value</td>
		</tr>
		<tr>
			<td><code>\x0</code> through <code>\xFF</code></td>
			<td>ASCII character represented by hex value</td>
		</tr>
		<tr>
			<td><code>\u</code></td>
			<td>UTF-8 encoding</td>
		</tr>
	</tbody>
</table>

<p>If an unknown escape sequence (i.e., a backslash followed by a character that is not one of those in <a data-type="xref" href="#escape_sequences_in_double_quoted_strin">Table 4-1</a>) is found in a double-quoted string literal, it is ignored (if you have the warning level <code>E_NOTICE</code> set, a warning is generated for such unknown escape sequences):</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$str</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">What is </code><code class="s2">\</code><code class="s2">c this?</code><code class="s2">"</code><code class="p">;</code><code class="c1">// unknown escape sequence
</code><code class="k">echo</code><code> </code><code class="nv">$str</code><code class="p">;</code><code>
</code><strong><code class="nx">What</code><code> </code><code class="nx">is</code><code> </code><code class="nx">\c</code><code> </code><code class="k">this</code><code class="o">?</code></strong></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Here Documents"><div class="sect2" id="here_documents">
<h2>Here Documents</h2>

<p><a contenteditable="false" data-primary="here documents (heredocs)" data-type="indexterm" id="ix_heredoc_ch4"/>You can easily put multiline strings into your program with a heredoc, as follows:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$clerihew</code><code> </code><code class="o">=</code><code> </code><code class="o">&lt;&lt;&lt;</code><code> </code><code class="nx">EndOfQuote</code><code>
</code><code class="nx">Sir</code><code> </code><code class="nx">Humphrey</code><code> </code><code class="nx">Davy</code><code>
</code><code class="nx">Abominated</code><code> </code><code class="nx">gravy</code><code class="o">.</code><code>
</code><code class="nx">He</code><code> </code><code class="nx">lived</code><code> </code><code class="nx">in</code><code> </code><code class="nx">the</code><code> </code><code class="nx">odium</code><code>
</code><code class="nx">Of</code><code> </code><code class="nx">having</code><code> </code><code class="nx">discovered</code><code> </code><code class="nx">sodium</code><code class="o">.</code><code>

</code><code class="nx">EndOfQuote</code><code class="p">;</code><code>
</code><code class="k">echo</code><code> </code><code class="nv">$clerihew</code><code class="p">;</code><code>
</code><strong><code class="nx">Sir</code><code> </code><code class="nx">Humphrey</code><code> </code><code class="nx">Davy</code></strong><code>
</code><strong><code class="nx">Abominated</code><code> </code><code class="nx">gravy</code><code class="o">.</code></strong><code>
</code><strong><code class="nx">He</code><code> </code><code class="nx">lived</code><code> </code><code class="nx">in</code><code> </code><code class="nx">the</code><code> </code><code class="nx">odium</code></strong><code>
</code><strong><code class="nx">Of</code><code> </code><code class="nx">having</code><code> </code><code class="nx">discovered</code><code> </code><code class="nx">sodium</code><code class="o">.</code></strong></pre>

<p><a contenteditable="false" data-primary="&lt;&lt;&lt; (left angle brackets, triple), preceding here documents" data-type="indexterm" id="idm45922791278584"/><a contenteditable="false" data-primary="left angle brackets, triple (&lt;&lt;&lt;), preceding here documents" data-type="indexterm" id="idm45922791277608"/>The <code>&lt;&lt;&lt;</code> identifier token tells the PHP parser that you’re writing a heredoc. You get to pick the identifier (<code>EndOfQuote</code> in this case), and you can put it in double quotes if you wish (e.g., <code>"EndOfQuote"</code>). The next line starts the text being quoted by the heredoc, which continues until it reaches a line containing only the identifier. To ensure the quoted text is displayed in the output area exactly as you’ve laid it out, turn on plain-text mode by adding this command at the top of your code file:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">header</code><code class="p">(</code><code class="s1">'Content-Type: text/plain;'</code><code class="p">);</code></pre>

<p>Alternately, if you have control of your server settings, you could set <code>default_mimetype</code> to <code>plain</code> in the <em>php.ini</em> file:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nx">default_mimetype</code> <code class="o">=</code> <code class="s2">"text/plain"</code></pre>

<p>This is not recommended, however, as it puts <em>all</em> output from the server in plain-text mode, which would affect the layout of most of your web code.</p>

<p>If you do not set plain-text mode for your heredoc, the default is typically HTML mode, which simply displays the output all on one line.</p>

<p>When using a heredoc for a simple expression, you can put a semicolon after the terminating identifier to end the statement (as shown in the first example). If you are using a heredoc in a more complex expression, however, you’ll need to continue the expression on the next line, as shown here:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">printf</code><code class="p">(</code><code class="o">&lt;&lt;&lt;</code> <code class="nx">Template</code>
<code class="o">%</code><code class="nx">s</code> <code class="nx">is</code> <code class="o">%</code><code class="nx">d</code> <code class="nx">years</code> <code class="nx">old</code><code class="o">.</code>
<code class="nx">Template</code>
<code class="p">,</code> <code class="s2">"Fred"</code><code class="p">,</code> <code class="mi">35</code><code class="p">);</code></pre>

<p>Single and double quotes in a heredoc are preserved:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$dialogue</code><code> </code><code class="o">=</code><code> </code><code class="o">&lt;&lt;&lt;</code><code> </code><code class="nx">NoMore</code><code>
</code><code class="s2">"</code><code class="s2">It's not going to happen!</code><code class="s2">"</code><code> </code><code class="nx">she</code><code> </code><code class="nx">fumed</code><code class="o">.</code><code>
</code><code class="nx">He</code><code> </code><code class="nx">raised</code><code> </code><code class="nx">an</code><code> </code><code class="nx">eyebrow</code><code class="o">.</code><code> </code><code class="s2">"</code><code class="s2">Want to bet?</code><code class="s2">"</code><code>
</code><code class="nx">NoMore</code><code class="p">;</code><code>
</code><code class="k">echo</code><code> </code><code class="nv">$dialogue</code><code class="p">;</code><code>
</code><strong><code class="s2">"</code><code class="s2">It's not going to happen!</code><code class="s2">"</code><code> </code><code class="nx">she</code><code> </code><code class="nx">fumed</code><code class="o">.</code></strong><code>
</code><strong><code class="nx">He</code><code> </code><code class="nx">raised</code><code> </code><code class="nx">an</code><code> </code><code class="nx">eyebrow</code><code class="o">.</code><code> </code><code class="s2">"</code><code class="s2">Want to bet?</code><code class="s2">"</code></strong></pre>

<p>As is whitespace:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$ws</code> <code class="o">=</code> <code class="o">&lt;&lt;&lt;</code> <code class="nx">Enough</code>
 <code class="nx">boo</code>
 <code class="nx">hoo</code>
<code class="nx">Enough</code><code class="p">;</code>
<code class="c1">// $ws = " boo\n hoo";</code></pre>

<p>New to PHP 7.3 is the indentation of the heredoc terminator. This allows for more legible formatting in the case of embedded code, as in the following function:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">function</code><code> </code><code class="nf">sayIt</code><code class="p">()</code><code> </code><code class="p">{</code><code>
 </code><code class="nv">$ws</code><code> </code><code class="o">=</code><code> </code><code class="o">&lt;&lt;&lt;</code><code> </code><code class="s2">"</code><code class="s2">StufftoSay</code><code class="s2">"</code><code>
 </code><code class="nx">The</code><code> </code><code class="nx">quick</code><code> </code><code class="nx">brown</code><code> </code><code class="nx">fox</code><code>
 </code><code class="nx">Jumps</code><code> </code><code class="nx">over</code><code> </code><code class="nx">the</code><code> </code><code class="nx">lazy</code><code> </code><code class="nx">dog</code><code class="o">.</code><code>
 </code><code class="nx">StufftoSay</code><code class="p">;</code><code>
</code><code class="k">return</code><code> </code><code class="nv">$ws</code><code class="p">;</code><code>
</code><code class="p">}</code><code>

</code><code class="k">echo</code><code> </code><code class="nx">sayIt</code><code class="p">()</code><code> </code><code class="p">;</code><code>

    </code><strong><code class="nx">The</code><code> </code><code class="nx">quick</code><code> </code><code class="nx">brown</code><code> </code><code class="nx">fox</code></strong><code>
</code><strong><code>    </code><code class="nx">Jumps</code><code> </code><code class="nx">over</code><code> </code><code class="nx">the</code><code> </code><code class="nx">lazy</code><code> </code><code class="nx">dog</code><code class="o">.</code></strong></pre>

<p>The newline before the trailing terminator is removed, so these two assignments are identical:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$s</code> <code class="o">=</code> <code class="s1">'Foo'</code><code class="p">;</code>
<code class="c1">// same as</code>
<code class="nv">$s</code> <code class="o">=</code> <code class="o">&lt;&lt;&lt;</code> <code class="nx">EndOfPointlessHeredoc</code>
<code class="nx">Foo</code>
<code class="nx">EndOfPointlessHeredoc</code><code class="p">;</code></pre>

<p>If you want a newline to end your heredoc-quoted string, you’ll need to add one yourself:<a contenteditable="false" data-primary="" data-startref="ix_strings_quoting_constants" data-type="indexterm" id="idm45922790970760"/><a contenteditable="false" data-primary="" data-startref="ix_strings_literals" data-type="indexterm" id="idm45922791000552"/><a contenteditable="false" data-primary="" data-startref="ix_literals_strings" data-type="indexterm" id="idm45922790999208"/><a contenteditable="false" data-primary="" data-startref="ix_heredoc_ch4" data-type="indexterm" id="idm45922790997832"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$s</code> <code class="o">=</code> <code class="o">&lt;&lt;&lt;</code> <code class="nx">End</code>
<code class="nx">Foo</code>

<code class="nx">End</code><code class="p">;</code></pre>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Printing Strings"><div class="sect1" id="printing_strings">
<h1>Printing Strings</h1>

<p><a contenteditable="false" data-primary="web pages" data-secondary="printing strings to" data-type="indexterm" id="ix_webpage_print_string"/><a contenteditable="false" data-primary="strings" data-secondary="printing to web pages" data-type="indexterm" id="ix_strings_print_web"/>There are four ways to send output to the browser. The <code>echo</code> construct lets you print many values at once, while <code>print()</code> prints only one value. The <code>printf()</code> function builds a formatted string by inserting values into a template. The <code>print_r()</code> function is useful for debugging; it prints the contents of arrays, objects, and other things in a more or less human-readable form.</p>

<section data-type="sect2" data-pdf-bookmark="echo"><div class="sect2" id="echo">
<h2>echo</h2>

<p>To put a string into the HTML of a PHP-generated page, use <a contenteditable="false" data-primary="echo construct" data-type="indexterm" id="idm45922790949416"/><code>echo</code>. While it looks—and for the most part behaves—like a function, <code>echo</code> is a language construct. This means that you can omit the parentheses, so the following expressions are equivalent:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code> <code class="s2">"Printy"</code><code class="p">;</code>
<code class="k">echo</code><code class="p">(</code><code class="s2">"Printy"</code><code class="p">);</code> <code class="c1">// also valid</code></pre>

<p>You can specify multiple items to print by separating them with commas:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code><code> </code><code class="s2">"</code><code class="s2">First</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">second</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">third</code><code class="s2">"</code><code class="p">;</code><code>
</code><strong><code class="nx">Firstsecondthird</code></strong></pre>

<p>It is a parse error to use parentheses when trying to echo multiple values:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="c1">// this is a parse error</code>
<code class="k">echo</code><code class="p">(</code><code class="s2">"Hello"</code><code class="p">,</code> <code class="s2">"world"</code><code class="p">);</code></pre>

<p>Because <code>echo</code> is not a true function, you can’t use it as part of a larger expression:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="c1">// parse error</code>
<code class="k">if</code> <code class="p">(</code><code class="k">echo</code><code class="p">(</code><code class="s2">"test"</code><code class="p">))</code> <code class="p">{</code>
 <code class="k">echo</code><code class="p">(</code><code class="s2">"It worked!"</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>You can easily remedy such errors by using the <code>print()</code> or <code>printf()</code> functions.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="print()"><div class="sect2" id="printleft_parenthesisright_parenthesis">
<h2>print()</h2>

<p><a contenteditable="false" data-primary="print function" data-type="indexterm" id="idm45922790797304"/>The <code>print()</code> function sends one value (its argument) to the browser:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">if</code><code> </code><code class="p">(</code><code class="k">print</code><code class="p">(</code><code class="s2">"</code><code class="s2">test</code><code class="se">\n</code><code class="s2">"</code><code class="p">))</code><code> </code><code class="p">{</code><code>
 </code><code class="k">print</code><code class="p">(</code><code class="s2">"</code><code class="s2">It worked!</code><code class="s2">"</code><code class="p">);</code><code>
</code><code class="p">}</code><code>
</code><strong><code class="nx">test</code></strong><code>
</code><strong><code class="nx">It</code><code> </code><code class="nx">worked</code><code class="o">!</code></strong></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="printf()"><div class="sect2" id="printfleft_parenthesisright_parenthesi">
<h2>printf()</h2>

<p><a contenteditable="false" data-primary="printf function" data-type="indexterm" id="ix_printf_function"/>The <code>printf()</code> function outputs a string built by substituting values into a template (the <em>format string</em>). It is derived from the function of the same name in the standard C library. The first argument to <code>printf()</code> is the <a contenteditable="false" data-primary="format string" data-type="indexterm" id="ix_format_string_ch4"/>format string. The remaining arguments are the values to be substituted. A <a contenteditable="false" data-primary="% (percent sign)" data-secondary="in format string" data-type="indexterm" id="idm45922790732984"/><a contenteditable="false" data-primary="percent sign (%)" data-secondary="in format string" data-type="indexterm" id="idm45922790731608"/><code>%</code> character in the format string indicates a substitution.</p>

<section data-type="sect3" data-pdf-bookmark="Format modifiers"><div class="sect3" id="format_modifiers">
<h3>Format modifiers</h3>

<p>Each substitution marker in the template consists of a percent sign (<code>%</code>), possibly followed by modifiers from the following list, and ends with a type specifier. (Use <code>%%</code> to get a single percent character in the output.) The modifiers must appear in the order in which they are listed here:</p>

<ol>
	<li>
	<p>A padding specifier denoting the character to use to pad the results to the appropriate string size. Specify <code>0</code>, a space, or any character prefixed with a single quote. Padding with spaces is the default.</p>
	</li>
	<li>
	<p>A sign. This has a different effect on strings than on numbers. For strings, a minus (<code>–</code>) here forces the string to be left-justified (the default is right-justified). For numbers, a plus (<code>+</code>) here forces positive numbers to be printed with a leading plus sign (e.g., <code>35</code> will be printed as <code>+35</code>).</p>
	</li>
	<li>
	<p>The minimum number of characters that this element should contain. If the result would be less than this number of characters, the sign and padding specifier govern how to pad to this length.</p>
	</li>
	<li>
	<p>For floating-point numbers, a precision specifier consisting of a period and a number; this dictates how many decimal digits will be displayed. For types other than double, this specifier is ignored.</p>
	</li>
</ol>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Type specifiers"><div class="sect3" id="type_specifiers">
<h3>Type specifiers</h3>

<p>The type specifier tells <code>printf()</code> what type of data is being substituted. This determines the interpretation of the previously listed modifiers. There are eight types, as listed in <a data-type="xref" href="#printfleft_parenthesisright_parenthesis">Table 4-2</a>.</p>

<table class="border" id="printfleft_parenthesisright_parenthesis">
	<caption><span class="label">Table 4-2. </span>printf() type specifiers</caption>
	<thead>
		<tr>
			<th>Specifier</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>%</code></td>
			<td>Displays the percent sign.</td>
		</tr>
		<tr>
			<td><code>b</code></td>
			<td>The argument is an integer and is displayed as a binary number.</td>
		</tr>
		<tr>
			<td><code>c</code></td>
			<td>The argument is an integer and is displayed as the character with that value.</td>
		</tr>
		<tr>
			<td><code>d</code></td>
			<td>The argument is an integer and is displayed as a decimal number.</td>
		</tr>
		<tr>
			<td><code>e</code></td>
			<td>The argument is a double and is displayed in scientific notation.</td>
		</tr>
		<tr>
			<td><code>E</code></td>
			<td>The argument is a double and is displayed in scientific notation using uppercase letters.</td>
		</tr>
		<tr>
			<td><code>f</code></td>
			<td>The argument is a floating-point number and is displayed as such in the current locale’s format.</td>
		</tr>
		<tr>
			<td><code>F</code></td>
			<td>The argument is a floating-point number and is displayed as such.</td>
		</tr>
		<tr>
			<td><code>g</code></td>
			<td>The argument is a double and is displayed either in scientific notation (as with the <code>%e</code> type specifier) or as a floating-point number (as with the <code>%f</code> type specifier), whichever is shorter.</td>
		</tr>
		<tr>
			<td><code>G</code></td>
			<td>The argument is a double and is displayed either in scientific notation (as with the <code>%E</code> type specifier) or as a floating-point number (as with the <code>%f</code> type specifier), whichever is shorter.</td>
		</tr>
		<tr>
			<td><code>o</code></td>
			<td>The argument is an integer and is displayed as an octal (base-8) number.</td>
		</tr>
		<tr>
			<td><code>s</code></td>
			<td>The argument is a string and is displayed as such.</td>
		</tr>
		<tr>
			<td><code>u</code></td>
			<td>The argument is an unsigned integer and is displayed as a decimal number.</td>
		</tr>
		<tr>
			<td><code>x</code></td>
			<td>The argument is an integer and is displayed as a hexadecimal (base-16) number; lowercase letters are used.</td>
		</tr>
		<tr>
			<td><code>X</code></td>
			<td>The argument is an integer and is displayed as a hexadecimal (base-16) number; uppercase letters are used.</td>
		</tr>
	</tbody>
</table>

<p>The <code>printf()</code> function looks outrageously complex to people who aren’t C programmers. Once you get used to it, though, you’ll find it a powerful formatting tool. Here are some examples:</p>

<ul>
	<li>
	<p>A floating-point number to two decimal places:</p>

	<pre data-type="programlisting" data-code-language="php">
<code class="nb">printf</code><code class="p">(</code><code class="s1">'%.2f'</code><code class="p">,</code><code> </code><code class="mf">27.452</code><code class="p">);</code><code>
</code><strong><code class="mf">27.45</code></strong></pre>
	</li>
	<li>
	<p>Decimal and hexadecimal output:</p>

	<pre data-type="programlisting" data-code-language="php">
<code class="nb">printf</code><code class="p">(</code><code class="s1">'The hex value of %d is %x'</code><code class="p">,</code><code> </code><code class="mi">214</code><code class="p">,</code><code> </code><code class="mi">214</code><code class="p">);</code><code>
</code><strong><code class="nx">The</code><code> </code><code class="nx">hex</code><code> </code><code class="nx">value</code><code> </code><code class="nx">of</code><code> </code><code class="mi">214</code><code> </code><code class="nx">is</code><code> </code><code class="nx">d6</code></strong></pre>
	</li>
	<li>
	<p>Padding an integer to three decimal places:</p>

	<pre data-type="programlisting" data-code-language="php">
<code class="nb">printf</code><code class="p">(</code><code class="s1">'Bond. James Bond. %03d.'</code><code class="p">,</code><code> </code><code class="mi">7</code><code class="p">);</code><code>
</code><strong><code class="nx">Bond</code><code class="o">.</code><code> </code><code class="nx">James</code><code> </code><code class="nx">Bond</code><code class="o">.</code><code> </code><code class="mf">007.</code></strong></pre>
	</li>
	<li>
	<p>Formatting a date:</p>

	<pre data-type="programlisting" data-code-language="php">
<code class="nb">printf</code><code class="p">(</code><code class="s1">'%02d/%02d/%04d'</code><code class="p">,</code><code> </code><code class="nv">$month</code><code class="p">,</code><code> </code><code class="nv">$day</code><code class="p">,</code><code> </code><code class="nv">$year</code><code class="p">);</code><code>
</code><strong><code class="mo">02</code><code class="o">/</code><code class="mi">15</code><code class="o">/</code><code class="mi">2005</code></strong></pre>
	</li>
	<li>
	<p>A percentage:</p>

	<pre data-type="programlisting" data-code-language="php">
<code class="nb">printf</code><code class="p">(</code><code class="s1">'%.2f%% Complete'</code><code class="p">,</code><code> </code><code class="mf">2.1</code><code class="p">);</code><code>
</code><strong><code class="mf">2.10</code><code class="o">%</code><code> </code><code class="nx">Complete</code></strong></pre>
	</li>
	<li>
	<p>Padding a floating-point number:</p>

	<pre data-type="programlisting" data-code-language="php">
<code class="nb">printf</code><code class="p">(</code><code class="s1">'You\'ve spent $%5.2f so far'</code><code class="p">,</code><code> </code><code class="mf">4.1</code><code class="p">);</code><code>
</code><strong><code class="nx">You</code><code class="err">'</code><code class="nx">ve</code><code> </code><code class="nx">spent</code><code> </code><code class="err">$</code><code> </code><code class="mf">4.10</code><code> </code><code class="nx">so</code><code> </code><code class="nx">far</code></strong></pre>
	</li>
</ul>

<p>The <a contenteditable="false" data-primary="sprintf function" data-type="indexterm" id="idm45922790472808"/><code>sprintf()</code> function takes the same arguments as <code>printf()</code> but returns the built-up string instead of printing it. This lets you save the string in a variable for later use:<a contenteditable="false" data-primary="" data-startref="ix_printf_function" data-type="indexterm" id="idm45922790470808"/><a contenteditable="false" data-primary="" data-startref="ix_format_string_ch4" data-type="indexterm" id="idm45922790469432"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$date</code> <code class="o">=</code> <code class="nb">sprintf</code><code class="p">(</code><code class="s2">"%02d/%02d/%04d"</code><code class="p">,</code> <code class="nv">$month</code><code class="p">,</code> <code class="nv">$day</code><code class="p">,</code> <code class="nv">$year</code><code class="p">);</code>
<code class="c1">// now we can interpolate $date wherever we need a date</code></pre>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="print_r() and var_dump()"><div class="sect2" id="print_rleft_parenthesisright_parenthesi">
<h2>print_r() and var_dump()</h2>

<p><a contenteditable="false" data-primary="var_dump function" data-type="indexterm" id="ix_var_dump"/><a contenteditable="false" data-primary="print_r function" data-type="indexterm" id="ix_print_r"/>The <code>print_r()</code> function intelligently displays what is passed to it, rather than casting everything to a string, as <code>echo</code> and <code>print()</code> do. Strings and numbers are simply printed. Arrays appear as parenthesized lists of keys and values, prefaced by <code>Array</code>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$a</code><code> </code><code class="o">=</code><code> </code><code class="k">array</code><code class="p">(</code><code class="s1">'name'</code><code> </code><code class="o">=&gt;</code><code> </code><code class="s1">'Fred'</code><code class="p">,</code><code> </code><code class="s1">'age'</code><code> </code><code class="o">=&gt;</code><code> </code><code class="mi">35</code><code class="p">,</code><code> </code><code class="s1">'wife'</code><code> </code><code class="o">=&gt;</code><code> </code><code class="s1">'Wilma'</code><code class="p">);</code><code>
</code><code class="nb">print_r</code><code class="p">(</code><code class="nv">$a</code><code class="p">);</code><code>
</code><strong><code class="k">Array</code></strong><code>
</code><strong><code class="p">(</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">name</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">Fred</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">age</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="mi">35</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">wife</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">Wilma</code><code class="p">)</code></strong></pre>

<p>Using <code>print_r()</code> on an array moves the internal iterator to the position of the last element in the array. See <a data-type="xref" href="ch05.xhtml#array">Chapter 5</a> for more on iterators and arrays.</p>

<p>When you <code>print_r()</code> an object, you see the word <code>Object</code>, followed by the initialized properties of the object displayed as an array:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">class</code><code> </code><code class="nc">P</code><code> </code><code class="p">{</code><code>
 </code><code class="k">var</code><code> </code><code class="nv">$name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'nat'</code><code class="p">;</code><code>
 </code><code class="c1">// ...
</code><code class="p">}</code><code>

</code><code class="nv">$p</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">P</code><code class="p">;</code><code>
</code><code class="nb">print_r</code><code class="p">(</code><code class="nv">$p</code><code class="p">);</code><code>
</code><strong><code class="nx">Object</code></strong><code>
</code><strong><code class="p">(</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">name</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">nat</code><code class="p">)</code></strong></pre>

<p>Boolean values and <code>NULL</code> are not meaningfully displayed by <code>print_r()</code>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">print_r</code><code class="p">(</code><code class="k">true</code><code class="p">);</code><code> </code><code class="c1">// prints "1";
</code><strong><code class="mi">1</code></strong><code>
</code><code class="nb">print_r</code><code class="p">(</code><code class="k">false</code><code class="p">);</code><code> </code><code class="c1">// prints "";
</code><code>
</code><code class="nb">print_r</code><code class="p">(</code><code class="k">null</code><code class="p">);</code><code> </code><code class="c1">// prints "";</code></pre>

<p>For this reason, <code>var_dump()</code> is preferred over <code>print_r()</code> for debugging. The <code>var_dump()</code> function displays any PHP value in a human-readable format:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">var_dump</code><code class="p">(</code><code class="k">true</code><code class="p">);</code><code>
</code><code class="nb">var_dump</code><code class="p">(</code><code class="k">false</code><code class="p">);</code><code>
</code><code class="nb">var_dump</code><code class="p">(</code><code class="k">null</code><code class="p">);</code><code>
</code><code class="nb">var_dump</code><code class="p">(</code><code class="k">array</code><code class="p">(</code><code class="s1">'name'</code><code> </code><code class="o">=&gt;</code><code> </code><code class="s2">"</code><code class="s2">Fred</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s1">'age'</code><code> </code><code class="o">=&gt;</code><code> </code><code class="mi">35</code><code class="p">));</code><code>
</code><code class="k">class</code><code> </code><code class="nc">P</code><code> </code><code class="p">{</code><code>
 </code><code class="k">var</code><code> </code><code class="nv">$name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Nat'</code><code class="p">;</code><code>
 </code><code class="c1">// ...
</code><code class="p">}</code><code>
</code><code class="nv">$p</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">P</code><code class="p">;</code><code>
</code><code class="nb">var_dump</code><code class="p">(</code><code class="nv">$p</code><code class="p">);</code><code>
</code><strong><code class="nx">bool</code><code class="p">(</code><code class="k">true</code><code class="p">)</code></strong><code>
</code><strong><code class="nx">bool</code><code class="p">(</code><code class="k">false</code><code class="p">)</code></strong><code>
</code><strong><code class="nx">bool</code><code class="p">(</code><code class="k">null</code><code class="p">)</code></strong><code>
</code><strong><code class="k">array</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code><code> </code><code class="p">{</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="s2">"</code><code class="s2">name</code><code class="s2">"</code><code class="p">]</code><code class="o">=&gt;</code></strong><code>
</code><strong><code> </code><code class="nx">string</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code><code> </code><code class="s2">"</code><code class="s2">Fred</code><code class="s2">"</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="s2">"</code><code class="s2">age</code><code class="s2">"</code><code class="p">]</code><code class="o">=&gt;</code></strong><code>
</code><strong><code> </code><code class="nx">int</code><code class="p">(</code><code class="mi">35</code><code class="p">)</code></strong><code>
</code><strong><code class="p">}</code></strong><code>
</code><strong><code class="nx">object</code><code class="p">(</code><code class="nx">p</code><code class="p">)(</code><code class="mi">1</code><code class="p">)</code><code> </code><code class="p">{</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="s2">"</code><code class="s2">name</code><code class="s2">"</code><code class="p">]</code><code class="o">=&gt;</code></strong><code>
</code><strong><code> </code><code class="nx">string</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code><code> </code><code class="s2">"</code><code class="s2">Nat</code><code class="s2">"</code></strong><code>
</code><strong><code class="p">}</code></strong></pre>

<p>Beware of using <code>print_r()</code> or <code>var_dump()</code> on a recursive structure such as <code>$GLOBALS</code> (which has an entry for <code>GLOBALS</code> that points back to itself). The <code>print_r()</code> function loops infinitely, while <code>var_dump()</code> cuts off after visiting the same element three times.<a contenteditable="false" data-primary="" data-startref="ix_strings_print_web" data-type="indexterm" id="idm45922790091080"/><a contenteditable="false" data-primary="" data-startref="ix_webpage_print_string" data-type="indexterm" id="idm45922790112760"/><a contenteditable="false" data-primary="" data-startref="ix_print_r" data-type="indexterm" id="idm45922790111384"/><a contenteditable="false" data-primary="" data-startref="ix_var_dump" data-type="indexterm" id="idm45922790110008"/></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Accessing Individual Characters"><div class="sect1" id="accessing_individual_characters">
<h1>Accessing Individual Characters</h1>

<p><a contenteditable="false" data-primary="strings" data-secondary="accessing individual characters of" data-type="indexterm" id="idm45922790107144"/>The <a contenteditable="false" data-primary="strlen function" data-type="indexterm" id="idm45922790105672"/><code>strlen()</code> function returns the number of characters in a string:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code> <code class="o">=</code> <code class="s1">'Hello, world'</code><code class="p">;</code>
<code class="nv">$length</code> <code class="o">=</code> <code class="nb">strlen</code><code class="p">(</code><code class="nv">$string</code><code class="p">);</code> <code class="c1">// $length is 12</code></pre>

<p>You can use the string offset syntax on a string to address individual characters:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Hello'</code><code class="p">;</code><code>
</code><code class="k">for</code><code> </code><code class="p">(</code><code class="nv">$i</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code><code> </code><code class="nv">$i</code><code> </code><code class="o">&lt;</code><code> </code><code class="nb">strlen</code><code class="p">(</code><code class="nv">$string</code><code class="p">);</code><code> </code><code class="nv">$i</code><code class="o">++</code><code class="p">)</code><code> </code><code class="p">{</code><code>
 </code><code class="nb">printf</code><code class="p">(</code><code class="s2">"</code><code class="s2">The %dth character is %s</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="nv">$i</code><code class="p">,</code><code> </code><code class="nv">$string</code><code class="p">{</code><code class="nv">$i</code><code class="p">});</code><code>
</code><code class="p">}</code><code>
</code><strong><code class="nx">The</code><code> </code><code class="mi">0</code><code class="nx">th</code><code> </code><code class="nx">character</code><code> </code><code class="nx">is</code><code> </code><code class="nx">H</code></strong><code>
</code><strong><code class="nx">The</code><code> </code><code class="mi">1</code><code class="nx">th</code><code> </code><code class="nx">character</code><code> </code><code class="nx">is</code><code> </code><code class="nx">e</code></strong><code>
</code><strong><code class="nx">The</code><code> </code><code class="mi">2</code><code class="nx">th</code><code> </code><code class="nx">character</code><code> </code><code class="nx">is</code><code> </code><code class="nx">l</code></strong><code>
</code><strong><code class="nx">The</code><code> </code><code class="mi">3</code><code class="nx">th</code><code> </code><code class="nx">character</code><code> </code><code class="nx">is</code><code> </code><code class="nx">l</code></strong><code>
</code><strong><code class="nx">The</code><code> </code><code class="mi">4</code><code class="nx">th</code><code> </code><code class="nx">character</code><code> </code><code class="nx">is</code><code> </code><code class="nx">o</code></strong></pre>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Cleaning Strings"><div class="sect1" id="cleaning_strings">
<h1>Cleaning Strings</h1>

<p><a contenteditable="false" data-primary="strings" data-secondary="cleaning" data-type="indexterm" id="ix_strings_cleaning"/>Often, the strings we get from files or users need to be cleaned up before we can use them. Two common problems with raw data are the presence of extraneous whitespace and incorrect capitalization (uppercase versus lowercase).</p>

<section data-type="sect2" data-pdf-bookmark="Removing Whitespace"><div class="sect2" id="removing_whitespace">
<h2>Removing Whitespace</h2>

<p><a contenteditable="false" data-primary="whitespace" data-secondary="removing from strings" data-type="indexterm" id="idm45922789952424"/>You can remove leading or trailing whitespace with the <a contenteditable="false" data-primary="trim function" data-type="indexterm" id="idm45922789950696"/><code>trim()</code>, <a contenteditable="false" data-primary="ltrim function" data-type="indexterm" id="idm45922789949176"/><code>ltrim()</code>, and <a contenteditable="false" data-primary="rtrim function" data-type="indexterm" id="idm45922789947624"/><code>rtrim()</code> functions:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$trimmed</code><code> </code><code class="o">=</code><code> </code><code class="nb">trim</code><code class="p">(</code><em><code class="nx">string</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">charlist</code></em><code> </code><code class="p">]);</code><code>
</code><code class="nv">$trimmed</code><code> </code><code class="o">=</code><code> </code><code class="nb">ltrim</code><code class="p">(</code><em><code class="nx">string</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">charlist</code></em><code> </code><code class="p">]);</code><code>
</code><code class="nv">$trimmed</code><code> </code><code class="o">=</code><code> </code><code class="nb">rtrim</code><code class="p">(</code><em><code class="nx">string</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">charlist</code></em><code> </code><code class="p">]);</code></pre>

<p><code>trim()</code> returns a copy of <em>string</em> with whitespace removed from the beginning and the end. <code>ltrim()</code> (the <em>l</em> is for <em>left</em>) does the same, but removes whitespace only from the start of the string. <code>rtrim()</code> (the <em>r</em> is for <em>right</em>) removes whitespace only from the end of the string. The optional <em>charlist</em> argument is a string that specifies all the characters to strip. <a contenteditable="false" data-primary="whitespace" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789878760"/>The default characters to strip are given in <a data-type="xref" href="#default_characters_removed_by_trimleft">Table 4-3</a>.</p>

<table class="border" id="default_characters_removed_by_trimleft">
	<caption><span class="label">Table 4-3. </span>Default characters removed by trim(), ltrim(), and rtrim()</caption>
	<thead>
		<tr>
			<th>Character</th>
			<th>ASCII value</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>" "</code></td>
			<td>0x20</td>
			<td>Space</td>
		</tr>
		<tr>
			<td><code>"\t"</code></td>
			<td>0x09</td>
			<td>Tab</td>
		</tr>
		<tr>
			<td><code>"\n"</code></td>
			<td>0x0A</td>
			<td>Newline (line feed)</td>
		</tr>
		<tr>
			<td><code>"\r"</code></td>
			<td>0x0D</td>
			<td>Carriage return</td>
		</tr>
		<tr>
			<td><code>"\0"</code></td>
			<td>0x00</td>
			<td>NUL-byte</td>
		</tr>
		<tr>
			<td><code>"\x0B"</code></td>
			<td>0x0B</td>
			<td>Vertical tab</td>
		</tr>
	</tbody>
</table>

<p>For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$title</code> <code class="o">=</code> <code class="s2">" Programming PHP </code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code>
<code class="nv">$str1</code> <code class="o">=</code> <code class="nb">ltrim</code><code class="p">(</code><code class="nv">$title</code><code class="p">);</code> <code class="c1">// $str1 is "Programming PHP \n"</code>
<code class="nv">$str2</code> <code class="o">=</code> <code class="nb">rtrim</code><code class="p">(</code><code class="nv">$title</code><code class="p">);</code> <code class="c1">// $str2 is " Programming PHP"</code>
<code class="nv">$str3</code> <code class="o">=</code> <code class="nb">trim</code><code class="p">(</code><code class="nv">$title</code><code class="p">);</code> <code class="c1">// $str3 is "Programming PHP"</code></pre>

<p>Given a line of tab-separated data, use the <em>charlist</em> argument to remove leading or trailing whitespace without deleting the tabs:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$record</code> <code class="o">=</code> <code class="s2">" Fred</code><code class="se">\t</code><code class="s2">Flintstone</code><code class="se">\t</code><code class="s2">35</code><code class="se">\t</code><code class="s2">Wilma</code><code class="se">\t</code><code class="s2"> </code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code>
<code class="nv">$record</code> <code class="o">=</code> <code class="nb">trim</code><code class="p">(</code><code class="nv">$record</code><code class="p">,</code> <code class="s2">" </code><code class="se">\r\n\0\x0B</code><code class="s2">"</code><code class="p">);</code>
<code class="c1">// $record is "Fred\tFlintstone\t35\tWilma"</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Changing Case"><div class="sect2" id="changing_case">
<h2>Changing Case</h2>

<p><a contenteditable="false" data-primary="strings" data-secondary="changing case of" data-type="indexterm" id="idm45922789761736"/><a contenteditable="false" data-primary="case of strings, changing" data-type="indexterm" id="idm45922789756984"/>PHP has several functions for changing the case of strings: <a contenteditable="false" data-primary="strtolower function" data-type="indexterm" id="idm45922789755784"/><code>strtolower()</code> and <a contenteditable="false" data-primary="strtoupper function" data-type="indexterm" id="idm45922789754264"/><code>strtoupper()</code> operate on entire strings, <a contenteditable="false" data-primary="ucfirst function" data-type="indexterm" id="idm45922789752712"/><code>ucfirst()</code> operates only on the first character of the string, and <a contenteditable="false" data-primary="ucwords function" data-type="indexterm" id="idm45922789751192"/><code>ucwords()</code> operates on the first character of each word in the string. Each function takes a string to operate on as an argument and returns a copy of that string, appropriately changed. For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string1</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">FRED flintstone</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$string2</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">barney rubble</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="k">print</code><code class="p">(</code><code class="nb">strtolower</code><code class="p">(</code><code class="nv">$string1</code><code class="p">));</code><code>
</code><code class="k">print</code><code class="p">(</code><code class="nb">strtoupper</code><code class="p">(</code><code class="nv">$string1</code><code class="p">));</code><code>
</code><code class="k">print</code><code class="p">(</code><code class="nb">ucfirst</code><code class="p">(</code><code class="nv">$string2</code><code class="p">));</code><code>
</code><code class="k">print</code><code class="p">(</code><code class="nb">ucwords</code><code class="p">(</code><code class="nv">$string2</code><code class="p">));</code><code>
</code><strong><code class="nx">fred</code><code> </code><code class="nx">flintstone</code></strong><code>
</code><strong><code class="nx">FRED</code><code> </code><code class="nx">FLINTSTONE</code></strong><code>
</code><strong><code class="nx">Barney</code><code> </code><code class="nx">rubble</code></strong><code>
</code><strong><code class="nx">Barney</code><code> </code><code class="nx">Rubble</code></strong></pre>

<p>If you’ve got a mixed-case string that you want to convert to “title case,” where the first letter of each word is in uppercase and the rest of the letters are in lowercase (and you’re not sure what case the string is in to begin with), use a combination of <code>strtolower()</code> and <code>ucwords()</code>:<a contenteditable="false" data-primary="" data-startref="ix_strings_cleaning" data-type="indexterm" id="idm45922789742824"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">print</code><code class="p">(</code><code class="nb">ucwords</code><code class="p">(</code><code class="nb">strtolower</code><code class="p">(</code><code class="nv">$string1</code><code class="p">)));</code><code>
</code><strong><code class="nx">Fred</code><code> </code><code class="nx">Flintstone</code></strong></pre>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Encoding and Escaping"><div class="sect1" id="encoding_and_escaping">
<h1>Encoding and Escaping</h1>

<p><a contenteditable="false" data-primary="strings" data-secondary="encoding and escaping" data-type="indexterm" id="ix_strings_enc_esc"/>Because PHP programs often interact with HTML pages, web addresses (URLs), and databases, there are functions to help you work with those types of data. HTML, web addresses, and database commands are all strings, but they each require different characters to be escaped in different ways. For instance, a space in a web address must be written as <code>%20</code>, while a literal less-than sign (<code>&lt;</code>) in an HTML document must be written as <code>&amp;lt;</code>. PHP has a number of built-in functions to convert to and from these encodings.</p>

<section data-type="sect2" data-pdf-bookmark="HTML"><div class="sect2" id="html">
<h2>HTML</h2>

<p><a contenteditable="false" data-primary="entities" data-secondary="HTML" data-type="indexterm" id="ix_entities_html_convert"/><a contenteditable="false" data-primary="special characters" data-secondary="converting to HTML entities" data-type="indexterm" id="ix_specchar_convert_html"/><a contenteditable="false" data-primary="HTML" data-secondary="converting special characters to entities in" data-type="indexterm" id="ix_html_specchar_convert"/>Special characters in HTML are represented by <em>entities</em> such as <code>&amp;amp;</code> (<code>&amp;</code>) and <code>&amp;lt;</code> (<code>&lt;</code>). There are two PHP functions that turn special characters in a string into their entities: one for removing HTML tags, and one for extracting only meta tags.</p>

<section data-type="sect3" data-pdf-bookmark="Entity-quoting all special characters"><div class="sect3" id="entity_quoting_all_special_characters">
<h3>Entity-quoting all special characters</h3>

<p>The <a contenteditable="false" data-primary="htmlentities function" data-type="indexterm" id="idm45922789583208"/><code>htmlentities()</code> function changes all characters with HTML entity equivalents into those equivalents (with the exception of the space character). This includes the less-than sign (<code>&lt;</code>), the greater-than sign (<code>&gt;</code>), the ampersand (<code>&amp;</code>), and accented <span class="keep-together">characters.</span></p>

<p>For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="nb">htmlentities</code><code class="p">(</code><code class="s2">"</code><code class="s2">Einstürzende Neubauten</code><code class="s2">"</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="nv">$string</code><code class="p">;</code><code>
</code><strong><code class="nx">Einstürzende</code><code> </code><code class="nx">Neubauten</code></strong></pre>

<p>The entity-escaped version, <code>&amp;uuml;</code> (seen by viewing the source), correctly displays as ü in the rendered web page. As you can see, the space has not been turned into <code>&amp;nbsp;</code>.</p>

<p>The <code>htmlentities()</code> function actually takes up to three arguments:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$output</code><code> </code><code class="o">=</code><code> </code><code class="nb">htmlentities</code><code class="p">(</code><em><code class="nx">input</code></em><code class="p">,</code><code> </code><em><code class="nx">flags</code></em><code class="p">,</code><code> </code><em><code class="nx">encoding</code></em><code class="p">);</code></pre>

<p>The <em>encoding</em> parameter, if given, identifies the character set. The default is “UTF-8.” The <em>flags</em> parameter controls whether single and double quotes are turned into their entity forms. <code>ENT_COMPAT</code> (the default) converts only double quotes, <code>ENT_QUOTES</code> converts both types of quotes, and <code>ENT_NOQUOTES</code> converts neither. There is no option to convert only single quotes. For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$input</code> <code class="o">=</code> <code class="o">&lt;&lt;&lt;</code> <code class="nx">End</code>
<code class="s2">"Stop pulling my hair!"</code> <code class="nx">Jane</code><code class="s1">'s eyes flashed.&lt;p&gt;</code>
<code class="s1">End;</code>

<code class="s1">$double = htmlentities($input);</code>
<code class="s1">// &amp;quot;Stop pulling my hair!&amp;quot; Jane'</code><code class="nx">s</code> <code class="nx">eyes</code> <code class="nx">flashed</code><code class="o">.&amp;</code><code class="nx">lt</code><code class="p">;</code><code class="nx">p</code><code class="o">&amp;</code><code class="nx">gt</code><code class="p">;</code>

<code class="nv">$both</code> <code class="o">=</code> <code class="nb">htmlentities</code><code class="p">(</code><code class="nv">$input</code><code class="p">,</code> <code class="nx">ENT_QUOTES</code><code class="p">);</code>
<code class="c1">// &amp;quot;Stop pulling my hair!&amp;quot; Jane&amp;#039;s eyes flashed.&amp;lt;p&amp;gt;</code>

<code class="nv">$neither</code> <code class="o">=</code> <code class="nb">htmlentities</code><code class="p">(</code><code class="nv">$input</code><code class="p">,</code> <code class="nx">ENT_NOQUOTES</code><code class="p">);</code>
<code class="c1">// "Stop pulling my hair!" Jane's eyes flashed.&amp;lt;p&amp;gt;</code></pre>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Entity-quoting only HTML syntax characters"><div class="sect3" id="entity_quoting_only_html_syntax_charact">
<h3>Entity-quoting only HTML syntax characters</h3>

<p>The <code>htmlspecialchars()</code> function converts the smallest set of entities possible to generate valid HTML. The following entities are converted:</p>

<ul>
	<li>
	<p><a contenteditable="false" data-primary="ampersand (&amp;)" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789463128"/>Ampersands (<code>&amp;</code>) are converted to <code>&amp;amp;</code></p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="double quotes (“…”)" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789460120"/><a contenteditable="false" data-primary="“…” (double quotes)" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789452312"/>Double quotes (<code>"</code>) are converted to <code>&amp;quot;</code></p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="‘…’ (single quotes)" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789449336"/><a contenteditable="false" data-primary="single quotes (‘…’)" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789447768"/>Single quotes (<code>'</code>) are converted to <code>&amp;#039;</code> (if <code>ENT_QUOTES</code> is on, as described for <code>htmlentities()</code>)</p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="&lt; (left angle bracket)" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789443896"/><a contenteditable="false" data-primary="left angle bracket (&lt;)" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789442520"/>Less-than signs (<code>&lt;</code>) are converted to <code>&amp;lt;</code></p>
	</li>
	<li>
	<p><a contenteditable="false" data-primary="&gt; (right angle bracket)" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789439512"/><a contenteditable="false" data-primary="right angle bracket (&gt;)" data-secondary="HTML entity for" data-type="indexterm" id="idm45922789438136"/>Greater-than signs (<code>&gt;</code>) are converted to <code>&amp;gt;</code></p>
	</li>
</ul>

<p>If you have an application that displays data that a user has entered in a form, you need to run that data through <a contenteditable="false" data-primary="htmlspecialchars function" data-type="indexterm" id="idm45922789435192"/><code>htmlspecialchars()</code> before displaying or saving it. If you don’t, and the user enters a string like <code>"angle &lt; 30"</code> or <code>"sturm &amp; drang"</code>, the browser will think the special characters are HTML, resulting in a garbled page.</p>

<p>Like <code>htmlentities()</code>, <code>htmlspecialchars()</code> can take up to three arguments:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$output</code><code> </code><code class="o">=</code><code> </code><code class="nb">htmlspecialchars</code><code class="p">(</code><em><code class="nx">input</code></em><code class="p">,</code><code> </code><code class="p">[</code><em><code class="nx">flags</code></em><code class="p">,</code><code> </code><code class="p">[</code><em><code class="nx">encoding</code></em><code class="p">]]);</code></pre>

<p>The <em>flags</em> and <em>encoding</em> arguments have the same meaning that they do for <code>html</code><span class="keep-together"><code>entities()</code></span>.</p>

<p>There are no functions specifically for converting back from the entities to the original text, because this is rarely needed. There is a relatively simple way to do this, though. Use the <a contenteditable="false" data-primary="get_html_translation_table function" data-type="indexterm" id="idm45922789405768"/><code>get_html_translation_table()</code> function to fetch the translation table used by either of these functions in a given quote style. For example, to get the translation table that <code>html</code><span class="keep-together"><code>entities()</code></span> uses, do this:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$table</code> <code class="o">=</code> <code class="nb">get_html_translation_table</code><code class="p">(</code><code class="nx">HTML_ENTITIES</code><code class="p">);</code></pre>

<p>To get the table for <code>htmlspecialchars()</code> in <code>ENT_NOQUOTES</code> mode, use:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$table</code> <code class="o">=</code> <code class="nb">get_html_translation_table</code><code class="p">(</code><code class="nx">HTML_SPECIALCHARS</code><code class="p">,</code> <code class="nx">ENT_NOQUOTES</code><code class="p">);</code></pre>

<p>A nice trick is to use this translation table, flip it using <a contenteditable="false" data-primary="array_flip function" data-type="indexterm" id="idm45922789332728"/><code>array_flip()</code>, and feed it to <a contenteditable="false" data-primary="strtr function" data-type="indexterm" id="idm45922789331304"/><code>strtr()</code> to apply it to a string, thereby effectively doing the reverse of <code>html</code><span class="keep-together"><code>entities()</code>:</span></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$str</code><code> </code><code class="o">=</code><code> </code><code class="nb">htmlentities</code><code class="p">(</code><code class="s2">"</code><code class="s2">Einstürzende Neubauten</code><code class="s2">"</code><code class="p">);</code><code> </code><code class="c1">// now it is encoded
</code><code>
</code><code class="nv">$table</code><code> </code><code class="o">=</code><code> </code><code class="nb">get_html_translation_table</code><code class="p">(</code><code class="nx">HTML_ENTITIES</code><code class="p">);</code><code>
</code><code class="nv">$revTrans</code><code> </code><code class="o">=</code><code> </code><code class="nb">array_flip</code><code class="p">(</code><code class="nv">$table</code><code class="p">);</code><code>

</code><code class="k">echo</code><code> </code><code class="nb">strtr</code><code class="p">(</code><code class="nv">$str</code><code class="p">,</code><code> </code><code class="nv">$revTrans</code><code class="p">);</code><code> </code><code class="c1">// back to normal
</code><strong><code class="nx">Einstürzende</code><code> </code><code class="nx">Neubauten</code></strong></pre>

<p>You can, of course, also fetch the translation table, add whatever other translations you want to it, and then do the <code>strtr()</code>. For example, if you wanted <code>htmlentities()</code> to also encode each space to <code>&amp;nbsp;</code>, you would do:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$table</code> <code class="o">=</code> <code class="nb">get_html_translation_table</code><code class="p">(</code><code class="nx">HTML_ENTITIES</code><code class="p">);</code>
<code class="nv">$table</code><code class="p">[</code><code class="s1">' '</code><code class="p">]</code> <code class="o">=</code> <code class="s1">'&amp;nbsp;'</code><code class="p">;</code>
<code class="nv">$encoded</code> <code class="o">=</code> <code class="nb">strtr</code><code class="p">(</code><code class="nv">$original</code><code class="p">,</code> <code class="nv">$table</code><code class="p">);</code></pre>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Removing HTML tags"><div class="sect3" id="removing_html_tags">
<h3>Removing HTML tags</h3>

<p><a contenteditable="false" data-primary="HTML" data-secondary="removing tags from strings" data-type="indexterm" id="idm45922789231400"/><a contenteditable="false" data-primary="strings" data-secondary="removing HTML tags in" data-type="indexterm" id="idm45922789230056"/><a contenteditable="false" data-primary="strip_tags function" data-type="indexterm" id="idm45922789228680"/>The <code>strip_tags()</code> function removes HTML tags from a string:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$input</code> <code class="o">=</code> <code class="s1">'&lt;p&gt;Howdy, &amp;quot;Cowboy&amp;quot;&lt;/p&gt;'</code><code class="p">;</code>
<code class="nv">$output</code> <code class="o">=</code> <code class="nb">strip_tags</code><code class="p">(</code><code class="nv">$input</code><code class="p">);</code>
<code class="c1">// $output is 'Howdy, &amp;quot;Cowboy&amp;quot;'</code></pre>

<p>The function may take a second argument that specifies a string of tags to leave in the string. List only the opening forms of the tags. The closing forms of tags listed in the second parameter are also preserved:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$input</code> <code class="o">=</code> <code class="s1">'The &lt;b&gt;bold&lt;/b&gt; tags will &lt;i&gt;stay&lt;/i&gt;&lt;p&gt;'</code><code class="p">;</code>
<code class="nv">$output</code> <code class="o">=</code> <code class="nb">strip_tags</code><code class="p">(</code><code class="nv">$input</code><code class="p">,</code> <code class="s1">'&lt;b&gt;'</code><code class="p">);</code>
<code class="c1">// $output is 'The &lt;b&gt;bold&lt;/b&gt; tags will stay'</code></pre>

<p>Attributes in preserved tags are not changed by <code>strip_tags()</code>. Because attributes such as <code>style</code> and <code>onmouseover</code> can affect the look and behavior of web pages, preserving some tags with <code>strip_tags()</code> won’t necessarily remove the potential for abuse.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Extracting meta tags"><div class="sect3" id="extracting_meta_tags">
<h3>Extracting meta tags</h3>

<p>The <a contenteditable="false" data-primary="get_meta_tags function" data-type="indexterm" id="idm45922789204840"/><a contenteditable="false" data-primary="HTML" data-secondary="meta tags, finding in strings" data-type="indexterm" id="idm45922789203704"/><a contenteditable="false" data-primary="meta tags, finding in strings" data-type="indexterm" id="idm45922789150888"/><code>get_meta_tags()</code> function returns an array of the meta tags for an HTML page, specified as a local filename or URL. The name of the meta tag (<code>keywords</code>, <code>author</code>, <code>description</code>, etc.) becomes the key in the array, and the content of the meta tag becomes the corresponding value:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$metaTags</code><code> </code><code class="o">=</code><code> </code><code class="nb">get_meta_tags</code><code class="p">(</code><code class="s1">'http://www.example.com/'</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="s2">Web page made by </code><code class="si">{</code><code class="nv">$metaTags</code><code class="p">[</code><code class="s1">'author'</code><code class="p">]</code><code class="si">}</code><code class="s2">"</code><code class="p">;</code><code>
</code><strong><code class="nx">Web</code><code> </code><code class="nx">page</code><code> </code><code class="nx">made</code><code> </code><code class="nx">by</code><code> </code><code class="nx">John</code><code> </code><code class="nx">Doe</code></strong></pre>

<p>The general form of the function is:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$array</code><code> </code><code class="o">=</code><code> </code><code class="nb">get_meta_tags</code><code class="p">(</code><em><code class="nx">filename</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">use_include_path</code></em><code class="p">]);</code></pre>

<p>Pass a <code>true</code> value for <em>use_include_path</em> to let PHP attempt to open the file using the standard include path.<a contenteditable="false" data-primary="" data-startref="ix_html_specchar_convert" data-type="indexterm" id="idm45922789072664"/><a contenteditable="false" data-primary="" data-startref="ix_specchar_convert_html" data-type="indexterm" id="idm45922789071320"/><a contenteditable="false" data-primary="" data-startref="ix_entities_html_convert" data-type="indexterm" id="idm45922789069976"/></p>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="URLs"><div class="sect2" id="urls-id00043">
<h2>URLs</h2>

<p><a contenteditable="false" data-primary="URLs" data-secondary="encoding and decoding" data-type="indexterm" id="ix_urls_enc_dec"/>PHP provides functions to convert to and from URL encoding, which allows you to build and decode URLs. There are actually two types of URL encoding, which differ in how they treat spaces. The first (specified by RFC 3986) treats a space as just another illegal character in a URL and encodes it as <code>%20</code>. The second (implementing the <code>application/x-www-form-urlencoded</code> system) encodes a space as a <code>+</code> and is used in building query strings.</p>

<p>Note that you don’t want to use these functions on a complete URL, such as <em><a href="http://www.example.com/hello"><em class="hyperlink">http://www.example.com/hello</em></a></em>, as they will escape the colons and slashes to produce:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nx">http</code><code class="o">%</code><code class="mi">3</code><code class="nx">A</code><code class="o">%</code><code class="mi">2</code><code class="nx">F</code><code class="o">%</code><code class="mi">2</code><code class="nx">Fwww</code><code class="o">.</code><code class="nx">example</code><code class="o">.</code><code class="nx">com</code><code class="o">%</code><code class="mi">2</code><code class="nx">Fhello</code></pre>

<p>Encode only partial URLs (the bit after <em>http://www.example.com/</em>) and add the protocol and domain name later.</p>

<section data-type="sect3" data-pdf-bookmark="RFC 3986 encoding and decoding"><div class="sect3" id="rfc_threenineeightsix_encoding_and_deco">
<h3>RFC 3986 encoding and decoding</h3>

<p><a contenteditable="false" data-primary="RFC 3986 encoding" data-type="indexterm" id="idm45922789017528"/>To encode a string according to the URL conventions, use <a contenteditable="false" data-primary="rawurlencode function" data-type="indexterm" id="idm45922789016296"/><code>rawurlencode()</code>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$output</code><code> </code><code class="o">=</code><code> </code><code class="nb">rawurlencode</code><code class="p">(</code><em><code class="nx">input</code></em><code class="p">);</code></pre>

<p>This function takes a string and returns a copy with illegal URL characters encoded in the <code>%dd</code> convention.</p>

<p>If you are dynamically generating hypertext references for links in a page, you need to convert them with <code>rawurlencode()</code>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$name</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Programming PHP</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$output</code><code> </code><code class="o">=</code><code> </code><code class="nb">rawurlencode</code><code class="p">(</code><code class="nv">$name</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="s2">http://localhost/</code><code class="si">{</code><code class="nv">$output</code><code class="si">}</code><code class="s2">"</code><code class="p">;</code><code>
</code><strong><code class="nx">http</code><code class="o">://</code><code class="nx">localhost</code><code class="o">/</code><code class="nx">Programming</code><code class="o">%</code><code class="mi">20</code><code class="nx">PHP</code></strong></pre>

<p>The <a contenteditable="false" data-primary="rawurldecode function" data-type="indexterm" id="idm45922788936200"/><code>rawurldecode()</code> function decodes URL-encoded strings:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$encoded</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Programming%20PHP'</code><code class="p">;</code><code>
</code><code class="k">echo</code><code> </code><code class="nb">rawurldecode</code><code class="p">(</code><code class="nv">$encoded</code><code class="p">);</code><code>
</code><strong><code class="nx">Programming</code><code> </code><code class="nx">PHP</code></strong></pre>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Query-string encoding"><div class="sect3" id="query_string_encoding">
<h3>Query-string encoding</h3>

<p><a contenteditable="false" data-primary="query string" data-type="indexterm" id="idm45922788887368"/>The <a contenteditable="false" data-primary="urlencode function" data-type="indexterm" id="idm45922788885912"/><code>urlencode()</code> and <a contenteditable="false" data-primary="urldecode function" data-type="indexterm" id="idm45922788884360"/><code>urldecode()</code> functions differ from their raw counterparts only in that they encode spaces as plus signs (<code>+</code>) instead of as the sequence <code>%20</code>. This is the format for building query strings and cookie values. These functions can be useful in supplying form-like URLs in the HTML. PHP automatically decodes query strings and cookie values, so you don’t need to use these functions to process those values. The functions are useful for generating query strings:<a contenteditable="false" data-primary="" data-startref="ix_urls_enc_dec" data-type="indexterm" id="idm45922788881528"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$baseUrl</code><code> </code><code class="o">=</code><code> </code><code class="s1">'http://www.google.com/q='</code><code class="p">;</code><code>
</code><code class="nv">$query</code><code> </code><code class="o">=</code><code> </code><code class="s1">'PHP sessions -cookies'</code><code class="p">;</code><code>
</code><code class="nv">$url</code><code> </code><code class="o">=</code><code> </code><code class="nv">$baseUrl</code><code> </code><code class="o">.</code><code> </code><code class="nb">urlencode</code><code class="p">(</code><code class="nv">$query</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="nv">$url</code><code class="p">;</code><code>

</code><strong><code class="nx">http</code><code class="o">://</code><code class="nx">www</code><code class="o">.</code><code class="nx">google</code><code class="o">.</code><code class="nx">com</code><code class="o">/</code><code class="nx">q</code><code class="o">=</code><code class="nx">PHP</code><code class="o">+</code><code class="nx">sessions</code><code class="o">+-</code><code class="nx">cookies</code></strong></pre>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="SQL"><div class="sect2" id="sql">
<h2>SQL</h2>

<p><a contenteditable="false" data-primary="special characters" data-secondary="SQL escape sequences for" data-type="indexterm" id="idm45922788818088"/><a contenteditable="false" data-primary="SQL (Structured Query Language)" data-secondary="escaping special characters in" data-type="indexterm" id="idm45922788816632"/>Most database systems require that string literals in your SQL queries be escaped. SQL’s encoding scheme is pretty simple—single quotes, double quotes, NUL-bytes, and backslashes need to be preceded by a backslash. <a contenteditable="false" data-primary="\ (backslash)" data-secondary="preceding SQL escape sequences" data-type="indexterm" id="idm45922788814952"/><a contenteditable="false" data-primary="addslashes function" data-type="indexterm" id="idm45922788813608"/><a contenteditable="false" data-primary="backslash (\)" data-secondary="preceding SQL escape sequences" data-type="indexterm" id="idm45922788812504"/>The <code>addslashes()</code> function adds these slashes, and the <a contenteditable="false" data-primary="stripslashes function" data-type="indexterm" id="idm45922788810584"/><code>stripslashes()</code> function removes them:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="o">&lt;&lt;&lt;</code><code> </code><code class="nx">EOF</code><code>
</code><code class="s2">"</code><code class="s2">It's never going to work,</code><code class="s2">"</code><code> </code><code class="nx">she</code><code> </code><code class="nx">cried</code><code class="p">,</code><code>
</code><code class="k">as</code><code> </code><code class="nx">she</code><code> </code><code class="nx">hit</code><code> </code><code class="nx">the</code><code> </code><code class="nx">backslash</code><code> </code><code class="p">(</code><code class="nx">\</code><code class="p">)</code><code> </code><code class="nb">key</code><code class="o">.</code><code>
</code><code class="nx">EOF</code><code class="p">;</code><code>
</code><code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="nb">addslashes</code><code class="p">(</code><code class="nv">$string</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="nv">$string</code><code class="p">;</code><code>
</code><code class="k">echo</code><code> </code><code class="nb">stripslashes</code><code class="p">(</code><code class="nv">$string</code><code class="p">);</code><code>
</code><strong><code class="nx">\</code><code class="s2">"</code><code class="s2">It</code><code class="s2">\</code><code class="s2">'s never going to work,</code><code class="se">\"</code><code class="s2"> she cried,</code></strong><code class="s2">
</code><strong><code class="s2">as she hit the backslash (</code><code class="se">\\</code><code class="s2">) key.</code></strong><code class="s2">
</code><strong><code class="s2">"</code><code class="nx">It</code><code class="err">'</code><code class="nx">s</code><code> </code><code class="nx">never</code><code> </code><code class="nx">going</code><code> </code><code class="nx">to</code><code> </code><code class="nx">work</code><code class="p">,</code><code class="s2">"</code><code class="s2"> she cried,</code></strong><code class="s2">
</code><strong><code class="s2">as she hit the backslash (</code><code class="s2">\</code><code class="s2">) key.</code></strong></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="C-String Encoding"><div class="sect2" id="c_string_encoding">
<h2>C-String Encoding</h2>

<p><a contenteditable="false" data-primary="special characters" data-secondary="C-string escape sequences for" data-type="indexterm" id="idm45922788691128"/><a contenteditable="false" data-primary="C-strings, encoding and decoding" data-type="indexterm" id="idm45922788705560"/><a contenteditable="false" data-primary="escape sequences for C-strings" data-type="indexterm" id="idm45922788704488"/><a contenteditable="false" data-primary="escape sequences for C-strings" data-secondary="for SQL" data-type="indexterm" id="idm45922788703416"/>The <code>addcslashes()</code> function escapes arbitrary characters by placing <a contenteditable="false" data-primary="\ (backslash)" data-secondary="preceding C-string escape sequences" data-type="indexterm" id="idm45922788701496"/><a contenteditable="false" data-primary="backslash (\)" data-secondary="preceding C-string escape sequences" data-type="indexterm" id="idm45922788700152"/>backslashes before them. With the exception of the characters in <a data-type="xref" href="#single_character_escapes_recognized_by">Table 4-4</a>, characters with ASCII values less than 32 or above 126 are encoded with their octal values (e.g., <code>"\002"</code>). The <a contenteditable="false" data-primary="addcslashes function" data-type="indexterm" id="idm45922788667528"/><code>addcslashes()</code> and <a contenteditable="false" data-primary="stripcslashes function" data-type="indexterm" id="idm45922788666168"/><code>stripcslashes()</code> functions are used with nonstandard database systems that have their own ideas of which characters need to be escaped.</p>

<table class="border" id="single_character_escapes_recognized_by">
	<caption><span class="label">Table 4-4. </span>Single-character escapes recognized by addcslashes() and stripcslashes()</caption>
	<thead>
		<tr>
			<th>ASCII value</th>
			<th>Encoding</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>7</td>
			<td><code>\a</code></td>
		</tr>
		<tr>
			<td>8</td>
			<td><code>\b</code></td>
		</tr>
		<tr>
			<td>9</td>
			<td><code>\t</code></td>
		</tr>
		<tr>
			<td>10</td>
			<td><code>\n</code></td>
		</tr>
		<tr>
			<td>11</td>
			<td><code>\v</code></td>
		</tr>
		<tr>
			<td>12</td>
			<td><code>\f</code></td>
		</tr>
		<tr>
			<td>13</td>
			<td><code>\r</code></td>
		</tr>
	</tbody>
</table>

<p>Call <code>addcslashes()</code> with two arguments—the string to encode and the characters to escape:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$escaped</code><code> </code><code class="o">=</code><code> </code><code class="nb">addcslashes</code><code class="p">(</code><em><code class="nx">string</code></em><code class="p">,</code><code> </code><em><code class="nx">charset</code></em><code class="p">);</code></pre>

<p>Specify a range of characters to escape with the <code>".."</code> construct:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code><code> </code><code class="nb">addcslashes</code><code class="p">(</code><code class="s2">"</code><code class="s2">hello</code><code class="se">\t</code><code class="s2">world</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="se">\x00</code><code class="s2">..</code><code class="se">\x1f</code><code class="s2">z..</code><code class="se">\xff</code><code class="s2">"</code><code class="p">);</code><code>
</code><strong><code class="nx">hello\tworld\n</code></strong></pre>

<p>Beware of specifying <code>'0'</code>, <code>'a'</code>, <code>'b'</code>, <code>'f'</code>, <code>'n'</code>, <code>'r'</code>, <code>'t'</code>, or <code>'v'</code> in the character set, as they will be turned into <code>'\0'</code>, <code>'\a'</code>, and so on. These escapes are recognized by C and PHP and may cause confusion.</p>

<p><code>stripcslashes()</code> takes a string and returns a copy with the escapes expanded:<a contenteditable="false" data-primary="" data-startref="ix_strings_enc_esc" data-type="indexterm" id="idm45922788588232"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="nb">stripcslashes</code><code class="p">(</code><em><code class="nx">escaped</code></em><code class="p">);</code></pre>

<p>For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code> <code class="o">=</code> <code class="nb">stripcslashes</code><code class="p">(</code><code class="s1">'hello\tworld\n'</code><code class="p">);</code>
<code class="c1">// $string is "hello\tworld\n"</code></pre>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Comparing Strings"><div class="sect1" id="comparing_strings">
<h1>Comparing Strings</h1>

<p><a contenteditable="false" data-primary="comparison operators" data-type="indexterm" id="idm45922788537976"/><a contenteditable="false" data-primary="operators" data-secondary="comparison operators" data-type="indexterm" id="idm45922788536872"/><a contenteditable="false" data-primary="strings" data-secondary="comparing" data-type="indexterm" id="ix_strings_comparing_ch4"/>PHP has two operators and six functions for comparing strings to each other.</p>

<section data-type="sect2" data-pdf-bookmark="Exact Comparisons"><div class="sect2" id="exact_comparisons">
<h2>Exact Comparisons</h2>

<p><a contenteditable="false" data-primary="exact string comparisons" data-type="indexterm" id="ix_exact_string_comp"/>You can compare two strings for equality with the <a contenteditable="false" data-primary="equal to operator (==)" data-type="indexterm" id="idm45922788529560"/><a contenteditable="false" data-primary="equals signs, double (==), equal to operator" data-type="indexterm" id="idm45922788528456"/><a contenteditable="false" data-primary="== (equals signs, double), equal to operator" data-type="indexterm" id="idm45922788527384"/><code>==</code> and <a contenteditable="false" data-primary="equals signs, triple (===), identity operator" data-type="indexterm" id="idm45922788525896"/><a contenteditable="false" data-primary="=== (equals signs, triple), identity operator" data-type="indexterm" id="idm45922788524792"/><a contenteditable="false" data-primary="identity operator (===)" data-type="indexterm" id="idm45922788523720"/><code>===</code> operators. These operators differ in how they deal with nonstring operands. The <code>==</code> operator casts string operands to numbers, so it reports that <code>3</code> and <code>"3"</code> are equal. Due to the rules for casting strings to numbers, it would also report that <code>3</code> and <code>"3b"</code> are equal, as only the portion of the string up to a non-number character is used in casting. The <code>===</code> operator does not cast, and returns <code>false</code> if the data types of the arguments differ:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$o1</code><code> </code><code class="o">=</code><code> </code><code class="mi">3</code><code class="p">;</code><code>
</code><code class="nv">$o2</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">3</code><code class="s2">"</code><code class="p">;</code><code>

</code><code class="k">if</code><code> </code><code class="p">(</code><code class="nv">$o1</code><code> </code><code class="o">==</code><code> </code><code class="nv">$o2</code><code class="p">)</code><code> </code><code class="p">{</code><code>
 </code><code class="k">echo</code><code class="p">(</code><code class="s2">"</code><code class="s2">== returns true&lt;br&gt;</code><code class="s2">"</code><code class="p">);</code><code>
</code><code class="p">}</code><code>
</code><code class="k">if</code><code> </code><code class="p">(</code><code class="nv">$o1</code><code> </code><code class="o">===</code><code> </code><code class="nv">$o2</code><code class="p">)</code><code> </code><code class="p">{</code><code>
 </code><code class="k">echo</code><code class="p">(</code><code class="s2">"</code><code class="s2">=== returns true&lt;br&gt;</code><code class="s2">"</code><code class="p">);</code><code>
</code><code class="p">}</code><code>
</code><strong><code class="o">==</code><code> </code><code class="nx">returns</code><code> </code><code class="k">true</code></strong></pre>

<p><a contenteditable="false" data-primary="greater than operator (&gt;)" data-type="indexterm" id="idm45922788498232"/><a contenteditable="false" data-primary="greater than or equal to operator (&gt;=)" data-type="indexterm" id="idm45922788436504"/><a contenteditable="false" data-primary="left angle bracket (&lt;)" data-secondary="less than operator" data-type="indexterm" id="idm45922788435432"/><a contenteditable="false" data-primary="left angle bracket, equals sign (&lt;=), less than or equal to operator" data-type="indexterm" id="idm45922788434056"/><a contenteditable="false" data-primary="less than operator (&lt;)" data-type="indexterm" id="idm45922788432984"/><a contenteditable="false" data-primary="less than or equal to operator (&lt;=)" data-type="indexterm" id="idm45922788431880"/><a contenteditable="false" data-primary="right angle bracket, equals sign (&gt;=), greater than or equal to operator" data-type="indexterm" id="idm45922788430808"/><a contenteditable="false" data-primary="right angle bracket (&gt;)" data-secondary="greater than operator" data-type="indexterm" id="idm45922788429736"/><a contenteditable="false" data-primary="&lt; (left angle bracket)" data-secondary="less than operator" data-type="indexterm" id="idm45922788428360"/><a contenteditable="false" data-primary="&lt;= (left angle bracket, equals sign), less than or equal to operator" data-type="indexterm" id="idm45922788426984"/><a contenteditable="false" data-primary="&gt; (right angle bracket)" data-secondary="greater than operator" data-type="indexterm" id="idm45922788409416"/><a contenteditable="false" data-primary="&gt;= (right angle bracket, equals sign), greater than or equal to operator" data-type="indexterm" id="idm45922788408200"/>The comparison operators (<code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>) also work on strings:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$him</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Fred</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$her</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Wilma</code><code class="s2">"</code><code class="p">;</code><code>

</code><code class="k">if</code><code> </code><code class="p">(</code><code class="nv">$him</code><code> </code><code class="o">&lt;</code><code> </code><code class="nv">$her</code><code class="p">)</code><code> </code><code class="p">{</code><code>
 </code><code class="k">print</code><code> </code><code class="s2">"</code><code class="si">{</code><code class="nv">$him</code><code class="si">}</code><code class="s2"> comes before </code><code class="si">{</code><code class="nv">$her</code><code class="si">}</code><code class="s2"> in the alphabet.</code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="p">}</code><code>
</code><strong><code class="nx">Fred</code><code> </code><code class="nx">comes</code><code> </code><code class="nx">before</code><code> </code><code class="nx">Wilma</code><code> </code><code class="nx">in</code><code> </code><code class="nx">the</code><code> </code><code class="nx">alphabet</code></strong></pre>

<p>However, the comparison operators give unexpected results when comparing strings and numbers:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">PHP Rocks</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$number</code><code> </code><code class="o">=</code><code> </code><code class="mi">5</code><code class="p">;</code><code>

</code><code class="k">if</code><code> </code><code class="p">(</code><code class="nv">$string</code><code> </code><code class="o">&lt;</code><code> </code><code class="nv">$number</code><code class="p">)</code><code> </code><code class="p">{</code><code>
 </code><code class="k">echo</code><code class="p">(</code><code class="s2">"</code><code class="si">{</code><code class="nv">$string</code><code class="si">}</code><code class="s2"> &lt; </code><code class="si">{</code><code class="nv">$number</code><code class="si">}</code><code class="s2">"</code><code class="p">);</code><code>
</code><code class="p">}</code><code>
</code><strong><code class="nx">PHP</code><code> </code><code class="nx">Rocks</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">5</code></strong></pre>

<p>When one argument to a comparison operator is a number, the other argument is cast to a number. This means that <code>"PHP Rocks"</code> is cast to a number, giving <code>0</code> (since the string does not start with a number). Because 0 is less than 5, PHP prints <code>"PHP Rocks &lt; 5"</code>.</p>

<p>To explicitly compare two strings as strings, casting numbers to strings if necessary, use the <a contenteditable="false" data-primary="strcmp function" data-type="indexterm" id="idm45922788289400"/><code>strcmp()</code> function:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$relationship</code><code> </code><code class="o">=</code><code> </code><code class="nb">strcmp</code><code class="p">(</code><em><code class="nx">string_1</code></em><code class="p">,</code><code> </code><em><code class="nx">string_2</code></em><code class="p">);</code></pre>

<p>The function returns a number less than 0 if <em>string_1</em> sorts before <em>string_2</em>, greater than 0 if <em>string_2</em> sorts before <em>string_1</em>, or 0 if they are the same:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$n</code><code> </code><code class="o">=</code><code> </code><code class="nb">strcmp</code><code class="p">(</code><code class="s2">"</code><code class="s2">PHP Rocks</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="mi">5</code><code class="p">);</code><code>
</code><code class="k">echo</code><code class="p">(</code><code class="nv">$n</code><code class="p">);</code><code>
</code><strong><code class="mi">1</code></strong></pre>

<p>A variation on <code>strcmp()</code> is <a contenteditable="false" data-primary="strcasecmp function" data-type="indexterm" id="idm45922788208024"/><code>strcasecmp()</code>, which converts strings to lowercase before comparing them. Its arguments and return values are the same as those for <code>strcmp()</code>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$n</code> <code class="o">=</code> <code class="nb">strcasecmp</code><code class="p">(</code><code class="s2">"Fred"</code><code class="p">,</code> <code class="s2">"frED"</code><code class="p">);</code> <code class="c1">// $n is 0</code></pre>

<p>Another variation on string comparison is to compare only the first few characters of the string. The <a contenteditable="false" data-primary="strncmp function" data-type="indexterm" id="idm45922788185640"/><code>strncmp()</code> and <a contenteditable="false" data-primary="strncasecmp function" data-type="indexterm" id="idm45922788184280"/><code>strncasecmp()</code> functions take an additional argument, the initial number of characters to use for the comparisons:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$relationship</code><code> </code><code class="o">=</code><code> </code><code class="nb">strncmp</code><code class="p">(</code><em><code class="nx">string_1</code></em><code class="p">,</code><code> </code><em><code class="nx">string_2</code></em><code class="p">,</code><code> </code><em><code class="nx">len</code></em><code class="p">);</code><code>
</code><code class="nv">$relationship</code><code> </code><code class="o">=</code><code> </code><code class="nb">strncasecmp</code><code class="p">(</code><em><code class="nx">string_1</code></em><code class="p">,</code><code> </code><em><code class="nx">string_2</code></em><code class="p">,</code><code> </code><em><code class="nx">len</code></em><code class="p">);</code></pre>

<p>The final variation on these functions is <em>natural-order</em> comparison with <a contenteditable="false" data-primary="strnatcmp function" data-type="indexterm" id="idm45922788125672"/><code>strnatcmp()</code> and <code>strnatcasecmp()</code>, which take the same arguments as <code>strcmp()</code> and return the same kinds of values. Natural-order comparison identifies numeric portions of the strings being compared and sorts the string parts separately from the numeric parts.</p>

<p><a data-type="xref" href="#natural_order_versus_ascii_order">Table 4-5</a> shows strings in natural order and ASCII order.<a contenteditable="false" data-primary="" data-startref="ix_exact_string_comp" data-type="indexterm" id="idm45922788121912"/></p>

<table class="border" id="natural_order_versus_ascii_order">
	<caption><span class="label">Table 4-5. </span>Natural order versus ASCII order</caption>
	<thead>
		<tr>
			<th>Natural order</th>
			<th>ASCII order</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>pic1.jpg</code></td>
			<td><code>pic1.jpg</code></td>
		</tr>
		<tr>
			<td><code>pic5.jpg</code></td>
			<td><code>pic10.jpg</code></td>
		</tr>
		<tr>
			<td><code>pic10.jpg</code></td>
			<td><code>pic5.jpg</code></td>
		</tr>
		<tr>
			<td><code>pic50.jpg</code></td>
			<td><code>pic50.jpg</code></td>
		</tr>
	</tbody>
</table>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Approximate Equality"><div class="sect2" id="approximate_equality">
<h2>Approximate Equality</h2>

<p><a contenteditable="false" data-primary="approximate equality, string comparisons" data-type="indexterm" id="ix_approx_equal_compar"/>PHP provides several functions that let you test whether two strings are approximately equal—<a contenteditable="false" data-primary="metaphone function" data-type="indexterm" id="idm45922788094024"/><a contenteditable="false" data-primary="soundex function" data-type="indexterm" id="idm45922788092984"/><code>soundex()</code>, <code>metaphone()</code>, <code>similar_text()</code>, and <a contenteditable="false" data-primary="levenshtein function" data-type="indexterm" id="idm45922788090568"/><code>levenshtein()</code>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$soundexCode</code><code> </code><code class="o">=</code><code> </code><code class="nb">soundex</code><code class="p">(</code><em><code class="nv">$string</code></em><code class="p">);</code><code>
</code><code class="nv">$metaphoneCode</code><code> </code><code class="o">=</code><code> </code><code class="nb">metaphone</code><code class="p">(</code><em><code class="nv">$string</code></em><code class="p">);</code><code>
</code><code class="nv">$inCommon</code><code> </code><code class="o">=</code><code> </code><code class="nb">similar_text</code><code class="p">(</code><em><code class="nv">$string_1</code></em><code class="p">,</code><code> </code><em><code class="nv">$string_2</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nv">$percentage</code></em><code> </code><code class="p">]);</code><code>
</code><code class="nv">$similarity</code><code> </code><code class="o">=</code><code> </code><code class="nb">levenshtein</code><code class="p">(</code><em><code class="nv">$string_1</code></em><code class="p">,</code><code> </code><em><code class="nv">$string_2</code></em><code class="p">);</code><code>
</code><code class="nv">$similarity</code><code> </code><code class="o">=</code><code> </code><code class="nb">levenshtein</code><code class="p">(</code><em><code class="nv">$string_1</code></em><code class="p">,</code><code> </code><em><code class="nv">$string_2</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nv">$cost_ins</code></em><code class="p">,</code><code> </code><em><code class="nv">$cost_rep</code></em><code class="p">,</code><code> 
</code><em><code class="nv">$cost_del</code></em><code> </code><code class="p">]);</code></pre>

<p>The <a contenteditable="false" data-primary="Soundex algorithm" data-type="indexterm" id="idm45922788019336"/>Soundex and <a contenteditable="false" data-primary="Metaphone algorithm" data-type="indexterm" id="idm45922788018168"/>Metaphone algorithms each yield a string that represents roughly how a word is pronounced in English. To see whether two strings are approximately equal with these algorithms, compare their pronunciations. You can compare Soundex values only to Soundex values and Metaphone values only to Metaphone values. The Metaphone algorithm is generally more accurate, as the following example <span class="keep-together">demonstrates:</span></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$known</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Fred</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$query</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Phred</code><code class="s2">"</code><code class="p">;</code><code>

</code><code class="k">if</code><code> </code><code class="p">(</code><code class="nb">soundex</code><code class="p">(</code><code class="nv">$known</code><code class="p">)</code><code> </code><code class="o">==</code><code> </code><code class="nb">soundex</code><code class="p">(</code><code class="nv">$query</code><code class="p">))</code><code> </code><code class="p">{</code><code>
 </code><code class="k">print</code><code> </code><code class="s2">"</code><code class="s2">soundex: </code><code class="si">{</code><code class="nv">$known</code><code class="si">}</code><code class="s2"> sounds like </code><code class="si">{</code><code class="nv">$query</code><code class="si">}</code><code class="s2">&lt;br&gt;</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="p">}</code><code>
</code><code class="k">else</code><code> </code><code class="p">{</code><code>
 </code><code class="k">print</code><code> </code><code class="s2">"</code><code class="s2">soundex: </code><code class="si">{</code><code class="nv">$known</code><code class="si">}</code><code class="s2"> doesn't sound like </code><code class="si">{</code><code class="nv">$query</code><code class="si">}</code><code class="s2">&lt;br&gt;</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="p">}</code><code>

</code><code class="k">if</code><code> </code><code class="p">(</code><code class="nb">metaphone</code><code class="p">(</code><code class="nv">$known</code><code class="p">)</code><code> </code><code class="o">==</code><code> </code><code class="nb">metaphone</code><code class="p">(</code><code class="nv">$query</code><code class="p">))</code><code> </code><code class="p">{</code><code>
 </code><code class="k">print</code><code> </code><code class="s2">"</code><code class="s2">metaphone: </code><code class="si">{</code><code class="nv">$known</code><code class="si">}</code><code class="s2"> sounds like </code><code class="si">{</code><code class="nv">$query</code><code class="si">}</code><code class="s2">&lt;br&gt;</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="p">}</code><code>
</code><code class="k">else</code><code> </code><code class="p">{</code><code>
 </code><code class="k">print</code><code> </code><code class="s2">"</code><code class="s2">metaphone: </code><code class="si">{</code><code class="nv">$known</code><code class="si">}</code><code class="s2"> doesn't sound like </code><code class="si">{</code><code class="nv">$query</code><code class="si">}</code><code class="s2">&lt;br&gt;</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="p">}</code><code>
</code><strong><code class="nb">soundex</code><code class="o">:</code><code> </code><code class="nx">Fred</code><code> </code><code class="nx">doesn</code><code class="err">'</code><code class="nx">t</code><code> </code><code class="nx">sound</code><code> </code><code class="nx">like</code><code> </code><code class="nx">Phred</code></strong><code>
</code><strong><code class="nb">metaphone</code><code class="o">:</code><code> </code><code class="nx">Fred</code><code> </code><code class="nx">sounds</code><code> </code><code class="nx">like</code><code> </code><code class="nx">Phred</code></strong></pre>

<p>The <a contenteditable="false" data-primary="similar_text function" data-type="indexterm" id="idm45922787993640"/><code>similar_text()</code> function returns the number of characters that its two string arguments have in common. The third argument, if present, is a variable in which to store the commonality as a percentage:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string1</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Rasmus Lerdorf</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$string2</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Razmus Lehrdorf</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$common</code><code> </code><code class="o">=</code><code> </code><code class="nb">similar_text</code><code class="p">(</code><code class="nv">$string1</code><code class="p">,</code><code> </code><code class="nv">$string2</code><code class="p">,</code><code> </code><code class="nv">$percent</code><code class="p">);</code><code>
</code><code class="nb">printf</code><code class="p">(</code><code class="s2">"</code><code class="s2">They have %d chars in common (%.2f%%).</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="nv">$common</code><code class="p">,</code><code> </code><code class="nv">$percent</code><code class="p">);</code><code>
</code><strong><code class="nx">They</code><code> </code><code class="nx">have</code><code> </code><code class="mi">13</code><code> </code><code class="nx">chars</code><code> </code><code class="nx">in</code><code> </code><code class="nx">common</code><code> </code><code class="p">(</code><code class="mf">89.66</code><code class="o">%</code><code class="p">)</code><code class="o">.</code></strong></pre>

<p><a contenteditable="false" data-primary="Levenshtein algorithm" data-type="indexterm" id="idm45922787856216"/>The Levenshtein algorithm calculates the similarity of two strings based on how many characters you must add, substitute, or remove to make them the same. For instance, <code>"cat"</code> and <code>"cot"</code> have a Levenshtein distance of 1, because you need to change only one character (the <code>"a"</code> to an <code>"o"</code>) to make them the same:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$similarity</code> <code class="o">=</code> <code class="nb">levenshtein</code><code class="p">(</code><code class="s2">"cat"</code><code class="p">,</code> <code class="s2">"cot"</code><code class="p">);</code> <code class="c1">// $similarity is 1</code></pre>

<p>This measure of similarity is generally quicker to calculate than that used by the <span class="keep-together"><code>similar_text()</code></span> function. Optionally, you can pass three values to the <code>leven</code><span class="keep-together"><code>shtein()</code></span> function to individually weight insertions, deletions, and replacements—for instance, to compare a word against a contraction.</p>

<p>This example excessively weights insertions when comparing a string against its possible contraction, because contractions should never insert characters:<a contenteditable="false" data-primary="" data-startref="ix_strings_comparing_ch4" data-type="indexterm" id="idm45922787965960"/><a contenteditable="false" data-primary="" data-startref="ix_approx_equal_compar" data-type="indexterm" id="idm45922787964648"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code> <code class="nb">levenshtein</code><code class="p">(</code><code class="s1">'would not'</code><code class="p">,</code> <code class="s1">'wouldn\'t'</code><code class="p">,</code> <code class="mi">500</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code></pre>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Manipulating and Searching Strings"><div class="sect1" id="manipulating_and_searching_strings">
<h1>Manipulating and Searching Strings</h1>

<p>PHP has many functions to work with strings. The most commonly used functions for searching and modifying strings are those that use regular expressions to describe the string in question. The functions described in this section do not use regular expressions—they are faster than regular expressions, but they work only when you’re looking for a fixed string (for instance, if you’re looking for <code>"12/11/01"</code> rather than “any numbers separated by slashes”).</p>

<section data-type="sect2" data-pdf-bookmark="Substrings"><div class="sect2" id="substrings">
<h2>Substrings</h2>

<p><a contenteditable="false" data-primary="substrings" data-type="indexterm" id="ix_substrings_ch4"/><a contenteditable="false" data-primary="strings" data-secondary="substrings of" data-type="indexterm" id="ix_strings_substrings"/>If you know where the data that you are interested in lies in a larger string, you can copy it out with the <a contenteditable="false" data-primary="substr function" data-type="indexterm" id="idm45922787669096"/><code>substr()</code> function:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$piece</code><code> </code><code class="o">=</code><code> </code><code class="nb">substr</code><code class="p">(</code><em><code class="nx">string</code></em><code class="p">,</code><code> </code><em><code class="nx">start</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">length</code></em><code> </code><code class="p">]);</code></pre>

<p>The <em>start</em> argument is the position in <em>string</em> at which to begin copying, with <code>0</code> meaning the start of the string. The <em>length</em> argument is the number of characters to copy (the default is to copy until the end of the string). For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$name</code> <code class="o">=</code> <code class="s2">"Fred Flintstone"</code><code class="p">;</code>
<code class="nv">$fluff</code> <code class="o">=</code> <code class="nb">substr</code><code class="p">(</code><code class="nv">$name</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">4</code><code class="p">);</code> <code class="c1">// $fluff is "lint"</code>
<code class="nv">$sound</code> <code class="o">=</code> <code class="nb">substr</code><code class="p">(</code><code class="nv">$name</code><code class="p">,</code> <code class="mi">11</code><code class="p">);</code> <code class="c1">// $sound is "tone"</code></pre>

<p>To learn how many times a smaller string occurs within a larger one, use <a contenteditable="false" data-primary="substr_count function" data-type="indexterm" id="idm45922787594680"/><code>substr_count()</code>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$number</code><code> </code><code class="o">=</code><code> </code><code class="nb">substr_count</code><code class="p">(</code><em><code class="nx">big_string</code></em><code class="p">,</code><code> </code><em><code class="nx">small_string</code></em><code class="p">);</code></pre>

<p>For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$sketch</code><code> </code><code class="o">=</code><code> </code><code class="o">&lt;&lt;&lt;</code><code> </code><code class="nx">EndOfSketch</code><code>
</code><code class="nx">Well</code><code class="p">,</code><code> </code><code class="nx">there</code><code class="err">'</code><code class="nx">s</code><code> </code><code class="nx">egg</code><code> </code><code class="k">and</code><code> </code><code class="nx">bacon</code><code class="p">;</code><code> </code><code class="nx">egg</code><code> </code><code class="nx">sausage</code><code> </code><code class="k">and</code><code> </code><code class="nx">bacon</code><code class="p">;</code><code> </code><code class="nx">egg</code><code> </code><code class="k">and</code><code> </code><code class="nx">spam</code><code class="p">;</code><code>
</code><code class="nx">egg</code><code> </code><code class="nx">bacon</code><code> </code><code class="k">and</code><code> </code><code class="nx">spam</code><code class="p">;</code><code> </code><code class="nx">egg</code><code> </code><code class="nx">bacon</code><code> </code><code class="nx">sausage</code><code> </code><code class="k">and</code><code> </code><code class="nx">spam</code><code class="p">;</code><code> </code><code class="nx">spam</code><code> </code><code class="nx">bacon</code><code> </code><code class="nx">sausage</code><code>
</code><code class="k">and</code><code> </code><code class="nx">spam</code><code class="p">;</code><code> </code><code class="nx">spam</code><code> </code><code class="nx">egg</code><code> </code><code class="nx">spam</code><code> </code><code class="nx">spam</code><code> </code><code class="nx">bacon</code><code> </code><code class="k">and</code><code> </code><code class="nx">spam</code><code class="p">;</code><code> </code><code class="nx">spam</code><code> </code><code class="nx">sausage</code><code> </code><code class="nx">spam</code><code> </code><code class="nx">spam</code><code>
</code><code class="nx">bacon</code><code> </code><code class="nx">spam</code><code> </code><code class="nx">tomato</code><code> </code><code class="k">and</code><code> </code><code class="nx">spam</code><code class="p">;</code><code>
</code><code class="nx">EndOfSketch</code><code class="p">;</code><code>
</code><code class="nv">$count</code><code> </code><code class="o">=</code><code> </code><code class="nb">substr_count</code><code class="p">(</code><code class="nv">$sketch</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">spam</code><code class="s2">"</code><code class="p">);</code><code>
</code><code class="k">print</code><code class="p">(</code><code class="s2">"</code><code class="s2">The word spam occurs </code><code class="si">{</code><code class="nv">$count</code><code class="si">}</code><code class="s2"> times.</code><code class="s2">"</code><code class="p">);</code><code>
</code><strong><code class="nx">The</code><code> </code><code class="nx">word</code><code> </code><code class="nx">spam</code><code> </code><code class="nx">occurs</code><code> </code><code class="mi">14</code><code> </code><code class="nx">times</code><code class="o">.</code></strong></pre>

<p>The <a contenteditable="false" data-primary="substr_replace function" data-type="indexterm" id="idm45922787367016"/><code>substr_replace()</code> function permits many kinds of string modifications:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="nb">substr_replace</code><code class="p">(</code><em><code class="nx">original</code></em><code class="p">,</code><code> </code><em><code class="k">new</code></em><code class="p">,</code><code> </code><em><code class="nx">start</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">length</code></em><code> </code><code class="p">]);</code></pre>

<p>The function replaces the part of <em>original</em> indicated by the <em>start</em> (<code>0</code> means the start of the string) and <em>length</em> values with the string <em>new</em>. If no fourth argument is given, <code>substr_replace()</code> removes the text from <em>start</em> to the end of the string.</p>

<p>For instance:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$greeting</code> <code class="o">=</code> <code class="s2">"good morning citizen"</code><code class="p">;</code>
<code class="nv">$farewell</code> <code class="o">=</code> <code class="nb">substr_replace</code><code class="p">(</code><code class="nv">$greeting</code><code class="p">,</code> <code class="s2">"bye"</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">);</code>
<code class="c1">// $farewell is "good bye citizen"</code></pre>

<p>Use a <em>length</em> of <code>0</code> to insert without deleting:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$farewell</code> <code class="o">=</code> <code class="nb">substr_replace</code><code class="p">(</code><code class="nv">$farewell</code><code class="p">,</code> <code class="s2">"kind "</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
<code class="c1">// $farewell is "good bye kind citizen"</code></pre>

<p>Use a replacement of <code>""</code> to delete without inserting:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$farewell</code> <code class="o">=</code> <code class="nb">substr_replace</code><code class="p">(</code><code class="nv">$farewell</code><code class="p">,</code> <code class="s2">""</code><code class="p">,</code> <code class="mi">8</code><code class="p">);</code>
<code class="c1">// $farewell is "good bye"</code></pre>

<p>Here’s how you can insert at the beginning of the string:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$farewell</code> <code class="o">=</code> <code class="nb">substr_replace</code><code class="p">(</code><code class="nv">$farewell</code><code class="p">,</code> <code class="s2">"now it's time to say "</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
<code class="c1">// $farewell is "now it's time to say good bye"'</code></pre>

<p>A negative value for <em>start</em> indicates the number of characters from the end of the string from which to start the replacement:<a contenteditable="false" data-primary="" data-startref="ix_strings_substrings" data-type="indexterm" id="idm45922787242568"/><a contenteditable="false" data-primary="" data-startref="ix_substrings_ch4" data-type="indexterm" id="idm45922787241288"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$farewell</code> <code class="o">=</code> <code class="nb">substr_replace</code><code class="p">(</code><code class="nv">$farewell</code><code class="p">,</code> <code class="s2">"riddance"</code><code class="p">,</code> <code class="nx">−3</code><code class="p">);</code>
<code class="c1">// $farewell is "now it's time to say good riddance"</code></pre>

<p>A negative <em>length</em> indicates the number of characters from the end of the string at which to stop deleting:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$farewell</code> <code class="o">=</code> <code class="nb">substr_replace</code><code class="p">(</code><code class="nv">$farewell</code><code class="p">,</code> <code class="s2">""</code><code class="p">,</code> <code class="nx">−8</code><code class="p">,</code> <code class="nx">−5</code><code class="p">);</code>
<code class="c1">// $farewell is "now it's time to say good dance"</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Miscellaneous String Functions"><div class="sect2" id="miscellaneous_string_functions">
<h2>Miscellaneous String Functions</h2>

<p><a contenteditable="false" data-primary="functions" data-secondary="miscellaneous" data-type="indexterm" id="idm45922787194152"/><a contenteditable="false" data-primary="functions" data-secondary="strings" data-type="indexterm" id="idm45922787200472"/><a contenteditable="false" data-primary="strings" data-secondary="reversing" data-type="indexterm" id="idm45922787199096"/>The <a contenteditable="false" data-primary="strrev function" data-type="indexterm" id="idm45922787149128"/><code>strrev()</code> function takes a string and returns a reversed copy of it:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="nb">strrev</code><code class="p">(</code><em><code class="nx">string</code></em><code class="p">);</code></pre>

<p class="pagebreak-before">For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code><code> </code><code class="nb">strrev</code><code class="p">(</code><code class="s2">"</code><code class="s2">There is no cabal</code><code class="s2">"</code><code class="p">);</code><code>
</code><strong><code class="nx">labac</code><code> </code><code class="nx">on</code><code> </code><code class="nx">si</code><code> </code><code class="nx">erehT</code></strong></pre>

<p><a contenteditable="false" data-primary="strings" data-secondary="repeating" data-type="indexterm" id="idm45922787082776"/>The <a contenteditable="false" data-primary="str_repeat function" data-type="indexterm" id="idm45922787081368"/><code>str_repeat()</code> function takes a string and a count and returns a new string consisting of the argument <em>string</em> repeated <em>count</em> times:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$repeated</code><code> </code><code class="o">=</code><code> </code><code class="nb">str_repeat</code><code class="p">(</code><em><code class="nx">string</code></em><code class="p">,</code><code> </code><em><code class="nb">count</code></em><code class="p">);</code></pre>

<p>For example, to build a crude wavy horizontal rule:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code> <code class="nb">str_repeat</code><code class="p">(</code><code class="s1">'_.-.'</code><code class="p">,</code> <code class="mi">40</code><code class="p">);</code></pre>

<p>The <a contenteditable="false" data-primary="str_pad function" data-type="indexterm" id="idm45922787049640"/><a contenteditable="false" data-primary="strings" data-secondary="padding with another string" data-type="indexterm" id="idm45922787048632"/><code>str_pad()</code> function pads one string with another. Optionally, you can say what string to pad with, and whether to pad on the left, right, or both:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$padded</code><code> </code><code class="o">=</code><code> </code><code class="nb">str_pad</code><code class="p">(</code><em><code class="nx">to_pad</code></em><code class="p">,</code><code> </code><em><code class="nx">length</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">with</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">pad_type</code></em><code> </code><code class="p">]]);</code></pre>

<p>The default is to pad on the right with spaces:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="nb">str_pad</code><code class="p">(</code><code class="s1">'Fred Flintstone'</code><code class="p">,</code><code> </code><code class="mi">30</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="si">{</code><code class="nv">$string</code><code class="si">}</code><code class="s2">:35:Wilma</code><code class="s2">"</code><code class="p">;</code><code>
</code><strong><code class="nx">Fred</code><code> </code><code class="nx">Flintstone</code><code> </code><code class="o">:</code><code class="mi">35</code><code class="o">:</code><code class="nx">Wilma</code></strong></pre>

<p>The optional third argument is the string to pad with:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="nb">str_pad</code><code class="p">(</code><code class="s1">'Fred Flintstone'</code><code class="p">,</code><code> </code><code class="mi">30</code><code class="p">,</code><code> </code><code class="s1">'. '</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="si">{</code><code class="nv">$string</code><code class="si">}</code><code class="s2">35</code><code class="s2">"</code><code class="p">;</code><code>
</code><strong><code class="nx">Fred</code><code> </code><code class="nx">Flintstone</code><code class="o">.</code><code> </code><code class="o">.</code><code> </code><code class="o">.</code><code> </code><code class="o">.</code><code> </code><code class="o">.</code><code> </code><code class="o">.</code><code> </code><code class="o">.</code><code> </code><code class="o">.</code><code class="mi">35</code></strong></pre>

<p>The optional fourth argument can be <code>STR_PAD_RIGHT</code> (the default), <code>STR_PAD_LEFT</code>, or <code>STR_PAD_BOTH</code> (to center). For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code><code> </code><code class="s1">'['</code><code> </code><code class="o">.</code><code> </code><code class="nb">str_pad</code><code class="p">(</code><code class="s1">'Fred Flintstone'</code><code class="p">,</code><code> </code><code class="mi">30</code><code class="p">,</code><code> </code><code class="s1">' '</code><code class="p">,</code><code> </code><code class="nx">STR_PAD_LEFT</code><code class="p">)</code><code> </code><code class="o">.</code><code> </code><code class="s2">"</code><code class="s2">]</code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="k">echo</code><code> </code><code class="s1">'['</code><code> </code><code class="o">.</code><code> </code><code class="nb">str_pad</code><code class="p">(</code><code class="s1">'Fred Flintstone'</code><code class="p">,</code><code> </code><code class="mi">30</code><code class="p">,</code><code> </code><code class="s1">' '</code><code class="p">,</code><code> </code><code class="nx">STR_PAD_BOTH</code><code class="p">)</code><code> </code><code class="o">.</code><code> </code><code class="s2">"</code><code class="s2">]</code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code><code>
</code><strong><code class="p">[</code><code> </code><code class="nx">Fred</code><code> </code><code class="nx">Flintstone</code><code class="p">]</code></strong><code>
</code><strong><code class="p">[</code><code> </code><code class="nx">Fred</code><code> </code><code class="nx">Flintstone</code><code> </code><code class="p">]</code></strong></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Decomposing a String"><div class="sect2" id="decomposing_a_string">
<h2>Decomposing a String</h2>

<p><a contenteditable="false" data-primary="strings" data-secondary="decomposing" data-type="indexterm" id="ix_strings_decompose"/><a contenteditable="false" data-primary="decomposing a string" data-type="indexterm" id="ix_decompose_string"/>PHP provides several functions to let you break a string into smaller components. In increasing order of complexity, they are <code>explode()</code>, <code>strtok()</code>, and <code>sscanf()</code>.</p>

<section data-type="sect3" data-pdf-bookmark="Exploding and imploding"><div class="sect3" id="exploding_and_imploding">
<h3>Exploding and imploding</h3>

<p>Data often arrives as strings, which must be broken down into an array of values. For instance, you might want to split up the comma-separated fields from a string such as <code>"Fred,25,Wilma</code>.<code>"</code> In these situations, use the <a contenteditable="false" data-primary="explode function" data-type="indexterm" id="idm45922786782936"/><code>explode()</code> function:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$array</code><code> </code><code class="o">=</code><code> </code><code class="nb">explode</code><code class="p">(</code><em><code class="nx">separator</code></em><code class="p">,</code><code> </code><em><code class="nx">string</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">limit</code></em><code class="p">]);</code></pre>

<p>The first argument, <em>separator</em>, is a string containing the field separator. The second argument, <em>string</em>, is the string to split. The optional third argument, <em>limit</em>, is the maximum number of values to return in the array. If the limit is reached, the last element of the array contains the remainder of the string:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$input</code> <code class="o">=</code> <code class="s1">'Fred,25,Wilma'</code><code class="p">;</code>
<code class="nv">$fields</code> <code class="o">=</code> <code class="nb">explode</code><code class="p">(</code><code class="s1">','</code><code class="p">,</code> <code class="nv">$input</code><code class="p">);</code>
<code class="c1">// $fields is array('Fred', '25', 'Wilma')</code>
<code class="nv">$fields</code> <code class="o">=</code> <code class="nb">explode</code><code class="p">(</code><code class="s1">','</code><code class="p">,</code> <code class="nv">$input</code><code class="p">,</code> <code class="mi">2</code><code class="p">);</code>
<code class="c1">// $fields is array('Fred', '25,Wilma')</code></pre>

<p>The <a contenteditable="false" data-primary="implode function" data-type="indexterm" id="idm45922786706008"/><code>implode()</code> function does the exact opposite of <code>explode()</code>—it creates a large string from an array of smaller strings:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="nb">implode</code><code class="p">(</code><em><code class="nx">separator</code></em><code class="p">,</code><code> </code><em><code class="k">array</code></em><code class="p">);</code></pre>

<p>The first argument, <em>separator</em>, is the string to put between the elements of the second argument, <em>array</em>. To reconstruct the simple comma-separated value string, simply say:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$fields</code> <code class="o">=</code> <code class="k">array</code><code class="p">(</code><code class="s1">'Fred'</code><code class="p">,</code> <code class="s1">'25'</code><code class="p">,</code> <code class="s1">'Wilma'</code><code class="p">);</code>
<code class="nv">$string</code> <code class="o">=</code> <code class="nb">implode</code><code class="p">(</code><code class="s1">','</code><code class="p">,</code> <code class="nv">$fields</code><code class="p">);</code> <code class="c1">// $string is 'Fred,25,Wilma'</code></pre>

<p>The <a contenteditable="false" data-primary="join function" data-type="indexterm" id="idm45922786642680"/><code>join()</code> function is an alias for <code>implode()</code>.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Tokenizing"><div class="sect3" id="tokenizing">
<h3>Tokenizing</h3>

<p><a contenteditable="false" data-primary="tokenizer" data-secondary-sortas="strings" data-secondary="for strings" data-type="indexterm" id="idm45922786639064"/>The <code>strtok()</code> function lets you iterate through a string, getting a new chunk (token) each time. The first time you call it, you need to pass two arguments: the string to iterate over and the token separator. For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$firstChunk</code><code> </code><code class="o">=</code><code> </code><code class="nb">strtok</code><code class="p">(</code><em><code class="nx">string</code></em><code class="p">,</code><code> </code><em><code class="nx">separator</code></em><code class="p">);</code></pre>

<p>To retrieve the rest of the tokens, repeatedly call <code>strtok()</code> with only the separator:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$nextChunk</code><code> </code><code class="o">=</code><code> </code><code class="nb">strtok</code><code class="p">(</code><em><code class="nx">separator</code></em><code class="p">);</code></pre>

<p>For instance, consider this invocation:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Fred,Flintstone,35,Wilma</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$token</code><code> </code><code class="o">=</code><code> </code><code class="nb">strtok</code><code class="p">(</code><code class="nv">$string</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">,</code><code class="s2">"</code><code class="p">);</code><code>

</code><code class="k">while</code><code> </code><code class="p">(</code><code class="nv">$token</code><code> </code><code class="o">!==</code><code> </code><code class="k">false</code><code class="p">)</code><code> </code><code class="p">{</code><code>
 </code><code class="k">echo</code><code class="p">(</code><code class="s2">"</code><code class="si">{</code><code class="nv">$token</code><code class="si">}</code><code class="s2">&lt;br /&gt;</code><code class="s2">"</code><code class="p">);</code><code>
 </code><code class="nv">$token</code><code> </code><code class="o">=</code><code> </code><code class="nb">strtok</code><code class="p">(</code><code class="s2">"</code><code class="s2">,</code><code class="s2">"</code><code class="p">);</code><code>
</code><code class="p">}</code><code>
</code><strong><code class="nx">Fred</code></strong><code>
</code><strong><code class="nx">Flintstone</code></strong><code>
</code><strong><code class="mi">35</code></strong><code>
</code><strong><code class="nx">Wilma</code></strong></pre>

<p>The <a contenteditable="false" data-primary="strtok function" data-type="indexterm" id="idm45922786571656"/><code>strtok()</code> function returns <code>false</code> when there are no more tokens to be returned.</p>

<p>Call <code>strtok()</code> with two arguments to reinitialize the iterator. This restarts the tokenizer from the start of the string.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="sscanf()"><div class="sect3" id="sscanfleft_parenthesisright_parenthesis">
<h3>sscanf()</h3>

<p><a contenteditable="false" data-primary="sscanf function" data-type="indexterm" id="idm45922786468776"/>The <code>sscanf()</code> function decomposes a string according to a <code>printf()</code>-like template:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$array</code><code> </code><code class="o">=</code><code> </code><code class="nb">sscanf</code><code class="p">(</code><em><code class="nx">string</code></em><code class="p">,</code><code> </code><em><code class="nx">template</code></em><code class="p">);</code><code>
</code><code class="nv">$count</code><code> </code><code class="o">=</code><code> </code><code class="nb">sscanf</code><code class="p">(</code><em><code class="nx">string</code></em><code class="p">,</code><code> </code><em><code class="nx">template</code></em><code class="p">,</code><code> </code><em><code class="nx">var1</code></em><code class="p">,</code><code> </code><code class="o">...</code><code> </code><code class="p">);</code></pre>

<p>If used without the optional variables, <code>sscanf()</code> returns an array of fields:<a contenteditable="false" data-primary="" data-startref="ix_decompose_string" data-type="indexterm" id="idm45922786417448"/><a contenteditable="false" data-primary="" data-startref="ix_strings_decompose" data-type="indexterm" id="idm45922786416200"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Fred</code><code class="se">\t</code><code class="s2">Flintstone (35)</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$a</code><code> </code><code class="o">=</code><code> </code><code class="nb">sscanf</code><code class="p">(</code><code class="nv">$string</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">%s</code><code class="se">\t</code><code class="s2">%s (%d)</code><code class="s2">"</code><code class="p">);</code><code>
</code><code class="nb">print_r</code><code class="p">(</code><code class="nv">$a</code><code class="p">);</code><code>
</code><strong><code class="k">Array</code></strong><code>
</code><strong><code class="p">(</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">Fred</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">Flintstone</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="mi">35</code><code class="p">)</code></strong></pre>

<p>Pass references to variables to have the fields stored in those variables. The number of fields assigned is returned:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Fred</code><code class="se">\t</code><code class="s2">Flintstone (35)</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$n</code><code> </code><code class="o">=</code><code> </code><code class="nb">sscanf</code><code class="p">(</code><code class="nv">$string</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">%s</code><code class="se">\t</code><code class="s2">%s (%d)</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="nv">$first</code><code class="p">,</code><code> </code><code class="nv">$last</code><code class="p">,</code><code> </code><code class="nv">$age</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="s2">"</code><code class="s2">Matched </code><code class="si">{</code><code class="nv">$n</code><code class="si">}</code><code class="s2"> fields: </code><code class="si">{</code><code class="nv">$first</code><code class="si">}</code><code class="s2"> </code><code class="si">{</code><code class="nv">$last</code><code class="si">}</code><code class="s2"> is </code><code class="si">{</code><code class="nv">$age</code><code class="si">}</code><code class="s2"> years old</code><code class="s2">"</code><code class="p">;</code><code>
</code><strong><code class="nx">Matched</code><code> </code><code class="mi">3</code><code> </code><code class="nx">fields</code><code class="o">:</code><code> </code><code class="nx">Fred</code><code> </code><code class="nx">Flintstone</code><code> </code><code class="nx">is</code><code> </code><code class="mi">35</code><code> </code><code class="nx">years</code><code> </code><code class="nx">old</code></strong></pre>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="String-Searching Functions"><div class="sect2" id="string_searching_functions">
<h2>String-Searching Functions</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="searching" data-secondary="strings" id="ix_search_strings_ch4"/><a contenteditable="false" data-type="indexterm" data-primary="strings" data-secondary="searching" data-seealso="regular expressions" id="ix_strings_search_ch4"/>Several functions find a string or character within a larger string. They come in three families: <code>strpos()</code> and <code>strrpos()</code>, which return a position; <code>strstr()</code>, <code>strchr()</code>, and friends, which return the string they find; and <code>strspn()</code> and <code>strcspn()</code>, which return how much of the start of the string matches a mask.</p>

<p>In all cases, if you specify a number as the “string” to search for, PHP treats that number as the ordinal value of the character to search for. Thus, these function calls are identical because 44 is the ASCII value of the comma:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$pos</code> <code class="o">=</code> <code class="nb">strpos</code><code class="p">(</code><code class="nv">$large</code><code class="p">,</code> <code class="s2">","</code><code class="p">);</code> <code class="c1">// find first comma</code>
<code class="nv">$pos</code> <code class="o">=</code> <code class="nb">strpos</code><code class="p">(</code><code class="nv">$large</code><code class="p">,</code> <code class="mi">44</code><code class="p">);</code> <code class="c1">// also find first comma</code></pre>

<p>All the string-searching functions return <code>false</code> if they can’t find the substring you specified. If the substring occurs at the beginning of the string, the functions return <code>0</code>. Because <code>false</code> casts to the number <code>0</code>, always compare the return value with <code>===</code> when testing for failure:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">if</code> <code class="p">(</code><code class="nv">$pos</code> <code class="o">===</code> <code class="k">false</code><code class="p">)</code> <code class="p">{</code>
 <code class="c1">// wasn't found</code>
<code class="p">}</code>
<code class="k">else</code> <code class="p">{</code>
 <code class="c1">// was found, $pos is offset into string</code>
<code class="p">}</code></pre>

<section data-type="sect3" data-pdf-bookmark="Searches returning position"><div class="sect3" id="searches_returning_position">
<h3>Searches returning position</h3>

<p>The <a contenteditable="false" data-primary="strpos function" data-type="indexterm" id="idm45922786189064"/><code>strpos()</code> function finds the first occurrence of a small string in a larger string:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$position</code><code> </code><code class="o">=</code><code> </code><code class="nb">strpos</code><code class="p">(</code><em><code class="nx">large_string</code></em><code class="p">,</code><code> </code><em><code class="nx">small_string</code></em><code class="p">);</code></pre>

<p>If the small string isn’t found, <code>strpos()</code> returns <code>false</code>.</p>

<p>The <a contenteditable="false" data-primary="strrpos function" data-type="indexterm" id="idm45922786156408"/><code>strrpos()</code> function finds the last occurrence of a character in a string. It takes the same arguments and returns the same type of value as <code>strpos()</code>.</p>

<p>For instance:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$record</code><code> </code><code class="o">=</code><code> </code><code class="s2">"</code><code class="s2">Fred,Flintstone,35,Wilma</code><code class="s2">"</code><code class="p">;</code><code>
</code><code class="nv">$pos</code><code> </code><code class="o">=</code><code> </code><code class="nb">strrpos</code><code class="p">(</code><code class="nv">$record</code><code class="p">,</code><code> </code><code class="s2">"</code><code class="s2">,</code><code class="s2">"</code><code class="p">);</code><code> </code><code class="c1">// find last comma
</code><code class="k">echo</code><code class="p">(</code><code class="s2">"</code><code class="s2">The last comma in the record is at position </code><code class="si">{</code><code class="nv">$pos</code><code class="si">}</code><code class="s2">"</code><code class="p">);</code><code>
</code><strong><code class="nx">The</code><code> </code><code class="nx">last</code><code> </code><code class="nx">comma</code><code> </code><code class="nx">in</code><code> </code><code class="nx">the</code><code> </code><code class="nx">record</code><code> </code><code class="nx">is</code><code> </code><code class="nx">at</code><code> </code><code class="nx">position</code><code> </code><code class="mi">18</code></strong></pre>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Searches returning rest of string"><div class="sect3" id="searches_returning_rest_of_string">
<h3>Searches returning rest of string</h3>

<p>The <a contenteditable="false" data-primary="strstr function" data-type="indexterm" id="idm45922786040472"/><code>strstr()</code> function finds the first occurrence of a small string in a larger string and returns from that small string on. For instance:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$record</code> <code class="o">=</code> <code class="s2">"Fred,Flintstone,35,Wilma"</code><code class="p">;</code>
<code class="nv">$rest</code> <code class="o">=</code> <code class="nb">strstr</code><code class="p">(</code><code class="nv">$record</code><code class="p">,</code> <code class="s2">","</code><code class="p">);</code> <code class="c1">// $rest is ",Flintstone,35,Wilma"</code></pre>

<p>The variations on <code>strstr()</code> are:</p>

<dl>
	<dt><a contenteditable="false" data-primary="stristr function" data-type="indexterm" id="idm45922786071464"/><code>stristr()</code></dt>
	<dd>Case-insensitive <code>strstr()</code></dd>
	<dt><a contenteditable="false" data-primary="strchr function" data-type="indexterm" id="idm45922786069048"/><code>strchr()</code></dt>
	<dd>Alias for <code>strstr()</code></dd>
	<dt><a contenteditable="false" data-primary="strrchr function" data-type="indexterm" id="idm45922786009128"/><code>strrchr()</code></dt>
	<dd>Finds last occurrence of a character in a string</dd>
</dl>

<p>As with <code>strrpos()</code>, <code>strrchr()</code> searches backward in the string, but only for a single character, not for an entire string.</p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Searches using masks"><div class="sect3" id="searches_using_masks">
<h3>Searches using masks</h3>

<p>If you thought <code>strrchr()</code> was esoteric, you haven’t seen anything yet. The <a contenteditable="false" data-primary="strspn function" data-type="indexterm" id="idm45922786003480"/><code>strspn()</code> and <code>strcspn()</code> functions tell you how many characters at the beginning of a string are composed of certain characters:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$length</code><code> </code><code class="o">=</code><code> </code><code class="nb">strspn</code><code class="p">(</code><em><code class="nx">string</code></em><code class="p">,</code><code> </code><em><code class="nx">charset</code></em><code class="p">);</code></pre>

<p>For example, this function tests whether a string holds an octal number:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">function</code> <code class="nf">isOctal</code><code class="p">(</code><code class="nv">$str</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">return</code> <code class="nb">strspn</code><code class="p">(</code><code class="nv">$str</code><code class="p">,</code> <code class="s1">'01234567'</code><code class="p">)</code> <code class="o">==</code> <code class="nb">strlen</code><code class="p">(</code><code class="nv">$str</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>The <em>c</em> in <a contenteditable="false" data-primary="strcspn function" data-type="indexterm" id="idm45922785948552"/><code>strcspn()</code> stands for <em>complement</em>—it tells you how much of the start of the string is not composed of the characters in the character set. Use it when the number of interesting characters is greater than the number of uninteresting characters. For example, this function tests whether a string has any NUL-bytes, tabs, or carriage returns:<a contenteditable="false" data-primary="" data-startref="ix_search_strings_ch4" data-type="indexterm" id="idm45922785946296"/><a contenteditable="false" data-primary="" data-startref="ix_strings_search_ch4" data-type="indexterm" id="idm45922785941944"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">function</code> <code class="nf">hasBadChars</code><code class="p">(</code><code class="nv">$str</code><code class="p">)</code>
<code class="p">{</code>
 <code class="k">return</code> <code class="nb">strcspn</code><code class="p">(</code><code class="nv">$str</code><code class="p">,</code> <code class="s2">"</code><code class="se">\n\t\0</code><code class="s2">"</code><code class="p">)</code> <code class="o">!=</code> <code class="nb">strlen</code><code class="p">(</code><code class="nv">$str</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Decomposing URLs"><div class="sect3" id="decomposing_urls">
<h3>Decomposing URLs</h3>

<p><a contenteditable="false" data-primary="URLs" data-secondary="decomposing (parsing)" data-type="indexterm" id="idm45922785889784"/>The <a contenteditable="false" data-primary="parse_url function" data-type="indexterm" id="idm45922785888280"/><code>parse_url()</code> function returns an array of components of a URL:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$array</code><code> </code><code class="o">=</code><code> </code><code class="nb">parse_url</code><code class="p">(</code><em><code class="nx">url</code></em><code class="p">);</code></pre>

<p>For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$bits</code><code> </code><code class="o">=</code><code> </code><code class="nb">parse_url</code><code class="p">(</code><code class="s2">"</code><code class="s2">http://me:secret@example.com/cgi-bin/board?user=fred</code><code class="s2">"</code><code class="p">);</code><code>
</code><code class="nb">print_r</code><code class="p">(</code><code class="nv">$bits</code><code class="p">);</code><code>

</code><strong><code class="k">Array</code></strong><code>
</code><strong><code class="p">(</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">scheme</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">http</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">host</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">example</code><code class="o">.</code><code class="nx">com</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">user</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">me</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">pass</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">secret</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">path</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="o">/</code><code class="nx">cgi</code><code class="o">-</code><code class="nx">bin</code><code class="o">/</code><code class="nx">board</code></strong><code>
</code><strong><code> </code><code class="p">[</code><code class="nx">query</code><code class="p">]</code><code> </code><code class="o">=&gt;</code><code> </code><code class="nx">user</code><code class="o">=</code><code class="nx">fred</code><code class="p">)</code></strong></pre>

<p>The possible keys of the hash are <code>scheme</code>, <code>host</code>, <code>port</code>, <code>user</code>, <code>pass</code>, <code>path</code>, <code>query</code>, and <code>fragment</code>.</p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Regular Expressions"><div class="sect1" id="regular_expressions">
<h1>Regular Expressions</h1>

<p><a contenteditable="false" data-primary="regular expressions" data-type="indexterm" id="ix_reg_express_ch4"/>If you need more complex searching functionality than the previous methods provide, you can use a regular expression—a string that represents a <em>pattern</em>. The regular expression functions compare that pattern to another string and see if any of the string matches the pattern. Some functions tell you whether there was a match, while others make changes to the string.</p>

<p>There are three uses for regular expressions: matching, which can also be used to extract information from a string; substituting new text for matching text; and splitting a string into an array of smaller chunks. PHP has functions for all. For instance, <code>preg_match()</code> does a regular expression match.</p>

<p>Perl has long been considered the benchmark for powerful regular expressions. PHP uses a C library called <em>pcre</em> to provide almost complete support for Perl’s arsenal of regular expression features. Perl regular expressions act on arbitrary binary data, so you can safely match with patterns or strings that contain the NUL-byte (<code>\x00</code>).</p>

<section data-type="sect2" data-pdf-bookmark="The Basics"><div class="sect2" id="the_basics">
<h2>The Basics</h2>

<p>Most characters in a regular expression are literal characters, meaning that they match only themselves. For instance, if you search for the regular expression <code>"/cow/"</code> in the string <code>"Dave was a cowhand"</code>, you get a match because <code>"cow"</code> occurs in that string.</p>

<p><a contenteditable="false" data-primary="^ (caret)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785718680"/><a contenteditable="false" data-primary="caret (^)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785717304"/>Some characters have special meanings in regular expressions. For instance, a caret (<code>^</code>) at the beginning of a regular expression indicates that it must match the beginning of the string (or, more precisely, <a contenteditable="false" data-primary="regular expressions" data-secondary="anchors in" data-type="indexterm" id="idm45922785715240"/><a contenteditable="false" data-primary="anchors, in regular expressions" data-type="indexterm" id="idm45922785713864"/><em>anchors</em> the regular expression to the beginning of the string):</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/^cow/"</code><code class="p">,</code> <code class="s2">"Dave was a cowhand"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/^cow/"</code><code class="p">,</code> <code class="s2">"cowabunga!"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p><a contenteditable="false" data-primary="$ (dollar sign)" data-secondary="in regular expressions" data-secondary-sortas="regular expressions" data-type="indexterm" id="idm45922785705752"/><a contenteditable="false" data-primary="dollar sign ($)" data-secondary="in regular expressions" data-secondary-sortas="regular expressions" data-type="indexterm" id="idm45922785698488"/>Similarly, a dollar sign (<code>$</code>) at the end of a regular expression means that it must match the end of the string (i.e., anchors the regular expression to the end of the string):</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/cow$/"</code><code class="p">,</code> <code class="s2">"Dave was a cowhand"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/cow$/"</code><code class="p">,</code> <code class="s2">"Don't have a cow"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p><a contenteditable="false" data-primary=". (period)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785676600"/><a contenteditable="false" data-primary="period (.)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785675384"/>A period (<code>.</code>) in a regular expression matches any single character:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c.t/"</code><code class="p">,</code> <code class="s2">"cat"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c.t/"</code><code class="p">,</code> <code class="s2">"cut"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c.t/"</code><code class="p">,</code> <code class="s2">"c t"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c.t/"</code><code class="p">,</code> <code class="s2">"bat"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c.t/"</code><code class="p">,</code> <code class="s2">"ct"</code><code class="p">);</code> <code class="c1">// returns false</code></pre>

<p><a contenteditable="false" data-primary="\ (backslash)" data-secondary="preceding regular expression escape sequences" data-type="indexterm" id="idm45922785529704"/><a contenteditable="false" data-primary="backslash (\)" data-secondary="preceding regular expression escape sequences" data-type="indexterm" id="idm45922785600568"/><a contenteditable="false" data-primary="special characters" data-secondary="regular expression escape sequences for" data-type="indexterm" id="idm45922785599160"/>If you want to match one of these special characters (called a <em>metacharacter</em>), you have to escape it with a backslash:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/</code><code class="se">\$</code><code class="s2">5.00/"</code><code class="p">,</code> <code class="s2">"Your bill is $5.00 exactly"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/$5.00/"</code><code class="p">,</code> <code class="s2">"Your bill is $5.00 exactly"</code><code class="p">);</code> <code class="c1">// returns false</code></pre>

<p><a contenteditable="false" data-primary="regular expressions" data-secondary="case sensitivity of" data-type="indexterm" id="idm45922785518136"/><a contenteditable="false" data-primary="case sensitivity" data-secondary="of regular expressions" data-type="indexterm" id="idm45922785517304"/>Regular expressions are case-sensitive by default, so the regular expression <code>"/cow/"</code> doesn’t match the string <code>"COW"</code>. If you want to perform a case-insensitive match, you specify a flag to indicate that (as you’ll see later in this chapter).</p>

<p>So far, we haven’t done anything we couldn’t have done with the string functions we’ve already seen, like <code>strstr()</code>. The real power of regular expressions comes from their ability to specify abstract patterns that can match many different character sequences. You can specify three basic types of abstract patterns in a regular <span class="keep-together">expression:</span></p>

<ul>
	<li>
	<p>A set of acceptable characters that can appear in the string (e.g., alphabetic characters, numeric characters, specific punctuation characters)</p>
	</li>
	<li>
	<p>A set of alternatives for the string (e.g., <code>"com"</code>, <code>"edu"</code>, <code>"net"</code>, or <code>"org"</code>)</p>
	</li>
	<li>
	<p>A repeating sequence in the string (e.g., at least one but not more than five numeric characters)</p>
	</li>
</ul>

<p>These three kinds of patterns can be combined in countless ways to create regular expressions that match such things as valid phone numbers and URLs.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Character Classes"><div class="sect2" id="character_classes">
<h2>Character Classes</h2>

<p><a contenteditable="false" data-primary="regular expressions" data-secondary="character classes in" data-type="indexterm" id="ix_reg_exp_char_classes"/><a contenteditable="false" data-primary="character classes, in regular expressions" data-type="indexterm" id="ix_char_classes_reg_exp"/>To specify a set of acceptable characters in your pattern, you can either build a character class yourself or use a predefined one. You can build your own character class by enclosing the acceptable characters in <a contenteditable="false" data-primary="[…] (square brackets)" data-secondary="enclosing character classes" data-type="indexterm" id="idm45922785570424"/><a contenteditable="false" data-primary="square brackets ([…])" data-secondary="enclosing character classes" data-type="indexterm" id="idm45922785569080"/>square brackets:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c[aeiou]t/"</code><code class="p">,</code> <code class="s2">"I cut my hand"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c[aeiou]t/"</code><code class="p">,</code> <code class="s2">"This crusty cat"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c[aeiou]t/"</code><code class="p">,</code> <code class="s2">"What cart?"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c[aeiou]t/"</code><code class="p">,</code> <code class="s2">"14ct gold"</code><code class="p">);</code> <code class="c1">// returns false</code></pre>

<p>The regular expression engine finds a <code>"c"</code>, then checks that the next character is one of <code>"a"</code>, <code>"e"</code>, <code>"i"</code>, <code>"o"</code>, or <code>"u"</code>. If it isn’t a vowel, the match fails and the engine goes back to looking for another <code>"c"</code>. If a vowel is found, the engine checks that the next character is a <code>"t"</code>. If it is, the engine is at the end of the match and returns <code>true</code>. If the next character isn’t a <code>"t"</code>, the engine goes back to looking for another <code>"c"</code>.</p>

<p><a contenteditable="false" data-primary="^ (caret)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785477304"/><a contenteditable="false" data-primary="caret (^)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785475896"/>You can negate a character class with a caret (<code>^</code>) at the start:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c[^aeiou]t/"</code><code class="p">,</code> <code class="s2">"I cut my hand"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c[^aeiou]t/"</code><code class="p">,</code> <code class="s2">"Reboot chthon"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/c[^aeiou]t/"</code><code class="p">,</code> <code class="s2">"14ct gold"</code><code class="p">);</code> <code class="c1">// returns false</code></pre>

<p>In this case, the regular expression engine is looking for a <code>"c"</code> followed by a character that isn’t a vowel, followed by a <code>"t"</code>.</p>

<p><a contenteditable="false" data-primary="- (hyphen), in regular expressions" data-type="indexterm" id="idm45922785436776"/><a contenteditable="false" data-primary="hyphen (-), in regular expressions" data-type="indexterm" id="idm45922785435704"/>You can define a range of characters with a hyphen (<code>-</code>). This simplifies character classes like “all letters” and “all digits”:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[0-9]%/"</code><code class="p">,</code> <code class="s2">"we are 25% complete"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[0123456789]%/"</code><code class="p">,</code> <code class="s2">"we are 25% complete"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[a-z]t/"</code><code class="p">,</code> <code class="s2">"11th"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[a-z]t/"</code><code class="p">,</code> <code class="s2">"cat"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[a-z]t/"</code><code class="p">,</code> <code class="s2">"PIT"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[a-zA-Z]!/"</code><code class="p">,</code> <code class="s2">"11!"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[a-zA-Z]!/"</code><code class="p">,</code> <code class="s2">"stop!"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p>When you are specifying a character class, some special characters lose their meaning, while others take on new meanings. In particular, the <code>$</code> anchor and the period lose their meaning in a character class, while the <code>^</code> character is no longer an anchor but negates the character class if it is the first character after the open bracket. For instance, <code>[^\]]</code> matches any nonclosing bracket character, while <code>[$.^]</code> matches any dollar sign, period, or caret.</p>

<p>The various regular expression libraries define shortcuts for character classes, including digits, alphabetic characters, and whitespace.<a contenteditable="false" data-primary="" data-startref="ix_char_classes_reg_exp" data-type="indexterm" id="idm45922785334856"/><a contenteditable="false" data-primary="" data-startref="ix_reg_exp_char_classes" data-type="indexterm" id="idm45922785333592"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Alternatives"><div class="sect2" id="alternatives">
<h2>Alternatives</h2>

<p><a contenteditable="false" data-primary="vertical bar (|)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785330536"/><a contenteditable="false" data-primary="| (vertical bar)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785329160"/><a contenteditable="false" data-primary="regular expressions" data-secondary="alternatives in" data-type="indexterm" id="idm45922785327784"/>You can use the vertical pipe (<code>|</code>) character to specify alternatives in a regular <span class="keep-together">expression:</span></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/cat|dog/"</code><code class="p">,</code> <code class="s2">"the cat rubbed my legs"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/cat|dog/"</code><code class="p">,</code> <code class="s2">"the dog rubbed my legs"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/cat|dog/"</code><code class="p">,</code> <code class="s2">"the rabbit rubbed my legs"</code><code class="p">);</code> <code class="c1">// returns false</code></pre>

<p>The precedence of alternation can be a surprise: <code>"/^cat|dog$/"</code> selects from <code>"^cat"</code> and <code>"dog$"</code>, meaning that it matches a line that either starts with <code>"cat"</code> or ends with <code>"dog"</code>. If you want a line that contains just <code>"cat"</code> or <code>"dog"</code>, you need to use the regular expression <code>"/^(cat|dog)$/"</code>.</p>

<p>You can combine character classes and alternation to, for example, check for strings that don’t start with a capital letter:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/^([a-z]|[0-9])/"</code><code class="p">,</code> <code class="s2">"The quick brown fox"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/^([a-z]|[0-9])/"</code><code class="p">,</code> <code class="s2">"jumped over"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/^([a-z]|[0-9])/"</code><code class="p">,</code> <code class="s2">"10 lazy dogs"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Repeating Sequences"><div class="sect2" id="repeating_sequences">
<h2>Repeating Sequences</h2>

<p><a contenteditable="false" data-primary="repeating sequences, in regular expressions" data-type="indexterm" id="idm45922785266856"/><a contenteditable="false" data-primary="regular expressions" data-secondary="repeating sequences in" data-type="indexterm" id="idm45922785236184"/>To specify a repeating pattern, you use a <a contenteditable="false" data-primary="regular expressions" data-secondary="quantifiers in" data-type="indexterm" id="idm45922785234680"/><a contenteditable="false" data-primary="quantifiers, in regular expressions" data-type="indexterm" id="idm45922785233304"/><em>quantifier</em>. The quantifier goes after the pattern that’s repeated and says how many times to repeat that pattern. <a data-type="xref" href="#regular_expression_quantifiers">Table 4-6</a> shows the quantifiers that are supported by PHP’s regular expressions.</p>

<table class="border" id="regular_expression_quantifiers">
	<caption><span class="label">Table 4-6. </span>Regular expression quantifiers</caption>
	<thead>
		<tr>
			<th>Quantifier</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>?</code></td>
			<td>0 or 1</td>
		</tr>
		<tr>
			<td><code>*</code></td>
			<td>0 or more</td>
		</tr>
		<tr>
			<td><code>+</code></td>
			<td>1 or more</td>
		</tr>
		<tr>
			<td><code>{</code> <em>n</em> <code>}</code></td>
			<td>Exactly <em>n</em> times</td>
		</tr>
		<tr>
			<td><code>{</code> <em>n</em> <code>,</code> <em>m</em> <code>}</code></td>
			<td>At least <em>n</em>, no more than <em>m</em> times</td>
		</tr>
		<tr>
			<td><code>{</code> <em>n</em> <code>,}</code></td>
			<td>At least <em>n</em> times</td>
		</tr>
	</tbody>
</table>

<p class="pagebreak-before">To repeat a single character, simply put the quantifier after the character:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/ca+t/"</code><code class="p">,</code> <code class="s2">"caaaaaaat"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/ca+t/"</code><code class="p">,</code> <code class="s2">"ct"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/ca?t/"</code><code class="p">,</code> <code class="s2">"caaaaaaat"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/ca*t/"</code><code class="p">,</code> <code class="s2">"ct"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p>With quantifiers and character classes, we can actually do something useful, like matching valid US telephone numbers:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[0-9]{3}-[0-9]{3}-[0-9]{4}/"</code><code class="p">,</code> <code class="s2">"303-555-1212"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[0-9]{3}-[0-9]{3}-[0-9]{4}/"</code><code class="p">,</code> <code class="s2">"64-9-555-1234"</code><code class="p">);</code> <code class="c1">// returns false</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Subpatterns"><div class="sect2" id="subpatterns">
<h2>Subpatterns</h2>

<p><a contenteditable="false" data-primary="subpatterns, in regular expressions" data-type="indexterm" id="idm45922785106136"/><a contenteditable="false" data-primary="regular expressions" data-secondary="subpatterns in" data-type="indexterm" id="idm45922785171240"/><a contenteditable="false" data-primary="parentheses (…)" data-secondary="enclosing subpatterns" data-type="indexterm" id="idm45922785169864"/><a contenteditable="false" data-primary="(…) (parentheses)" data-secondary="enclosing subpatterns" data-type="indexterm" id="idm45922785168488"/>You can use parentheses to group bits of a regular expression together to be treated as a single unit called a <em>subpattern</em>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/a (very )+big dog/"</code><code class="p">,</code> <code class="s2">"it was a very very big dog"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/^(cat|dog)$/"</code><code class="p">,</code> <code class="s2">"cat"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/^(cat|dog)$/"</code><code class="p">,</code> <code class="s2">"dog"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p>The parentheses also cause the substring that matches the subpattern to be captured. If you pass an array as the third argument to a match function, the array is populated with any captured substrings:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/([0-9]+)/"</code><code class="p">,</code> <code class="s2">"You have 42 magic beans"</code><code class="p">,</code> <code class="nv">$captured</code><code class="p">);</code>
<code class="c1">// returns true and populates $captured</code></pre>

<p>The zeroth element of the array is set to the entire string being matched against. The first element is the substring that matched the first subpattern (if there is one), the second element is the substring that matched the second subpattern, and so on.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Delimiters"><div class="sect2" id="delimiters">
<h2>Delimiters</h2>

<p><a contenteditable="false" data-primary="delimiters, in regular expressions" data-type="indexterm" id="idm45922785046472"/><a contenteditable="false" data-primary="regular expressions" data-secondary="delimiters in" data-type="indexterm" id="idm45922785045176"/>Perl-style regular expressions emulate the Perl syntax for patterns, which means that each pattern must be enclosed in a pair of delimiters. Traditionally, the <a contenteditable="false" data-primary="slash (/)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785043496"/><a contenteditable="false" data-primary="/ (slash)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922785042120"/>forward slash (<code>/</code>) character is used; for example, <code>/</code><em>pattern</em><code>/</code>. However, any nonalphanumeric character other than the backslash character (<code>\</code>) can be used to delimit a Perl-style pattern. This is useful for matching strings containing slashes, such as filenames. For example, the following are equivalent:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/\/usr\/local\//"</code><code class="p">,</code> <code class="s2">"/usr/local/bin/perl"</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"#/usr/local/#"</code><code class="p">,</code> <code class="s2">"/usr/local/bin/perl"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p>Parentheses (<code>()</code>), curly braces (<code>{}</code>), square brackets (<code>[]</code>), and angle brackets (<code>&lt;&gt;</code>) can be used as pattern delimiters:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"{/usr/local/}"</code><code class="p">,</code> <code class="s2">"/usr/local/bin/perl"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p>The section <a data-type="xref" href="#trailing_options">“Trailing Options”</a> discusses the single-character modifiers you can put after the closing delimiter to modify the behavior of the regular expression engine. A very useful one is <code>x</code>, which makes the regular expression engine strip whitespace and <code>#</code>-marked comments from the regular expression before matching. These two patterns are the same, but one is much easier to read:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="s1">'/([[:alpha:]]+)\s+\1/'</code>
<code class="s1">'/( # start capture</code>
<code class="s1">[[:alpha:]]+ # a word</code>
<code class="s1">\s+ # whitespace</code>
<code class="s1">\1 # the same word again</code>
<code class="s1"> ) # end capture</code>
<code class="s1">/x'</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Match Behavior"><div class="sect2" id="match_behavior">
<h2>Match Behavior</h2>

<p><a contenteditable="false" data-primary="match behavior, regular expressions" data-type="indexterm" id="idm45922784947464"/><a contenteditable="false" data-primary="regular expressions" data-secondary="match behavior in" data-type="indexterm" id="idm45922784946280"/><a contenteditable="false" data-primary=". (period)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922784944904"/><a contenteditable="false" data-primary="period (.)" data-secondary="in regular expressions" data-type="indexterm" id="idm45922784943528"/>The period (<code>.</code>) matches any character except for a newline (<code>\n</code>). The dollar sign (<code>$</code>) matches at the end of the string or, if the string ends with a newline, just before that newline:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/is (.*)$/"</code><code class="p">,</code> <code class="s2">"the key is in my pants"</code><code class="p">,</code> <code class="nv">$captured</code><code class="p">);</code>
<code class="c1">// $captured[1] is 'in my pants'</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Character Classes"><div class="sect2" id="character_classes-id00003">
<h2>Character Classes</h2>

<p>As shown in <a data-type="xref" href="#character_classes-id00004">Table 4-7</a>, Perl-compatible regular expressions define a number of named sets of characters that you can use in character classes. The expansions in <a data-type="xref" href="#character_classes-id00004">Table 4-7</a> are for English. The actual letters vary from locale to locale.</p>

<p>a<a contenteditable="false" data-primary="[:…:] (square bracket, colon), enclosing character classes" data-type="indexterm" id="idm45922784899352"/><a contenteditable="false" data-primary="square bracket, colon ([:…:]), enclosing character classes" data-type="indexterm" id="idm45922784898248"/>Each <code>[:</code> <em>something</em> <code>:]</code> class can be used in place of a character in a character class. For instance, to find any character that’s a digit, an uppercase letter, or an “at” sign (<code>@</code>), use the following regular expression:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="p">[</code><code class="o">@</code><code class="p">[</code><code class="o">:</code><code class="nx">digit</code><code class="o">:</code><code class="p">][</code><code class="o">:</code><code class="nx">upper</code><code class="o">:</code><code class="p">]]</code></pre>

<p>However, you can’t use a character class as the endpoint of a range:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[A-[:lower:]]/"</code><code class="p">,</code> <code class="s2">"string"</code><code class="p">);</code><code class="c1">// invalid regular expression</code></pre>

<p>Some locales consider certain character sequences as if they were a single character—these are called <a contenteditable="false" data-primary="collating sequences, regular expressions" data-type="indexterm" id="idm45922784767128"/><em>collating sequences</em>. To match one of these multicharacter sequences in a character class, enclose it with <a contenteditable="false" data-primary="[. … .] (square bracket, period), enclosing character classes" data-type="indexterm" id="idm45922784765704"/><a contenteditable="false" data-primary="square bracket, period ([. … .]), enclosing character classes" data-type="indexterm" id="idm45922784764632"/><code>[.</code> and <code>.]</code>. For example, if your locale has the collating sequence <code>ch</code>, you can match <code>s</code>, <code>t</code>, or <code>ch</code> with this character class:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="p">[</code><code class="nx">st</code><code class="p">[</code><code class="o">.</code><code class="nx">ch</code><code class="o">.</code><code class="p">]]</code></pre>

<p>The final extension to character classes is the <a contenteditable="false" data-primary="equivalence classes, regular expressions" data-type="indexterm" id="idm45922784831048"/><em>equivalence class</em>, which you specify by enclosing the character within <code>[=</code> and <code>=]</code>. Equivalence classes match characters that have the same collating order, as defined in the current locale. For example, a locale may define <code>a</code>, <code>á</code>, and <code>ä</code> as having the same sorting precedence. <a contenteditable="false" data-primary="[=…=] (square bracket, equals sign), enclosing equivalence classes" data-type="indexterm" id="idm45922784746904"/><a contenteditable="false" data-primary="square bracket, equals sign ([=…=]), enclosing equivalence classes" data-type="indexterm" id="idm45922784745832"/>To match any one of them, the equivalence class is <code>[=a=]</code>.</p>

<table class="border" id="character_classes-id00004">
	<caption><span class="label">Table 4-7. </span>Character classes</caption>
	<thead>
		<tr>
			<th>Class</th>
			<th>Description</th>
			<th>Expansion</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>[:alnum:]</code></td>
			<td>Alphanumeric characters</td>
			<td><code>[0-9a-zA-Z]</code></td>
		</tr>
		<tr>
			<td><code>[:alpha:]</code></td>
			<td>Alphabetic characters (letters)</td>
			<td><code>[a-zA-Z]</code></td>
		</tr>
		<tr>
			<td><code>[:ascii:]</code></td>
			<td>7-bit ASCII</td>
			<td><code>[\x01-\x7F]</code></td>
		</tr>
		<tr>
			<td><code>[:blank:]</code></td>
			<td>Horizontal whitespace (space, tab)</td>
			<td><code>[ \t]</code></td>
		</tr>
		<tr>
			<td><code>[:cntrl:]</code></td>
			<td>Control characters</td>
			<td><code>[\x01-\x1F]</code></td>
		</tr>
		<tr>
			<td><code>[:digit:]</code></td>
			<td>Digits</td>
			<td><code>[0-9]</code></td>
		</tr>
		<tr>
			<td><code>[:graph:]</code></td>
			<td>Characters that use ink to print (nonspace, noncontrol)</td>
			<td><code>[^\x01-\x20]</code></td>
		</tr>
		<tr>
			<td><code>[:lower:]</code></td>
			<td>Lowercase letter</td>
			<td><code>[a-z]</code></td>
		</tr>
		<tr>
			<td><code>[:print:]</code></td>
			<td>Printable character (graph class plus space and tab)</td>
			<td><code>[\t\x20-\xFF]</code></td>
		</tr>
		<tr>
			<td><code>[:punct:]</code></td>
			<td>Any punctuation character, such as the period (<code>.</code>) and the semicolon (<code>;</code>)</td>
			<td><code>[-!"#$%&amp;'()*+,./:;&lt;=&gt;?@[\\\]^_'{|}~]</code></td>
		</tr>
		<tr>
			<td><code>[:space:]</code></td>
			<td>Whitespace (newline, carriage return, tab, space, vertical tab)</td>
			<td><code>[\n\r\t \x0B]</code></td>
		</tr>
		<tr>
			<td><code>[:upper:]</code></td>
			<td>Uppercase letter</td>
			<td><code>[A-Z]</code></td>
		</tr>
		<tr>
			<td><code>[:xdigit:]</code></td>
			<td>Hexadecimal digit</td>
			<td><code>[0-9a-fA-F]</code></td>
		</tr>
		<tr>
			<td><code>\s</code></td>
			<td>Whitespace</td>
			<td><code>[\r\n \t]</code></td>
		</tr>
		<tr>
			<td><code>\S</code></td>
			<td>Nonwhitespace</td>
			<td><code>[^\r\n \t]</code></td>
		</tr>
		<tr>
			<td><code>\w</code></td>
			<td>Word (identifier) character</td>
			<td><code>[0-9A-Za-z_]</code></td>
		</tr>
		<tr>
			<td><code>\W</code></td>
			<td>Nonword (identifier) character</td>
			<td><code>[^0-9A-Za-z_]</code></td>
		</tr>
		<tr>
			<td><code>\d</code></td>
			<td>Digit</td>
			<td><code>[0-9]</code></td>
		</tr>
		<tr>
			<td><code>\D</code></td>
			<td>Nondigit</td>
			<td><code>[^0-9]</code></td>
		</tr>
	</tbody>
</table>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Anchors"><div class="sect2" id="anchors">
<h2>Anchors</h2>

<p><a contenteditable="false" data-primary="anchors, in regular expressions" data-type="indexterm" id="idm45922784697080"/><a contenteditable="false" data-primary="regular expressions" data-secondary="anchors in" data-type="indexterm" id="idm45922784696008"/>An anchor limits a match to a particular location in the string (anchors do not match actual characters in the target string). <a data-type="xref" href="#anchor">Table 4-8</a> lists the anchors supported by regular expressions.</p>

<table class="border" id="anchor">
	<caption><span class="label">Table 4-8. </span>Anchors</caption>
	<thead>
		<tr>
			<th>Anchor</th>
			<th>Matches</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>^</code></td>
			<td>Start of string</td>
		</tr>
		<tr>
			<td><code>$</code></td>
			<td>End of string</td>
		</tr>
		<tr>
			<td><code>[[:&lt;:]]</code></td>
			<td>Start of word</td>
		</tr>
		<tr>
			<td><code>[[:&gt;:]]</code></td>
			<td>End of word</td>
		</tr>
		<tr>
			<td><code>\b</code></td>
			<td>Word boundary (between <code>\w</code> and <code>\W</code> or at start or end of string)</td>
		</tr>
		<tr>
			<td><code>\B</code></td>
			<td>Nonword boundary (between <code>\w</code> and <code>\w</code>, or <code>\W</code> and <code>\W</code>)</td>
		</tr>
		<tr>
			<td><code>\A</code></td>
			<td>Beginning of string</td>
		</tr>
		<tr>
			<td><code>\Z</code></td>
			<td>End of string or before <code>\n</code> at end</td>
		</tr>
		<tr>
			<td><code>\z</code></td>
			<td>End of string</td>
		</tr>
		<tr>
			<td><code>^</code></td>
			<td>Start of line (or after <code>\n</code> if <code>/m</code> flag is enabled)</td>
		</tr>
		<tr>
			<td><code>$</code></td>
			<td>End of line (or before <code>\n</code> if <code>/m</code> flag is enabled)</td>
		</tr>
	</tbody>
</table>

<p><a contenteditable="false" data-primary="word boundaries, regular expressions" data-type="indexterm" id="idm45922784668232"/>A word boundary is defined as the point between a whitespace character and an identifier (alphanumeric or underscore) character:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/[[:&lt;:]]gun[[:&gt;:]]/"</code><code class="p">,</code> <code class="s2">"the Burgundy exploded"</code><code class="p">);</code> <code class="c1">// returns false</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/gun/"</code><code class="p">,</code> <code class="s2">"the Burgundy exploded"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p>Note that the beginning and end of a string also qualify as word boundaries.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Quantifiers and Greed"><div class="sect2" id="quantifiers_and_greed">
<h2>Quantifiers and Greed</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="regular expressions" data-secondary="quantifiers in" id="idm45922784646904"/><a contenteditable="false" data-type="indexterm" data-primary="greed, of regular expressions" id="idm45922784645528"/><a contenteditable="false" data-primary="quantifiers, in regular expressions" data-type="indexterm" id="idm45922784644456"/><a contenteditable="false" data-primary="regular expressions" data-secondary="greed of" data-type="indexterm" id="idm45922784643384"/>Regular expression quantifiers are typically <em>greedy</em>. That is, when faced with a quantifier, the engine matches as much as it can while still satisfying the rest of the pattern. For instance:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/(&lt;.*&gt;)/"</code><code class="p">,</code> <code class="s2">"do &lt;b&gt;not&lt;/b&gt; press the button"</code><code class="p">,</code> <code class="nv">$match</code><code class="p">);</code>
<code class="c1">// $match[1] is '&lt;b&gt;not&lt;/b&gt;'</code></pre>

<p>The regular expression matches from the first less-than sign to the last greater-than sign. In effect, the <code>.*</code> matches everything after the first less-than sign, and the engine backtracks to make it match less and less until finally there’s a greater-than sign to be matched.</p>

<p>This greediness can be a problem. <a contenteditable="false" data-primary="minimal matching, regular expression searching" data-type="indexterm" id="idm45922784634744"/>Sometimes you need <em>minimal (nongreedy) matching</em>—that is, quantifiers that match as few times as possible to satisfy the rest of the pattern. Perl provides a parallel set of quantifiers that match minimally. They’re easy to remember, because they’re the same as the greedy quantifiers, but with a question mark (<code>?</code>) appended. <a data-type="xref" href="#greedy_and_nongreedy_quantifiers_in_per">Table 4-9</a> shows the corresponding greedy and nongreedy quantifiers supported by Perl-style regular expressions.</p>

<table class="border" id="greedy_and_nongreedy_quantifiers_in_per">
	<caption><span class="label">Table 4-9. </span>Greedy and nongreedy quantifiers in Perl-compatible regular expressions</caption>
	<thead>
		<tr>
			<th>Greedy quantifier</th>
			<th>Nongreedy quantifier</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>?</code></td>
			<td><code>??</code></td>
		</tr>
		<tr>
			<td><code>*</code></td>
			<td><code>*?</code></td>
		</tr>
		<tr>
			<td><code>+</code></td>
			<td><code>+?</code></td>
		</tr>
		<tr>
			<td><code>{m}</code></td>
			<td><code>{m}?</code></td>
		</tr>
		<tr>
			<td><code>{m,}</code></td>
			<td><code>{m,}?</code></td>
		</tr>
		<tr>
			<td><code>{m,n}</code></td>
			<td><code>{m,n}?</code></td>
		</tr>
	</tbody>
</table>

<p>Here’s how to match a tag using a nongreedy quantifier:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/(&lt;.*?&gt;)/"</code><code class="p">,</code> <code class="s2">"do &lt;b&gt;not&lt;/b&gt; press the button"</code><code class="p">,</code> <code class="nv">$match</code><code class="p">);</code>
<code class="c1">// $match[1] is "&lt;b&gt;"</code></pre>

<p>Another, faster way is to use a character class to match every non-greater-than character up to the next greater-than sign:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/(&lt;[^&gt;]*&gt;)/"</code><code class="p">,</code> <code class="s2">"do &lt;b&gt;not&lt;/b&gt; press the button"</code><code class="p">,</code> <code class="nv">$match</code><code class="p">);</code>
<code class="c1">// $match[1] is '&lt;b&gt;'</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Noncapturing Groups"><div class="sect2" id="noncapturing_groups">
<h2>Noncapturing Groups</h2>

<p><a contenteditable="false" data-primary="noncapturing groups, regular expressions" data-type="indexterm" id="idm45922784575784"/><a contenteditable="false" data-primary="regular expressions" data-secondary="noncapturing groups in" data-type="indexterm" id="idm45922784574424"/><a contenteditable="false" data-type="indexterm" data-primary="regular expressions" data-secondary="subpatterns in" id="idm45922784565544"/><a contenteditable="false" data-type="indexterm" data-primary="subpatterns, in regular expressions" id="idm45922784564168"/>If you enclose a part of a pattern in parentheses, the text that matches that subpattern is captured and can be accessed later. Sometimes, though, you want to create a subpattern without capturing the matching text. In Perl-compatible regular expressions, you can do this using the <a contenteditable="false" data-primary="? : (question mark, colon)" data-secondary="preceding noncapturing groups" data-type="indexterm" id="idm45922784562664"/><a contenteditable="false" data-primary="question mark, colon (? :)" data-secondary="preceding noncapturing groups" data-type="indexterm" id="idm45922784561352"/><code>(?:</code> <em>subpattern</em> <code>)</code> construct:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/(?:ello)(.*)/"</code><code class="p">,</code> <code class="s2">"jello biafra"</code><code class="p">,</code> <code class="nv">$match</code><code class="p">);</code>
<code class="c1">// $match[1] is " biafra"</code></pre>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Backreferences"><div class="sect2" id="backreferences">
<h2>Backreferences</h2>

<p><a contenteditable="false" data-primary="backreferences, regular expressions" data-type="indexterm" id="idm45922784467480"/><a contenteditable="false" data-primary="regular expressions" data-secondary="backreferences in" data-type="indexterm" id="idm45922784466520"/>You can refer to text captured earlier in a pattern with a <em>backreference</em>: <code>\1</code> refers to the contents of the first subpattern, <code>\2</code> refers to the second, and so on. If you nest subpatterns, the first begins with the first opening parenthesis, the second begins with the second opening parenthesis, and so on.</p>

<p>For instance, this identifies doubled words:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/([[:alpha:]]+)\s+</code><code class="se">\1</code><code class="s2">/"</code><code class="p">,</code> <code class="s2">"Paris in the the spring"</code><code class="p">,</code> <code class="nv">$m</code><code class="p">);</code>
<code class="c1">// returns true and $m[1] is "the"</code></pre>

<p><a contenteditable="false" data-primary="preg_match function" data-type="indexterm" id="idm45922784492296"/>The <code>preg_match()</code> function captures at most 99 subpatterns; subpatterns after the 99th are ignored.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Trailing Options"><div class="sect2" id="trailing_options">
<h2>Trailing Options</h2>

<p><a contenteditable="false" data-primary="trailing options, regular expressions" data-type="indexterm" id="idm45922784488776"/><a contenteditable="false" data-primary="regular expressions" data-secondary="trailing options (flags) in" data-type="indexterm" id="idm45922784444632"/>Perl-style regular expressions let you put <a contenteditable="false" data-type="indexterm" data-primary="flags, in regular expressions" id="idm45922784443160"/>single-letter options (flags) after the regular expression pattern to modify the interpretation, or behavior, of the match. For instance, to match case-insensitively, simply use the <code>i</code> flag:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/cat/i"</code><code class="p">,</code> <code class="s2">"Stop, Catherine!"</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p><a data-type="xref" href="#perl_flags">Table 4-10</a> shows which Perl modifiers are supported in Perl-compatible regular expressions.</p>

<table class="border" id="perl_flags">
	<caption><span class="label">Table 4-10. </span>Perl flags</caption>
	<thead>
		<tr>
			<th>Modifier</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>/</code><em>regexp</em><code>/i</code></td>
			<td>Match case-insensitively</td>
		</tr>
		<tr>
			<td><code>/</code><em>regexp</em><code>/s</code></td>
			<td>Make period (<code>.</code>) match any character, <em>including</em> newline (<code>\n</code>)</td>
		</tr>
		<tr>
			<td><code>/</code><em>regexp</em><code>/x</code></td>
			<td>Remove whitespace and comments from the pattern</td>
		</tr>
		<tr>
			<td><code>/</code><em>regexp</em><code>/m</code></td>
			<td>Make caret (<code>^</code>) match after, and dollar sign (<code>$</code>) match before, internal newlines (<code>\n</code>)</td>
		</tr>
		<tr>
			<td><code>/</code><em>regexp</em><code>/e</code></td>
			<td>If the replacement string is PHP code, <code>eval()</code> it to get the actual replacement string</td>
		</tr>
	</tbody>
</table>

<p>PHP’s Perl-compatible regular expression functions also support other modifiers that aren’t supported by Perl, as listed in <a data-type="xref" href="#additional_php_flags">Table 4-11</a>.</p>

<table class="border" id="additional_php_flags">
	<caption><span class="label">Table 4-11. </span>Additional PHP flags</caption>
	<thead>
		<tr>
			<th>Modifier</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>/</code><em>regexp</em><code>/U</code></td>
			<td>Reverses the greediness of the subpattern; <code>*</code> and <code>+</code> now match as little as possible, instead of as much as possible</td>
		</tr>
		<tr>
			<td><code>/</code><em>regexp</em><code>/u</code></td>
			<td>Causes pattern strings to be treated as UTF-8</td>
		</tr>
		<tr>
			<td><code>/</code><em>regexp</em><code>/X</code></td>
			<td>Causes a backslash followed by a character with no special meaning to emit an error</td>
		</tr>
		<tr>
			<td><code>/</code><em>regexp</em><code>/A</code></td>
			<td>Causes the beginning of the string to be anchored as if the first character of the pattern were <code>^</code></td>
		</tr>
		<tr>
			<td><code>/</code><em>regexp</em><code>/D</code></td>
			<td>Causes the <code>$</code> character to match only at the end of a line</td>
		</tr>
		<tr>
			<td><code>/</code><em>regexp</em><code>/S</code></td>
			<td>Causes the expression parser to more carefully examine the structure of the pattern, so it may run slightly faster the next time (such as in a loop)</td>
		</tr>
	</tbody>
</table>

<p>It’s possible to use more than one option in a single pattern, as demonstrated in the following example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$message</code> <code class="o">=</code> <code class="o">&lt;&lt;&lt;</code> <code class="nx">END</code>
<code class="nx">To</code><code class="o">:</code> <code class="nx">you</code><code class="o">@</code><code class="nx">youcorp</code>
<code class="nx">From</code><code class="o">:</code> <code class="nx">me</code><code class="o">@</code><code class="nx">mecorp</code>
<code class="nx">Subject</code><code class="o">:</code> <code class="nx">pay</code> <code class="nx">up</code>

<code class="nx">Pay</code> <code class="nx">me</code> <code class="k">or</code> <code class="k">else</code><code class="o">!</code>
<code class="nx">END</code><code class="p">;</code>

<code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/^subject: (.*)/im"</code><code class="p">,</code> <code class="nv">$message</code><code class="p">,</code> <code class="nv">$match</code><code class="p">);</code>

<code class="nb">print_r</code><code class="p">(</code><code class="nv">$match</code><code class="p">);</code>

<code class="c1">// output: Array ( [0] =&gt; Subject: pay up [1] =&gt; pay up )</code></pre>
</div></section>

<section class="pagebreak-before" data-type="sect2" data-pdf-bookmark="Inline Options"><div class="sect2" id="inline_options">
<h2 class="less_space">Inline Options</h2>

<p><a contenteditable="false" data-primary="inline options, regular expressions" data-type="indexterm" id="idm45922784339640"/><a contenteditable="false" data-primary="regular expressions" data-secondary="inline options in" data-type="indexterm" id="idm45922784338568"/>In addition to specifying pattern-wide options after the closing pattern delimiter, you can specify options within a pattern to have them apply only to part of the pattern. The syntax for this is:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="p">(</code><code class="o">?</code><em><code class="nx">flags</code></em><code class="o">:</code><em><code class="nx">subpattern</code></em><code class="p">)</code></pre>

<p>For example, only the word “PHP” is case-insensitive in this example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code> <code class="nb">preg_match</code><code class="p">(</code><code class="s1">'/I like (?i:PHP)/'</code><code class="p">,</code> <code class="s1">'I like pHp'</code><code class="p">,</code> <code class="nv">$match</code><code class="p">);</code>
<code class="nb">print_r</code><code class="p">(</code><code class="nv">$match</code><code class="p">)</code> <code class="p">;</code>
<code class="c1">// returns true (echo: 1)</code>
<code class="c1">// $match[0] is 'I like pHp'</code></pre>

<p>The <code>i</code>, <code>m</code>, <code>s</code>, <code>U</code>, <code>x</code>, and <code>X</code> options can be applied internally in this fashion. You can use multiple options at once:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s1">'/eat (?ix:foo d)/'</code><code class="p">,</code> <code class="s1">'eat FoOD'</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p><a contenteditable="false" data-primary="- (hyphen), in regular expressions" data-type="indexterm" id="idm45922784234664"/><a contenteditable="false" data-primary="hyphen (-), in regular expressions" data-type="indexterm" id="idm45922784233272"/>Prefix an option with a hyphen (<code>-</code>) to turn it off:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code> <code class="nb">preg_match</code><code class="p">(</code><code class="s1">'/I like (?-i:PHP)/'</code><code class="p">,</code> <code class="s1">'I like pHp'</code><code class="p">,</code> <code class="nv">$match</code><code class="p">);</code>
<code class="nb">print_r</code><code class="p">(</code><code class="nv">$matche</code><code class="p">)</code> <code class="p">;</code>
<code class="c1">// returns false (echo: 0)</code>
<code class="c1">// $match[0] is ''</code></pre>

<p>An alternative form enables or disables the flags until the end of the enclosing subpattern or pattern:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s1">'/I like (?i)PHP/'</code><code class="p">,</code> <code class="s1">'I like pHp'</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s1">'/I (like (?i)PHP) a lot/'</code><code class="p">,</code> <code class="s1">'I like pHp a lot'</code><code class="p">,</code> <code class="nv">$match</code><code class="p">);</code>
<code class="c1">// $match[1] is 'like pHp'</code></pre>

<p>Inline flags do not enable capturing. You need an additional set of capturing parentheses to do that.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Lookahead and Lookbehind"><div class="sect2" id="lookahead_and_lookbehind">
<h2>Lookahead and Lookbehind</h2>

<p><a contenteditable="false" data-primary="regular expressions" data-secondary="lookahead and lookbehind in" data-type="indexterm" id="ix_reg_exp_look_ahead_behind"/><a contenteditable="false" data-primary="lookahead and lookbehind, regular expressions" data-type="indexterm" id="ix_look_ahead_behind"/>In patterns it’s sometimes useful to be able to say “match here if this is next.” This is particularly common when you are splitting a string. The regular expression describes the separator, which is not returned. You can use <em>lookahead</em> to make sure (without matching it, thus preventing it from being returned) that there’s more data after the separator. Similarly, <em>lookbehind</em> checks the preceding text.</p>

<p>Lookahead and lookbehind come in two forms: <em>positive</em> and <em>negative</em>. A positive lookahead or lookbehind says “the next/preceding text must be like this.” A negative lookahead or lookbehind indicates “the next/preceding text must not be like this.” <a data-type="xref" href="#lookahead_and_lookbehind_assertions">Table 4-12</a> shows the four constructs you can use in Perl-compatible patterns. None of these constructs captures text.<a contenteditable="false" data-primary="?&lt;= (question mark, left angle bracket, equals sign), in regular expressions" data-type="indexterm" id="idm45922784177528"/><a contenteditable="false" data-primary="?! (question mark, exclamation point), in regular expressions" data-type="indexterm" id="idm45922784176488"/><a contenteditable="false" data-primary="?= (question mark, equals sign), in regular expressions" data-type="indexterm" id="idm45922784175416"/><a contenteditable="false" data-primary="question mark, equals sign (?=), in regular expressions" data-type="indexterm" id="idm45922784174280"/><a contenteditable="false" data-primary="question mark, exclamation point (?!), in regular expressions" data-type="indexterm" id="idm45922784081832"/><a contenteditable="false" data-primary="question mark, left angle bracket, equals sign (?&lt;=), in regular expressions" data-type="indexterm" id="idm45922784080760"/><a contenteditable="false" data-primary="question mark, left angle bracket, exclamation point (?&lt;!), in regular expressions" data-type="indexterm" id="idm45922784079688"/><a contenteditable="false" data-primary="?&lt;! (question mark, left angle bracket, exclamation point), in regular expressions" data-type="indexterm" id="idm45922784078616"/></p>

<table class="border" id="lookahead_and_lookbehind_assertions">
	<caption><span class="label">Table 4-12. </span>Lookahead and lookbehind assertions</caption>
	<thead>
		<tr>
			<th>Construct</th>
			<th>Meaning</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><code>(?=</code><em>subpattern</em><code>)</code></td>
			<td>Positive lookahead</td>
		</tr>
		<tr>
			<td><code>(?!</code><em>subpattern</em><code>)</code></td>
			<td>Negative lookahead</td>
		</tr>
		<tr>
			<td><code>(?&lt;=</code><em>subpattern</em><code>)</code></td>
			<td>Positive lookbehind</td>
		</tr>
		<tr>
			<td><code>(?&lt;!</code><em>subpattern</em><code>)</code></td>
			<td>Negative lookbehind</td>
		</tr>
	</tbody>
</table>

<p>A simple use of positive lookahead is splitting a Unix mbox mail file into individual messages. The word <code>"From"</code> starting a line by itself indicates the start of a new message, so you can split the mailbox into messages by specifying the separator as the point where the next text is <code>"From"</code> at the start of a line:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$messages</code> <code class="o">=</code> <code class="nb">preg_split</code><code class="p">(</code><code class="s1">'/(?=^From )/m'</code><code class="p">,</code> <code class="nv">$mailbox</code><code class="p">);</code></pre>

<p>A simple use of negative lookbehind is to extract quoted strings that contain quoted delimiters. For instance, here’s how to extract a single-quoted string (note that the regular expression is commented using the <code>x</code> modifier):</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$input</code><code> </code><code class="o">=</code><code> </code><code class="o">&lt;&lt;&lt;</code><code> </code><code class="nx">END</code><code>
</code><code class="nx">name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Tim O\'Reilly'</code><code class="p">;</code><code>
</code><code class="nx">END</code><code class="p">;</code><code>

</code><code class="nv">$pattern</code><code> </code><code class="o">=</code><code> </code><code class="o">&lt;&lt;&lt;</code><code> </code><code class="nx">END</code><code>
</code><code class="s1">' # opening quote
( # begin capturing
 .*? # the string
 (?&lt;! \\\\ ) # skip escaped quotes
) # end capturing
'</code><code> </code><code class="c1"># closing quote
</code><code class="nx">END</code><code class="p">;</code><code>
</code><code class="nb">preg_match</code><code class="p">(</code><code> </code><code class="s2">"</code><code class="s2">(</code><code class="si">$pattern</code><code class="s2">)x</code><code class="s2">"</code><code class="p">,</code><code> </code><code class="nv">$input</code><code class="p">,</code><code> </code><code class="nv">$match</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="nv">$match</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code><code>
</code><strong><code class="nx">Tim</code><code> </code><code class="nx">O\</code><code class="err">'</code><code class="nx">Reilly</code></strong></pre>

<p>The only tricky part is that to get a pattern that looks behind to see if the last character was a <a contenteditable="false" data-type="indexterm" data-primary="\ (backslash)" data-secondary="in regular expressions" data-secondary-sortas="regular expressions" id="idm45922783990536"/><a contenteditable="false" data-primary="backslash (\)" data-secondary="in regular expressions" data-secondary-sortas="regular expressions" data-type="indexterm" id="idm45922783984536"/>backslash, we need to escape the backslash to prevent the regular expression engine from seeing <code>\)</code>, which would mean a literal close parenthesis. In other words, we have to backslash that backslash: <code>\\)</code>. But PHP’s string-quoting rules say that <code>\\</code> produces a literal single backslash, so we end up requiring <em>four</em> backslashes to get one through the regular expression! This is why regular expressions have a reputation for being hard to read.</p>

<p>Perl limits lookbehind to constant-width expressions. That is, the expressions cannot contain quantifiers, and if you use alternation, all the choices must be the same length. The Perl-compatible regular expression engine also forbids quantifiers in lookbehind, but does permit alternatives of different lengths.<a contenteditable="false" data-primary="" data-startref="ix_look_ahead_behind" data-type="indexterm" id="idm45922783992408"/><a contenteditable="false" data-primary="" data-startref="ix_reg_exp_look_ahead_behind" data-type="indexterm" id="idm45922783994408"/></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Cut"><div class="sect2" id="cut">
<h2>Cut</h2>

<p><a contenteditable="false" data-primary="regular expressions" data-secondary="subpatterns in" data-type="indexterm" id="idm45922783998328"/><a contenteditable="false" data-primary="subpatterns, in regular expressions" data-type="indexterm" id="idm45922784023912"/><a contenteditable="false" data-primary="cut (once-only subpattern), in regular expressions" data-type="indexterm" id="idm45922784022840"/><a contenteditable="false" data-primary="regular expressions" data-secondary="cut (once-only subpattern) in" data-type="indexterm" id="idm45922784021144"/>The rarely used once-only subpattern, or <em>cut</em>, prevents worst-case behavior by the regular expression engine on some kinds of patterns. The subpattern is never backed out of once matched.</p>

<p>The common use for the once-only subpattern is when you have a repeated expression that may itself be repeated:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="o">/</code><code class="p">(</code><code class="nx">a</code><code class="o">+|</code><code class="nx">b</code><code class="o">+</code><code class="p">)</code><code class="o">*</code><code class="nx">\</code><code class="o">.+/</code></pre>

<p>This code snippet takes several seconds to report failure:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$p</code> <code class="o">=</code> <code class="s1">'/(a+|b+)*\.+$/'</code><code class="p">;</code>
<code class="nv">$s</code> <code class="o">=</code> <code class="s1">'abababababbabbbabbaaaaaabbbbabbababababababbba..!'</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="nb">preg_match</code><code class="p">(</code><code class="nv">$p</code><code class="p">,</code> <code class="nv">$s</code><code class="p">))</code> <code class="p">{</code>
 <code class="k">echo</code> <code class="s2">"Y"</code><code class="p">;</code>
<code class="p">}</code>
<code class="k">else</code> <code class="p">{</code>
 <code class="k">echo</code> <code class="s2">"N"</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>This is because the regular expression engine tries all the different places to start the match, but has to backtrack out of each one, which takes time. If you know that once something is matched it should never be backed out of, you should mark it with <span class="keep-together"><code>(?&gt;<em>subpattern</em>)</code></span>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$p</code> <code class="o">=</code> <code class="s1">'/(?&gt;a+|b+)*\.+$/'</code><code class="p">;</code></pre>

<p>The cut never changes the outcome of the match; it simply makes it fail faster.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Conditional Expressions"><div class="sect2" id="conditional_expressions">
<h2>Conditional Expressions</h2>

<p><a contenteditable="false" data-primary="conditional expressions, in regular expressions" data-type="indexterm" id="idm45922783867368"/><a contenteditable="false" data-primary="regular expressions" data-secondary="conditional expressions in" data-type="indexterm" id="idm45922783834056"/>A conditional expression is like an <code>if</code> statement in a regular expression. The general form is:<a contenteditable="false" data-type="indexterm" data-primary="? (question mark)" data-secondary="preceding conditional expressions" id="idm45922783832168"/><a contenteditable="false" data-type="indexterm" data-primary="question mark (?)" data-secondary="preceding conditional expressions" id="idm45922783830824"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="p">(</code><code class="o">?</code><code class="p">(</code><em><code class="nx">condition</code></em><code class="p">)</code><em><code class="nx">yespattern</code></em><code class="p">)</code><code>
</code><code class="p">(</code><code class="o">?</code><code class="p">(</code><em><code class="nx">condition</code></em><code class="p">)</code><em><code class="nx">yespattern</code></em><code class="o">|</code><em><code class="nx">nopattern</code></em><code class="p">)</code></pre>

<p>If the assertion succeeds, the regular expression engine matches the <em>yespattern</em>. With the second form, if the assertion doesn’t succeed, the regular expression engine skips the <em>yespattern</em> and tries to match the <em>nopattern</em>.</p>

<p>The assertion can be one of two types: either a backreference, or a lookahead or lookbehind match. To reference a previously matched substring, the assertion is a number from 1 to 99 (the most backreferences available). The condition uses the pattern in the assertion only if the backreference was matched. If the assertion is not a backreference, it must be a positive or negative lookahead or lookbehind assertion.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Functions"><div class="sect2" id="functions-id00021">
<h2>Functions</h2>

<p><a contenteditable="false" data-primary="regular expressions" data-secondary="functions in" data-type="indexterm" id="ix_perl_reg_exp_functions"/><a contenteditable="false" data-primary="functions" data-secondary="in regular expressions" data-secondary-sortas="regular expressions" data-type="indexterm" id="ix_functions_perl_reg_exp"/>There are five classes of functions that work with Perl-compatible regular expressions: matching, replacing, splitting, filtering, and a utility function for quoting text.</p>

<section data-type="sect3" data-pdf-bookmark="Matching"><div class="sect3" id="matching">
<h3>Matching</h3>

<p><a contenteditable="false" data-primary="functions" data-secondary="matching of" data-type="indexterm" id="ix_functions_matching_reg_exp"/><a contenteditable="false" data-primary="match behavior, regular expressions" data-type="indexterm" id="ix_match_reg_exp_functions"/><a contenteditable="false" data-primary="regular expressions" data-secondary="match behavior in" data-type="indexterm" id="ix_reg_exp_function_match"/>The <a contenteditable="false" data-primary="preg_match function" data-type="indexterm" id="idm45922783776824"/><code>preg_match()</code> function performs Perl-style pattern matching on a string. It’s the equivalent of the <code>m//</code> operator in Perl. The <code>preg_match</code>_all<code>()</code> function takes the same arguments and gives the same return value as the <code>preg_match()</code> function, except that it takes a Perl-style pattern instead of a standard pattern:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$found</code><code> </code><code class="o">=</code><code> </code><code class="nb">preg_match</code><code class="p">(</code><em><code class="nx">pattern</code></em><code class="p">,</code><code> </code><em><code class="nx">string</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">captured</code></em><code> </code><code class="p">]);</code></pre>

<p>For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s1">'/y.*e$/'</code><code class="p">,</code> <code class="s1">'Sylvie'</code><code class="p">);</code> <code class="c1">// returns true</code>
<code class="nb">preg_match</code><code class="p">(</code><code class="s1">'/y(.*)e$/'</code><code class="p">,</code> <code class="s1">'Sylvie'</code><code class="p">,</code> <code class="nv">$m</code><code class="p">);</code> <code class="c1">// $m is array('ylvie', 'lvi')</code></pre>

<p>While there’s a <code>preg_match()</code> function to match case-insensitively, there’s no <code>preg_matchi()</code> function. Instead, use the <code>i</code> flag on the pattern:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nb">preg_match</code><code class="p">(</code><code class="s1">'y.*e$/i'</code><code class="p">,</code> <code class="s1">'SyLvIe'</code><code class="p">);</code> <code class="c1">// returns true</code></pre>

<p><a contenteditable="false" data-primary="preg_match_all function" data-type="indexterm" id="idm45922783715864"/>The <code>preg_match_all()</code> function repeatedly matches from where the last match ended, until no more matches can be made:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$found</code><code> </code><code class="o">=</code><code> </code><code class="nb">preg_match_all</code><code class="p">(</code><em><code class="nx">pattern</code></em><code class="p">,</code><code> </code><em><code class="nx">string</code></em><code class="p">,</code><code> </code><em><code class="nx">matches</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">order</code></em><code> </code><code class="p">]);</code></pre>

<p>The <em>order</em> value, either <code>PREG_PATTERN_ORDER</code> or <code>PREG_SET_ORDER</code>, determines the layout of <em>matches</em>. We’ll look at both, using this code as a guide:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code> <code class="o">=</code> <code class="o">&lt;&lt;&lt;</code> <code class="nx">END</code>
<code class="mi">13</code> <code class="nx">dogs</code>
<code class="mi">12</code> <code class="nx">rabbits</code>
<code class="mi">8</code> <code class="nx">cows</code>
<code class="mi">1</code> <code class="nx">goat</code>
<code class="nx">END</code><code class="p">;</code>
<code class="nb">preg_match_all</code><code class="p">(</code><code class="s1">'/(\d+) (\S+)/'</code><code class="p">,</code> <code class="nv">$string</code><code class="p">,</code> <code class="nv">$m1</code><code class="p">,</code> <code class="nx">PREG_PATTERN_ORDER</code><code class="p">);</code>
<code class="nb">preg_match_all</code><code class="p">(</code><code class="s1">'/(\d+) (\S+)/'</code><code class="p">,</code> <code class="nv">$string</code><code class="p">,</code> <code class="nv">$m2</code><code class="p">,</code> <code class="nx">PREG_SET_ORDER</code><code class="p">);</code></pre>

<p>With <code>PREG_PATTERN_ORDER</code> (the default), each element of the array corresponds to a particular capturing subpattern. So <code>$m1[0]</code> is an array of all the substrings that matched the pattern, <code>$m1[1]</code> is an array of all the substrings that matched the first subpattern (the numbers), and <code>$m1[2]</code> is an array of all the substrings that matched the second subpattern (the words). The array <code>$m1</code> has one more element than it has subpatterns.</p>

<p>With <code>PREG_SET_ORDER</code>, each element of the array corresponds to the next attempt to match the whole pattern. So <code>$m2[0]</code> is an array of the first set of matches (<code>'13 dogs'</code>, <code>'13'</code>, <code>'dogs'</code>), <code>$m2[1]</code> is an array of the second set of matches (<code>'12 rabbits'</code>, <code>'12'</code>, <code>'rabbits'</code>), and so on. The array <code>$m2</code> has as many elements as there were successful matches of the entire pattern.</p>

<p><a data-type="xref" href="#example_four_onedot_extracting_urls_fro">Example 4-1</a> fetches the HTML at a particular web address into a string and extracts the URLs from that HTML. For each URL, it generates a link back to the program that will display the URLs at that address.<a contenteditable="false" data-primary="" data-startref="ix_reg_exp_function_match" data-type="indexterm" id="idm45922783550040"/><a contenteditable="false" data-primary="" data-startref="ix_match_reg_exp_functions" data-type="indexterm" id="idm45922783548728"/><a contenteditable="false" data-primary="" data-startref="ix_functions_matching_reg_exp" data-type="indexterm" id="idm45922783547384"/></p>

<div data-type="example" id="example_four_onedot_extracting_urls_fro">
<h5><span class="label">Example 4-1. </span>Extracting URLs from an HTML page</h5>

<pre data-type="programlisting" data-code-language="html+php">
<code class="cp">&lt;?php</code>
<code class="k">if</code> <code class="p">(</code><code class="nb">getenv</code><code class="p">(</code><code class="s1">'REQUEST_METHOD'</code><code class="p">)</code> <code class="o">==</code> <code class="s1">'POST'</code><code class="p">)</code> <code class="p">{</code>
 <code class="nv">$url</code> <code class="o">=</code> <code class="nv">$_POST</code><code class="p">[</code><code class="s1">'url'</code><code class="p">];</code>
<code class="p">}</code>
<code class="k">else</code> <code class="p">{</code>
 <code class="nv">$url</code> <code class="o">=</code> <code class="nv">$_GET</code><code class="p">[</code><code class="s1">'url'</code><code class="p">];</code>
<code class="p">}</code>
<code class="cp">?&gt;</code>

<code class="nt">&lt;form</code> <code class="na">action=</code><code class="s">"</code><code class="cp">&lt;?php</code> <code class="k">echo</code> <code class="nv">$_SERVER</code><code class="p">[</code><code class="s1">'PHP_SELF'</code><code class="p">];</code> <code class="cp">?&gt;</code><code class="s">"</code> <code class="na">method=</code><code class="s">"POST"</code><code class="nt">&gt;</code>
 <code class="nt">&lt;p&gt;</code>URL: <code class="nt">&lt;input</code> <code class="na">type=</code><code class="s">"text"</code> <code class="na">name=</code><code class="s">"url"</code> <code class="na">value=</code><code class="s">"</code><code class="cp">&lt;?php</code> <code class="k">echo</code> <code class="nv">$url</code> <code class="cp">?&gt;</code><code class="s">"</code> <code class="nt">/&gt;&lt;br</code> <code class="nt">/&gt;</code>
 <code class="nt">&lt;input</code> <code class="na">type=</code><code class="s">"submit"</code><code class="nt">&gt;</code>
<code class="nt">&lt;/form&gt;</code>

<code class="cp">&lt;?php</code>
<code class="k">if</code> <code class="p">(</code><code class="nv">$url</code><code class="p">)</code> <code class="p">{</code>
 <code class="nv">$remote</code> <code class="o">=</code> <code class="nb">fopen</code><code class="p">(</code><code class="nv">$url</code><code class="p">,</code> <code class="s1">'r'</code><code class="p">);</code> <code class="p">{</code>
 <code class="nv">$html</code> <code class="o">=</code> <code class="nb">fread</code><code class="p">(</code><code class="nv">$remote</code><code class="p">,</code> <code class="mi">1048576</code><code class="p">);</code> <code class="c1">// read up to 1 MB of HTML</code>
 <code class="p">}</code>
 <code class="nb">fclose</code><code class="p">(</code><code class="nv">$remote</code><code class="p">);</code>

 <code class="nv">$urls</code> <code class="o">=</code> <code class="s1">'(http|telnet|gopher|file|wais|ftp)'</code><code class="p">;</code>
 <code class="nv">$ltrs</code> <code class="o">=</code> <code class="s1">'\w'</code><code class="p">;</code>
 <code class="nv">$gunk</code> <code class="o">=</code> <code class="s1">'/#~:.?+=&amp;%@!\-'</code><code class="p">;</code>
 <code class="nv">$punc</code> <code class="o">=</code> <code class="s1">'.:?\-'</code><code class="p">;</code>
 <code class="nv">$any</code> <code class="o">=</code> <code class="s2">"</code><code class="si">{</code><code class="nv">$ltrs</code><code class="si">}{</code><code class="nv">$gunk</code><code class="si">}{</code><code class="nv">$punc</code><code class="si">}</code><code class="s2">"</code><code class="p">;</code>

 <code class="nb">preg_match_all</code><code class="p">(</code><code class="s2">"{</code>
<code class="s2"> \b # start at word boundary</code>
<code class="s2"> </code><code class="si">{</code><code class="nv">$urls</code><code class="si">}</code><code class="s2">: # need resource and a colon</code>
<code class="s2"> [</code><code class="si">{</code><code class="nv">$any</code><code class="si">}</code><code class="s2">] +? # followed by one or more of any valid</code>
<code class="s2"> # characters—but be conservative</code>
<code class="s2"> # and take only what you need</code>
<code class="s2"> (?= # the match ends at</code>
<code class="s2"> [</code><code class="si">{</code><code class="nv">$punc</code><code class="si">}</code><code class="s2">]* # punctuation</code>
<code class="s2"> [^</code><code class="si">{</code><code class="nv">$any</code><code class="si">}</code><code class="s2">] # followed by a non-URL character</code>
<code class="s2"> | # or</code>
<code class="s2"> </code><code class="se">\$</code><code class="s2"> # the end of the string</code>
<code class="s2"> )</code>
<code class="s2"> }x"</code><code class="p">,</code> <code class="nv">$html</code><code class="p">,</code> <code class="nv">$matches</code><code class="p">);</code>

 <code class="nb">printf</code><code class="p">(</code><code class="s2">"I found %d URLs&lt;P&gt;</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="nb">sizeof</code><code class="p">(</code><code class="nv">$matches</code><code class="p">[</code><code class="mi">0</code><code class="p">]));</code>

 <code class="k">foreach</code> <code class="p">(</code><code class="nv">$matches</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="k">as</code> <code class="nv">$u</code><code class="p">)</code> <code class="p">{</code>
 <code class="nv">$link</code> <code class="o">=</code> <code class="nv">$_SERVER</code><code class="p">[</code><code class="s1">'PHP_SELF'</code><code class="p">]</code> <code class="o">.</code> <code class="s1">'?url='</code> <code class="o">.</code> <code class="nb">urlencode</code><code class="p">(</code><code class="nv">$u</code><code class="p">);</code>
 <code class="k">echo</code> <code class="s2">"&lt;a href=</code><code class="se">\"</code><code class="si">{</code><code class="nv">$link</code><code class="si">}</code><code class="se">\"</code><code class="s2">&gt;</code><code class="si">{</code><code class="nv">$u</code><code class="si">}</code><code class="s2">&lt;/a&gt;&lt;br /&gt;</code><code class="se">\n</code><code class="s2">"</code><code class="p">;</code>
 <code class="p">}</code>
<code class="p">}</code></pre>
</div>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Replacing"><div class="sect3" id="replacing">
<h3>Replacing</h3>

<p><a contenteditable="false" data-primary="functions" data-secondary="replacing" data-type="indexterm" id="ix_function_preg_replace"/><a contenteditable="false" data-primary="preg_replace function" data-type="indexterm" id="ix_preg_replace_function"/>The <code>preg_replace()</code> function behaves like the search-and-replace operation in your text editor. It finds all occurrences of a pattern in a string and changes those occurrences to something else:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$new</code><code> </code><code class="o">=</code><code> </code><code class="nb">preg_replace</code><code class="p">(</code><em><code class="nx">pattern</code></em><code class="p">,</code><code> </code><em><code class="nx">replacement</code></em><code class="p">,</code><code> </code><em><code class="nx">subject</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">limit</code></em><code> </code><code class="p">]);</code></pre>

<p>The most common usage has all the argument strings except for the integer <em>limit</em>. The limit is the maximum number of occurrences of the pattern to replace (the default, and the behavior when a limit of <code>−1</code> is passed, is all occurrences):</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$better</code> <code class="o">=</code> <code class="nb">preg_replace</code><code class="p">(</code><code class="s1">'/&lt;.*?&gt;/'</code><code class="p">,</code> <code class="s1">'!'</code><code class="p">,</code> <code class="s1">'do &lt;b&gt;not&lt;/b&gt; press the button'</code><code class="p">);</code>
<code class="c1">// $better is 'do !not! press the button'</code></pre>

<p>Pass an array of strings as <em>subject</em> to make the substitution on all of them. The new strings are returned from <code>preg_replace()</code>:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$names</code> <code class="o">=</code> <code class="k">array</code><code class="p">(</code><code class="s1">'Fred Flintstone'</code><code class="p">,</code>
 <code class="s1">'Barney Rubble'</code><code class="p">,</code>
 <code class="s1">'Wilma Flintstone'</code><code class="p">,</code>
 <code class="s1">'Betty Rubble'</code><code class="p">);</code>
<code class="nv">$tidy</code> <code class="o">=</code> <code class="nb">preg_replace</code><code class="p">(</code><code class="s1">'/(\w)\w* (\w+)/'</code><code class="p">,</code> <code class="s1">'\1 \2'</code><code class="p">,</code> <code class="nv">$names</code><code class="p">);</code>
<code class="c1">// $tidy is array ('F Flintstone', 'B Rubble', 'W Flintstone', 'B Rubble')</code></pre>

<p>To perform multiple substitutions on the same string or array of strings with one call to <code>preg_replace()</code>, pass arrays of patterns and replacements:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$contractions</code> <code class="o">=</code> <code class="k">array</code><code class="p">(</code><code class="s2">"/don't/i"</code><code class="p">,</code> <code class="s2">"/won't/i"</code><code class="p">,</code> <code class="s2">"/can't/i"</code><code class="p">);</code>
<code class="nv">$expansions</code> <code class="o">=</code> <code class="k">array</code><code class="p">(</code><code class="s1">'do not'</code><code class="p">,</code> <code class="s1">'will not'</code><code class="p">,</code> <code class="s1">'can not'</code><code class="p">);</code>
<code class="nv">$string</code> <code class="o">=</code> <code class="s2">"Please don't yell - I can't jump while you won't speak"</code><code class="p">;</code>
<code class="nv">$longer</code> <code class="o">=</code> <code class="nb">preg_replace</code><code class="p">(</code><code class="nv">$contractions</code><code class="p">,</code> <code class="nv">$expansions</code><code class="p">,</code> <code class="nv">$string</code><code class="p">);</code>
<code class="c1">// $longer is 'Please do not yell - I can not jump while you will not speak';</code></pre>

<p>If you give fewer replacements than patterns, text matching the extra patterns is deleted. This is a handy way to delete a lot of things at once:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$htmlGunk</code> <code class="o">=</code> <code class="k">array</code><code class="p">(</code><code class="s1">'/&lt;.*?&gt;/'</code><code class="p">,</code> <code class="s1">'/&amp;.*?;/'</code><code class="p">);</code>
<code class="nv">$html</code> <code class="o">=</code> <code class="s1">'&amp;eacute; : &lt;b&gt;very&lt;/b&gt; cute'</code><code class="p">;</code>
<code class="nv">$stripped</code> <code class="o">=</code> <code class="nb">preg_replace</code><code class="p">(</code><code class="nv">$htmlGunk</code><code class="p">,</code> <code class="k">array</code><code class="p">(),</code> <code class="nv">$html</code><code class="p">);</code>
<code class="c1">// $stripped is ' : very cute'</code></pre>

<p>If you give an array of patterns but a single string replacement, the same replacement is used for every pattern:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$stripped</code> <code class="o">=</code> <code class="nb">preg_replace</code><code class="p">(</code><code class="nv">$htmlGunk</code><code class="p">,</code> <code class="s1">''</code><code class="p">,</code> <code class="nv">$html</code><code class="p">);</code></pre>

<p>The replacement can use backreferences. Unlike backreferences in patterns, though, the preferred syntax for backreferences in replacements is <code>$1</code>, <code>$2</code>, <code>$3</code>, and so on. For example:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code> <code class="nb">preg_replace</code><code class="p">(</code><code class="s1">'/(\w)\w+\s+(\w+)/'</code><code class="p">,</code> <code class="s1">'$2, $1.'</code><code class="p">,</code> <code class="s1">'Fred Flintstone'</code><code class="p">)</code>
<code class="nx">Flintstone</code><code class="p">,</code> <code class="nx">F</code><code class="o">.</code></pre>

<p>The <code>/e</code> modifier makes <code>preg_replace()</code> treat the replacement string as PHP code that returns the actual string to use in the replacement. For example, this converts every Celsius temperature to Fahrenheit:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$string</code> <code class="o">=</code> <code class="s1">'It was 5C outside, 20C inside'</code><code class="p">;</code>
<code class="k">echo</code> <code class="nb">preg_replace</code><code class="p">(</code><code class="s1">'/(\d+)C\b/e'</code><code class="p">,</code> <code class="s1">'$1*9/5+32'</code><code class="p">,</code> <code class="nv">$string</code><code class="p">);</code>
<code class="nx">It</code> <code class="nx">was</code> <code class="mi">41</code> <code class="nx">outside</code><code class="p">,</code> <code class="mi">68</code> <code class="nx">inside</code></pre>

<p>This more complex example expands variables in a string:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$name</code> <code class="o">=</code> <code class="s1">'Fred'</code><code class="p">;</code>
<code class="nv">$age</code> <code class="o">=</code> <code class="mi">35</code><code class="p">;</code>
<code class="nv">$string</code> <code class="o">=</code> <code class="s1">'$name is $age'</code><code class="p">;</code>
<code class="nb">preg_replace</code><code class="p">(</code><code class="s1">'/\$(\w+)/e'</code><code class="p">,</code> <code class="s1">'$$1'</code><code class="p">,</code> <code class="nv">$string</code><code class="p">);</code></pre>

<p>Each match isolates the name of a variable (<code>$name</code>, <code>$age</code>). The <code>$1</code> in the replacement refers to those names, so the PHP code actually executed is <code>$name</code> and <code>$age</code>. That code evaluates to the value of the variable, which is what’s used as the replacement. Whew!</p>

<p>A variation on <code>preg_replace()</code> is <a contenteditable="false" data-primary="preg_replace_callback function" data-type="indexterm" id="idm45922782865048"/><code>preg_replace_callback()</code>. This calls a function to get the replacement string. The function is passed an array of matches (the zeroth element is all the text that matched the pattern, the first is the contents of the first captured subpattern, and so on). For example:<a contenteditable="false" data-primary="" data-startref="ix_preg_replace_function" data-type="indexterm" id="idm45922782863272"/><a contenteditable="false" data-primary="" data-startref="ix_function_preg_replace" data-type="indexterm" id="idm45922782861928"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">function</code><code> </code><code class="nf">titlecase</code><code class="p">(</code><code class="nv">$s</code><code class="p">)</code><code>
</code><code class="p">{</code><code>
 </code><code class="k">return</code><code> </code><code class="nb">ucfirst</code><code class="p">(</code><code class="nb">strtolower</code><code class="p">(</code><code class="nv">$s</code><code class="p">[</code><code class="mi">0</code><code class="p">]));</code><code>
</code><code class="p">}</code><code>

</code><code class="nv">$string</code><code> </code><code class="o">=</code><code> </code><code class="s1">'goodbye cruel world'</code><code class="p">;</code><code>
</code><code class="nv">$new</code><code> </code><code class="o">=</code><code> </code><code class="nb">preg_replace_callback</code><code class="p">(</code><code class="s1">'/\w+/'</code><code class="p">,</code><code> </code><code class="s1">'titlecase'</code><code class="p">,</code><code> </code><code class="nv">$string</code><code class="p">);</code><code>
</code><code class="k">echo</code><code> </code><code class="nv">$new</code><code class="p">;</code><code>

</code><strong><code class="nx">Goodbye</code><code> </code><code class="nx">Cruel</code><code> </code><code class="nx">World</code></strong></pre>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Splitting"><div class="sect3" id="splitting">
<h3>Splitting</h3>

<p><a contenteditable="false" data-primary="functions" data-secondary="splitting" data-type="indexterm" id="idm45922782851848"/>Whereas you use <code>preg_match_all()</code> to extract chunks of a string when you know what those chunks are, use <a contenteditable="false" data-primary="preg_split function" data-type="indexterm" id="idm45922782843768"/><code>preg_split()</code> to extract chunks when you know what <em>separates</em> the chunks from each other:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$chunks</code><code> </code><code class="o">=</code><code> </code><code class="nb">preg_split</code><code class="p">(</code><em><code class="nx">pattern</code></em><code class="p">,</code><code> </code><em><code class="nx">string</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">limit</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">flags</code></em><code> </code><code class="p">]]);</code></pre>

<p>The <em>pattern</em> matches a separator between two chunks. By default, the separators are not returned. The optional <em>limit</em> specifies the maximum number of chunks to return (<code>−1</code> is the default, which means all chunks). The <em>flags</em> argument is a bitwise OR combination of the flags <code>PREG_SPLIT_NO_EMPTY</code> (empty chunks are not returned) and <code>PREG_SPLIT_DELIM_CAPTURE</code> (parts of the string captured in the pattern are returned).</p>

<p>For example, to extract just the operands from a simple numeric expression, use:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$ops</code> <code class="o">=</code> <code class="nb">preg_split</code><code class="p">(</code><code class="s1">'{[+*/−]}'</code><code class="p">,</code> <code class="s1">'3+5*9/2'</code><code class="p">);</code>
<code class="c1">// $ops is array('3', '5', '9', '2')</code></pre>

<p>To extract the operands and the operators, use:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$ops</code> <code class="o">=</code> <code class="nb">preg_split</code><code class="p">(</code><code class="s1">'{([+*/−])}'</code><code class="p">,</code> <code class="s1">'3+5*9/2'</code><code class="p">,</code> <code class="nx">−1</code><code class="p">,</code> <code class="nx">PREG_SPLIT_DELIM_CAPTURE</code><code class="p">);</code>
<code class="c1">// $ops is array('3', '+', '5', '*', '9', '/', '2')</code></pre>

<p>An empty pattern matches at every boundary between characters in the string, and at the start and end of the string. This lets you split a string into an array of characters:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$array</code> <code class="o">=</code> <code class="nb">preg_split</code><code class="p">(</code><code class="s1">'//'</code><code class="p">,</code> <code class="nv">$string</code><code class="p">);</code></pre>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Filtering an array with a regular expression"><div class="sect3" id="filtering_an_array_with_a_regular_expre">
<h3>Filtering an array with a regular expression</h3>

<p><a contenteditable="false" data-primary="functions" data-secondary="filtering an array with a regular expression" data-type="indexterm" id="idm45922782654024"/><a contenteditable="false" data-primary="arrays" data-secondary="filtering with regular expression" data-type="indexterm" id="idm45922782683864"/><a contenteditable="false" data-primary="regular expressions" data-secondary="filtering an array with" data-type="indexterm" id="idm45922782682520"/><a contenteditable="false" data-primary="preg_grep function" data-type="indexterm" id="idm45922782688840"/>The <code>preg_grep()</code> function returns those elements of an array that match a given <span class="keep-together">pattern:</span></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$matching</code><code> </code><code class="o">=</code><code> </code><code class="nb">preg_grep</code><code class="p">(</code><em><code class="nx">pattern</code></em><code class="p">,</code><code> </code><em><code class="k">array</code></em><code class="p">);</code></pre>

<p>For instance, to get only the filenames that end in <em>.txt</em>, use:<a contenteditable="false" data-primary="" data-startref="ix_functions_perl_reg_exp" data-type="indexterm" id="idm45922782592024"/><a contenteditable="false" data-primary="" data-startref="ix_perl_reg_exp_functions" data-type="indexterm" id="idm45922782590888"/></p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$textfiles</code> <code class="o">=</code> <code class="nb">preg_grep</code><code class="p">(</code><code class="s1">'/\.txt$/'</code><code class="p">,</code> <code class="nv">$filenames</code><code class="p">);</code></pre>
</div></section>

<section data-type="sect3" data-pdf-bookmark="Quoting for regular expressions"><div class="sect3" id="quoting_for_regular_expressions">
<h3>Quoting for regular expressions</h3>

<p><a contenteditable="false" data-primary="functions" data-secondary="quoting for regular expressions" data-type="indexterm" id="idm45922782565944"/><a contenteditable="false" data-primary="preg_quote function" data-type="indexterm" id="idm45922782564632"/>The <code>preg_quote()</code> function creates a regular expression that matches only a given string:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$re</code><code> </code><code class="o">=</code><code> </code><code class="nb">preg_quote</code><code class="p">(</code><em><code class="nx">string</code></em><code> </code><code class="p">[,</code><code> </code><em><code class="nx">delimiter</code></em><code> </code><code class="p">]);</code></pre>

<p>Every character in <em>string</em> that has special meaning inside a regular expression (e.g., <code>*</code> or <code>$</code>) is prefaced with a backslash:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="k">echo</code> <code class="nb">preg_quote</code><code class="p">(</code><code class="s1">'$5.00 (five bucks)'</code><code class="p">);</code>
<code class="nx">\</code><code class="err">$</code><code class="mi">5</code><code class="nx">\</code><code class="o">.</code><code class="mo">00</code> <code class="nx">\</code><code class="p">(</code><code class="nx">five</code> <code class="nx">bucks\</code><code class="p">)</code></pre>

<p>The optional second argument is an extra character to be quoted. Usually, you pass your regular expression delimiter here:</p>

<pre data-type="programlisting" data-code-language="php">
<code class="nv">$toFind</code> <code class="o">=</code> <code class="s1">'/usr/local/etc/rsync.conf'</code><code class="p">;</code>
<code class="nv">$re</code> <code class="o">=</code> <code class="nb">preg_quote</code><code class="p">(</code><code class="nv">$toFind</code><code class="p">,</code> <code class="s1">'/'</code><code class="p">);</code>

<code class="k">if</code> <code class="p">(</code><code class="nb">preg_match</code><code class="p">(</code><code class="s2">"/</code><code class="si">{</code><code class="nv">$re</code><code class="si">}</code><code class="s2">/"</code><code class="p">,</code> <code class="nv">$filename</code><code class="p">))</code> <code class="p">{</code>
 <code class="c1">// found it!</code>
<code class="p">}</code></pre>
</div></section>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Differences from Perl Regular Expressions"><div class="sect2" id="differences_from_perl_regular_expressio">
<h2>Differences from Perl Regular Expressions</h2>

<p><a contenteditable="false" data-type="indexterm" data-primary="regular expressions" data-secondary="compared to Perl regular expressions" id="idm45922782454936"/><a contenteditable="false" data-type="indexterm" data-primary="Perl-compatible regular expressions" data-seealso="regular expressions" id="idm45922782453704"/>Although very similar, PHP’s implementation of Perl-style regular expressions has a few minor differences from actual Perl regular expressions:</p>

<ul>
	<li>
	<p>The NULL character (ASCII 0) is not allowed as a literal character within a pattern string. You can reference it in other ways, however (<code>\000</code>, <code>\x00</code>, etc.).</p>
	</li>
	<li>
	<p>The <code>\E</code>, <code>\G</code>, <code>\L</code>, <code>\l</code>, <code>\Q</code>, <code>\u</code>, and <code>\U</code> options are not supported.</p>
	</li>
	<li>
	<p>The <code>(?{</code> <em>some perl code</em> <code>})</code> construct is not supported.</p>
	</li>
	<li>
	<p>The <code>/D</code>, <code>/G</code>, <code>/U</code>, <code>/u</code>, <code>/A</code>, and <code>/X</code> modifiers are supported.</p>
	</li>
	<li>
	<p>The vertical tab <code>\v</code> counts as a whitespace character.</p>
	</li>
	<li>
	<p>Lookahead and lookbehind assertions cannot be repeated using <code>*</code>, <code>+</code>, or <code>?</code>.</p>
	</li>
	<li>
	<p>Parenthesized submatches within negative assertions are not remembered.</p>
	</li>
	<li>
	<p>Alternation branches within a lookbehind assertion can be of different lengths.<a contenteditable="false" data-primary="" data-startref="ix_strings_ch4" data-type="indexterm" id="idm45922782434536"/><a contenteditable="false" data-primary="" data-startref="ix_reg_express_ch4" data-type="indexterm" id="idm45922782433160"/></p>
	</li>
</ul>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="What’s Next"><div class="sect1" id="whatapostrophes_next-id00062">
<h1>What’s Next</h1>

<p>Now that you know everything there is to know about strings and working with them, the next major part of PHP we’ll focus on is arrays. These compound data types will challenge you, but you need to get well acquainted with them, as PHP works with them in many areas. Learning how to add array elements, sort arrays, and deal with multidimensional forms of arrays is essential to being a good PHP developer.</p>
</div></section>
</div></section></div>



  </body></html>