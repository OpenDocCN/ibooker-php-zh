- en: Chapter 4\. Expressions and Control Flow in PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter introduced several topics in passing that this chapter
    covers more fully, such as making choices (branching) and creating complex expressions.
    In the previous chapter, I wanted to focus on the most basic syntax and operations
    in PHP, but I couldn’t avoid touching on more advanced topics. Now I can fill
    in the background that you need to use these powerful PHP features properly.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will get a thorough grounding in how PHP programming works
    in practice and how to control the flow of the program.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with the most fundamental part of any programming language: *expressions*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An expression is a combination of values, variables, operators, and functions
    that results in a value. It’s familiar to anyone who has taken high-school algebra.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Which in PHP would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The value returned (*`y`* in this mathematical statement, or `$y` in the PHP)
    can be a number, a string, or a *Boolean value* (named after George Boole, a 19th-century
    English mathematician and philosopher). By now, you should be familiar with the
    first two value types, but I’ll explain the third.
  prefs: []
  type: TYPE_NORMAL
- en: TRUE or FALSE?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A basic Boolean value can be either `TRUE` or `FALSE`. For example, the expression
    `20 > 9` (20 is greater than 9) is `TRUE`, and the expression `5 == 6` (5 is equal
    to 6) is `FALSE`. (You can combine such operations using other classic Boolean
    operators such as `AND`, `OR`, and `XOR`, which are covered later in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that I am using uppercase letters for the names `TRUE` and `FALSE`. This
    is because they are predefined constants in PHP. You can use the lowercase versions
    if you prefer, as they are also predefined. In fact, the lowercase versions are
    more stable, because PHP does not allow you to redefine them; the uppercase ones
    may be redefined, which is something you should bear in mind if you import third-party
    code.
  prefs: []
  type: TYPE_NORMAL
- en: PHP doesn’t actually print the predefined constants if you ask it to do so as
    in [Example 4-1](#outputting_the_values_of_true_and_false). For each line, the
    example prints out a letter followed by a colon and a predefined constant. PHP
    arbitrarily assigns a numerical value of `1` to `TRUE`, so `1` is displayed after
    `a:` when the example runs. Even more mysteriously, because `b:` evaluates to
    `FALSE`, it does not show any value. In PHP the constant `FALSE` is defined as
    `NULL`, another predefined constant that denotes nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-1\. Outputting the values of `TRUE` and `FALSE`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `<br>` tags are there to create line breaks and thus separate the output
    into two lines in HTML. Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Turning to Boolean expressions, [Example 4-2](#four_simple_boolean_expressions)
    shows some simple expressions: the two I mentioned earlier, plus a couple more.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-2\. Four simple Boolean expressions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this code is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: By the way, in some languages `FALSE` may be defined as `0` or even `–1`, so
    it’s worth checking on its definition in each language you use. Luckily, Boolean
    expressions are usually buried in other code, so you don’t normally have to worry
    about what `TRUE` and `FALSE` look like internally. In fact, those names rarely
    appear in code.
  prefs: []
  type: TYPE_NORMAL
- en: Literals and Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These are the most basic elements of programming, and the building blocks of
    expressions. A *literal* simply means something that evaluates to itself, such
    as the number `73` or the string `"Hello"`. A variable, which we’ve already seen
    has a name beginning with a dollar sign, evaluates to the value that has been
    assigned to it. The simplest expression is just a single literal or variable,
    because both return a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-3](#literals_and_variables-id00008) shows three literals and two
    variables, all of which return values, albeit of different types.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-3\. Literals and variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And, as you’d expect, you see a return value from all of these with the exception
    of `c:`, which evaluates to `FALSE`, returning nothing in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In conjunction with operators, it’s possible to create more complex expressions
    that evaluate to useful results.
  prefs: []
  type: TYPE_NORMAL
- en: Programmers combine expressions with other language constructs, such as the
    assignment operators we saw earlier, to form *statements*. [Example 4-4](#expression_and_a_statement)
    shows two statements. The first assigns the result of the expression `366 - $day_number`
    to the variable `$days_to_new_year`, and the second outputs a friendly message
    only if the expression `$days_to_new_year < 30` evaluates to `TRUE`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-4\. An expression and a statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP offers a lot of powerful operators of different types—arithmetic, string,
    logical, assignment, comparison, and more (see [Table 4-1](#php_operator_types)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. PHP operator types
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Arithmetic | Basic mathematics | `$a + $b` |'
  prefs: []
  type: TYPE_TB
- en: '| Array | Array union | `$a + $b` |'
  prefs: []
  type: TYPE_TB
- en: '| Assignment | Assign values | `$a = $b + 23` |'
  prefs: []
  type: TYPE_TB
- en: '| Bitwise | Manipulate bits within bytes | `12 ^ 9` |'
  prefs: []
  type: TYPE_TB
- en: '| Comparison | Compare two values | `$a < $b` |'
  prefs: []
  type: TYPE_TB
- en: '| Execution | Execute contents of backticks | `` `ls -al` `` |'
  prefs: []
  type: TYPE_TB
- en: '| Increment/decrement | Add or subtract 1 | `$a++` |'
  prefs: []
  type: TYPE_TB
- en: '| Logical | Boolean | `$a and $b` |'
  prefs: []
  type: TYPE_TB
- en: '| String | Concatenation | `$a . $b` |'
  prefs: []
  type: TYPE_TB
- en: 'Each operator takes a different number of operands:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unary* operators, such as incrementing (`$a++`) or negation (!`$a`), take
    a single operand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Binary* operators, which represent the bulk of PHP operators (including addition,
    subtraction, multiplication, and division), take two operands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The one *ternary* operator, which takes the form `expr ? x : y`, requires three
    operands. It’s a terse, single-line `if` statement that returns `x` if `expr`
    is `TRUE` and `y` if `expr` is `FALSE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operator Precedence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all operators had the same precedence, they would be processed in the order
    in which they are encountered. In fact, many operators do have the same precedence.
    Take a look at [Example 4-5](#three_equivalent_expressions).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-5\. Three equivalent expressions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here you will see that although the numbers (and their preceding operators)
    have been moved around, the result of each expression is the value `7`, because
    the plus and minus operators have the same precedence. We can try the same thing
    with multiplication and division (see [Example 4-6](#three_expressions_that_are_also_equivale)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-6\. Three expressions that are also equivalent
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here the resulting value is always `7.5`. But things change when we mix operators
    with *different* precedences in an expression, as in [Example 4-7](#three_expressions_using_operators_of_mix).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-7\. Three expressions using operators of mixed precedence
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If there were no operator precedence, these three expressions would evaluate
    to `25`, `–29`, and `12`, respectively. But because multiplication and division
    take precedence over addition and subtraction, the expressions are evaluated as
    if there were parentheses around these parts of the expressions, just like mathematical
    notation (see [Example 4-8](#three_expressions_showing_implied_parent)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-8\. Three expressions showing implied parentheses
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: PHP evaluates the subexpressions within parentheses first to derive the semi-completed
    expressions in [Example 4-9](#after_evaluating_the_sub-expressions_in).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-9\. After evaluating the subexpressions in parentheses
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The final results of these expressions are `–13`, `–57`, and `6`, respectively
    (quite different from the results of `25`, `–29`, and `12` that we would have
    seen had there been no operator precedence).
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can override the default operator precedence by inserting your
    own parentheses and forcing whatever order you want (see [Example 4-10](#forcing_left-to-right_evaluation)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-10\. Forcing left-to-right evaluation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With parentheses correctly inserted, we now see the values `25`, `–29`, and
    `12`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-2](#precedence_of_php_operators_left_par) lists PHP’s operators in
    order of precedence from high to low.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-2\. The precedence of PHP operators (high to low)
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator(s) | Type |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `()` | Parentheses |'
  prefs: []
  type: TYPE_TB
- en: '| `++ --` | Increment/decrement |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `* / %` | Arithmetic |'
  prefs: []
  type: TYPE_TB
- en: '| `+ - .` | Arithmetic and string |'
  prefs: []
  type: TYPE_TB
- en: '| `<< >>` | Bitwise |'
  prefs: []
  type: TYPE_TB
- en: '| `< <= > >= <>` | Comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `== != === !==` | Comparison |'
  prefs: []
  type: TYPE_TB
- en: '| `&` | Bitwise (and references) |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Bitwise |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;` | Bitwise |'
  prefs: []
  type: TYPE_TB
- en: '| `&&` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124;` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `? :` | Ternary |'
  prefs: []
  type: TYPE_TB
- en: '| `= += -= *= /= .= %= &= != ^= <<= >>=` | Assignment |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `xor` | Logical |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | Logical |'
  prefs: []
  type: TYPE_TB
- en: The order in this table is not arbitrary but carefully designed so that the
    most common and intuitive precedences are the ones you can get without parentheses.
    For instance, you can separate two comparisons with an `and` or `or` and get what
    you’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve been looking at processing expressions from left to right, except where
    operator precedence is in effect. But some operators require processing from right
    to left, and this direction of processing is called the operator’s *associativity*.
    For some operators, there is no associativity.
  prefs: []
  type: TYPE_NORMAL
- en: Associativity (as detailed in [Table 4-3](#operator_associativity)) becomes
    important in cases in which you do not explicitly force precedence, so you need
    to be aware of the default actions of operators.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-3\. Operator associativity
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description | Associativity |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `< <= >= == != === !== <>` | Comparison | None |'
  prefs: []
  type: TYPE_TB
- en: '| `!` | Logical `NOT` | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `~` | Bitwise `NOT` | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `++ --` | Increment and decrement | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `(int)` | Cast to an integer | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `(double) (float) (real)` | Cast to a floating-point number | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `(string)` | Cast to a string | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `(array)` | Cast to an array | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `(object)` | Cast to an object | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `@` | Inhibit error reporting | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `= += -= *= /=` | Assignment | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `.= %= &= &#124;= ^= <<= >>=` | Assignment | Right |'
  prefs: []
  type: TYPE_TB
- en: '| `+` | Addition and unary plus | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | Subtraction and negation | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `*` | Multiplication | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Division | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `%` | Modulus | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | String concatenation | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `<< >> & ^ &#124;` | Bitwise | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `?:` | Ternary | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `&#124;&#124; && and or xor` | Logical | Left |'
  prefs: []
  type: TYPE_TB
- en: '| `,` | Separator | Left |'
  prefs: []
  type: TYPE_TB
- en: For example, let’s take a look at the assignment operator in [Example 4-11](#multiple-assignment_statement),
    where three variables are all set to the value `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-11\. A multiple-assignment statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This multiple assignment is possible only if the rightmost part of the expression
    is evaluated first and then processing continues in a right-to-left direction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As a newcomer to PHP, you should avoid the potential pitfalls of operator associativity
    by always nesting your subexpressions within parentheses to force the order of
    evaluation. This will also help other programmers who may have to maintain your
    code to understand what is happening.
  prefs: []
  type: TYPE_NORMAL
- en: Relational Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Relational operators answer questions such as “Does this variable have a value
    of zero?” and “Which variable has a greater value?” These operators test two operands
    and return a Boolean result of either `TRUE` or `FALSE`. There are three types
    of relational operators: *equality*, *comparison*, and *logical*.'
  prefs: []
  type: TYPE_NORMAL
- en: Equality
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we’ve already seen a few times in this chapter, the equality operator is
    `==` (two equals signs). It is important not to confuse it with the `=` (single
    equals sign) assignment operator. In [Example 4-12](#assigning_a_value_and_testing_for_equali),
    the first statement assigns a value and the second tests it for equality.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-12\. Assigning a value and testing for equality
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As you see, by returning either `TRUE` or `FALSE`, the equality operator enables
    you to test for conditions using, for example, an `if` statement. But that’s not
    the whole story, because PHP is a loosely typed language. If the two operands
    of an equality expression are of different types, PHP will convert them to whatever
    type makes the best sense to it. A rarely used *identity* operator, which consists
    of three equals signs in a row, can be used to compare items without doing conversion.
  prefs: []
  type: TYPE_NORMAL
- en: For example, any strings composed entirely of numbers will be converted to numbers
    whenever compared with a number. In [Example 4-13](#equality_and_identity_operators),
    `$a` and `$b` are two different strings, and we would therefore expect neither
    of the `if` statements to output a result.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-13\. The equality and identity operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: However, if you run the example, you will see that it outputs the number `1`,
    which means that the first `if` statement evaluated to `TRUE`. This is because
    both strings were first converted to numbers, and `1000` is the same numerical
    value as `+1000`. In contrast, the second `if` statement uses the identity operator,
    so it compares `$a` and `$b` as strings, sees that they are different, and thus
    doesn’t output anything.
  prefs: []
  type: TYPE_NORMAL
- en: As with forcing operator precedence, whenever you have any doubt about how PHP
    will convert operand types, you can use the identity operator to turn this behavior
    off.
  prefs: []
  type: TYPE_NORMAL
- en: In the same way that you can use the equality operator to test for operands
    being equal, you can test for them *not* being equal using `!=`, the inequality
    operator. Take a look at [Example 4-14](#inequality_and_not_identical_operato),
    which is a rewrite of [Example 4-13](#equality_and_identity_operators), in which
    the equality and identity operators have been replaced with their inverses.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-14\. The inequality and not-identical operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And, as you might expect, the first `if` statement does not output the number
    `1`, because the code is asking whether `$a` and `$b` are *not* equal to each
    other numerically.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, this code outputs the number `2`, because the second `if` statement
    is asking whether `$a` and `$b` are *not* identical to each other in their actual
    string type, and the answer is `TRUE`; they are not the same.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using comparison operators, you can test for more than just equality and inequality.
    PHP also gives you `>` (is greater than), `<` (is less than), `>=` (is greater
    than or equal to), and `<=` (is less than or equal to) to play with. [Example 4-15](#four_comparison_operators)
    shows these in use.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-15\. The four comparison operators
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, where `$a` is `2` and `$b` is `3`, the following is output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Try this example yourself, altering the values of `$a` and `$b`, to see the
    results. Try setting them to the same value and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: Logical operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Logical operators produce true or false results and therefore are also known
    as *Boolean operators*. There are four of them (see [Table 4-4](#logical_operators-id00012)).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-4\. The logical operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Logical operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AND` | `TRUE` if both operands are `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `OR` | `TRUE` if either operand is `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `XOR` | `TRUE` if one of the two operands is `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `! (NOT)` | `TRUE` if the operand is `FALSE`, or `FALSE` if the operand is
    `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: You can see these operators used in [Example 4-16](#logical_operators_in_use).
    Note that the `!` symbol is required by PHP in place of `NOT`. Furthermore, the
    operators can be lower- or uppercase.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-16\. The logical operators in use
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Line by line, this example outputs nothing, `1`, `1`, and nothing, meaning that
    only the second and third `echo` statements evaluate as `TRUE`. (Remember that
    `NULL`—or nothing—represents a value of `FALSE`.) This is because the `AND` statement
    requires both operands to be `TRUE` if it is going to return a value of `TRUE`,
    while the fourth statement performs a `NOT` on the value of `$a`, turning it from
    `TRUE` (a value of `1`) to `FALSE`. If you wish to experiment with this, try out
    the code, giving `$a` and `$b` varying values of `1` and `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When coding, remember that `AND` and `OR` have lower precedence than the other
    versions of the operators, `&&` and `||`.
  prefs: []
  type: TYPE_NORMAL
- en: The `OR` operator can cause unintentional problems in `if` statements, because
    the second operand will not be evaluated if the first is evaluated as `TRUE`.
    In [Example 4-17](#statement_using_the_or_operator), the function `getnext` will
    never be called if `$finished` has a value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-17\. A statement using the `OR` operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you need `getnext` to be called at each `if` statement, you could rewrite
    the code as has been done in [Example 4-18](#quotation_markif_dotdotdot_orquotati).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-18\. The `if...OR` statement modified to ensure calling of `getnext`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the code executes the `getnext` function and stores the value
    returned in `$gn` before executing the `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another solution is to switch the two clauses to make sure that `getnext` is
    executed, as it will then appear first in the expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 4-5](#all_possible_php_logical_expressions) shows all the possible variations
    of using the logical operators. You should also note that `!TRUE` equals `FALSE`,
    and `!FALSE` equals `TRUE`.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-5\. All possible PHP logical expressions
  prefs: []
  type: TYPE_NORMAL
- en: '| Inputs |   | Operators and results |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| a | b | AND | OR | XOR |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `TRUE` | `TRUE` | `TRUE` | `FALSE` |'
  prefs: []
  type: TYPE_TB
- en: '| `TRUE` | `FALSE` | `FALSE` | `TRUE` | `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `FALSE` | `TRUE` | `FALSE` | `TRUE` | `TRUE` |'
  prefs: []
  type: TYPE_TB
- en: '| `FALSE` | `FALSE` | `FALSE` | `FALSE` | `FALSE` |'
  prefs: []
  type: TYPE_TB
- en: Conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Conditionals* alter program flow. They enable you to ask questions about certain
    things and respond to the answers you get in different ways. Conditionals are
    central to creating dynamic web pages—the goal of using PHP in the first place—because
    they make it easy to render different output each time a page is viewed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll present three basic conditionals in this section: the `if` statement,
    the `switch` statement, and the `?` operator. In addition, looping conditionals
    (which we’ll get to shortly) execute code over and over until a condition is met.'
  prefs: []
  type: TYPE_NORMAL
- en: The if Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of thinking about program flow is to imagine it as a single-lane highway
    that you are driving along. It’s pretty much a straight line, but now and then
    you encounter various signs telling you where to go.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of an `if` statement, you could imagine coming across a detour sign
    that you have to follow if a certain condition is `TRUE`. If so, you drive off
    and follow the detour until you return to the main road and then continue on your
    way in your original direction. Or, if the condition isn’t `TRUE`, you ignore
    the detour and carry on driving (see [Figure 4-1](#program_flow_is_like_a_single-lane_highw)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Program flow is like a single-lane highway](Images/pmj6_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Program flow is like a single-lane highway
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The contents of the `if` condition can be any valid PHP expression, including
    tests for equality, comparison expressions, tests for `0` and `NULL`, and even
    functions (either built-in functions or ones that you write).
  prefs: []
  type: TYPE_NORMAL
- en: The actions to take when an `if` condition is `TRUE` are generally placed inside
    curly braces (`{ }`). You can ignore the braces if you have only a single statement
    to execute, but if you always use curly braces, you’ll avoid having to hunt down
    difficult-to-trace bugs, such as when you add an extra line to a condition and
    it doesn’t get evaluated due to the lack of braces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A notorious security vulnerability known as the “goto fail” bug haunted the
    Secure Sockets Layer (SSL) code in Apple’s products for many years because a programmer
    had forgotten the curly braces around an `if` statement, causing a function to
    sometimes report a successful connection when that may not actually have always
    been the case. This allowed a malicious attacker to get a secure certificate to
    be accepted when it should have been rejected. If in doubt, place braces around
    your `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for brevity and clarity, however, many of the examples in this book
    ignore this suggestion and omit the braces for single statements.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 4-19](#if_statement_with_curly_braces), imagine that it is the end
    of the month and all your bills have been paid, so you are performing some bank
    account maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-19\. An `if` statement with curly braces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, you are checking your balance to see whether it is less than
    $100 (or whatever your currency is). If so, you pay yourself $1,000 and then add
    it to the balance. (If only making money were that simple!)
  prefs: []
  type: TYPE_NORMAL
- en: If the bank balance is $100 or greater, the conditional statements are ignored
    and program flow skips to the next line (not shown).
  prefs: []
  type: TYPE_NORMAL
- en: In this book, opening curly braces generally start on a new line. Some people
    like to place the first curly brace to the right of the conditional expression;
    others start a new line with it. Either of these is fine, because PHP allows you
    to set out your whitespace characters (spaces, newlines, and tabs) any way you
    choose. However, you will find your code easier to read and debug if you indent
    each level of conditionals with a tab.
  prefs: []
  type: TYPE_NORMAL
- en: The else Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes when a conditional is not `TRUE`, you may not want to continue on
    to the main program code immediately but might wish to do something else instead.
    This is where the `else` statement comes in. With it, you can set up a second
    detour on your highway, as in [Figure 4-2](#highway_now_has_an_if_detour_and_an).
  prefs: []
  type: TYPE_NORMAL
- en: With an `if...else` statement, the first conditional statement is executed if
    the condition is `TRUE`. But if it’s `FALSE`, the second one is executed. One
    of the two choices *must* be executed. Under no circumstance can both (or neither)
    be executed. [Example 4-20](#if_dotdotdot_else_statement_with_curl) shows the
    use of the `if...else` structure.
  prefs: []
  type: TYPE_NORMAL
- en: '![The highway now has an if detour and an else detour](Images/pmj6_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Highway now has an `if` detour and an `else` detour
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Example 4-20\. An `if...else` statement with curly braces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if you’ve ascertained that you have $100 or more in the bank,
    the `else` statement is executed, placing some of this money into your savings
    account.
  prefs: []
  type: TYPE_NORMAL
- en: As with `if` statements, if your `else` has only one conditional statement,
    you can opt to leave out the curly braces. (Curly braces are always recommended,
    though. First, they make the code easier to understand. Second, they let you easily
    add more statements to the branch later.)
  prefs: []
  type: TYPE_NORMAL
- en: The elseif Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also times when you want a number of different possibilities to occur,
    based upon a sequence of conditions. You can achieve this using the `elseif` statement.
    As you might imagine, it is like an `else` statement, except that you place a
    further conditional expression prior to the conditional code. In [Example 4-21](#if_dotdotdot_elseif_dotdotdot_else_st),
    you can see a complete `if...elseif...else` construct.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-21\. An `if...elseif...else` statement with curly braces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the example, an `elseif` statement has been inserted between the `if` and
    `else` statements. It checks whether your bank balance exceeds $200 and, if so,
    decides that you can afford to save $100 this month.
  prefs: []
  type: TYPE_NORMAL
- en: Although I’m starting to stretch the metaphor a bit too far, you can imagine
    this as a multiway set of detours (see [Figure 4-3](#highway_with_ifcomma_elseifcomma_and)).
  prefs: []
  type: TYPE_NORMAL
- en: '![The highway with if, elseif, and else detours](Images/pmj6_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. The highway with `if`, `elseif`, and `else` detours
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An `else` statement closes either an `if...else` or an `if...elseif...else`
    statement. You can leave out a final `else` if it is not required, but you cannot
    have one before an `elseif`; you also cannot have an `elseif` before an `if` statement.
  prefs: []
  type: TYPE_NORMAL
- en: You may have as many `elseif` statements as you like. But as the number of `elseif`
    statements increases, you would probably be better advised to consider a `switch`
    statement if it fits your needs. We’ll look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: The switch Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `switch` statement is useful where one variable, or the result of an expression,
    can have multiple values, each of which should trigger a different activity.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a PHP-driven menu system that passes a single string to
    the main menu code according to what the user requests. Let’s say the options
    are Home, About, News, Login, and Links, and we set the variable `$page` to one
    of these, according to the user’s input.
  prefs: []
  type: TYPE_NORMAL
- en: If we write the code for this using `if...elseif...else`, it might look like
    [Example 4-22](#multiple-line_if_dotdotdot_elseif_dotd).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-22\. A multiline `if...elseif...else` statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If we use a `switch` statement, the code might look like [Example 4-23](#switch_statement-id00013).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-23\. A `switch` statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `$page` is mentioned only once at the start of the `switch`
    statement. Thereafter, the `case` command checks for matches. When one occurs,
    the matching conditional statement is executed. Of course, in a real program you
    would have code here to display or jump to a page, rather than simply telling
    the user what was selected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With `switch` statements, you do not use curly braces inside `case` commands.
    Instead, they commence with a colon and end with the `break` statement. The entire
    list of cases in the `switch` statement is enclosed in a set of curly braces,
    though.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking out
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you wish to break out of the `switch` statement because a condition has been
    fulfilled, use the `break` command. This command tells PHP to exit the `switch`
    and jump to the following statement.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to leave out the `break` commands in [Example 4-23](#switch_statement-id00013)
    and the case of `Home` evaluated to be `TRUE`, all five cases would then be executed.
    Or, if `$page` had the value `News`, all the `case` commands from then on would
    execute. This is deliberate and allows for some advanced programming, but generally
    you should always remember to issue a `break` command every time a set of `case`
    conditionals has finished executing. In fact, leaving out the `break` statement
    is a common error.
  prefs: []
  type: TYPE_NORMAL
- en: Default action
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical requirement in `switch` statements is to fall back on a default action
    if none of the `case` conditions are met. For example, in the case of the menu
    code in [Example 4-23](#switch_statement-id00013), you could add the code in [Example 4-24](#default_statement_to_add_to_example_4)
    immediately before the final curly brace.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-24\. A default statement to add to [Example 4-23](#switch_statement-id00013)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This replicates the effect of the `else` statement in [Example 4-22](#multiple-line_if_dotdotdot_elseif_dotd).
  prefs: []
  type: TYPE_NORMAL
- en: Although a `break` command is not required here because the default is the final
    sub-statement and program flow will automatically continue to the closing curly
    brace, should you decide to place the `default` statement higher up, it would
    definitely need a `break` command to prevent program flow from dropping into the
    following statements. Generally, the safest practice is to always include the
    `break` command.
  prefs: []
  type: TYPE_NORMAL
- en: Alternative syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you prefer, you may replace the first curly brace in a `switch` statement
    with a single colon and the final curly brace with an `endswitch` command, as
    in [Example 4-25](#alternate_switch_statement_syntax). However, this approach
    is not commonly used and is mentioned here only in case you encounter it in third-party
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-25\. Alternate `switch` statement syntax
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `?` (or ternary) Operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of avoiding the verbosity of `if` and `else` statements is to use the
    more compact ternary operator, `?`, which is unusual in that it takes three operands
    rather than the typical two.
  prefs: []
  type: TYPE_NORMAL
- en: We briefly came across this in [Chapter 3](ch03.xhtml#introduction_to_php) in
    the discussion about the difference between the `print` and `echo` statements
    as an example of an operator type that works well with `print` but not `echo`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `?` operator is passed an expression that it must evaluate, along with
    two statements to execute: one for when the expression evaluates to `TRUE`, the
    other for when it is `FALSE`. [Example 4-26](#using_the_question_mark_operator)
    shows code we might use for writing a warning about the fuel level of a car to
    its digital dashboard.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-26\. Using the `?` operator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this statement, if there is one gallon or less of fuel (in other words, `$fuel`
    is set to `1` or less), the string `Fill tank now` is returned to the preceding
    `echo` statement. Otherwise, the string `There's enough fuel` is returned. You
    can also assign the value returned in a `?` statement to a variable (see [Example 4-27](#assigning_a_question_markconditional_res)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-27\. Assigning a `?` conditional result to a variable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, `$enough` will be assigned the value `TRUE` only when there is more than
    a gallon of fuel; otherwise, it is assigned the value `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find the `?` operator confusing, you are free to stick to `if` statements,
    but you should be familiar with the operator because you’ll see it in other people’s
    code. It can be hard to read, because it often mixes multiple occurrences of the
    same variable. For instance, code such as the following is quite popular:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you take it apart carefully, you can figure out what this code does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It’s a concise way to keep track of the largest value that you’ve seen as a
    program progresses. You save the largest value in `$saved` and compare it to `$new`
    each time you get a new value. Programmers familiar with the `?` operator find
    it more convenient than `if` statements for such short comparisons. When not used
    for writing compact code, it is typically used to make some decision inline, such
    as when you are testing whether a variable is set before passing it to a function.
  prefs: []
  type: TYPE_NORMAL
- en: Looping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the great things about computers is that they can repeat calculating
    tasks quickly and tirelessly. Often you may want a program to repeat the same
    sequence of code again and again until something happens, such as a user inputting
    a value or reaching a natural end. PHP’s loop structures provide the perfect way
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: To picture how this works, look at [Figure 4-4](#imagining_a_loop_as_part_of_a_program_hi).
    It is much the same as the highway metaphor used to illustrate `if` statements,
    except the detour also has a loop section that—once a vehicle has entered it—can
    be exited only under the right program conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '![Imagining a loop as part of a program highway layout](Images/pmj6_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. Imagining a loop as part of a program highway layout
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: while Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s turn the digital car dashboard in [Example 4-26](#using_the_question_mark_operator)
    into a loop that continuously checks the fuel level as you drive, using a `while`
    loop ([Example 4-28](#while_loop)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-28\. A `while` loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Actually, you might prefer to keep a green light lit rather than output text,
    but the point is that whatever positive indication you wish to make about the
    level of fuel is placed inside the `while` loop. By the way, if you try this example
    for yourself, note that it will keep printing the string until you click the Stop
    button in your browser.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As with `if` statements, you will notice that curly braces are required to hold
    the statements inside the `while` statements, unless there’s only one.
  prefs: []
  type: TYPE_NORMAL
- en: For another example of a `while` loop that displays the 12 times table, see
    [Example 4-29](#while_loop_to_print_the_12_times_table).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-29\. A `while` loop to print the 12 times table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the variable `$count` is initialized to a value of `1`, and then a `while`
    loop starts with the comparative expression `$count <= 12`. This loop will continue
    executing until the variable is greater than 12\. The output from this code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Inside the loop, a string is printed along with the value of `$count` multiplied
    by 12\. For neatness, this is followed with a `<br>` tag to force a new line.
    Then `$count` is incremented, ready for the final curly brace that tells PHP to
    return to the start of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, `$count` is again tested to see whether it is greater than 12\.
    It isn’t, but it now has the value `2`, and after another 11 times around the
    loop, it will have the value `13`. When that happens, the code within the `while`
    loop is skipped and execution passes to the code following the loop, which, in
    this case, is the end of the program.
  prefs: []
  type: TYPE_NORMAL
- en: If the `++$count` statement (which could equally have been `$count++`) had not
    been there, this loop would be like the first one in this section. It would never
    end, and only the result of `1 * 12` would be printed over and over.
  prefs: []
  type: TYPE_NORMAL
- en: But there is a much neater way this loop can be written, which I think you will
    like. Take a look at [Example 4-30](#shortened_version_of_example_4-29).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-30\. A shortened version of [Example 4-29](#while_loop_to_print_the_12_times_table)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, it was possible to move the `++$count` statement from the statements
    inside the `while` loop into the conditional expression of the loop. What now
    happens is that PHP encounters the variable `$count` at the start of each iteration
    of the loop and, noticing that it is prefaced with the increment operator, first
    increments the variable and only then compares it to the value `12`. You can therefore
    see that `$count` now has to be initialized to `0`, not `1`, because it is incremented
    as soon as the loop is entered. If you keep the initialization at `1`, only results
    between 2 and 12 will be output.
  prefs: []
  type: TYPE_NORMAL
- en: do...while Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A slight variation to the `while` loop is the `do...while` loop, used when you
    want a block of code to be executed at least once and made conditional only after
    that. [Example 4-31](#do_dotdotdot_while_loop_for_printing_t) shows a modified
    version of the code for the 12 times table that uses such a loop.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-31\. A `do...while` loop for printing the 12 times table
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we are back to initializing `$count` to `1` (rather than `0`) because
    of the loop’s `echo` statement being executed before we have an opportunity to
    increment the variable. Other than that, though, the code looks pretty similar.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you have more than a single statement inside a `do...while` loop,
    remember to use curly braces, as in [Example 4-32](#expanding_example_4-31_to_use_curly_brac).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-32\. Expanding [Example 4-31](#do_dotdotdot_while_loop_for_printing_t)
    to use curly braces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: for Loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final kind of loop statement, the `for` loop, is also the most powerful,
    as it combines the abilities to set up variables as you enter the loop, test for
    conditions while iterating loops, and modify variables after each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 4-33](#outputting_the_times_table_for_12_from_a) shows how to write
    the multiplication table program with a `for` loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-33\. Outputting the 12 times table from a `for` loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'See how the code has been reduced to a single `for` statement containing a
    single conditional statement? Here’s what is going on. Each `for` statement takes
    three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: An initialization expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A condition expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A modification expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are separated by semicolons like this: `for (`*`expr1`* `;` *`expr2`*
    `;` *`expr3`*`)`. At the start of the first iteration of the loop, the initialization
    expression is executed. In the case of the times table code, `$count` is initialized
    to the value `1`. Then, each time around the loop, the condition expression (in
    this case, `$count <= 12`) is tested, and the loop is entered only if the condition
    is `TRUE`. Finally, at the end of each iteration, the modification expression
    is executed. In the case of the times table code, the variable `$count` is incremented.'
  prefs: []
  type: TYPE_NORMAL
- en: All this structure neatly removes any requirement to place the controls for
    a loop within its body, freeing it up just for the statements you want the loop
    to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to use curly braces with a `for` loop if it will contain more than
    one statement, as in [Example 4-34](#for_loop_from_example_4-33_with_adde).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-34\. The `for` loop from [Example 4-33](#outputting_the_times_table_for_12_from_a)
    with added curly braces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s compare when to use `for` and `while` loops. The `for` loop is explicitly
    designed around a single value that changes on a regular basis. Usually you have
    a value that increments, as when you are passed a list of user choices and want
    to process each choice in turn. But you can transform the variable any way you
    like. A more complex form of the `for` statement even lets you perform multiple
    operations in each of the three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s complicated and not recommended for first-time users, though. The key
    is to distinguish commas from semicolons. The three parameters must be separated
    by semicolons. Within each parameter, multiple statements can be separated by
    commas. Thus, in the previous example, the first and third parameters each contain
    two statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The main thing to take from this example is that you must separate the three
    parameter sections with semicolons, not commas (which should be used only to separate
    statements within a parameter section).
  prefs: []
  type: TYPE_NORMAL
- en: So, when is a `while` statement more appropriate than a `for` statement? When
    your condition doesn’t depend on a simple, regular change to a variable. For instance,
    if you want to check for some special input or error and end the loop when it
    occurs, use a `while` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking Out of a Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as you saw how to break out of a `switch` statement, you can also break
    out of a `for` loop (or any loop) using the same `break` command. This step can
    be necessary when, for example, one of your statements returns an error and the
    loop cannot continue executing safely. One case in which this might occur is when
    writing a file returns an error, possibly because the disk is full (see [Example 4-35](#writing_a_file_using_a_for_loop_with_err)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-35\. Writing a file using a `for` loop with error trapping
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is the most complicated piece of code that you have seen so far, but you’re
    ready for it. We’ll look into the file-handling commands in [Chapter 7](ch07.xhtml#practical_php),
    but for now all you need to know is that the first line opens the file *text.txt*
    for writing in binary mode and then returns a pointer to the file in the variable
    `$fp`, which is used later to refer to the open file.
  prefs: []
  type: TYPE_NORMAL
- en: The loop then iterates 100 times (from 0 to 99), writing the string `data` to
    the file. After each write, the variable `$written` is assigned a value by the
    `fwrite` function representing the number of characters correctly written. But
    if there is an error, the `fwrite` function assigns the value `FALSE`.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of `fwrite` makes it easy for the code to check the variable `$written`
    to see whether it is set to `FALSE` and, if so, to break out of the loop to the
    following statement that closes the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are looking to improve the code, you can simplify the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'using the `NOT` operator, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, the pair of inner loop statements can be shortened to a single statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In other words, you can eliminate the `$written` variable, because it existed
    only to check the value returned from `fwrite`. You can instead test the return
    value directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `break` command is even more powerful than you might think, because if
    you have code nested more than one layer deep that you need to break out of, you
    can follow the `break` command with a number to indicate how many levels to break
    out of:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The continue Statement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `continue` statement is a little like a `break` statement, except that it
    instructs PHP to stop processing the current iteration of the loop and move right
    to its next iteration. So, instead of breaking out of the whole loop, PHP exits
    only the current iteration.
  prefs: []
  type: TYPE_NORMAL
- en: This approach can be useful in cases where you know there is no point continuing
    execution within the current loop and you want to save processor cycles or prevent
    an error from occurring by moving right along to the next iteration of the loop.
    In [Example 4-36](#trapping_division-by-zero_errors_using_c), a `continue` statement
    is used to prevent a division-by-zero error from being issued when the variable
    `$j` has a value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-36\. Trapping division-by-zero errors using `continue`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: For all values of `$j` between `10` and `–10`, with the exception of `0`, the
    result of calculating `10` divided by `$j` is displayed. But for the case of `$j`
    being `0`, the `continue` statement is issued, and execution skips immediately
    to the next iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit and Explicit Casting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP is a loosely typed language that allows you to declare a variable and its
    type simply by using it. It also automatically converts values from one type to
    another whenever required. This is called *implicit casting*.
  prefs: []
  type: TYPE_NORMAL
- en: However, at times PHP’s implicit casting may not be what you want. In [Example 4-37](#this_expression_returns_a_floating-point),
    note that the inputs to the division are integers. By default, PHP converts the
    output to floating point so it can give the most precise value—4.66 recurring.
  prefs: []
  type: TYPE_NORMAL
- en: Example 4-37\. This expression returns a floating-point number
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'But what if we had wanted `$c` to be an integer instead? There are various
    ways we could achieve this, one of which is to force the result of `$a / $b` to
    be cast to an integer value using the integer cast type `(int)`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This is called *explicit* casting. Note that in order to ensure that the value
    of the entire expression is cast to an integer, we place the expression within
    parentheses. Otherwise, only the variable `$a` would have been cast to an integer—a
    pointless exercise, as the division by `$b` would still have returned a floating-point
    number.
  prefs: []
  type: TYPE_NORMAL
- en: You can explicitly cast variables and literals to the types shown in [Table 4-6](#phpapostrophes_cast_types).
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-6\. PHP’s cast types
  prefs: []
  type: TYPE_NORMAL
- en: '| Cast type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `(int) (integer)` | Cast to an integer by dropping the decimal portion. |'
  prefs: []
  type: TYPE_TB
- en: '| `(bool) (boolean)` | Cast to a Boolean. |'
  prefs: []
  type: TYPE_TB
- en: '| `(float) (double) (real)` | Cast to a floating-point number. |'
  prefs: []
  type: TYPE_TB
- en: '| `(string)` | Cast to a string. |'
  prefs: []
  type: TYPE_TB
- en: '| `(array)` | Cast to an array. |'
  prefs: []
  type: TYPE_TB
- en: '| `(object)` | Cast to an object. |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can usually avoid having to use a cast by calling one of PHP’s built-in
    functions. For example, to obtain an integer value, you could use the `intval`
    function. As with some other sections in this book, this section is here mainly
    to help you understand third-party code that you may encounter from time to time.
  prefs: []
  type: TYPE_NORMAL
- en: PHP Dynamic Linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Because PHP is a programming language, and the output from it can be completely
    different for each user, it’s possible for an entire website to run from a single
    PHP web page. Each time the user clicks something, the details can be sent back
    to the same web page, which decides what to do next according to the various cookies
    and/or other session details it may have stored.
  prefs: []
  type: TYPE_NORMAL
- en: But although it is possible to build an entire website this way, it’s not recommended,
    because your source code will grow and grow and start to become unwieldy, as it
    has to account for every possible action a user could take.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, it’s much more sensible to split your website development into different
    parts. For example, one distinct process is signing up for a website, along with
    all the checking this entails to validate an email address, determine whether
    a username is already taken, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: A second module might be one that logs users in before handing them off to the
    main part of your website. Then you might have a messaging module with the facility
    for users to leave comments, a module containing links and useful information,
    another to allow uploading of images, and more.
  prefs: []
  type: TYPE_NORMAL
- en: As long as you have created a way to track your user through your website by
    means of cookies or session variables (both of which we’ll look at more closely
    in later chapters), you can split up your website into sensible sections of PHP
    code, each one self-contained, and therefore treat yourself to a much easier future,
    developing each new feature and maintaining old ones. If you have a team, different
    people can work on different modules so that each programmer needs to learn just
    one part of the program thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Linking in Action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the more popular PHP-driven applications on the web today is the Content
    Management System (CMS) WordPress (see [Figure 4-5](#wordpress_blogging_platform_is_writt)).
    You might not realize it, but every major section has been given its own main
    PHP file, and a whole raft of generic, shared functions have been placed in separate
    files that are included by the main PHP pages as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/pmj6_0405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-5\. The WordPress CMS
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The whole platform is held together with behind-the-scenes session tracking
    so that you hardly know when you are transitioning from one subsection to another.
    Therefore, a web developer who wants to tweak WordPress can easily find the particular
    file they need, modify it, and test and debug it without messing around with unconnected
    parts of the program. Next time you use WordPress, keep an eye on your browser’s
    address bar, and you’ll notice some of the different PHP files that it uses.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter has covered quite a lot of ground, and by now you should be able
    to put together your own small PHP programs. But before you do, and before proceeding
    with the following chapter on functions and objects, you may wish to test your
    new knowledge by answering the following questions.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What actual underlying values are represented by `TRUE` and `FALSE`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the simplest two forms of expressions?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between unary, binary, and ternary operators?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the best way to force your own operator precedence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is meant by *operator associativity*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When would you use the `===` (identity) operator?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the three conditional statement types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What command can you use to skip the current iteration of a loop and move on
    to the next one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is a `for` loop more powerful than a `while` loop?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do `if` and `while` statements interpret conditional expressions of different
    data types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See [“Chapter 4 Answers”](app01_split_003.xhtml#chapter_4_answers) in the [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions)
    for the answers to these questions.
  prefs: []
  type: TYPE_NORMAL
