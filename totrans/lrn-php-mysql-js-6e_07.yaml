- en: Chapter 4\. Expressions and Control Flow in PHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章。PHP中的表达式和控制流
- en: The previous chapter introduced several topics in passing that this chapter
    covers more fully, such as making choices (branching) and creating complex expressions.
    In the previous chapter, I wanted to focus on the most basic syntax and operations
    in PHP, but I couldn’t avoid touching on more advanced topics. Now I can fill
    in the background that you need to use these powerful PHP features properly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章只是简单介绍了一些这一章更全面涵盖的主题，如做出选择（分支）和创建复杂表达式。在前一章中，我想专注于PHP中最基本的语法和操作，但无法避免触及更高级的主题。现在我可以填补你需要正确使用这些强大PHP功能的背景。
- en: In this chapter, you will get a thorough grounding in how PHP programming works
    in practice and how to control the flow of the program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将深入了解PHP编程的实践工作以及如何控制程序的流程。
- en: Expressions
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式
- en: 'Let’s start with the most fundamental part of any programming language: *expressions*.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从任何编程语言中最基础的部分开始：*表达式*。
- en: 'An expression is a combination of values, variables, operators, and functions
    that results in a value. It’s familiar to anyone who has taken high-school algebra.
    Here’s an example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式是值、变量、运算符和函数的组合，其结果是一个值。对于任何已经学过高中代数的人来说，这是熟悉的。这里有一个例子：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Which in PHP would be:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '在PHP中，它将是:'
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The value returned (*`y`* in this mathematical statement, or `$y` in the PHP)
    can be a number, a string, or a *Boolean value* (named after George Boole, a 19th-century
    English mathematician and philosopher). By now, you should be familiar with the
    first two value types, but I’ll explain the third.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数学声明中返回的值（*`y`*在这个数学声明中，或者在PHP中是`$y`）可以是一个数字，一个字符串，或者一个*布尔值*（以19世纪英国数学家和哲学家乔治·布尔命名）。到现在为止，你应该熟悉前两种值类型，但我将解释第三种。
- en: TRUE or FALSE?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 真还是假？
- en: A basic Boolean value can be either `TRUE` or `FALSE`. For example, the expression
    `20 > 9` (20 is greater than 9) is `TRUE`, and the expression `5 == 6` (5 is equal
    to 6) is `FALSE`. (You can combine such operations using other classic Boolean
    operators such as `AND`, `OR`, and `XOR`, which are covered later in this chapter.)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的布尔值可以是`TRUE`或`FALSE`。例如，表达式`20 > 9`（20大于9）是`TRUE`，表达式`5 == 6`（5等于6）是`FALSE`。（你可以使用其他经典布尔运算符如`AND`、`OR`和`XOR`来结合这些操作，这些在本章后面会介绍。）
- en: Note
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Note that I am using uppercase letters for the names `TRUE` and `FALSE`. This
    is because they are predefined constants in PHP. You can use the lowercase versions
    if you prefer, as they are also predefined. In fact, the lowercase versions are
    more stable, because PHP does not allow you to redefine them; the uppercase ones
    may be redefined, which is something you should bear in mind if you import third-party
    code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我在`TRUE`和`FALSE`的名称中使用了大写字母。这是因为它们在PHP中是预定义常量。如果你愿意，你也可以使用小写版本，因为它们也是预定义的。事实上，小写版本更稳定，因为PHP不允许重新定义它们；大写的可能会被重新定义，这是在导入第三方代码时需要注意的事情。
- en: PHP doesn’t actually print the predefined constants if you ask it to do so as
    in [Example 4-1](#outputting_the_values_of_true_and_false). For each line, the
    example prints out a letter followed by a colon and a predefined constant. PHP
    arbitrarily assigns a numerical value of `1` to `TRUE`, so `1` is displayed after
    `a:` when the example runs. Even more mysteriously, because `b:` evaluates to
    `FALSE`, it does not show any value. In PHP the constant `FALSE` is defined as
    `NULL`, another predefined constant that denotes nothing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要求PHP打印预定义的常量，它实际上不会这样做，就像在[示例4-1](#outputting_the_values_of_true_and_false)中一样。对于每一行，示例打印出一个字母，后面跟着一个冒号和一个预定义常量。当示例运行时，PHP将数字值`1`随意分配给`TRUE`，因此在`a:`之后显示`1`。更神秘的是，因为`b:`评估为`FALSE`，它不显示任何值。在PHP中，常量`FALSE`被定义为`NULL`，另一个表示无值的预定义常量。
- en: Example 4-1\. Outputting the values of `TRUE` and `FALSE`
  id: totrans-15
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-1。输出`TRUE`和`FALSE`的值
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `<br>` tags are there to create line breaks and thus separate the output
    into two lines in HTML. Here is the output:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`<br>`标签用于创建换行符，从而在HTML中将输出分为两行。这是输出：'
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Turning to Boolean expressions, [Example 4-2](#four_simple_boolean_expressions)
    shows some simple expressions: the two I mentioned earlier, plus a couple more.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 转向布尔表达式，[示例4-2](#four_simple_boolean_expressions)展示了一些简单的表达式：前面提到的两个，再加上另外两个。
- en: Example 4-2\. Four simple Boolean expressions
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-2。四个简单的布尔表达式
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output from this code is:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出是：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By the way, in some languages `FALSE` may be defined as `0` or even `–1`, so
    it’s worth checking on its definition in each language you use. Luckily, Boolean
    expressions are usually buried in other code, so you don’t normally have to worry
    about what `TRUE` and `FALSE` look like internally. In fact, those names rarely
    appear in code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，在某些语言中，`FALSE` 可能被定义为 `0` 或者甚至是 `-1`，所以在使用每种语言时，检查其定义是很重要的。幸运的是，布尔表达式通常深藏在其他代码中，因此你通常不必担心
    `TRUE` 和 `FALSE` 在内部的具体表现。事实上，这些名称在代码中很少出现。
- en: Literals and Variables
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文字和变量
- en: These are the most basic elements of programming, and the building blocks of
    expressions. A *literal* simply means something that evaluates to itself, such
    as the number `73` or the string `"Hello"`. A variable, which we’ve already seen
    has a name beginning with a dollar sign, evaluates to the value that has been
    assigned to it. The simplest expression is just a single literal or variable,
    because both return a value.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是编程的最基本元素，也是表达式的构建块。*文字* 简单地意味着评估为其自身的东西，比如数字 `73` 或字符串 `"Hello"`。变量，我们已经看到其名称以美元符号开头，评估为已分配给它的值。最简单的表达式只是一个单一的文字或变量，因为两者都返回一个值。
- en: '[Example 4-3](#literals_and_variables-id00008) shows three literals and two
    variables, all of which return values, albeit of different types.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-3](#literals_and_variables-id00008) 显示了三个文字和两个变量，它们都返回值，尽管类型不同。'
- en: Example 4-3\. Literals and variables
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-3\. 文字和变量
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And, as you’d expect, you see a return value from all of these with the exception
    of `c:`, which evaluates to `FALSE`, returning nothing in the following output:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，你会从所有这些运算中看到返回值，除了 `c:`，它评估为 `FALSE`，在以下输出中不返回任何内容：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In conjunction with operators, it’s possible to create more complex expressions
    that evaluate to useful results.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结合运算符，可以创建更复杂的表达式，评估为有用的结果。
- en: Programmers combine expressions with other language constructs, such as the
    assignment operators we saw earlier, to form *statements*. [Example 4-4](#expression_and_a_statement)
    shows two statements. The first assigns the result of the expression `366 - $day_number`
    to the variable `$days_to_new_year`, and the second outputs a friendly message
    only if the expression `$days_to_new_year < 30` evaluates to `TRUE`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员将表达式与我们早些时候看到的赋值操作符等其他语言结构结合起来，形成*语句*。 [示例 4-4](#expression_and_a_statement)
    显示了两个语句。第一个将表达式 `366 - $day_number` 的结果赋给变量 `$days_to_new_year`，第二个仅在表达式 `$days_to_new_year
    < 30` 评估为 `TRUE` 时输出友好消息。
- en: Example 4-4\. An expression and a statement
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-4\. 表达式和语句
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Operators
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: PHP offers a lot of powerful operators of different types—arithmetic, string,
    logical, assignment, comparison, and more (see [Table 4-1](#php_operator_types)).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了许多强大的不同类型的运算符——算术、字符串、逻辑、赋值、比较等等（参见 [表 4-1](#php_operator_types)）。
- en: Table 4-1\. PHP operator types
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1\. PHP 运算符类型
- en: '| Operator | Description | Example |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 描述 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Arithmetic | Basic mathematics | `$a + $b` |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 算术 | 基本数学运算 | `$a + $b` |'
- en: '| Array | Array union | `$a + $b` |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 数组 | 数组并集 | `$a + $b` |'
- en: '| Assignment | Assign values | `$a = $b + 23` |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 赋值 | 赋值操作 | `$a = $b + 23` |'
- en: '| Bitwise | Manipulate bits within bytes | `12 ^ 9` |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 位运算 | 在字节内操作位 | `12 ^ 9` |'
- en: '| Comparison | Compare two values | `$a < $b` |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 比较 | 比较两个值 | `$a < $b` |'
- en: '| Execution | Execute contents of backticks | `` `ls -al` `` |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 执行 | 执行反引号内容 | `` `ls -al` `` |'
- en: '| Increment/decrement | Add or subtract 1 | `$a++` |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 增量/减量 | 加或减 1 | `$a++` |'
- en: '| Logical | Boolean | `$a and $b` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑 | 布尔运算 | `$a and $b` |'
- en: '| String | Concatenation | `$a . $b` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 字符串 | 连接 | `$a . $b` |'
- en: 'Each operator takes a different number of operands:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每个运算符接受不同数量的操作数：
- en: '*Unary* operators, such as incrementing (`$a++`) or negation (!`$a`), take
    a single operand.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*一元* 运算符，如递增（`$a++`）或否定（`!$a`），接受一个操作数。'
- en: '*Binary* operators, which represent the bulk of PHP operators (including addition,
    subtraction, multiplication, and division), take two operands.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*二元* 运算符，代表大多数 PHP 运算符（包括加法、减法、乘法和除法），接受两个操作数。'
- en: 'The one *ternary* operator, which takes the form `expr ? x : y`, requires three
    operands. It’s a terse, single-line `if` statement that returns `x` if `expr`
    is `TRUE` and `y` if `expr` is `FALSE`.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '唯一的*三元* 运算符，采用 `expr ? x : y` 的形式，需要三个操作数。它是一个简洁的单行 `if` 语句，如果 `expr` 是 `TRUE`，则返回
    `x`，如果 `expr` 是 `FALSE`，则返回 `y`。'
- en: Operator Precedence
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运算符优先级
- en: If all operators had the same precedence, they would be processed in the order
    in which they are encountered. In fact, many operators do have the same precedence.
    Take a look at [Example 4-5](#three_equivalent_expressions).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有运算符的优先级相同，则按遇到的顺序处理它们。实际上，许多运算符确实具有相同的优先级。看看 [示例 4-5](#three_equivalent_expressions)。
- en: Example 4-5\. Three equivalent expressions
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 三个等价表达式
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here you will see that although the numbers (and their preceding operators)
    have been moved around, the result of each expression is the value `7`, because
    the plus and minus operators have the same precedence. We can try the same thing
    with multiplication and division (see [Example 4-6](#three_expressions_that_are_also_equivale)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您会看到尽管数字（及其前面的运算符）已经移动，但每个表达式的结果是值`7`，因为加号和减号运算符具有相同的优先级。我们可以用乘法和除法来尝试同样的事情（参见
    [示例 4-6](#three_expressions_that_are_also_equivale)）。
- en: Example 4-6\. Three expressions that are also equivalent
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. 三个同等表达式
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here the resulting value is always `7.5`. But things change when we mix operators
    with *different* precedences in an expression, as in [Example 4-7](#three_expressions_using_operators_of_mix).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的结果值始终为`7.5`。但是当我们在一个表达式中混合具有*不同*优先级的运算符时，情况就会改变，就像 [示例 4-7](#three_expressions_using_operators_of_mix)
    中一样。
- en: Example 4-7\. Three expressions using operators of mixed precedence
  id: totrans-62
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. 使用混合优先级运算符的三个表达式
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If there were no operator precedence, these three expressions would evaluate
    to `25`, `–29`, and `12`, respectively. But because multiplication and division
    take precedence over addition and subtraction, the expressions are evaluated as
    if there were parentheses around these parts of the expressions, just like mathematical
    notation (see [Example 4-8](#three_expressions_showing_implied_parent)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有运算符优先级，这三个表达式的计算结果将分别为`25`，`–29`和`12`。但是因为乘法和除法优先于加法和减法，这些表达式被计算为如果在表达式的这些部分周围有括号，就像数学表示法一样（参见
    [示例 4-8](#three_expressions_showing_implied_parent)）。
- en: Example 4-8\. Three expressions showing implied parentheses
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 显示隐含括号的三个表达式
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: PHP evaluates the subexpressions within parentheses first to derive the semi-completed
    expressions in [Example 4-9](#after_evaluating_the_sub-expressions_in).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PHP首先计算括号内的子表达式，以得出半完成的表达式在 [示例 4-9](#after_evaluating_the_sub-expressions_in)
    中的结果。
- en: Example 4-9\. After evaluating the subexpressions in parentheses
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. 在评估括号中的子表达式后
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The final results of these expressions are `–13`, `–57`, and `6`, respectively
    (quite different from the results of `25`, `–29`, and `12` that we would have
    seen had there been no operator precedence).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表达式的最终结果分别为`–13`，`–57`和`6`（与没有运算符优先级时得到的`25`，`–29`和`12`完全不同）。
- en: Of course, you can override the default operator precedence by inserting your
    own parentheses and forcing whatever order you want (see [Example 4-10](#forcing_left-to-right_evaluation)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以通过插入自己的括号并强制希望的任何顺序来覆盖默认的运算符优先级（参见 [示例 4-10](#forcing_left-to-right_evaluation)）。
- en: Example 4-10\. Forcing left-to-right evaluation
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-10\. 强制左到右的评估
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With parentheses correctly inserted, we now see the values `25`, `–29`, and
    `12`, respectively.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正确插入括号后，现在可以看到值分别为`25`，`–29`和`12`。
- en: '[Table 4-2](#precedence_of_php_operators_left_par) lists PHP’s operators in
    order of precedence from high to low.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-2](#precedence_of_php_operators_left_par) 按优先级从高到低列出了PHP的运算符。'
- en: Table 4-2\. The precedence of PHP operators (high to low)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-2\. PHP运算符的优先级（从高到低）
- en: '| Operator(s) | Type |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 运算符 | 类型 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `()` | Parentheses |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `()` | 括号 |'
- en: '| `++ --` | Increment/decrement |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `++ --` | 自增/自减 |'
- en: '| `!` | Logical |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 逻辑 |'
- en: '| `* / %` | Arithmetic |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `* / %` | 算术 |'
- en: '| `+ - .` | Arithmetic and string |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `+ - .` | 算术和字符串 |'
- en: '| `<< >>` | Bitwise |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `<< >>` | 位 |'
- en: '| `< <= > >= <>` | Comparison |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `< <= > >= <>` | 比较 |'
- en: '| `== != === !==` | Comparison |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `== != === !==` | 比较 |'
- en: '| `&` | Bitwise (and references) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `&` | 位（及引用） |'
- en: '| `^` | Bitwise |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 位 |'
- en: '| `&#124;` | Bitwise |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | 位 |'
- en: '| `&&` | Logical |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `&&` | 逻辑 |'
- en: '| `&#124;&#124;` | Logical |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124;` | 逻辑 |'
- en: '| `? :` | Ternary |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `? :` | 三元 |'
- en: '| `= += -= *= /= .= %= &= != ^= <<= >>=` | Assignment |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `= += -= *= /= .= %= &= != ^= <<= >>=` | 赋值 |'
- en: '| `and` | Logical |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `and` | 逻辑 |'
- en: '| `xor` | Logical |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `xor` | 逻辑 |'
- en: '| `or` | Logical |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `or` | 逻辑 |'
- en: The order in this table is not arbitrary but carefully designed so that the
    most common and intuitive precedences are the ones you can get without parentheses.
    For instance, you can separate two comparisons with an `and` or `or` and get what
    you’d expect.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此表中的顺序并非任意排列，而是精心设计，以便您可以在不使用括号的情况下获取最常见和直观的优先级。例如，您可以使用`and`或`or`分隔两个比较，以获得预期的结果。
- en: Associativity
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结合性
- en: We’ve been looking at processing expressions from left to right, except where
    operator precedence is in effect. But some operators require processing from right
    to left, and this direction of processing is called the operator’s *associativity*.
    For some operators, there is no associativity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在讨论从左到右处理表达式，除非运算符优先级生效。但是有些运算符要求从右到左处理，这种处理方向称为运算符的*结合性*。对于某些运算符，没有结合性。
- en: Associativity (as detailed in [Table 4-3](#operator_associativity)) becomes
    important in cases in which you do not explicitly force precedence, so you need
    to be aware of the default actions of operators.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 结合性（如[表 4-3](#operator_associativity)所详细说明的）在不显式强制优先级的情况下变得重要，因此您需要了解运算符的默认操作。
- en: Table 4-3\. Operator associativity
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-3\. 运算符结合性
- en: '| Operator | Description | Associativity |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| Operator | 描述 | Associativity |'
- en: '| --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `< <= >= == != === !== <>` | Comparison | None |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `< <= >= == != === !== <>` | 比较 | None |'
- en: '| `!` | Logical `NOT` | Right |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `!` | 逻辑 `NOT` | Right |'
- en: '| `~` | Bitwise `NOT` | Right |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `~` | 位 `NOT` | Right |'
- en: '| `++ --` | Increment and decrement | Right |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `++ --` | 增加和减少 | Right |'
- en: '| `(int)` | Cast to an integer | Right |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `(int)` | 转换为整数 | Right |'
- en: '| `(double) (float) (real)` | Cast to a floating-point number | Right |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `(double) (float) (real)` | 转换为浮点数 | Right |'
- en: '| `(string)` | Cast to a string | Right |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `(string)` | 转换为字符串 | Right |'
- en: '| `(array)` | Cast to an array | Right |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `(array)` | 转换为数组 | Right |'
- en: '| `(object)` | Cast to an object | Right |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `(object)` | 转换为对象 | Right |'
- en: '| `@` | Inhibit error reporting | Right |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `@` | 抑制错误报告 | Right |'
- en: '| `= += -= *= /=` | Assignment | Right |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `= += -= *= /=` | 赋值 | Right |'
- en: '| `.= %= &= &#124;= ^= <<= >>=` | Assignment | Right |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `.= %= &= &#124;= ^= <<= >>=` | 赋值 | Right |'
- en: '| `+` | Addition and unary plus | Left |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 加法和一元加 | Left |'
- en: '| `-` | Subtraction and negation | Left |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `-` | 减法和取反 | Left |'
- en: '| `*` | Multiplication | Left |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 乘法 | Left |'
- en: '| `/` | Division | Left |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `/` | 除法 | Left |'
- en: '| `%` | Modulus | Left |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 取模 | Left |'
- en: '| `.` | String concatenation | Left |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 字符串连接 | Left |'
- en: '| `<< >> & ^ &#124;` | Bitwise | Left |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `<< >> & ^ &#124;` | 位运算 | Left |'
- en: '| `?:` | Ternary | Left |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `?:` | 三元运算符 | Left |'
- en: '| `&#124;&#124; && and or xor` | Logical | Left |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;&#124; && and or xor` | 逻辑 | Left |'
- en: '| `,` | Separator | Left |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `,` | 分隔符 | Left |'
- en: For example, let’s take a look at the assignment operator in [Example 4-11](#multiple-assignment_statement),
    where three variables are all set to the value `0`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们看一下赋值运算符在[示例 4-11](#multiple-assignment_statement)中的应用，其中三个变量都设置为值`0`。
- en: Example 4-11\. A multiple-assignment statement
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-11\. 多重赋值语句
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This multiple assignment is possible only if the rightmost part of the expression
    is evaluated first and then processing continues in a right-to-left direction.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在先评估表达式的最右部分，然后继续从右到左处理时，才可能进行多重赋值。
- en: Note
  id: totrans-130
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As a newcomer to PHP, you should avoid the potential pitfalls of operator associativity
    by always nesting your subexpressions within parentheses to force the order of
    evaluation. This will also help other programmers who may have to maintain your
    code to understand what is happening.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为PHP的新手，您应该避免运算符结合性的潜在陷阱，始终将子表达式嵌套在括号中以强制评估顺序。这也将有助于其他可能需要维护您代码的程序员理解正在发生的事情。
- en: Relational Operators
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系运算符
- en: 'Relational operators answer questions such as “Does this variable have a value
    of zero?” and “Which variable has a greater value?” These operators test two operands
    and return a Boolean result of either `TRUE` or `FALSE`. There are three types
    of relational operators: *equality*, *comparison*, and *logical*.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 关系运算符回答诸如“这个变量的值是否为零？”和“哪个变量的值更大？”的问题。这些运算符测试两个操作数并返回布尔结果，要么是`TRUE`要么是`FALSE`。关系运算符有三种类型：*相等性*，*比较*和*逻辑*。
- en: Equality
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相等性
- en: As we’ve already seen a few times in this chapter, the equality operator is
    `==` (two equals signs). It is important not to confuse it with the `=` (single
    equals sign) assignment operator. In [Example 4-12](#assigning_a_value_and_testing_for_equali),
    the first statement assigns a value and the second tests it for equality.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在本章中已经看到的几次一样，等号运算符是`==`（两个等号）。重要的是不要将它与`=`（单个等号）赋值运算符混淆。在[例子 4-12](#assigning_a_value_and_testing_for_equali)中，第一条语句分配一个值，第二条测试它是否相等。
- en: Example 4-12\. Assigning a value and testing for equality
  id: totrans-136
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 4-12\. 分配一个值并测试相等性
- en: '[PRE16]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you see, by returning either `TRUE` or `FALSE`, the equality operator enables
    you to test for conditions using, for example, an `if` statement. But that’s not
    the whole story, because PHP is a loosely typed language. If the two operands
    of an equality expression are of different types, PHP will convert them to whatever
    type makes the best sense to it. A rarely used *identity* operator, which consists
    of three equals signs in a row, can be used to compare items without doing conversion.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，通过返回`TRUE`或`FALSE`，等号运算符使你能够使用例如`if`语句来测试条件。但这并不是全部，因为PHP是一种弱类型语言。如果等号表达式的两个操作数类型不同，PHP会将它们转换为它认为最合适的类型。很少使用的*全等*运算符由三个连续的等号组成，可以用来比较项目而不进行转换。
- en: For example, any strings composed entirely of numbers will be converted to numbers
    whenever compared with a number. In [Example 4-13](#equality_and_identity_operators),
    `$a` and `$b` are two different strings, and we would therefore expect neither
    of the `if` statements to output a result.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，任何完全由数字组成的字符串在与数字比较时将被转换为数字。在[例子 4-13](#equality_and_identity_operators)中，`$a`和`$b`是两个不同的字符串，因此我们预期`if`语句都不会输出结果。
- en: Example 4-13\. The equality and identity operators
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 4-13\. 等号和全等运算符
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, if you run the example, you will see that it outputs the number `1`,
    which means that the first `if` statement evaluated to `TRUE`. This is because
    both strings were first converted to numbers, and `1000` is the same numerical
    value as `+1000`. In contrast, the second `if` statement uses the identity operator,
    so it compares `$a` and `$b` as strings, sees that they are different, and thus
    doesn’t output anything.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你运行这个例子，你会看到它输出数字`1`，这意味着第一个`if`语句评估为`TRUE`。这是因为两个字符串首先被转换为数字，并且`1000`与`+1000`是相同的数值。相比之下，第二个`if`语句使用全等运算符，因此它将`$a`和`$b`作为字符串进行比较，发现它们不同，因此不输出任何内容。
- en: As with forcing operator precedence, whenever you have any doubt about how PHP
    will convert operand types, you can use the identity operator to turn this behavior
    off.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 就像强制操作符优先级一样，每当你对PHP如何转换操作数类型感到怀疑时，你可以使用全等运算符来关闭这种行为。
- en: In the same way that you can use the equality operator to test for operands
    being equal, you can test for them *not* being equal using `!=`, the inequality
    operator. Take a look at [Example 4-14](#inequality_and_not_identical_operato),
    which is a rewrite of [Example 4-13](#equality_and_identity_operators), in which
    the equality and identity operators have been replaced with their inverses.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用等号运算符来测试操作数是否相等一样，你也可以使用`!=`，不等运算符来测试它们*不*相等。看一下[例子 4-14](#inequality_and_not_identical_operato)，它是[例子
    4-13](#equality_and_identity_operators)的重写，其中等号和全等运算符已被它们的反向替换。
- en: Example 4-14\. The inequality and not-identical operators
  id: totrans-145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 4-14\. 不等和非全等运算符
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And, as you might expect, the first `if` statement does not output the number
    `1`, because the code is asking whether `$a` and `$b` are *not* equal to each
    other numerically.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能期望的那样，第一个`if`语句不会输出数字`1`，因为代码询问`$a`和`$b`是否*不*在数值上相等。
- en: Instead, this code outputs the number `2`, because the second `if` statement
    is asking whether `$a` and `$b` are *not* identical to each other in their actual
    string type, and the answer is `TRUE`; they are not the same.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这段代码输出数字`2`，因为第二个`if`语句询问`$a`和`$b`是否在它们实际的字符串类型上*不*相同，答案是`TRUE`；它们不同。
- en: Comparison operators
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 比较运算符
- en: Using comparison operators, you can test for more than just equality and inequality.
    PHP also gives you `>` (is greater than), `<` (is less than), `>=` (is greater
    than or equal to), and `<=` (is less than or equal to) to play with. [Example 4-15](#four_comparison_operators)
    shows these in use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用比较运算符，你不仅可以测试相等和不相等，PHP还提供了`>`（大于）、`<`（小于）、`>=`（大于等于）和`<=`（小于等于）等来使用。[例子 4-15](#four_comparison_operators)展示了它们的使用。
- en: Example 4-15\. The four comparison operators
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-15\. 四个比较运算符
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, where `$a` is `2` and `$b` is `3`, the following is output:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '在此示例中，其中`$a`为`2`，`$b`为`3`，输出如下： '
- en: '[PRE20]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Try this example yourself, altering the values of `$a` and `$b`, to see the
    results. Try setting them to the same value and see what happens.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试自己运行此示例，改变`$a`和`$b`的值，看看结果。尝试将它们设置为相同的值，看看会发生什么。
- en: Logical operators
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 逻辑运算符
- en: Logical operators produce true or false results and therefore are also known
    as *Boolean operators*. There are four of them (see [Table 4-4](#logical_operators-id00012)).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑运算符产生`true`或`false`的结果，因此也称为*布尔运算符*。共有四种运算符（请参见[表 4-4](#logical_operators-id00012)）。
- en: Table 4-4\. The logical operators
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-4\. 逻辑运算符
- en: '| Logical operator | Description |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| 逻辑运算符 | 描述 |'
- en: '| --- | --- |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AND` | `TRUE` if both operands are `TRUE` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `AND` | 如果两个操作数都为`TRUE`则为`TRUE` |'
- en: '| `OR` | `TRUE` if either operand is `TRUE` |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `OR` | 如果任一操作数为`TRUE`则为`TRUE` |'
- en: '| `XOR` | `TRUE` if one of the two operands is `TRUE` |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `XOR` | 如果两个操作数中的一个为`TRUE`则为`TRUE` |'
- en: '| `! (NOT)` | `TRUE` if the operand is `FALSE`, or `FALSE` if the operand is
    `TRUE` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `! (NOT)` | 如果操作数为`FALSE`则为`TRUE`，如果操作数为`TRUE`则为`FALSE` |'
- en: You can see these operators used in [Example 4-16](#logical_operators_in_use).
    Note that the `!` symbol is required by PHP in place of `NOT`. Furthermore, the
    operators can be lower- or uppercase.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[示例 4-16](#logical_operators_in_use)中看到这些运算符的使用。请注意，PHP要求使用`!`符号代替`NOT`。此外，这些运算符可以是小写或大写。
- en: Example 4-16\. The logical operators in use
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-16\. 使用的逻辑运算符
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Line by line, this example outputs nothing, `1`, `1`, and nothing, meaning that
    only the second and third `echo` statements evaluate as `TRUE`. (Remember that
    `NULL`—or nothing—represents a value of `FALSE`.) This is because the `AND` statement
    requires both operands to be `TRUE` if it is going to return a value of `TRUE`,
    while the fourth statement performs a `NOT` on the value of `$a`, turning it from
    `TRUE` (a value of `1`) to `FALSE`. If you wish to experiment with this, try out
    the code, giving `$a` and `$b` varying values of `1` and `0`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 逐行分析，此示例输出空值、`1`、`1`和空值，意味着只有第二个和第三个`echo`语句评估为`TRUE`。（请记住，`NULL`—或空值—表示`FALSE`的值。）这是因为`AND`语句要求如果要返回`TRUE`值，那么两个操作数都必须为`TRUE`，而第四个语句对`$a`的值执行`NOT`操作，将其从`TRUE`（值为`1`）转换为`FALSE`。如果你想要试验一下，请尝试运行代码，并为`$a`和`$b`赋予不同的`1`和`0`值。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When coding, remember that `AND` and `OR` have lower precedence than the other
    versions of the operators, `&&` and `||`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时，请记住`AND`和`OR`的优先级低于操作符的其他版本，如`&&`和`||`。
- en: The `OR` operator can cause unintentional problems in `if` statements, because
    the second operand will not be evaluated if the first is evaluated as `TRUE`.
    In [Example 4-17](#statement_using_the_or_operator), the function `getnext` will
    never be called if `$finished` has a value of `1`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`OR`运算符可能会在`if`语句中造成意外问题，因为如果第一个操作数被评估为`TRUE`，则不会评估第二个操作数。在[示例 4-17](#statement_using_the_or_operator)中，如果`$finished`的值为`1`，则函数`getnext`将永远不会被调用。'
- en: Example 4-17\. A statement using the `OR` operator
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-17\. 使用`OR`运算符的语句
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If you need `getnext` to be called at each `if` statement, you could rewrite
    the code as has been done in [Example 4-18](#quotation_markif_dotdotdot_orquotati).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在每个`if`语句中调用`getnext`，可以像[示例 4-18](#quotation_markif_dotdotdot_orquotati)中所做的那样重写代码。
- en: Example 4-18\. The `if...OR` statement modified to ensure calling of `getnext`
  id: totrans-175
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-18\. 修改后的`if...OR`语句以确保调用`getnext`
- en: '[PRE23]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this case, the code executes the `getnext` function and stores the value
    returned in `$gn` before executing the `if` statement.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在执行`getnext`函数并将返回的值存储在`$gn`之前，会执行`if`语句。
- en: Note
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Another solution is to switch the two clauses to make sure that `getnext` is
    executed, as it will then appear first in the expression.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是交换两个子句以确保执行`getnext`，因为它将首先出现在表达式中。
- en: '[Table 4-5](#all_possible_php_logical_expressions) shows all the possible variations
    of using the logical operators. You should also note that `!TRUE` equals `FALSE`,
    and `!FALSE` equals `TRUE`.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-5](#all_possible_php_logical_expressions)显示了使用逻辑运算符的所有可能变体。还应注意，`!TRUE`等于`FALSE`，`!FALSE`等于`TRUE`。'
- en: Table 4-5\. All possible PHP logical expressions
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-5\. 所有可能的 PHP 逻辑表达式
- en: '| Inputs |   | Operators and results |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| 输入 |   | 运算符和结果 |'
- en: '| --- | --- | --- |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| a | b | AND | OR | XOR |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| a | b | AND | OR | XOR |'
- en: '| `TRUE` | `TRUE` | `TRUE` | `TRUE` | `FALSE` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| `TRUE` | `TRUE` | `TRUE` | `TRUE` | `FALSE` |'
- en: '| `TRUE` | `FALSE` | `FALSE` | `TRUE` | `TRUE` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `TRUE` | `FALSE` | `FALSE` | `TRUE` | `TRUE` |'
- en: '| `FALSE` | `TRUE` | `FALSE` | `TRUE` | `TRUE` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| `FALSE` | `TRUE` | `FALSE` | `TRUE` | `TRUE` |'
- en: '| `FALSE` | `FALSE` | `FALSE` | `FALSE` | `FALSE` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| `FALSE` | `FALSE` | `FALSE` | `FALSE` | `FALSE` |'
- en: Conditionals
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: '*Conditionals* alter program flow. They enable you to ask questions about certain
    things and respond to the answers you get in different ways. Conditionals are
    central to creating dynamic web pages—the goal of using PHP in the first place—because
    they make it easy to render different output each time a page is viewed.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '*条件语句* 改变程序流。它们使您能够对某些事物提出问题，并以不同的方式响应您得到的答案。条件语句是创建动态网页的核心（使用PHP的初衷），因为它们使得每次查看页面时都可以轻松地呈现不同的输出。'
- en: 'I’ll present three basic conditionals in this section: the `if` statement,
    the `switch` statement, and the `?` operator. In addition, looping conditionals
    (which we’ll get to shortly) execute code over and over until a condition is met.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将介绍三种基本的条件语句：`if`语句、`switch`语句和`?`运算符。此外，循环条件语句（我们马上会讲到）会反复执行代码，直到满足条件为止。
- en: The if Statement
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if`语句'
- en: One way of thinking about program flow is to imagine it as a single-lane highway
    that you are driving along. It’s pretty much a straight line, but now and then
    you encounter various signs telling you where to go.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下程序流就像是你驾驶沿着的一条单车道公路。它基本上是一条笔直的路线，但偶尔会遇到各种指示牌，告诉你应该往哪个方向走。
- en: In the case of an `if` statement, you could imagine coming across a detour sign
    that you have to follow if a certain condition is `TRUE`. If so, you drive off
    and follow the detour until you return to the main road and then continue on your
    way in your original direction. Or, if the condition isn’t `TRUE`, you ignore
    the detour and carry on driving (see [Figure 4-1](#program_flow_is_like_a_single-lane_highw)).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`if`语句，你可以想象遇到一个绕行标志，如果某个条件为`TRUE`，你必须按照绕行标志的指示行驶。如果是这样，你会驶出去，沿着绕行路线直到回到主路，然后继续沿着原来的方向前进。或者，如果条件不为`TRUE`，你将忽略绕行路线，继续驾驶（见[图4-1](#program_flow_is_like_a_single-lane_highw)）。
- en: '![Program flow is like a single-lane highway](Images/pmj6_0401.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![程序流就像是一条单车道公路](Images/pmj6_0401.png)'
- en: Figure 4-1\. Program flow is like a single-lane highway
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1。程序流就像是一条单车道公路
- en: The contents of the `if` condition can be any valid PHP expression, including
    tests for equality, comparison expressions, tests for `0` and `NULL`, and even
    functions (either built-in functions or ones that you write).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`条件的内容可以是任何有效的PHP表达式，包括相等测试、比较表达式、对`0`和`NULL`的测试，甚至函数（无论是内置函数还是你自己编写的函数）。'
- en: The actions to take when an `if` condition is `TRUE` are generally placed inside
    curly braces (`{ }`). You can ignore the braces if you have only a single statement
    to execute, but if you always use curly braces, you’ll avoid having to hunt down
    difficult-to-trace bugs, such as when you add an extra line to a condition and
    it doesn’t get evaluated due to the lack of braces.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当`if`条件为`TRUE`时要执行的操作通常放在大括号内（`{ }`）。如果只有一个语句要执行，可以忽略大括号，但如果始终使用大括号，将避免因缺少大括号而导致的难以追踪的错误，例如当您向条件添加额外的行时，该行不会被评估。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A notorious security vulnerability known as the “goto fail” bug haunted the
    Secure Sockets Layer (SSL) code in Apple’s products for many years because a programmer
    had forgotten the curly braces around an `if` statement, causing a function to
    sometimes report a successful connection when that may not actually have always
    been the case. This allowed a malicious attacker to get a secure certificate to
    be accepted when it should have been rejected. If in doubt, place braces around
    your `if` statements.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，“goto fail”漏洞一直困扰着苹果产品中安全套接层（SSL）代码，因为一位程序员忘记在`if`语句周围加上大括号，导致有时函数会错误地报告成功连接，而实际上并非总是如此。这使得恶意攻击者能够让一个安全证书被接受，而本应被拒绝。如果有疑问，请在你的`if`语句周围加上大括号。
- en: Note that for brevity and clarity, however, many of the examples in this book
    ignore this suggestion and omit the braces for single statements.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，出于简洁和清晰的考虑，本书中的许多示例忽略了这个建议，并省略了单语句的大括号。
- en: In [Example 4-19](#if_statement_with_curly_braces), imagine that it is the end
    of the month and all your bills have been paid, so you are performing some bank
    account maintenance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例4-19](#if_statement_with_curly_braces)中，想象一下现在是月底，你所有的账单都已经支付，所以你正在进行一些银行账户的维护工作。
- en: Example 4-19\. An `if` statement with curly braces
  id: totrans-203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-19。带有大括号的`if`语句
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, you are checking your balance to see whether it is less than
    $100 (or whatever your currency is). If so, you pay yourself $1,000 and then add
    it to the balance. (If only making money were that simple!)
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，您正在检查您的余额，以查看是否少于$100（或您的货币单位）。如果是，则支付自己$1,000，然后将其添加到余额中。（如果赚钱那么简单！）
- en: If the bank balance is $100 or greater, the conditional statements are ignored
    and program flow skips to the next line (not shown).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果银行余额为$100或更高，则忽略条件语句，程序流将跳到下一行（未显示）。
- en: In this book, opening curly braces generally start on a new line. Some people
    like to place the first curly brace to the right of the conditional expression;
    others start a new line with it. Either of these is fine, because PHP allows you
    to set out your whitespace characters (spaces, newlines, and tabs) any way you
    choose. However, you will find your code easier to read and debug if you indent
    each level of conditionals with a tab.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，开放的花括号通常从新行开始。有些人喜欢将第一个花括号放在条件表达式的右侧；其他人则从新行开始。无论哪种方式都可以，因为PHP允许您按照自己的方式设置空白字符（空格、换行和制表符）。但是，如果您每个条件级别都用制表符缩进，您会发现代码更易于阅读和调试。
- en: The else Statement
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`else`语句'
- en: Sometimes when a conditional is not `TRUE`, you may not want to continue on
    to the main program code immediately but might wish to do something else instead.
    This is where the `else` statement comes in. With it, you can set up a second
    detour on your highway, as in [Figure 4-2](#highway_now_has_an_if_detour_and_an).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当条件不为`TRUE`时，您可能不希望立即继续主程序代码，而是希望执行其他操作。这就是`else`语句的用处。借助它，您可以在公路上设置第二个分支，就像[图 4-2](#highway_now_has_an_if_detour_and_an)中那样。
- en: With an `if...else` statement, the first conditional statement is executed if
    the condition is `TRUE`. But if it’s `FALSE`, the second one is executed. One
    of the two choices *must* be executed. Under no circumstance can both (or neither)
    be executed. [Example 4-20](#if_dotdotdot_else_statement_with_curl) shows the
    use of the `if...else` structure.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`if...else`语句，如果条件为`TRUE`，则执行第一个条件语句。但如果为`FALSE`，则执行第二个条件语句。两者之一 *必须* 被执行。在任何情况下都不能两者都执行（或都不执行）。[示例 4-20](#if_dotdotdot_else_statement_with_curl)展示了使用`if...else`结构。
- en: '![The highway now has an if detour and an else detour](Images/pmj6_0402.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![现在的公路有一个if分支和一个else分支](Images/pmj6_0402.png)'
- en: Figure 4-2\. Highway now has an `if` detour and an `else` detour
  id: totrans-212
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-2\. 现在的公路有一个`if`分支和一个`else`分支
- en: Example 4-20\. An `if...else` statement with curly braces
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-20\. 使用花括号的`if...else`语句
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, if you’ve ascertained that you have $100 or more in the bank,
    the `else` statement is executed, placing some of this money into your savings
    account.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果您确定银行账户中有$100或更多的金额，则执行`else`语句，将一部分资金存入您的储蓄账户。
- en: As with `if` statements, if your `else` has only one conditional statement,
    you can opt to leave out the curly braces. (Curly braces are always recommended,
    though. First, they make the code easier to understand. Second, they let you easily
    add more statements to the branch later.)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`语句一样，如果您的`else`只有一个条件语句，可以选择省略花括号。（但建议始终使用花括号。首先，它们使代码更易于理解。其次，它们让您可以轻松地在以后的分支中添加更多语句。）
- en: The elseif Statement
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`elseif`语句'
- en: There are also times when you want a number of different possibilities to occur,
    based upon a sequence of conditions. You can achieve this using the `elseif` statement.
    As you might imagine, it is like an `else` statement, except that you place a
    further conditional expression prior to the conditional code. In [Example 4-21](#if_dotdotdot_elseif_dotdotdot_else_st),
    you can see a complete `if...elseif...else` construct.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您希望根据一系列条件发生不同的可能性。您可以使用`elseif`语句来实现这一点。正如您可能想象的那样，它类似于`else`语句，只是您在条件代码之前放置了进一步的条件表达式。在[示例 4-21](#if_dotdotdot_elseif_dotdotdot_else_st)中，您可以看到完整的`if...elseif...else`结构。
- en: Example 4-21\. An `if...elseif...else` statement with curly braces
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-21\. 使用花括号的`if...elseif...else`语句
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the example, an `elseif` statement has been inserted between the `if` and
    `else` statements. It checks whether your bank balance exceeds $200 and, if so,
    decides that you can afford to save $100 this month.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，在`if`和`else`语句之间插入了一个`elseif`语句。它检查您的银行余额是否超过$200，并且如果是，则决定您本月可以存下$100。
- en: Although I’m starting to stretch the metaphor a bit too far, you can imagine
    this as a multiway set of detours (see [Figure 4-3](#highway_with_ifcomma_elseifcomma_and)).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我可能有些过度使用这个比喻，但你可以把它想象成一个多路的绕道 (见 [图 4-3](#highway_with_ifcomma_elseifcomma_and))。
- en: '![The highway with if, elseif, and else detours](Images/pmj6_0403.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![带有 if、elseif 和 else 的公路](Images/pmj6_0403.png)'
- en: Figure 4-3\. The highway with `if`, `elseif`, and `else` detours
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 带有 `if`、`elseif` 和 `else` 的公路
- en: Note
  id: totrans-225
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: An `else` statement closes either an `if...else` or an `if...elseif...else`
    statement. You can leave out a final `else` if it is not required, but you cannot
    have one before an `elseif`; you also cannot have an `elseif` before an `if` statement.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 语句关闭 `if...else` 或 `if...elseif...else` 语句。如果不需要最终的 `else`，可以省略它，但不能在
    `elseif` 之前留有 `else`；在 `if` 语句之前也不能有 `elseif`。'
- en: You may have as many `elseif` statements as you like. But as the number of `elseif`
    statements increases, you would probably be better advised to consider a `switch`
    statement if it fits your needs. We’ll look at that next.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有任意多个 `elseif` 语句。但是随着 `elseif` 语句的数量增加，如果符合你的需求，可能更适合考虑使用 `switch` 语句。接下来我们将详细讨论这一点。
- en: The switch Statement
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`switch` 语句'
- en: The `switch` statement is useful where one variable, or the result of an expression,
    can have multiple values, each of which should trigger a different activity.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句在一个变量或表达式的结果可能有多个值，并且每个值应该触发不同活动的情况下非常有用。'
- en: For example, consider a PHP-driven menu system that passes a single string to
    the main menu code according to what the user requests. Let’s say the options
    are Home, About, News, Login, and Links, and we set the variable `$page` to one
    of these, according to the user’s input.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个由 PHP 驱动的菜单系统，根据用户的请求向主菜单代码传递单个字符串。假设选项是主页、关于、新闻、登录和链接，我们将变量 `$page`
    设置为其中一个，根据用户的输入。
- en: If we write the code for this using `if...elseif...else`, it might look like
    [Example 4-22](#multiple-line_if_dotdotdot_elseif_dotd).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `if...elseif...else` 来编写这段代码，可能会像 [示例 4-22](#multiple-line_if_dotdotdot_elseif_dotd)。
- en: Example 4-22\. A multiline `if...elseif...else` statement
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-22\. 多行 `if...elseif...else` 语句
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If we use a `switch` statement, the code might look like [Example 4-23](#switch_statement-id00013).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `switch` 语句，代码可能看起来像 [示例 4-23](#switch_statement-id00013)。
- en: Example 4-23\. A `switch` statement
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-23\. `switch` 语句
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As you can see, `$page` is mentioned only once at the start of the `switch`
    statement. Thereafter, the `case` command checks for matches. When one occurs,
    the matching conditional statement is executed. Of course, in a real program you
    would have code here to display or jump to a page, rather than simply telling
    the user what was selected.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`$page` 只在 `switch` 语句的开头提到。此后，`case` 命令检查是否匹配。一旦匹配，执行匹配的条件语句。当然，在实际程序中，你会在这里编写代码来显示或跳转到一个页面，而不仅仅是告诉用户选择了什么。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: With `switch` statements, you do not use curly braces inside `case` commands.
    Instead, they commence with a colon and end with the `break` statement. The entire
    list of cases in the `switch` statement is enclosed in a set of curly braces,
    though.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `switch` 语句中，你不使用花括号来定义 `case` 命令。相反，它们以冒号开头，并以 `break` 语句结束。整个 `switch` 语句中的所有
    `case` 都包含在一对花括号中。
- en: Breaking out
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 退出
- en: If you wish to break out of the `switch` statement because a condition has been
    fulfilled, use the `break` command. This command tells PHP to exit the `switch`
    and jump to the following statement.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在 `switch` 语句中因为条件已满足而跳出，使用 `break` 命令。这个命令告诉 PHP 退出 `switch` 并跳转到下一条语句。
- en: If you were to leave out the `break` commands in [Example 4-23](#switch_statement-id00013)
    and the case of `Home` evaluated to be `TRUE`, all five cases would then be executed.
    Or, if `$page` had the value `News`, all the `case` commands from then on would
    execute. This is deliberate and allows for some advanced programming, but generally
    you should always remember to issue a `break` command every time a set of `case`
    conditionals has finished executing. In fact, leaving out the `break` statement
    is a common error.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 [示例 4-23](#switch_statement-id00013) 中省略了 `break` 命令，并且 `Home` 的情况被评估为
    `TRUE`，那么所有五个情况都会被执行。或者，如果 `$page` 的值是 `News`，那么之后的所有 `case` 命令都会被执行。这是有意为之的，允许一些高级编程，但通常你应该记住每次一组
    `case` 条件执行完毕时都要发出 `break` 命令。事实上，忽略 `break` 语句是一个常见的错误。
- en: Default action
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认操作
- en: A typical requirement in `switch` statements is to fall back on a default action
    if none of the `case` conditions are met. For example, in the case of the menu
    code in [Example 4-23](#switch_statement-id00013), you could add the code in [Example 4-24](#default_statement_to_add_to_example_4)
    immediately before the final curly brace.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句中的典型要求是在未满足任何`case`条件时返回默认操作。例如，在[示例 4-23](#switch_statement-id00013)中的菜单代码中，你可以在最后一个大括号之前立即添加[示例 4-24](#default_statement_to_add_to_example_4)中的代码。'
- en: Example 4-24\. A default statement to add to [Example 4-23](#switch_statement-id00013)
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-24\. 添加到[示例 4-23](#switch_statement-id00013)的默认语句
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This replicates the effect of the `else` statement in [Example 4-22](#multiple-line_if_dotdotdot_elseif_dotd).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这复制了[示例 4-22](#multiple-line_if_dotdotdot_elseif_dotd)中`else`语句的效果。
- en: Although a `break` command is not required here because the default is the final
    sub-statement and program flow will automatically continue to the closing curly
    brace, should you decide to place the `default` statement higher up, it would
    definitely need a `break` command to prevent program flow from dropping into the
    following statements. Generally, the safest practice is to always include the
    `break` command.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此处不需要`break`命令，因为默认是最终的子语句，并且程序流会自动继续到结束大括号，但如果你决定将`default`语句放在较高位置，那么肯定需要一个`break`命令来防止程序流陷入后续语句。通常，最安全的做法是始终包含`break`命令。
- en: Alternative syntax
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替代语法
- en: If you prefer, you may replace the first curly brace in a `switch` statement
    with a single colon and the final curly brace with an `endswitch` command, as
    in [Example 4-25](#alternate_switch_statement_syntax). However, this approach
    is not commonly used and is mentioned here only in case you encounter it in third-party
    code.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以在`switch`语句中用单个冒号替换第一个大括号，并用`endswitch`命令替换最后一个大括号，就像[示例 4-25](#alternate_switch_statement_syntax)中所示。然而，这种方法并不常用，仅在你在第三方代码中遇到时才会提到。
- en: Example 4-25\. Alternate `switch` statement syntax
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-25\. 备选`switch`语句语法
- en: '[PRE30]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `?` (or ternary) Operator
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`?`（或三元）操作符'
- en: One way of avoiding the verbosity of `if` and `else` statements is to use the
    more compact ternary operator, `?`, which is unusual in that it takes three operands
    rather than the typical two.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用`if`和`else`语句的冗长方法之一是使用更紧凑的三元操作符`?`，这在使用中有些不同，因为它需要三个操作数而不是通常的两个。
- en: We briefly came across this in [Chapter 3](ch03.xhtml#introduction_to_php) in
    the discussion about the difference between the `print` and `echo` statements
    as an example of an operator type that works well with `print` but not `echo`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第三章](ch03.xhtml#introduction_to_php)中简要提到了这一点，讨论了`print`和`echo`语句之间的区别，作为与`print`良好配合但不与`echo`良好配合的操作符类型的示例。
- en: 'The `?` operator is passed an expression that it must evaluate, along with
    two statements to execute: one for when the expression evaluates to `TRUE`, the
    other for when it is `FALSE`. [Example 4-26](#using_the_question_mark_operator)
    shows code we might use for writing a warning about the fuel level of a car to
    its digital dashboard.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`?`操作符接受一个必须评估的表达式，以及两个要执行的语句：一个是当表达式评估为`TRUE`时，另一个是当它为`FALSE`时。[示例 4-26](#using_the_question_mark_operator)展示了我们可能会用于向汽车数字仪表板写入有关燃油水平警告的代码。'
- en: Example 4-26\. Using the `?` operator
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-26\. 使用`?`操作符
- en: '[PRE31]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this statement, if there is one gallon or less of fuel (in other words, `$fuel`
    is set to `1` or less), the string `Fill tank now` is returned to the preceding
    `echo` statement. Otherwise, the string `There's enough fuel` is returned. You
    can also assign the value returned in a `?` statement to a variable (see [Example 4-27](#assigning_a_question_markconditional_res)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在此语句中，如果燃料少于或等于一加仑（换句话说，`$fuel`设置为`1`或更少），则将字符串`Fill tank now`返回给前面的`echo`语句。否则，将返回字符串`There's
    enough fuel`。你也可以将`?`语句返回的值赋给一个变量（参见[示例 4-27](#assigning_a_question_markconditional_res)）。
- en: Example 4-27\. Assigning a `?` conditional result to a variable
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-27\. 将`?`条件结果赋给变量
- en: '[PRE32]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, `$enough` will be assigned the value `TRUE` only when there is more than
    a gallon of fuel; otherwise, it is assigned the value `FALSE`.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，只有当燃料超过一加仑时，`$enough`才会被赋值为`TRUE`；否则，它将被赋值为`FALSE`。
- en: 'If you find the `?` operator confusing, you are free to stick to `if` statements,
    but you should be familiar with the operator because you’ll see it in other people’s
    code. It can be hard to read, because it often mixes multiple occurrences of the
    same variable. For instance, code such as the following is quite popular:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您觉得`?`运算符令人困惑，可以继续使用`if`语句，但您应该熟悉这个运算符，因为您会在其他人的代码中看到它。它可能很难阅读，因为它经常混合多个相同变量的出现。例如，以下代码是相当流行的：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you take it apart carefully, you can figure out what this code does:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果仔细拆解，您可以弄清楚此代码的作用：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It’s a concise way to keep track of the largest value that you’ve seen as a
    program progresses. You save the largest value in `$saved` and compare it to `$new`
    each time you get a new value. Programmers familiar with the `?` operator find
    it more convenient than `if` statements for such short comparisons. When not used
    for writing compact code, it is typically used to make some decision inline, such
    as when you are testing whether a variable is set before passing it to a function.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在程序进行时跟踪所见到的最大值的简洁方法。您将最大值保存在`$saved`中，并在每次获得新值时将其与`$new`进行比较。熟悉`?`运算符的程序员发现它比用于这样的短比较的`if`语句更为方便。当不用于编写紧凑的代码时，它通常用于在行内做出一些决策，例如在将变量设置为函数参数之前测试是否已设置。
- en: Looping
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: One of the great things about computers is that they can repeat calculating
    tasks quickly and tirelessly. Often you may want a program to repeat the same
    sequence of code again and again until something happens, such as a user inputting
    a value or reaching a natural end. PHP’s loop structures provide the perfect way
    to do this.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的一大优点是它们可以快速且不知疲倦地重复计算任务。通常情况下，您可能希望程序重复执行相同的代码序列，直到发生某些事件，如用户输入值或达到自然结束。PHP的循环结构为实现这一点提供了完美的方式。
- en: To picture how this works, look at [Figure 4-4](#imagining_a_loop_as_part_of_a_program_hi).
    It is much the same as the highway metaphor used to illustrate `if` statements,
    except the detour also has a loop section that—once a vehicle has entered it—can
    be exited only under the right program conditions.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要想象这是如何工作的，请看[图 4-4](#imagining_a_loop_as_part_of_a_program_hi)。这与用于说明`if`语句的公路隐喻大致相同，只是这条路也有一个循环部分，一旦车辆进入其中，只有在正确的程序条件下才能退出。
- en: '![Imagining a loop as part of a program highway layout](Images/pmj6_0404.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![将循环想象为程序高速公路布局](Images/pmj6_0404.png)'
- en: Figure 4-4\. Imagining a loop as part of a program highway layout
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-4\. 将循环想象为程序高速公路布局的示意图
- en: while Loops
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`while`循环'
- en: Let’s turn the digital car dashboard in [Example 4-26](#using_the_question_mark_operator)
    into a loop that continuously checks the fuel level as you drive, using a `while`
    loop ([Example 4-28](#while_loop)).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将[示例 4-26](#using_the_question_mark_operator)中的数字汽车仪表板转变为一个循环，以在驾驶时持续检查燃油水平，使用一个`while`循环（[示例 4-28](#while_loop)）。
- en: Example 4-28\. A `while` loop
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-28\. 一个`while`循环
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Actually, you might prefer to keep a green light lit rather than output text,
    but the point is that whatever positive indication you wish to make about the
    level of fuel is placed inside the `while` loop. By the way, if you try this example
    for yourself, note that it will keep printing the string until you click the Stop
    button in your browser.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，您可能更喜欢保持绿灯亮起，而不是输出文本，但关键是您希望对燃油水平做出的任何正面指示都放在`while`循环内部。顺便说一句，如果您尝试这个示例，注意它会持续打印字符串，直到您在浏览器中单击停止按钮。
- en: Note
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As with `if` statements, you will notice that curly braces are required to hold
    the statements inside the `while` statements, unless there’s only one.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 与`if`语句一样，您会注意到`while`语句内部需要用花括号来容纳语句，除非只有一个语句。
- en: For another example of a `while` loop that displays the 12 times table, see
    [Example 4-29](#while_loop_to_print_the_12_times_table).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 查看另一个显示12倍表的`while`循环的示例，请参阅[示例 4-29](#while_loop_to_print_the_12_times_table)。
- en: Example 4-29\. A `while` loop to print the 12 times table
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-29\. 打印12倍表的`while`循环
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here the variable `$count` is initialized to a value of `1`, and then a `while`
    loop starts with the comparative expression `$count <= 12`. This loop will continue
    executing until the variable is greater than 12\. The output from this code is
    as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量`$count`被初始化为`1`的值，然后开始一个`while`循环，其比较表达式为`$count <= 12`。此循环将继续执行，直到变量大于12。从这段代码输出如下：
- en: '[PRE37]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Inside the loop, a string is printed along with the value of `$count` multiplied
    by 12\. For neatness, this is followed with a `<br>` tag to force a new line.
    Then `$count` is incremented, ready for the final curly brace that tells PHP to
    return to the start of the loop.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环内部，打印一个字符串以及`$count`乘以12的值。为了整洁起见，接下来是一个`<br>`标签，强制换行。然后递增`$count`，准备最后的大括号，告诉PHP回到循环的起始处。
- en: At this point, `$count` is again tested to see whether it is greater than 12\.
    It isn’t, but it now has the value `2`, and after another 11 times around the
    loop, it will have the value `13`. When that happens, the code within the `while`
    loop is skipped and execution passes to the code following the loop, which, in
    this case, is the end of the program.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，再次测试`$count`是否大于12。它不是，但现在它的值是`2`，再绕过循环11次后，它的值将变为`13`。当发生这种情况时，跳过`while`循环内的代码，执行转到循环后的代码，本例中即为程序的末尾。
- en: If the `++$count` statement (which could equally have been `$count++`) had not
    been there, this loop would be like the first one in this section. It would never
    end, and only the result of `1 * 12` would be printed over and over.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`++$count`语句（同样也可以是`$count++`），这个循环就像本节中的第一个循环。它永远不会结束，只会一遍又一遍地打印`1 * 12`的结果。
- en: But there is a much neater way this loop can be written, which I think you will
    like. Take a look at [Example 4-30](#shortened_version_of_example_4-29).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有一种更整洁的方式可以编写这个循环，我想你会喜欢。看看[示例4-30](#shortened_version_of_example_4-29)。
- en: Example 4-30\. A shortened version of [Example 4-29](#while_loop_to_print_the_12_times_table)
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-30。[示例4-29](#while_loop_to_print_the_12_times_table)的简化版本
- en: '[PRE38]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this example, it was possible to move the `++$count` statement from the statements
    inside the `while` loop into the conditional expression of the loop. What now
    happens is that PHP encounters the variable `$count` at the start of each iteration
    of the loop and, noticing that it is prefaced with the increment operator, first
    increments the variable and only then compares it to the value `12`. You can therefore
    see that `$count` now has to be initialized to `0`, not `1`, because it is incremented
    as soon as the loop is entered. If you keep the initialization at `1`, only results
    between 2 and 12 will be output.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，可以将`++$count`语句从`while`循环内的语句移动到循环的条件表达式中。现在发生的是，PHP在每次迭代循环开始时遇到变量`$count`，注意到它前面有递增操作符，首先递增变量，然后再将其与值`12`进行比较。因此，你可以看到现在必须将`$count`初始化为`0`，而不是`1`，因为一进入循环就会递增。如果保持初始化为`1`，则只会输出2到12之间的结果。
- en: do...while Loops
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: do...while循环
- en: A slight variation to the `while` loop is the `do...while` loop, used when you
    want a block of code to be executed at least once and made conditional only after
    that. [Example 4-31](#do_dotdotdot_while_loop_for_printing_t) shows a modified
    version of the code for the 12 times table that uses such a loop.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对`while`循环的轻微变化是`do...while`循环，当您希望一段代码至少执行一次并在此后进行条件检查时使用。[示例4-31](#do_dotdotdot_while_loop_for_printing_t)展示了使用这种循环的修改版本的12乘法表代码。
- en: Example 4-31\. A `do...while` loop for printing the 12 times table
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-31。用于打印12乘法表的`do...while`循环
- en: '[PRE39]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice how we are back to initializing `$count` to `1` (rather than `0`) because
    of the loop’s `echo` statement being executed before we have an opportunity to
    increment the variable. Other than that, though, the code looks pretty similar.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们又回到了将`$count`初始化为`1`（而不是`0`）的地方，因为在我们有机会递增变量之前，循环的`echo`语句就已执行了。尽管如此，代码看起来还是相当相似的。
- en: Of course, if you have more than a single statement inside a `do...while` loop,
    remember to use curly braces, as in [Example 4-32](#expanding_example_4-31_to_use_curly_brac).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果在`do...while`循环内有多个语句，记得使用大括号，就像[示例4-32](#expanding_example_4-31_to_use_curly_brac)中那样。
- en: Example 4-32\. Expanding [Example 4-31](#do_dotdotdot_while_loop_for_printing_t)
    to use curly braces
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-32。扩展[示例4-31](#do_dotdotdot_while_loop_for_printing_t)以使用大括号
- en: '[PRE40]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: for Loops
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: for循环
- en: The final kind of loop statement, the `for` loop, is also the most powerful,
    as it combines the abilities to set up variables as you enter the loop, test for
    conditions while iterating loops, and modify variables after each iteration.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种循环语句是`for`循环，也是最强大的，因为它结合了在进入循环时设置变量、在迭代循环时测试条件以及在每次迭代后修改变量的能力。
- en: '[Example 4-33](#outputting_the_times_table_for_12_from_a) shows how to write
    the multiplication table program with a `for` loop.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-33](#outputting_the_times_table_for_12_from_a)展示了如何使用`for`循环编写乘法表程序。'
- en: Example 4-33\. Outputting the 12 times table from a `for` loop
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-33\. 输出12乘法表的`for`循环
- en: '[PRE41]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'See how the code has been reduced to a single `for` statement containing a
    single conditional statement? Here’s what is going on. Each `for` statement takes
    three parameters:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 看看代码是如何被简化为一个包含单个条件语句的`for`语句？这里发生了什么。每个`for`语句都有三个参数：
- en: An initialization expression
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个初始化表达式
- en: A condition expression
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个条件表达式
- en: A modification expression
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个修改表达式
- en: 'These are separated by semicolons like this: `for (`*`expr1`* `;` *`expr2`*
    `;` *`expr3`*`)`. At the start of the first iteration of the loop, the initialization
    expression is executed. In the case of the times table code, `$count` is initialized
    to the value `1`. Then, each time around the loop, the condition expression (in
    this case, `$count <= 12`) is tested, and the loop is entered only if the condition
    is `TRUE`. Finally, at the end of each iteration, the modification expression
    is executed. In the case of the times table code, the variable `$count` is incremented.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这些用分号分隔开，像这样：`for (`*`expr1`* `;` *`expr2`* `;` *`expr3`*`)`。在循环的第一次迭代开始时，初始化表达式被执行。在乘法表代码中，`$count`被初始化为值`1`。然后，在每次循环中，条件表达式（在本例中是`$count
    <= 12`）被测试，只有在条件为`TRUE`时才进入循环。最后，在每次迭代结束时，修改表达式被执行。在乘法表代码中，变量`$count`被递增。
- en: All this structure neatly removes any requirement to place the controls for
    a loop within its body, freeing it up just for the statements you want the loop
    to perform.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些结构都清晰地消除了将循环控制放置在其主体内的要求，仅仅为你希望循环执行的语句保留空间。
- en: Remember to use curly braces with a `for` loop if it will contain more than
    one statement, as in [Example 4-34](#for_loop_from_example_4-33_with_adde).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`for`循环包含多个语句，记得要使用大括号，就像[示例 4-34](#for_loop_from_example_4-33_with_adde)中那样。
- en: Example 4-34\. The `for` loop from [Example 4-33](#outputting_the_times_table_for_12_from_a)
    with added curly braces
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-34\. [示例 4-33](#outputting_the_times_table_for_12_from_a)中的`for`循环，加入了大括号
- en: '[PRE42]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Let’s compare when to use `for` and `while` loops. The `for` loop is explicitly
    designed around a single value that changes on a regular basis. Usually you have
    a value that increments, as when you are passed a list of user choices and want
    to process each choice in turn. But you can transform the variable any way you
    like. A more complex form of the `for` statement even lets you perform multiple
    operations in each of the three parameters:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较何时使用`for`循环和`while`循环。`for`循环是专门设计用于一个在规律性变化的单一值上。通常情况下，你有一个增量值，例如你得到一个用户选择列表并想逐个处理每个选择。但你可以随意变换这个变量。`for`语句的更复杂形式甚至允许在每个参数中执行多个操作：
- en: '[PRE43]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'That’s complicated and not recommended for first-time users, though. The key
    is to distinguish commas from semicolons. The three parameters must be separated
    by semicolons. Within each parameter, multiple statements can be separated by
    commas. Thus, in the previous example, the first and third parameters each contain
    two statements:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这很复杂且不建议首次使用者使用。关键是要区分逗号和分号。这三个参数必须用分号分隔。在每个参数内部，多个语句可以用逗号分隔。因此，在前面的示例中，第一个和第三个参数每个包含两个语句：
- en: '[PRE44]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The main thing to take from this example is that you must separate the three
    parameter sections with semicolons, not commas (which should be used only to separate
    statements within a parameter section).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中要理解的主要内容是，你必须使用分号来分隔这三个参数部分，而不是逗号（逗号只能用来分隔参数部分内的语句）。
- en: So, when is a `while` statement more appropriate than a `for` statement? When
    your condition doesn’t depend on a simple, regular change to a variable. For instance,
    if you want to check for some special input or error and end the loop when it
    occurs, use a `while` statement.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，什么情况下使用`while`语句比`for`语句更合适？当你的条件不依赖于变量的简单、规律性变化时。例如，如果你想要检查某些特殊输入或错误，并在其发生时结束循环，就使用`while`语句。
- en: Breaking Out of a Loop
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出循环
- en: Just as you saw how to break out of a `switch` statement, you can also break
    out of a `for` loop (or any loop) using the same `break` command. This step can
    be necessary when, for example, one of your statements returns an error and the
    loop cannot continue executing safely. One case in which this might occur is when
    writing a file returns an error, possibly because the disk is full (see [Example 4-35](#writing_a_file_using_a_for_loop_with_err)).
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你看到如何跳出`switch`语句一样，你也可以使用相同的`break`命令跳出`for`循环（或任何循环）。当例如其中一个语句返回错误且循环无法继续安全执行时，这一步就是必要的。可能出现这种情况的一个案例是写入文件返回错误，可能是因为磁盘已满（参见[示例 4-35](#writing_a_file_using_a_for_loop_with_err)）。
- en: Example 4-35\. Writing a file using a `for` loop with error trapping
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-35\. 使用`for`循环编写文件并进行错误处理
- en: '[PRE45]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This is the most complicated piece of code that you have seen so far, but you’re
    ready for it. We’ll look into the file-handling commands in [Chapter 7](ch07.xhtml#practical_php),
    but for now all you need to know is that the first line opens the file *text.txt*
    for writing in binary mode and then returns a pointer to the file in the variable
    `$fp`, which is used later to refer to the open file.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这是迄今为止你见过的最复杂的代码片段，但你已经准备好了。我们将在[第7章](ch07.xhtml#practical_php)中探讨文件处理命令，但现在你只需要知道，第一行以二进制模式打开文件*text.txt*进行写入，并将文件指针返回到变量`$fp`中，稍后用于引用打开的文件。
- en: The loop then iterates 100 times (from 0 to 99), writing the string `data` to
    the file. After each write, the variable `$written` is assigned a value by the
    `fwrite` function representing the number of characters correctly written. But
    if there is an error, the `fwrite` function assigns the value `FALSE`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，循环迭代100次（从0到99），将字符串`data`写入文件。每次写入后，变量`$written`由`fwrite`函数赋值，表示正确写入的字符数。但如果发生错误，`fwrite`函数则赋值为`FALSE`。
- en: The behavior of `fwrite` makes it easy for the code to check the variable `$written`
    to see whether it is set to `FALSE` and, if so, to break out of the loop to the
    following statement that closes the file.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`fwrite`的行为使得代码可以轻松检查变量`$written`是否设置为`FALSE`，如果是，则跳出循环，并进入关闭文件的下一条语句。'
- en: 'If you are looking to improve the code, you can simplify the line:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望改进代码，可以简化这行代码：
- en: '[PRE46]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'using the `NOT` operator, like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NOT`运算符，像这样：
- en: '[PRE47]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In fact, the pair of inner loop statements can be shortened to a single statement:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，内部循环语句对可以缩短为单个语句：
- en: '[PRE48]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In other words, you can eliminate the `$written` variable, because it existed
    only to check the value returned from `fwrite`. You can instead test the return
    value directly.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你可以消除`$written`变量，因为它只是用来检查`fwrite`返回的值。你可以直接测试返回值而不是用`$written`变量。
- en: 'The `break` command is even more powerful than you might think, because if
    you have code nested more than one layer deep that you need to break out of, you
    can follow the `break` command with a number to indicate how many levels to break
    out of:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '`break`命令比你想象的更加强大，因为如果你的代码嵌套超过一层需要跳出，你可以在`break`命令后跟一个数字来指示跳出多少层：'
- en: '[PRE49]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The continue Statement
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: continue语句
- en: The `continue` statement is a little like a `break` statement, except that it
    instructs PHP to stop processing the current iteration of the loop and move right
    to its next iteration. So, instead of breaking out of the whole loop, PHP exits
    only the current iteration.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue`语句有点像`break`语句，不过它指示PHP停止处理当前循环的迭代，并直接进入下一次迭代。因此，PHP不会跳出整个循环，而是仅退出当前迭代。'
- en: This approach can be useful in cases where you know there is no point continuing
    execution within the current loop and you want to save processor cycles or prevent
    an error from occurring by moving right along to the next iteration of the loop.
    In [Example 4-36](#trapping_division-by-zero_errors_using_c), a `continue` statement
    is used to prevent a division-by-zero error from being issued when the variable
    `$j` has a value of `0`.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这种方法非常有用，例如你知道在当前循环中继续执行没有意义，并且你想要节省处理器周期，或者通过直接进入循环的下一次迭代来防止发生错误。在[示例 4-36](#trapping_division-by-zero_errors_using_c)中，使用`continue`语句可以防止当变量`$j`的值为`0`时发生除以零的错误。
- en: Example 4-36\. Trapping division-by-zero errors using `continue`
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-36\. 使用`continue`捕获除零错误
- en: '[PRE50]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: For all values of `$j` between `10` and `–10`, with the exception of `0`, the
    result of calculating `10` divided by `$j` is displayed. But for the case of `$j`
    being `0`, the `continue` statement is issued, and execution skips immediately
    to the next iteration of the loop.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `$j` 在 `10` 到 `-10` 之间的所有值（`0` 除外），计算 `10` 除以 `$j` 的结果会显示出来。但是当 `$j` 为 `0`
    时，会执行 `continue` 语句，并立即跳到循环的下一个迭代。
- en: Implicit and Explicit Casting
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式和显式转换
- en: PHP is a loosely typed language that allows you to declare a variable and its
    type simply by using it. It also automatically converts values from one type to
    another whenever required. This is called *implicit casting*.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 是一种弱类型语言，允许你在使用变量时简单地声明其类型。它还会根据需要自动将值从一种类型转换为另一种类型。这称为*隐式转换*。
- en: However, at times PHP’s implicit casting may not be what you want. In [Example 4-37](#this_expression_returns_a_floating-point),
    note that the inputs to the division are integers. By default, PHP converts the
    output to floating point so it can give the most precise value—4.66 recurring.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时 PHP 的隐式转换可能不是你想要的。在 [示例 4-37](#this_expression_returns_a_floating-point)
    中，请注意除法的输入是整数。默认情况下，PHP 将输出转换为浮点数，以便提供最精确的值——4.66 循环。
- en: Example 4-37\. This expression returns a floating-point number
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-37\. 这个表达式返回一个浮点数
- en: '[PRE51]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'But what if we had wanted `$c` to be an integer instead? There are various
    ways we could achieve this, one of which is to force the result of `$a / $b` to
    be cast to an integer value using the integer cast type `(int)`, like this:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果我们希望 `$c` 是一个整数呢？我们可以通过各种方式来实现这一点，其中一种方法是使用整数转换类型 `(int)` 强制将 `$a / $b`
    的结果转换为整数值，就像这样：
- en: '[PRE52]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This is called *explicit* casting. Note that in order to ensure that the value
    of the entire expression is cast to an integer, we place the expression within
    parentheses. Otherwise, only the variable `$a` would have been cast to an integer—a
    pointless exercise, as the division by `$b` would still have returned a floating-point
    number.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这称为*显式*转换。请注意，为了确保整个表达式的值被转换为整数，我们将表达式置于括号中。否则，只有变量 `$a` 会被转换为整数，这将是毫无意义的练习，因为除以
    `$b` 仍将返回一个浮点数。
- en: You can explicitly cast variables and literals to the types shown in [Table 4-6](#phpapostrophes_cast_types).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将变量和文字显式转换为 [表 4-6](#phpapostrophes_cast_types) 中所示的类型。
- en: Table 4-6\. PHP’s cast types
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-6\. PHP 的类型转换
- en: '| Cast type | Description |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| 类型转换 | 描述 |'
- en: '| --- | --- |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(int) (integer)` | Cast to an integer by dropping the decimal portion. |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| `(int) (integer)` | 通过舍弃小数部分转换为整数。 |'
- en: '| `(bool) (boolean)` | Cast to a Boolean. |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| `(bool) (boolean)` | 转换为布尔值。 |'
- en: '| `(float) (double) (real)` | Cast to a floating-point number. |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| `(float) (double) (real)` | 转换为浮点数。 |'
- en: '| `(string)` | Cast to a string. |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| `(string)` | 转换为字符串。 |'
- en: '| `(array)` | Cast to an array. |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| `(array)` | 转换为数组。 |'
- en: '| `(object)` | Cast to an object. |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| `(object)` | 转换为对象。 |'
- en: Note
  id: totrans-360
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You can usually avoid having to use a cast by calling one of PHP’s built-in
    functions. For example, to obtain an integer value, you could use the `intval`
    function. As with some other sections in this book, this section is here mainly
    to help you understand third-party code that you may encounter from time to time.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以通过调用 PHP 的内置函数避免使用转换。例如，要获取整数值，可以使用 `intval` 函数。正如本书中的其他部分一样，本节主要是为了帮助您理解可能偶尔遇到的第三方代码。
- en: PHP Dynamic Linking
  id: totrans-362
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PHP 动态链接
- en: Because PHP is a programming language, and the output from it can be completely
    different for each user, it’s possible for an entire website to run from a single
    PHP web page. Each time the user clicks something, the details can be sent back
    to the same web page, which decides what to do next according to the various cookies
    and/or other session details it may have stored.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 PHP 是一种编程语言，其输出对于每个用户可能完全不同，因此一个完整的网站可以仅由单个 PHP 网页运行。每当用户点击某些内容时，细节可以发送回同一个网页，根据各种
    cookie 和/或其他会话详细信息决定下一步该执行什么操作。
- en: But although it is possible to build an entire website this way, it’s not recommended,
    because your source code will grow and grow and start to become unwieldy, as it
    has to account for every possible action a user could take.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管可以通过这种方式构建整个网站，但并不推荐，因为您的源代码会越来越庞大，并开始变得难以管理，因为它必须考虑用户可能采取的每一个可能的操作。
- en: Instead, it’s much more sensible to split your website development into different
    parts. For example, one distinct process is signing up for a website, along with
    all the checking this entails to validate an email address, determine whether
    a username is already taken, and so on.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，将您的网站开发分成不同的部分更加明智。例如，一个明确的过程是注册网站，以及所有这些操作的检查以验证电子邮件地址，确定用户名是否已被使用等等。
- en: A second module might be one that logs users in before handing them off to the
    main part of your website. Then you might have a messaging module with the facility
    for users to leave comments, a module containing links and useful information,
    another to allow uploading of images, and more.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模块可能是登录用户后将其传递到网站的主要部分之前的模块。然后您可能有一个具有用户留言功能的消息模块，一个包含链接和有用信息的模块，另一个允许上传图片的模块等等。
- en: As long as you have created a way to track your user through your website by
    means of cookies or session variables (both of which we’ll look at more closely
    in later chapters), you can split up your website into sensible sections of PHP
    code, each one self-contained, and therefore treat yourself to a much easier future,
    developing each new feature and maintaining old ones. If you have a team, different
    people can work on different modules so that each programmer needs to learn just
    one part of the program thoroughly.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您已经通过cookie或会话变量创建了跟踪用户在网站上行动的方式（我们将在后面的章节中更详细地讨论这两者），您可以将您的网站分成PHP代码的合理部分，每个部分都是自包含的，因此在未来开发每个新功能和维护旧功能时会变得更加轻松。如果您有一个团队，不同的人可以分别工作在不同的模块上，这样每个程序员只需彻底了解一个部分。
- en: Dynamic Linking in Action
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态链接实例
- en: One of the more popular PHP-driven applications on the web today is the Content
    Management System (CMS) WordPress (see [Figure 4-5](#wordpress_blogging_platform_is_writt)).
    You might not realize it, but every major section has been given its own main
    PHP file, and a whole raft of generic, shared functions have been placed in separate
    files that are included by the main PHP pages as necessary.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如今Web上更受欢迎的基于PHP的应用之一是内容管理系统（CMS）WordPress（见[图4-5](#wordpress_blogging_platform_is_writt)）。您可能没有意识到，但每个主要部分都有自己的主PHP文件，并且一整套通用的共享函数已放置在根据需要由主PHP页面包含的单独文件中。
- en: '![](Images/pmj6_0405.png)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pmj6_0405.png)'
- en: Figure 4-5\. The WordPress CMS
  id: totrans-371
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-5. WordPress CMS
- en: The whole platform is held together with behind-the-scenes session tracking
    so that you hardly know when you are transitioning from one subsection to another.
    Therefore, a web developer who wants to tweak WordPress can easily find the particular
    file they need, modify it, and test and debug it without messing around with unconnected
    parts of the program. Next time you use WordPress, keep an eye on your browser’s
    address bar, and you’ll notice some of the different PHP files that it uses.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 整个平台通过幕后的会话追踪来紧密连接，以便在从一个子部分过渡到另一个子部分时几乎感觉不到。因此，希望调整WordPress的Web开发人员可以轻松找到他们需要的特定文件，修改它，测试和调试它，而不必去破坏程序的不相关部分。下次您使用WordPress时，请关注您浏览器的地址栏，您会注意到它使用的一些不同的PHP文件。
- en: This chapter has covered quite a lot of ground, and by now you should be able
    to put together your own small PHP programs. But before you do, and before proceeding
    with the following chapter on functions and objects, you may wish to test your
    new knowledge by answering the following questions.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容涵盖了相当多的内容，到目前为止，您应该能够编写自己的小型PHP程序。但在开始下一章关于函数和对象之前，您可能希望通过回答以下问题来测试您的新知识。
- en: Questions
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What actual underlying values are represented by `TRUE` and `FALSE`?
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TRUE`和`FALSE`分别表示什么实际底层值？'
- en: What are the simplest two forms of expressions?
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是最简单的两种表达形式？
- en: What is the difference between unary, binary, and ternary operators?
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是一元、二元和三元运算符的区别？
- en: What is the best way to force your own operator precedence?
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 强制自己操作符优先级的最佳方法是什么？
- en: What is meant by *operator associativity*?
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*运算符结合性*是什么意思？'
- en: When would you use the `===` (identity) operator?
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时使用`===`（身份）运算符？
- en: Name the three conditional statement types.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名三种条件语句类型。
- en: What command can you use to skip the current iteration of a loop and move on
    to the next one?
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用哪个命令来跳过当前循环迭代并继续下一个迭代？
- en: Why is a `for` loop more powerful than a `while` loop?
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么`for`循环比`while`循环更强大？
- en: How do `if` and `while` statements interpret conditional expressions of different
    data types?
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`if`和`while`语句如何解释不同数据类型的条件表达式？'
- en: See [“Chapter 4 Answers”](app01_split_003.xhtml#chapter_4_answers) in the [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions)
    for the answers to these questions.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 请查看[“第四章答案”](app01_split_003.xhtml#chapter_4_answers)，在[附录 A](app01_split_000.xhtml#solutions_to_the_chapter_questions)中可以找到这些问题的答案。
