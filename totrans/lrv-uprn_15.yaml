- en: Chapter 15\. Mail and Notifications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 15 章 电子邮件与通知
- en: Sending an application’s users notifications via email, Slack, SMS, or another
    notification system is a common but surprisingly complex requirement. Laravel’s
    mail and notification features provide consistent APIs that abstract away the
    need to pay too close attention to any particular provider. Just like in [Chapter 14](ch14.html#storage_and_retrieval),
    you’ll write your code once and choose at the configuration level which provider
    you’ll use to send your email or notifications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通过电子邮件、Slack、SMS 或其他通知系统向应用的用户发送通知是一个常见但令人惊讶地复杂的需求。Laravel 的邮件和通知功能提供了一致的 API，抽象了不必太关注任何特定提供者的需要。就像在[第
    14 章](ch14.html#storage_and_retrieval)中一样，你只需编写一次代码，并在配置级别选择要用于发送电子邮件或通知的提供程序。
- en: Mail
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件
- en: Laravel’s mail functionality is a convenience layer on top of [Symfony Mailer](https://oreil.ly/ceZ3K).
    Out of the box, Laravel comes with drivers for SMTP, Mailgun, Postmark, Amazon
    SES, and Sendmail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的邮件功能是建立在[Symfony Mailer](https://oreil.ly/ceZ3K)之上的便捷层。默认情况下，Laravel
    提供了 SMTP、Mailgun、Postmark、Amazon SES 和 Sendmail 驱动程序。
- en: For all of the cloud services, you’ll set your authentication information in
    *config**/services.php*. However, if you take a look, you’ll see there are already
    keys there—and in *config/mail.php*—that allow you to customize your application’s
    mail functionality in *.env* using variables like `MAIL_MAILER` and `MAILGUN_SECRET`.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的云服务，你将在 *config**/services.php* 中设置你的身份验证信息。然而，如果你查看一下，你会看到已经有了一些键——在 *config/mail.php*
    中——允许你使用像 `MAIL_MAILER` 和 `MAILGUN_SECRET` 这样的变量，在 *.env* 中自定义应用程序的邮件功能。
- en: Basic “Mailable” Mail Usage
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本的“Mailable”邮件使用
- en: Every mail message you’ll send in a modern Laravel app will be an instance of
    a specific PHP class, created to represent each email, called a *mailable*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 Laravel 应用中，你发送的每一封邮件都是一个特定的 PHP 类的实例，用来表示每封邮件，称为*mailable*。
- en: 'To make a mailable, use the `make:mail` Artisan command:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 mailable，可以使用 `make:mail` Artisan 命令：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Example 15-1](#autogenerated_mailable_PHP_class) shows what that class looks
    like.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-1](#autogenerated_mailable_PHP_class) 展示了该类的样子。'
- en: Example 15-1\. An autogenerated mailable PHP class
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-1 自动生成的 mailable PHP 类
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may notice a few similarities between mailables and jobs; this class even
    imports the `Queueable` trait for queuing your mail and the `SerializesModels`
    trait so any Eloquent models you pass to the constructor will be serialized correctly.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到 mailable 和 jobs 之间有一些相似之处；这个类甚至导入了 `Queueable` trait 用于排队你的邮件和 `SerializesModels`
    trait，因此你传递给构造函数的任何 Eloquent 模型都将被正确序列化。
- en: So, how does this work? The class constructor is the place where you’ll pass
    in any data, and any properties you set as public on your mailable class will
    be available to the template.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是如何工作的呢？类的构造函数是你传递任何数据的地方，你在 mailable 类上设置为公共的任何属性都将在模板中可用。
- en: In the `envelope()` method, you’ll set configuration details about the mail—sender,
    subject, metadata.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `envelope()` 方法中，你将设置关于邮件的配置详情——发件人、主题、元数据。
- en: In the `content()` method, you’ll define the content—which view you’re using
    to render, any Markdown contents, and text parameters.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `content()` 方法中，你将定义内容——包括你使用的视图以及任何 Markdown 内容和文本参数。
- en: And if you want to attach any files to the mail, you’ll use the `attachments()`
    method.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要附加文件到邮件中，你将使用 `attachments()` 方法。
- en: Take a look at [Example 15-2](#EX1453) to see how we might update the autogenerated
    mailable for our assignment example.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [示例 15-2](#EX1453) 以了解我们如何更新为我们的任务示例自动生成的 mailable。
- en: Example 15-2\. A sample mailable
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-2 一个示例 mailable
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once you’ve created the mailable class, it’s time to send it. First, you create
    an instance of the mailable class, passing in the appropriate data; then, you
    chain `Mail::to($user)->send($mailable)` to send the mail. You can also customize
    some other details of your mail, like the CC and BCC, as part of the inline call
    chain. Take a look at [Example 15-3](#ways_to_send_mailables) to see a few examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了 mailable 类，就可以开始发送邮件了。首先，创建 mailable 类的一个实例，并传入适当的数据；然后，通过链式调用 `Mail::to($user)->send($mailable)`
    来发送邮件。你还可以在内联调用链的一部分中自定义邮件的一些其他细节，例如 CC 和 BCC。查看 [示例 15-3](#ways_to_send_mailables)
    以查看一些示例。
- en: Example 15-3\. How to send mailables
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-3 如何发送 mailables
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Mail Templates
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子邮件模板
- en: Mail templates are just like any other template. They can extend other templates,
    use sections, parse variables, contain conditional or looping directives, and
    do anything else you can do in a normal Blade view.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 邮件模板与任何其他模板都一样。它们可以扩展其他模板，使用部分，解析变量，包含条件或循环指令，以及执行任何您可以在普通 Blade 视图中执行的操作。
- en: Take a look at [Example 15-4](#EX1409) to see a possible `emails.assignment-created`
    template for [Example 15-2](#EX1453).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[示例 15-4](#EX1409)，查看[示例 15-2](#EX1453)的可能的 `emails.assignment-created` 模板。
- en: Example 15-4\. Sample `assignment-created` email template
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-4\. 示例 `assignment-created` 电子邮件模板
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In [Example 15-2](#EX1453), both `$trainer` and `$trainee` are public properties
    on your mailable, which makes them available to the template. Had one of them
    been private, it would not have been available.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 15-2](#EX1453)中，`$trainer` 和 `$trainee` 都是您的可邮件化对象上的公共属性，这使它们可供模板使用。如果其中一个是私有的，它将不可用。
- en: If you want to explicitly define which variables are passed to the template,
    you can use the `with` parameter on the `Content` of your mailable, as in [Example 15-5](#customizing_template_variables).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想明确定义传递给模板的变量，可以在您的可邮件化内容的 `with` 参数中使用，如[示例 15-5](#customizing_template_variables)。
- en: Example 15-5\. Customizing the template variables
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-5\. 自定义模板变量
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: HTML Versus Plain-Text Emails
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTML 与纯文本邮件
- en: 'So far we’ve used the `view` parameter on the `new Content()` instantiation.
    This expects the template we’re referencing to pass back HTML. If you’d like to
    pass a plain-text version, use the `text` parameter to define your plain-text
    view:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用了 `new Content()` 实例上的 `view` 参数。这需要我们引用的模板返回 HTML。如果您想传递纯文本版本，请使用
    `text` 参数来定义您的纯文本视图：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Methods Available in envelope()
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`envelope()` 方法中可用的方法'
- en: 'We’ve already looked at how we can customize the subject and the “from” address
    using the `envelope()` method. Note that the way we’re customizing these is by
    passing different named parameters to the constructor of the `Envelope` class:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过如何使用 `envelope()` 方法自定义主题和“发件人”地址。请注意，我们自定义它们的方式是通过向 `Envelope` 类的构造函数传递不同的命名参数：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This isn’t an exhaustive list, but here is a short list of parameters the `envelope()`
    method allows us to pass to the `Envelope` class to customize our email. Any parameter
    that can accept an `Address` can also accept a string email address or an array
    containing a mixture of `Address` objects and/or strings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个详尽的列表，但这里是一些可以通过 `envelope()` 方法传递到 `Envelope` 类以自定义电子邮件的参数的简短列表。任何可以接受
    `Address` 的参数也可以接受字符串电子邮件地址或包含 `Address` 对象和/或字符串混合的数组。
- en: '`from: *Address*`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`from: *地址*`'
- en: Sets the “from” name and address—​represents the author
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 设置“发件人”姓名和地址 — 代表作者
- en: '`subject: *string*`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`subject: *字符串*`'
- en: Sets the email subject
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 设置电子邮件主题
- en: '`cc: *Address*`'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`cc: *地址*`'
- en: Sets the CC
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 设置抄送
- en: '`bcc: *Address*`'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`bcc: *地址*`'
- en: Sets the BCC
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 设置密送
- en: '`replyTo: *Address*`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`replyTo: *地址*`'
- en: Sets the “reply to”
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 设置“回复地址”
- en: '`tags: *array*`'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags: *数组*`'
- en: Sets the tags, if relevant for your email sender
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 设置标签，如果适用于您的电子邮件发件人
- en: '`metadata: *array*`'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`metadata: *数组*`'
- en: Sets the metadata, if relevant for your email sender
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 设置元数据，如果适用于您的电子邮件发件人
- en: Finally, if you want to perform any manual modifications on the underlying Symfony
    message, you can do that in the `using` parameter, as shown in [Example 15-6](#modify_underlying_SymfonyMessage).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您想要对底层 Symfony 消息进行任何手动修改，可以在 `using` 参数中执行，如[示例 15-6](#modify_underlying_SymfonyMessage)所示。
- en: Example 15-6\. Modifying the underlying `SymfonyMessage` object
  id: totrans-54
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-6\. 修改底层 `SymfonyMessage` 对象
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Attaching Files and Inlining Images
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附加文件和内联图片
- en: To attach a file to your mail, return an array (in which each entry is an `Attachment`)
    from the `attachments()` method, as shown in [Example 15-7](#attach_files_or_data_to_mailables).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要将文件附加到您的邮件中，请从 `attachments()` 方法返回一个数组（其中每个条目都是 `Attachment`），如[示例 15-7](#attach_files_or_data_to_mailables)所示。
- en: Example 15-7\. Attaching files or data to mailables
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-7\. 附加文件或数据到可邮件化对象
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Attachable mail objects
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可附加的邮件对象
- en: If you have a PHP class that can be represented as an attachment to an email,
    or if you’d like to build a PHP class full of logic around the objects you attach
    to your emails, you’ll want to try Laravel’s attachable objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个可以作为电子邮件附件表示的 PHP 类，或者如果您想要构建一个围绕附加到电子邮件的对象的逻辑的 PHP 类，您可以尝试 Laravel 的可附加对象。
- en: Each of these objects need only be a PHP class that implements the `Illuminate\Contracts\Mail\Attachable`
    interface, which requires a `toMailAttachment()` method, which returns an instance
    of `Illuminate\Mail\Attachment`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象中的每一个只需要是一个实现`Illuminate\Contracts\Mail\Attachable`接口的PHP类，该接口需要一个`toMailAttachment()`方法，该方法返回一个`Illuminate\Mail\Attachment`实例。
- en: One common example would be if you want to make one of your Eloquent models
    attachable. In our example, we’ve been emailing our clients about a new assignment
    from their trainer, so let’s try making `Assignment` attachable. Take a look at
    [Example 15-8](#making_model_attachable).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的例子是，如果你想要使你的Eloquent模型中的一个可附加的，我们的例子中，我们一直在给我们的客户发送来自他们的教练的新作业的电子邮件，所以让我们尝试使`Assignment`可附加。查看[示例
    15-8](#making_model_attachable)。
- en: Example 15-8\. Making an Eloquent model attachable
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-8\. 使Eloquent模型可附加
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If a class implements `Attachable`, you can use any instances of that class
    as entries in the array you return from `attachments()`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类实现了`Attachable`接口，你可以将该类的任何实例用作从`attachments()`方法返回的数组中的条目：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Inlining images
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联图像
- en: If you want to attach images inline, directly into your email, Laravel provides
    a feature for that as well, as you can see in [Example 15-9](#inlining_images).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将图像内联附加到你的电子邮件中，Laravel也提供了相应的功能，正如你在[示例 15-9](#inlining_images)中所见。
- en: Example 15-9\. Inlining images in email
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-9\. 在电子邮件中内联图像
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Markdown Mailables
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Markdown可发送邮件
- en: Markdown mailables allow you to write your email content in Markdown, after
    which it will be converted into full HTML (and plain-text) emails with Laravel’s
    built-in, responsive HTML templates. You can also tweak these templates to make
    a customized email template that’s simple for your developers and nondevelopers
    to create content for.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown可发送邮件允许你在Markdown中编写电子邮件内容，之后它将被转换为具有Laravel内置响应式HTML模板的完整HTML（和纯文本）电子邮件。你还可以调整这些模板，以创建一个简单的、适合开发人员和非开发人员创建内容的自定义电子邮件模板。
- en: 'First, run the `make:mail` Artisan command with the `markdown` flag:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用`markdown`标志运行`make:mail` Artisan命令：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can see an example of what the generated mail file looks like in [Example 15-10](#generated_markdown_mailable).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[示例 15-10](#generated_markdown_mailable)中看到生成的邮件文件的示例。
- en: Example 15-10\. Generated Markdown mailable
  id: totrans-77
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-10\. 生成的Markdown可发送邮件
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, this is almost exactly the same as a normal mailable file in
    Laravel. The main difference is that you’re passing your template into the `markdown`
    parameter instead of the `view` parameter. Also note that the template you’re
    referencing should represent a Markdown template, not a normal Blade template.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这几乎与Laravel中的普通可发送邮件文件完全相同。主要区别在于，你将你的模板传递给`markdown`参数而不是`view`参数。还要注意，你引用的模板应该代表一个Markdown模板，而不是普通的Blade模板。
- en: What’s a *Markdown template*? Unlike a normal Blade email template, which is
    expected—​with the use of includes and inheritance like any Blade file—​to generate
    a full HTML email, Markdown templates simply pass Markdown content to a few predefined
    components.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是*Markdown模板*？与普通的Blade电子邮件模板不同，Blade模板预期—​通过包含和继承等方式—​生成完整的HTML电子邮件，而Markdown模板只需将Markdown内容传递给几个预定义的组件。
- en: These components will look like `<x-mail::component-name-here>`, and, as such,
    the main body of your Markdown email should be passed into a component named `<x-mail::message>`.
    Take a look at [Example 15-11](#simple_assignment_markdown_email) to see an example
    of a simple Markdown mail template.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件看起来像`<x-mail::component-name-here>`，因此，你的Markdown邮件的主体应该传递给名为`<x-mail::message>`的组件。查看[示例
    15-11](#simple_assignment_markdown_email)来查看一个简单Markdown邮件模板的示例。
- en: Example 15-11\. Simple assignment Markdown email
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-11\. 简单分配的Markdown邮件
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see in [Example 15-11](#simple_assignment_markdown_email), there’s
    a parent `mail::message` component to which you pass the body of your email, but
    you’re also provided with other, smaller components you can sprinkle into your
    emails. We used the `mail::button` component here, which takes the content (“View
    Your Assignment”) but also requires the `url` attribute to be passed.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[示例 15-11](#simple_assignment_markdown_email)中所见，有一个父级`mail::message`组件，你可以向其传递电子邮件的正文，但你还可以添加其他更小的组件到你的电子邮件中。我们在这里使用了`mail::button`组件，它需要传递内容（“查看您的作业”），同时需要传递`url`属性。
- en: 'There are three types of components available:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种可用的组件类型：
- en: Button
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮
- en: Generates a centered button link. The button component requires a `url` attribute
    and allows an optional `color` attribute, to which you can pass `primary`, `success`,
    or `error`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个居中的按钮链接。按钮组件需要一个`url`属性，并允许一个可选的`color`属性，你可以传递`primary`、`success`或`error`。
- en: Panel
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 面板
- en: Renders the provided text with a slightly lighter background than the rest of
    the message.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用稍亮于消息其余部分的背景来渲染提供的文本。
- en: Table
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 表格
- en: Converts the content passed into it via the Markdown table syntax.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 将通过 Markdown 表格语法传递的内容转换为表格。
- en: Customizing the Components
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义组件
- en: 'These Markdown components are built into the core of the Laravel framework,
    but if you need to customize how they work, you can publish their files and edit
    them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 Markdown 组件内置在 Laravel 框架的核心中，但如果您需要自定义它们的工作方式，可以发布它们的文件并进行编辑：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can learn more about customizing these files and their themes in the [Laravel
    docs](https://oreil.ly/R4Gr9).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Laravel 文档](https://oreil.ly/R4Gr9)中了解有关自定义这些文件及其主题的更多信息。
- en: Rendering Mailables to the Browser
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将可邮件渲染到浏览器
- en: When you’re developing emails in your applications, it’s helpful to be able
    to preview how they’ll render. You can rely on a tool like Mailtrap for this,
    and that is a useful tool, but it can also be helpful to render the mails directly
    in your browser and see your changes made immediately.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中开发电子邮件时，能够预览它们的渲染效果是很有帮助的。您可以依赖像 Mailtrap 这样的工具来进行预览，这是一个很有用的工具，但直接在浏览器中渲染邮件并立即看到您所做的更改也是很有帮助的。
- en: Take a look at [Example 15-12](#rendering_mailables) to see a sample route you
    can add to your application to render a given mailable.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[示例 15-12](#rendering_mailables)以查看您可以添加到应用程序中以渲染给定可邮件的示例路由。
- en: Example 15-12\. Rendering a mailable to a route
  id: totrans-99
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-12. 将可邮件渲染到路由
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Laravel also provides a way to quickly preview a notification in the browser:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 也提供了一种快速在浏览器中预览通知的方法：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Queues
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 队列
- en: 'Sending email is a time-consuming task that can cause applications to slow
    down, so it’s common to move it to a background queue. It’s so common, in fact,
    that Laravel has a set of built-in tools to make it easier to queue your messages
    without writing queue jobs for each email:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件是一项耗时的任务，可能导致应用程序变慢，因此通常将其移到后台队列中是很常见的。事实上，Laravel 提供了一组内置工具，使得可以更轻松地将消息加入队列，而不必为每封电子邮件编写队列作业：
- en: '`queue()`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue()`'
- en: 'To queue a mail object instead of sending it immediately, simply pass your
    mailable object to `Mail::queue()` instead of `Mail::send()`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要将邮件对象加入队列而不是立即发送，只需将可邮件对象传递给`Mail::queue()`而不是`Mail::send()`：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`later()`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`later()`'
- en: '`Mail::later()` works the same as `Mail::queue()`, but it allows you to add
    a delay—​either in minutes or by specifying a specific time by passing an instance
    of `DateTime` or `Carbon`—specifying when the email will be pulled from the queue
    and sent:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mail::later()`与`Mail::queue()`相同，但允许您添加延迟—​可以是几分钟，也可以通过传递`DateTime`或`Carbon`的实例来指定具体时间—​指定何时从队列中提取并发送电子邮件：'
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Configuring Queues
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置队列
- en: Your queues must be configured correctly for these methods to work. Take a look
    at [Chapter 16](ch16.html#queues_jobs_events) to learn more about how queues work
    and how to get them running in your application.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的工作需要正确配置您的队列。查看[第 16 章](ch16.html#queues_jobs_events)了解有关队列工作原理及如何在应用程序中运行它们的更多信息。
- en: 'For both `queue()` and `later()`, if you’d like to specify which queue or queue
    connection your mail is added to, use the `onConnection()` and `onQueue()` methods
    on your mailable object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`queue()`和`later()`，如果您希望指定邮件添加到哪个队列或队列连接，请在可邮件对象上使用`onConnection()`和`onQueue()`方法：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you’d like to direct that a given mailable should always be queued, you can
    make the mailable implement the `Illuminate\Contracts\Queue\ShouldQueue` interface.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望指定某个可邮件始终应该加入队列，可以让该可邮件实现`Illuminate\Contracts\Queue\ShouldQueue`接口。
- en: Local Development
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地开发
- en: 'This is all well and good for sending mail in your production environments.
    But how do you test it all out? There are two primary tools you’ll want to consider:
    Laravel’s `log` driver and fake inboxes for testing, such as Mailtrap.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于在生产环境中发送邮件是很好的。但是如何进行测试呢？有两个主要工具值得考虑：Laravel 的`log`驱动程序和用于测试的虚拟收件箱，比如 Mailtrap。
- en: The log driver
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: log 驱动程序
- en: Laravel provides a `log` driver that logs every email you try to send to your
    local *laravel.log* file (which is, by default, in *storage/logs*).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 提供了一个`log`驱动程序，会将您尝试发送的每封电子邮件记录到本地的*laravel.log*文件中（默认位于*storage/logs*中）。
- en: 'To use this, edit *.env* and set `MAIL_MAILER` to `log`. Now open up or tail
    *storage/logs/laravel.log* and send an email from your app. You’ll see something
    like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，请编辑*.env*文件，并将`MAIL_MAILER`设置为`log`。现在打开或尾随*storage/logs/laravel.log*并从您的应用程序发送电子邮件。您将看到类似于以下内容：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can optionally specify that logged mail gets sent to a different log channel
    than the rest of your logs. Either modify *config/mail.php* or set the `MAIL_LOG_CHANNEL`
    variable in your *.env* file to the name of any existing log channel.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择指定将记录的邮件发送到与其余日志不同的日志通道。要么修改*config/mail.php*，要么在您的*.env*文件中将`MAIL_LOG_CHANNEL`变量设置为任何现有日志通道的名称。
- en: Fake inboxes
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟收件箱
- en: If you want to see your test emails as they’ll look in a real inbox, you can
    use one of several services that allow you to send your emails to them and show
    you your emails in a full fake inbox.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想看看您的测试电子邮件在真实收件箱中的外观，您可以使用几种服务之一，这些服务允许您将您的电子邮件发送到它们，并在一个完整的虚假收件箱中显示您的电子邮件。
- en: The two most common such services are Mailtrap, a paid SaaS that requires no
    setup and allows you to share your inbox with coworkers and clients, and Mailpit,
    a service you can run on your local machine through Docker.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的两种此类服务是Mailtrap，这是一个无需设置的付费SaaS，允许您与同事和客户分享收件箱，以及Mailpit，这是一个可以通过Docker在本地运行的服务。
- en: Mailtrap
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Mailtrap
- en: '[Mailtrap](https://mailtrap.io) is a service for capturing and inspecting emails
    in development environments. You send your mail to the Mailtrap servers via SMTP,
    but instead of sending those emails off to the intended recipients, Mailtrap captures
    them all and provides you with a web-based email client for inspecting them, regardless
    of which email address is in the `to` field.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[Mailtrap](https://mailtrap.io)是一个在开发环境中捕获和检查电子邮件的服务。您通过SMTP将您的邮件发送到Mailtrap服务器，但Mailtrap不会将这些邮件发送给预期的接收者，而是捕获它们并为您提供一个基于Web的电子邮件客户端以进行检查，无论目标电子邮件地址是什么。'
- en: To set up Mailtrap, sign up for a free account and visit the base dashboard
    for your demo. Copy your username and password from the SMTP column.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置Mailtrap，请注册免费帐户并访问您的演示基础仪表板。从SMTP列复制您的用户名和密码。
- en: 'Then edit your app’s *.env* file and set the following values in the `mail`
    section:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后编辑您的应用程序的*.env*文件，并在`mail`部分设置以下值：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, any email you send from your app will show up in your Mailtrap inbox.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您从应用程序发送的任何电子邮件都将显示在Mailtrap收件箱中。
- en: Mailpit
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Mailpit
- en: If you like the idea of Mailtrap, but you’d like to run the application locally
    (and for free), you can use [Mailpit](https://oreil.ly/dPgRK), a Mailtrap alternative
    you can spin up in a local Docker container.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您喜欢Mailtrap的想法，但希望在本地（免费）运行应用程序，您可以使用[Mailpit](https://oreil.ly/dPgRK)，这是Mailtrap的一种替代方案，您可以在本地Docker容器中运行。
- en: Notifications
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知
- en: The purpose of most of the mail that’s sent from web apps is to notify users
    that a particular action has happened or needs to happen. As users’ communication
    preferences grow more and more diverse, we gather ever more—and more disparate—packages
    to communicate via Slack, SMS, and other means.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数从Web应用程序发送的邮件的目的是通知用户特定操作已发生或需要发生。随着用户的沟通偏好变得越来越多样化，我们通过Slack、短信和其他方式收集越来越多——以及更为不同的——通信包。
- en: To support these preferences, Laravel introduced a concept called, fittingly,
    *notifications*. Just like a mailable, a notification is a PHP class that represents
    a single communication that you might want to send to your users. For now, let’s
    imagine we’re notifying the users of our physical training app that they have
    a new workout available.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为支持这些偏好，Laravel引入了一个名为*notifications*的概念。就像可邮寄物一样，通知是一个表示您可能希望发送给用户的单个通信的PHP类。现在，让我们假设我们正在通知我们的身体训练应用程序用户，他们有新的训练可用。
- en: Each class represents all of the information necessary to send notifications
    to your users *using one or many notification channels*. A single notification
    could send an email, send an SMS via Vonage, send a WebSocket ping, add a record
    to a database, send a message to a Slack channel, and much more.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类代表发送通知给您的用户所需的所有信息，*可以使用一个或多个通知渠道*。单个通知可以通过电子邮件发送，通过Vonage发送短信，发送WebSocket
    ping，向数据库添加记录，向Slack频道发送消息等等。
- en: 'So, let’s create our notification:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们创建我们的通知：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[Example 15-13](#autogenerated_notification_class) shows what that gives us.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 15-13](#autogenerated_notification_class)展示了这给我们带来的东西。'
- en: Example 15-13\. An autogenerated notification class
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-13\. 自动生成的通知类
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can learn a few things here. First, we’re going to pass relevant data into
    the constructor. Second, there’s a `via()` method that allows us to define, for
    a given user, which notification channels to use (`$notifiable` represents whatever
    entities you want to notify in your system; for most apps, it’ll be a user, but
    that’s not always the case). And third, there are individual methods for each
    notification channel that allow us to specifically define how to send one of these
    notifications through that channel.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这里学到一些东西。首先，我们将向构造函数传递相关数据。其次，有一个`via()`方法，允许我们为给定用户定义要使用的通知渠道（`$notifiable`代表您系统中希望通知的任何实体；对于大多数应用程序，它将是一个用户，但并非总是如此）。第三，每个通知渠道都有单独的方法，允许我们明确定义如何通过该渠道发送其中一个通知。
- en: When Would a $notifiable Not Be a User?
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当`$notifiable`不是一个用户时会发生什么？
- en: Although the most common notification targets will be users, it’s possible you
    may want to notify something else. This may simply be because your application
    has multiple user types—so, you might want to be able to notify both trainers
    and trainees. But you also might find yourself wanting to notify a group, a company,
    or a server.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管最常见的通知目标将是用户，但您可能希望通知其他内容。这可能仅仅是因为您的应用程序具有多个用户类型，因此您可能希望通知培训师和学员。但您也可能希望通知一个群组、一个公司或一个服务器。
- en: So, let’s modify this class for our `WorkoutAvailable` example. Take a look
    at [Example 15-14](#EX1419).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们修改这个类，适用于我们的`WorkoutAvailable`示例。看一下[示例 15-14](#EX1419)。
- en: Example 15-14\. Our `WorkoutAvailable` notification class
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-14\. 我们的`WorkoutAvailable`通知类
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Defining the via() Method for Your Notifiables
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为您的通知定义`via()`方法
- en: As you can see in [Example 15-14](#EX1419), we’re responsible for deciding,
    for each notification and each notifiable, which notification channels we’re going
    to use.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[示例 15-14](#EX1419)中所看到的，我们需要负责决定每个通知和每个通知对象要使用哪些通知渠道。
- en: You could just send everything as mail or just send everything as an SMS ([Example 15-15](#simplest_via_method)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将所有内容都发送为邮件或只发送为短信（[示例 15-15](#simplest_via_method)）。
- en: Example 15-15\. Simplest possible `via()` method
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-15\. 最简单的`via()`方法
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You could also let each user choose a preferred method and save that on the
    `User` itself ([Example 15-16](#customizing_via_method)).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以让每个用户选择一种首选方法，并将其保存在用户本身上（[示例 15-16](#customizing_via_method)）。
- en: Example 15-16\. Customizing the `via()` method per user
  id: totrans-155
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-16\. 根据用户自定义`via()`方法
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Or, as we imagined in [Example 15-14](#EX1419), you could create a method on
    each notifiable that allows for some complex notification logic. For example,
    you could notify the user over certain channels during work hours and other channels
    in the evening. What is important is that `via()` is a PHP class method, so you
    can do whatever complex logic you want there.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，正如我们在[示例 15-14](#EX1419)中设想的那样，您可以在每个通知对象上创建一个方法，以进行一些复杂的通知逻辑。例如，您可以在工作时间通过某些渠道通知用户，而在晚上通过其他渠道通知用户。重要的是`via()`是一个PHP类方法，因此您可以在那里执行任何复杂的逻辑。
- en: Sending Notifications
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发送通知
- en: 'There are two ways to send a notification: using the `Notification` facade,
    or adding the `Notifiable` trait to an Eloquent class (likely your `User` class).'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以发送通知：使用`Notification`门面，或将`Notifiable`特性添加到一个Eloquent类（通常是您的`User`类）。
- en: Sending notifications using the notification facade
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通知门面发送通知
- en: The `Notification` facade is the clumsier of the two methods, since you have
    to pass both the notifiable and the notification. However, it’s helpful because
    you can choose to pass more than one notifiable at the same time, as shown in
    [Example 15-17](#EX1417).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notification`门面是两种方法中较为笨拙的一种，因为您必须同时传递通知对象和通知内容。然而，它非常有用，因为您可以选择同时传递多个通知对象，就像[示例 15-17](#EX1417)中所示。'
- en: Example 15-17\. Sending a notification using the `Notification` facade
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-17\. 使用`Notification`门面发送通知
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Sending notifications using the notifiable trait
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用通知特性发送通知
- en: Any model that imports the `Laravel\Notifications\Notifiable` trait (which the
    `App\User` class does by default) has a `notify()` method that can be passed a
    notification, which will look like [Example 15-18](#EX1418).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 任何导入`Laravel\Notifications\Notifiable`特性的模型（默认情况下是`App\User`类）都有一个`notify()`方法，可以传递一个通知，看起来像[示例 15-18](#EX1418)。
- en: Example 15-18\. Sending a notification using the `Notifiable` trait
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-18\. 使用`Notifiable`特性发送通知
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Queueing Notifications
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将通知排队
- en: Most notification drivers need to use HTTP requests to send notifications, which
    could slow down your user experience. To deal with this you’ll probably want to
    queue your notifications. All notifications import the `Queueable` trait by default,
    so all you need to do is add `implements ShouldQueue` to your notification, and
    Laravel will instantly move it to a queue.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数通知驱动程序需要使用 HTTP 请求发送通知，这可能会减慢用户体验。为了处理这个问题，您可能希望将通知加入队列。所有通知默认导入 `Queueable`
    特性，因此您只需在通知中添加 `implements ShouldQueue`，Laravel 将立即将其移到队列中。
- en: As with any other queued features, you’ll need to make sure you have your queue
    settings configured correctly and a queue worker running.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他队列功能一样，您需要确保正确配置队列设置并运行队列工作程序。
- en: 'If you’d like to delay the delivery of a notification, you can run the `delay()`
    method on the notification:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想延迟发送通知，可以在通知上运行 `delay()` 方法：
- en: '[PRE31]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Out-of-the-Box Notification Types
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开箱即用的通知类型
- en: Out of the box, Laravel comes with notification drivers for email, database,
    broadcast, Vonage SMS, and Slack. I’ll cover each briefly, but I’d recommend referring
    to the [notifications docs](https://oreil.ly/VzICd) for more thorough introductions
    to each.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 默认提供了用于电子邮件、数据库、广播、Vonage SMS 和 Slack 的通知驱动程序。我会简要介绍每一个，但建议参考 [通知文档](https://oreil.ly/VzICd)
    以获取更详细的介绍。
- en: It’s also easy to create your own notification drivers, and dozens of people
    already have; you can find them at the [Laravel Notification Channels website](https://oreil.ly/6d4_L).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的通知驱动程序也很容易，已经有数十个人这样做了；您可以在 [Laravel 通知通道网站](https://oreil.ly/6d4_L) 找到它们。
- en: Email notifications
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 电子邮件通知
- en: 'Let’s take a look at how the email from our earlier example, [Example 15-14](#EX1419),
    is built:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们先前示例中的电子邮件，[示例 15-14](#EX1419)，是如何构建的：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The result is shown in [Figure 15-1](#default_notifiation_template). The email
    notification system puts your application’s name in the header of the email; you
    can customize that app name in the `name` key of *config/app.php*.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 结果显示在 [图 15-1](#default_notifiation_template) 中。电子邮件通知系统将您应用程序的名称放在电子邮件的标题中；您可以在
    *config/app.php* 的 `name` 键中自定义该应用程序名称。
- en: This email is automatically sent to the `email` property on the notifiable,
    but you can customize this behavior by adding a method to your notifiable class
    named `routeNotificationForMail()` that returns the email address you’d like email
    notifications sent to.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 此电子邮件会自动发送到可通知对象的 `email` 属性，但您可以通过向可通知类添加名为 `routeNotificationForMail()` 的方法并返回您希望发送电子邮件通知的电子邮件地址来自定义此行为。
- en: The email’s subject is set by parsing the notification class name and converting
    it to words. So, our `WorkoutAvailable` notification would have the default subject
    of “Workout Available.” You can also customize this by chaining the `subject()`
    method on the `MailMessage` in the `toMail()` method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 电子邮件的主题是通过解析通知类名称并将其转换为单词来设置的。因此，我们的 `WorkoutAvailable` 通知将具有默认主题“Workout Available”。您还可以通过在
    `toMail()` 方法中的 `MailMessage` 上链接 `subject()` 方法来自定义此主题。
- en: 'If you want to modify the templates, publish them and edit to your heart’s
    content:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想修改模板，请发布它们并随心所欲地编辑：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![An email sent with with the default notification template](assets/lur3_1501.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![使用默认通知模板发送的电子邮件](assets/lur3_1501.png)'
- en: Figure 15-1\. An email sent with the default notification template
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 15-1\. 使用默认通知模板发送的电子邮件
- en: Database notifications
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库通知
- en: You can send notifications to a database table using the `database` notification
    channel. First, create your table with `php artisan notifications:table`. Next,
    create a `toDatabase()` method on your notification and return an array of data
    there. This data will be encoded as JSON and stored in the database table’s `data`
    column.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `database` 通知渠道将通知发送到数据库表。首先，使用 `php artisan notifications:table` 创建您的表。接下来，在通知上创建一个
    `toDatabase()` 方法并在其中返回一个数据数组。这些数据将被编码为 JSON 并存储在数据库表的 `data` 列中。
- en: 'The `Notifiable` trait adds a `notifications` relationship to any model it’s
    imported into, allowing you to easily access records in the notifications table.
    So if you’re using database notifications, you could do something like [Example 15-20](#database-notifications):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Notifiable` 特性将 `notifications` 关系添加到其导入的任何模型中，使您可以轻松访问通知表中的记录。因此，如果您使用数据库通知，您可以执行类似
    [示例 15-20](#database-notifications) 的操作：'
- en: Example 15-20\. Iterating over a user’s database notifications
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-20\. 遍历用户的数据库通知
- en: '[PRE34]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `database` notification channel also has the concept of whether or not
    a notification is “read.” You can scope to only the “unread” notifications as
    shown in [Example 15-21](#unread-notifications):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`database`通知渠道还有一个通知是否“已读”的概念。您可以仅作用于“未读”通知，如[示例 15-21](#unread-notifications)所示：'
- en: Example 15-21\. Iterating over a user’s unread database notifications
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-21\. 遍历用户的未读数据库通知
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: And you can mark one or all notifications as read, as [Example 15-22](#marking-read-notifications)
    demonstrates.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将一个或所有通知标记为已读，正如[示例 15-22](#marking-read-notifications)所示。
- en: Example 15-22\. Marking database notifications as read
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-22\. 将数据库通知标记为已读
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Broadcast notifications
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广播通知
- en: The `broadcast` channel sends notifications using Laravel’s event broadcasting
    features, which are powered by WebSockets (we’ll learn more about these in [“Broadcasting
    Events Over WebSockets, and Laravel Echo”](ch16.html#broadcasting_events)).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`broadcast`通道使用Laravel的事件广播功能发送通知，该功能由WebSockets提供支持（我们将在[“通过WebSockets广播事件和Laravel
    Echo”](ch16.html#broadcasting_events)中了解更多信息）。'
- en: Create a `toBroadcast()` method on your notification and return an array of
    data. If your app is correctly configured for event broadcasting, that data will
    be broadcast on a private channel named `*notifiable.id*`. The `*id*` will be
    the ID of the notifiable, and `*notifiable*` will be the notifiable’s fully qualified
    class name, with the slashes replaced by periods—​for example, the private channel
    for the `App\User` with the ID of `1` will be `App.User.1`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的通知上创建一个`toBroadcast()`方法并返回一个数据数组。如果您的应用程序已正确配置为事件广播，则该数据将在名为`*notifiable.id*`的私有通道上广播。`*id*`将是可通知对象的ID，而`*notifiable*`将是可通知对象的完全限定类名，斜杠替换为句点—例如，ID为`1`的`App\User`的私有通道将是`App.User.1`。
- en: SMS notifications
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 短信通知
- en: SMS notifications are sent via [Vonage](https://www.vonage.com), so if you want
    to send SMS notifications, sign up for a Vonage account and follow the instructions
    in the [notifications docs](https://oreil.ly/VzICd). Like with the other channels,
    you’ll be setting up a `toVonage()` method and customizing the SMS message there.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 短信通知通过[Vonage](https://www.vonage.com)发送，因此如果您想发送短信通知，请注册Vonage帐户，并按照[通知文档](https://oreil.ly/VzICd)中的说明操作。与其他渠道一样，您将设置`toVonage()`方法并在那里自定义短信内容。
- en: SMS Notification Package Install
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 短信通知包安装
- en: 'In Laravel, the SMS notification channel is a first-party package. If you want
    to use Vonage SMS notifications, simply require this package with Composer:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在Laravel中，短信通知渠道是一个官方包。如果您想使用Vonage短信通知，只需使用Composer要求此包：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Slack notifications
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Slack通知
- en: The `slack` notification channel allows you to customize the appearance of your
    notifications and even attach files to them. As with the other channels, you’ll
    set up a `toSlack()` method and customize the message there.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`slack`通知渠道允许您自定义通知的外观，甚至附加文件。与其他渠道一样，您将设置`toSlack()`方法并在那里自定义消息。'
- en: Slack Notification Package Install
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slack通知包安装
- en: 'Laravel’s Slack notification channel is a first-party package. If you want
    to use Slack notifications, simply require this package with Composer:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的Slack通知渠道是一个官方包。如果您想使用Slack通知，只需使用Composer要求此包：
- en: '[PRE38]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Other notifications
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他通知
- en: Looking to send your notifications through other channels than those that come
    out of the box? There’s a robust community effort to provide an incredible variety
    of notification channels; check out what’s on offer at the [Laravel Notifications
    Channels website](https://oreil.ly/6d4_L).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 想要通过其他渠道发送通知，而不是默认提供的渠道？有一个强大的社区努力提供各种通知渠道的选择；请查看[Laravel通知渠道网站](https://oreil.ly/6d4_L)上提供的内容。
- en: Testing
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Let’s take a look at how to test mail and notifications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何测试邮件和通知。
- en: Mail
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 邮件
- en: 'There are two aspects of our mail we can write assertions against: the mail’s
    content and attributes, and the fact that it was actually triggered to be sent.
    Let’s start with assertions against the mail’s content.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以针对我们的邮件编写两个方面的断言：邮件的内容和属性，以及实际触发发送的事实。让我们从针对邮件内容的断言开始。
- en: Asserting against the mail
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对邮件进行断言
- en: First, we can run assertions against the `envelope()` type data, as you can
    see in [Example 15-23](#asserting_mailable_envelope_data).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以对`envelope()`类型的数据运行断言，就像您在[示例 15-23](#asserting_mailable_envelope_data)中所看到的那样。
- en: Example 15-23\. Asserting against a mailable’s envelope data
  id: totrans-218
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-23\. 针对可邮寄信封数据的断言
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Next, we can run assertions against the contents of the message, as you can
    see in [Example 15-24](#asserting_mailable_contents).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以对消息内容进行断言，正如您在 [示例 15-24](#asserting_mailable_contents) 中所看到的。
- en: Example 15-24\. Asserting against a mailable’s contents
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-24\. 对可邮寄对象的内容进行断言
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We can assert against attachments, as you can see in [Example 15-25](#asserting_mailable_attachments).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对附件进行断言，正如您在 [示例 15-25](#asserting_mailable_attachments) 中所看到的。
- en: Example 15-25\. Asserting against mailable attachments
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-25\. 对可邮寄对象的附件进行断言
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Asserting whether the mail was sent
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断言邮件是否已发送
- en: To test what mail was (or wasn’t) sent, we’ll first want to run `Mail::fake()`
    to capture the mail actions for inspection. Then, we can run our various assertions,
    as you can see in [Example 15-26](#asserting_against_mail_sending).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试邮件是否发送（或未发送），我们首先会运行 `Mail::fake()` 来捕获邮件动作以便检查。然后，我们可以运行各种断言，正如您在 [示例 15-26](#asserting_against_mail_sending)
    中所看到的。
- en: Example 15-26\. Asserting against whether or not mail was sent
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-26\. 对邮件是否已发送进行断言
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Laravel also allows us to pass a closure as the second parameter to these assertions,
    inspecting the emails to make sure they fit what we’re expecting. Take a look
    at [Example 15-27](#examining_email_in_assertions).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 还允许我们将闭包作为这些断言的第二个参数，检查电子邮件以确保它们符合我们的预期。看一看 [示例 15-27](#examining_email_in_assertions)。
- en: Example 15-27\. Examining an email’s properties in assertions
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-27\. 在断言中检查邮件的属性
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can also use `hasCc()`, `hasBcc()`, `hasReplyTo()`, and `hasFrom()`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `hasCc()`、`hasBcc()`、`hasReplyTo()` 和 `hasFrom()`。
- en: Notifications
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知
- en: Laravel provides a built-in set of assertions for testing your notifications.
    [Example 15-28](#asserting_notifications_were_sent) demonstrates.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 提供了一组内置的断言用于测试您的通知。示例 [15-28](#asserting_notifications_were_sent) 示范了这一点。
- en: Example 15-28\. Asserting notifications were sent
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 15-28\. 断言通知已发送
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: TL;DR
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TL;DR
- en: Laravel’s mail and notification features provide simple, consistent interfaces
    to a variety of messaging systems. Laravel’s mail system uses mailables, PHP classes
    that represent emails, to provide a consistent syntax to different mail drivers.
    The notification system makes it easy to build a single notification that can
    be delivered in many different media—​from emails to SMS messages to physical
    postcards.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的邮件和通知功能提供了简单一致的接口，可以连接各种消息系统。Laravel 的邮件系统使用可邮寄对象（mailables），这些是代表电子邮件的
    PHP 类，提供了对不同邮件驱动程序一致的语法。通知系统使得构建一个可以通过多种不同媒介传送的单一通知变得简单，从电子邮件到短信再到实体明信片。
