- en: Chapter 15\. Mail and Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sending an application’s users notifications via email, Slack, SMS, or another
    notification system is a common but surprisingly complex requirement. Laravel’s
    mail and notification features provide consistent APIs that abstract away the
    need to pay too close attention to any particular provider. Just like in [Chapter 14](ch14.html#storage_and_retrieval),
    you’ll write your code once and choose at the configuration level which provider
    you’ll use to send your email or notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Mail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel’s mail functionality is a convenience layer on top of [Symfony Mailer](https://oreil.ly/ceZ3K).
    Out of the box, Laravel comes with drivers for SMTP, Mailgun, Postmark, Amazon
    SES, and Sendmail.
  prefs: []
  type: TYPE_NORMAL
- en: For all of the cloud services, you’ll set your authentication information in
    *config**/services.php*. However, if you take a look, you’ll see there are already
    keys there—and in *config/mail.php*—that allow you to customize your application’s
    mail functionality in *.env* using variables like `MAIL_MAILER` and `MAILGUN_SECRET`.
  prefs: []
  type: TYPE_NORMAL
- en: Basic “Mailable” Mail Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every mail message you’ll send in a modern Laravel app will be an instance of
    a specific PHP class, created to represent each email, called a *mailable*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a mailable, use the `make:mail` Artisan command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15-1](#autogenerated_mailable_PHP_class) shows what that class looks
    like.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-1\. An autogenerated mailable PHP class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You may notice a few similarities between mailables and jobs; this class even
    imports the `Queueable` trait for queuing your mail and the `SerializesModels`
    trait so any Eloquent models you pass to the constructor will be serialized correctly.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this work? The class constructor is the place where you’ll pass
    in any data, and any properties you set as public on your mailable class will
    be available to the template.
  prefs: []
  type: TYPE_NORMAL
- en: In the `envelope()` method, you’ll set configuration details about the mail—sender,
    subject, metadata.
  prefs: []
  type: TYPE_NORMAL
- en: In the `content()` method, you’ll define the content—which view you’re using
    to render, any Markdown contents, and text parameters.
  prefs: []
  type: TYPE_NORMAL
- en: And if you want to attach any files to the mail, you’ll use the `attachments()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Example 15-2](#EX1453) to see how we might update the autogenerated
    mailable for our assignment example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-2\. A sample mailable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Once you’ve created the mailable class, it’s time to send it. First, you create
    an instance of the mailable class, passing in the appropriate data; then, you
    chain `Mail::to($user)->send($mailable)` to send the mail. You can also customize
    some other details of your mail, like the CC and BCC, as part of the inline call
    chain. Take a look at [Example 15-3](#ways_to_send_mailables) to see a few examples.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-3\. How to send mailables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Mail Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mail templates are just like any other template. They can extend other templates,
    use sections, parse variables, contain conditional or looping directives, and
    do anything else you can do in a normal Blade view.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Example 15-4](#EX1409) to see a possible `emails.assignment-created`
    template for [Example 15-2](#EX1453).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-4\. Sample `assignment-created` email template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 15-2](#EX1453), both `$trainer` and `$trainee` are public properties
    on your mailable, which makes them available to the template. Had one of them
    been private, it would not have been available.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to explicitly define which variables are passed to the template,
    you can use the `with` parameter on the `Content` of your mailable, as in [Example 15-5](#customizing_template_variables).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-5\. Customizing the template variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: HTML Versus Plain-Text Emails
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we’ve used the `view` parameter on the `new Content()` instantiation.
    This expects the template we’re referencing to pass back HTML. If you’d like to
    pass a plain-text version, use the `text` parameter to define your plain-text
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Methods Available in envelope()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve already looked at how we can customize the subject and the “from” address
    using the `envelope()` method. Note that the way we’re customizing these is by
    passing different named parameters to the constructor of the `Envelope` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t an exhaustive list, but here is a short list of parameters the `envelope()`
    method allows us to pass to the `Envelope` class to customize our email. Any parameter
    that can accept an `Address` can also accept a string email address or an array
    containing a mixture of `Address` objects and/or strings.
  prefs: []
  type: TYPE_NORMAL
- en: '`from: *Address*`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the “from” name and address—​represents the author
  prefs: []
  type: TYPE_NORMAL
- en: '`subject: *string*`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the email subject
  prefs: []
  type: TYPE_NORMAL
- en: '`cc: *Address*`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the CC
  prefs: []
  type: TYPE_NORMAL
- en: '`bcc: *Address*`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the BCC
  prefs: []
  type: TYPE_NORMAL
- en: '`replyTo: *Address*`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the “reply to”
  prefs: []
  type: TYPE_NORMAL
- en: '`tags: *array*`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the tags, if relevant for your email sender
  prefs: []
  type: TYPE_NORMAL
- en: '`metadata: *array*`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the metadata, if relevant for your email sender
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you want to perform any manual modifications on the underlying Symfony
    message, you can do that in the `using` parameter, as shown in [Example 15-6](#modify_underlying_SymfonyMessage).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-6\. Modifying the underlying `SymfonyMessage` object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Attaching Files and Inlining Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To attach a file to your mail, return an array (in which each entry is an `Attachment`)
    from the `attachments()` method, as shown in [Example 15-7](#attach_files_or_data_to_mailables).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-7\. Attaching files or data to mailables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Attachable mail objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have a PHP class that can be represented as an attachment to an email,
    or if you’d like to build a PHP class full of logic around the objects you attach
    to your emails, you’ll want to try Laravel’s attachable objects.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these objects need only be a PHP class that implements the `Illuminate\Contracts\Mail\Attachable`
    interface, which requires a `toMailAttachment()` method, which returns an instance
    of `Illuminate\Mail\Attachment`.
  prefs: []
  type: TYPE_NORMAL
- en: One common example would be if you want to make one of your Eloquent models
    attachable. In our example, we’ve been emailing our clients about a new assignment
    from their trainer, so let’s try making `Assignment` attachable. Take a look at
    [Example 15-8](#making_model_attachable).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-8\. Making an Eloquent model attachable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If a class implements `Attachable`, you can use any instances of that class
    as entries in the array you return from `attachments()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Inlining images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to attach images inline, directly into your email, Laravel provides
    a feature for that as well, as you can see in [Example 15-9](#inlining_images).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-9\. Inlining images in email
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Markdown Mailables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Markdown mailables allow you to write your email content in Markdown, after
    which it will be converted into full HTML (and plain-text) emails with Laravel’s
    built-in, responsive HTML templates. You can also tweak these templates to make
    a customized email template that’s simple for your developers and nondevelopers
    to create content for.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, run the `make:mail` Artisan command with the `markdown` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can see an example of what the generated mail file looks like in [Example 15-10](#generated_markdown_mailable).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-10\. Generated Markdown mailable
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is almost exactly the same as a normal mailable file in
    Laravel. The main difference is that you’re passing your template into the `markdown`
    parameter instead of the `view` parameter. Also note that the template you’re
    referencing should represent a Markdown template, not a normal Blade template.
  prefs: []
  type: TYPE_NORMAL
- en: What’s a *Markdown template*? Unlike a normal Blade email template, which is
    expected—​with the use of includes and inheritance like any Blade file—​to generate
    a full HTML email, Markdown templates simply pass Markdown content to a few predefined
    components.
  prefs: []
  type: TYPE_NORMAL
- en: These components will look like `<x-mail::component-name-here>`, and, as such,
    the main body of your Markdown email should be passed into a component named `<x-mail::message>`.
    Take a look at [Example 15-11](#simple_assignment_markdown_email) to see an example
    of a simple Markdown mail template.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-11\. Simple assignment Markdown email
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Example 15-11](#simple_assignment_markdown_email), there’s
    a parent `mail::message` component to which you pass the body of your email, but
    you’re also provided with other, smaller components you can sprinkle into your
    emails. We used the `mail::button` component here, which takes the content (“View
    Your Assignment”) but also requires the `url` attribute to be passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of components available:'
  prefs: []
  type: TYPE_NORMAL
- en: Button
  prefs: []
  type: TYPE_NORMAL
- en: Generates a centered button link. The button component requires a `url` attribute
    and allows an optional `color` attribute, to which you can pass `primary`, `success`,
    or `error`.
  prefs: []
  type: TYPE_NORMAL
- en: Panel
  prefs: []
  type: TYPE_NORMAL
- en: Renders the provided text with a slightly lighter background than the rest of
    the message.
  prefs: []
  type: TYPE_NORMAL
- en: Table
  prefs: []
  type: TYPE_NORMAL
- en: Converts the content passed into it via the Markdown table syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These Markdown components are built into the core of the Laravel framework,
    but if you need to customize how they work, you can publish their files and edit
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can learn more about customizing these files and their themes in the [Laravel
    docs](https://oreil.ly/R4Gr9).
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Mailables to the Browser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re developing emails in your applications, it’s helpful to be able
    to preview how they’ll render. You can rely on a tool like Mailtrap for this,
    and that is a useful tool, but it can also be helpful to render the mails directly
    in your browser and see your changes made immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Example 15-12](#rendering_mailables) to see a sample route you
    can add to your application to render a given mailable.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-12\. Rendering a mailable to a route
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Laravel also provides a way to quickly preview a notification in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sending email is a time-consuming task that can cause applications to slow
    down, so it’s common to move it to a background queue. It’s so common, in fact,
    that Laravel has a set of built-in tools to make it easier to queue your messages
    without writing queue jobs for each email:'
  prefs: []
  type: TYPE_NORMAL
- en: '`queue()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To queue a mail object instead of sending it immediately, simply pass your
    mailable object to `Mail::queue()` instead of `Mail::send()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`later()`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mail::later()` works the same as `Mail::queue()`, but it allows you to add
    a delay—​either in minutes or by specifying a specific time by passing an instance
    of `DateTime` or `Carbon`—specifying when the email will be pulled from the queue
    and sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your queues must be configured correctly for these methods to work. Take a look
    at [Chapter 16](ch16.html#queues_jobs_events) to learn more about how queues work
    and how to get them running in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For both `queue()` and `later()`, if you’d like to specify which queue or queue
    connection your mail is added to, use the `onConnection()` and `onQueue()` methods
    on your mailable object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you’d like to direct that a given mailable should always be queued, you can
    make the mailable implement the `Illuminate\Contracts\Queue\ShouldQueue` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Local Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is all well and good for sending mail in your production environments.
    But how do you test it all out? There are two primary tools you’ll want to consider:
    Laravel’s `log` driver and fake inboxes for testing, such as Mailtrap.'
  prefs: []
  type: TYPE_NORMAL
- en: The log driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Laravel provides a `log` driver that logs every email you try to send to your
    local *laravel.log* file (which is, by default, in *storage/logs*).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this, edit *.env* and set `MAIL_MAILER` to `log`. Now open up or tail
    *storage/logs/laravel.log* and send an email from your app. You’ll see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can optionally specify that logged mail gets sent to a different log channel
    than the rest of your logs. Either modify *config/mail.php* or set the `MAIL_LOG_CHANNEL`
    variable in your *.env* file to the name of any existing log channel.
  prefs: []
  type: TYPE_NORMAL
- en: Fake inboxes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to see your test emails as they’ll look in a real inbox, you can
    use one of several services that allow you to send your emails to them and show
    you your emails in a full fake inbox.
  prefs: []
  type: TYPE_NORMAL
- en: The two most common such services are Mailtrap, a paid SaaS that requires no
    setup and allows you to share your inbox with coworkers and clients, and Mailpit,
    a service you can run on your local machine through Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Mailtrap
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[Mailtrap](https://mailtrap.io) is a service for capturing and inspecting emails
    in development environments. You send your mail to the Mailtrap servers via SMTP,
    but instead of sending those emails off to the intended recipients, Mailtrap captures
    them all and provides you with a web-based email client for inspecting them, regardless
    of which email address is in the `to` field.'
  prefs: []
  type: TYPE_NORMAL
- en: To set up Mailtrap, sign up for a free account and visit the base dashboard
    for your demo. Copy your username and password from the SMTP column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then edit your app’s *.env* file and set the following values in the `mail`
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, any email you send from your app will show up in your Mailtrap inbox.
  prefs: []
  type: TYPE_NORMAL
- en: Mailpit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you like the idea of Mailtrap, but you’d like to run the application locally
    (and for free), you can use [Mailpit](https://oreil.ly/dPgRK), a Mailtrap alternative
    you can spin up in a local Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Notifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The purpose of most of the mail that’s sent from web apps is to notify users
    that a particular action has happened or needs to happen. As users’ communication
    preferences grow more and more diverse, we gather ever more—and more disparate—packages
    to communicate via Slack, SMS, and other means.
  prefs: []
  type: TYPE_NORMAL
- en: To support these preferences, Laravel introduced a concept called, fittingly,
    *notifications*. Just like a mailable, a notification is a PHP class that represents
    a single communication that you might want to send to your users. For now, let’s
    imagine we’re notifying the users of our physical training app that they have
    a new workout available.
  prefs: []
  type: TYPE_NORMAL
- en: Each class represents all of the information necessary to send notifications
    to your users *using one or many notification channels*. A single notification
    could send an email, send an SMS via Vonage, send a WebSocket ping, add a record
    to a database, send a message to a Slack channel, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create our notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15-13](#autogenerated_notification_class) shows what that gives us.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-13\. An autogenerated notification class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can learn a few things here. First, we’re going to pass relevant data into
    the constructor. Second, there’s a `via()` method that allows us to define, for
    a given user, which notification channels to use (`$notifiable` represents whatever
    entities you want to notify in your system; for most apps, it’ll be a user, but
    that’s not always the case). And third, there are individual methods for each
    notification channel that allow us to specifically define how to send one of these
    notifications through that channel.
  prefs: []
  type: TYPE_NORMAL
- en: When Would a $notifiable Not Be a User?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the most common notification targets will be users, it’s possible you
    may want to notify something else. This may simply be because your application
    has multiple user types—so, you might want to be able to notify both trainers
    and trainees. But you also might find yourself wanting to notify a group, a company,
    or a server.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s modify this class for our `WorkoutAvailable` example. Take a look
    at [Example 15-14](#EX1419).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-14\. Our `WorkoutAvailable` notification class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Defining the via() Method for Your Notifiables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see in [Example 15-14](#EX1419), we’re responsible for deciding,
    for each notification and each notifiable, which notification channels we’re going
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: You could just send everything as mail or just send everything as an SMS ([Example 15-15](#simplest_via_method)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-15\. Simplest possible `via()` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You could also let each user choose a preferred method and save that on the
    `User` itself ([Example 15-16](#customizing_via_method)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-16\. Customizing the `via()` method per user
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Or, as we imagined in [Example 15-14](#EX1419), you could create a method on
    each notifiable that allows for some complex notification logic. For example,
    you could notify the user over certain channels during work hours and other channels
    in the evening. What is important is that `via()` is a PHP class method, so you
    can do whatever complex logic you want there.
  prefs: []
  type: TYPE_NORMAL
- en: Sending Notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to send a notification: using the `Notification` facade,
    or adding the `Notifiable` trait to an Eloquent class (likely your `User` class).'
  prefs: []
  type: TYPE_NORMAL
- en: Sending notifications using the notification facade
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Notification` facade is the clumsier of the two methods, since you have
    to pass both the notifiable and the notification. However, it’s helpful because
    you can choose to pass more than one notifiable at the same time, as shown in
    [Example 15-17](#EX1417).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-17\. Sending a notification using the `Notification` facade
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Sending notifications using the notifiable trait
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any model that imports the `Laravel\Notifications\Notifiable` trait (which the
    `App\User` class does by default) has a `notify()` method that can be passed a
    notification, which will look like [Example 15-18](#EX1418).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-18\. Sending a notification using the `Notifiable` trait
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Queueing Notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most notification drivers need to use HTTP requests to send notifications, which
    could slow down your user experience. To deal with this you’ll probably want to
    queue your notifications. All notifications import the `Queueable` trait by default,
    so all you need to do is add `implements ShouldQueue` to your notification, and
    Laravel will instantly move it to a queue.
  prefs: []
  type: TYPE_NORMAL
- en: As with any other queued features, you’ll need to make sure you have your queue
    settings configured correctly and a queue worker running.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to delay the delivery of a notification, you can run the `delay()`
    method on the notification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Out-of-the-Box Notification Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Out of the box, Laravel comes with notification drivers for email, database,
    broadcast, Vonage SMS, and Slack. I’ll cover each briefly, but I’d recommend referring
    to the [notifications docs](https://oreil.ly/VzICd) for more thorough introductions
    to each.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also easy to create your own notification drivers, and dozens of people
    already have; you can find them at the [Laravel Notification Channels website](https://oreil.ly/6d4_L).
  prefs: []
  type: TYPE_NORMAL
- en: Email notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at how the email from our earlier example, [Example 15-14](#EX1419),
    is built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The result is shown in [Figure 15-1](#default_notifiation_template). The email
    notification system puts your application’s name in the header of the email; you
    can customize that app name in the `name` key of *config/app.php*.
  prefs: []
  type: TYPE_NORMAL
- en: This email is automatically sent to the `email` property on the notifiable,
    but you can customize this behavior by adding a method to your notifiable class
    named `routeNotificationForMail()` that returns the email address you’d like email
    notifications sent to.
  prefs: []
  type: TYPE_NORMAL
- en: The email’s subject is set by parsing the notification class name and converting
    it to words. So, our `WorkoutAvailable` notification would have the default subject
    of “Workout Available.” You can also customize this by chaining the `subject()`
    method on the `MailMessage` in the `toMail()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to modify the templates, publish them and edit to your heart’s
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![An email sent with with the default notification template](assets/lur3_1501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. An email sent with the default notification template
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Database notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can send notifications to a database table using the `database` notification
    channel. First, create your table with `php artisan notifications:table`. Next,
    create a `toDatabase()` method on your notification and return an array of data
    there. This data will be encoded as JSON and stored in the database table’s `data`
    column.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Notifiable` trait adds a `notifications` relationship to any model it’s
    imported into, allowing you to easily access records in the notifications table.
    So if you’re using database notifications, you could do something like [Example 15-20](#database-notifications):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-20\. Iterating over a user’s database notifications
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The `database` notification channel also has the concept of whether or not
    a notification is “read.” You can scope to only the “unread” notifications as
    shown in [Example 15-21](#unread-notifications):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-21\. Iterating over a user’s unread database notifications
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: And you can mark one or all notifications as read, as [Example 15-22](#marking-read-notifications)
    demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-22\. Marking database notifications as read
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Broadcast notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `broadcast` channel sends notifications using Laravel’s event broadcasting
    features, which are powered by WebSockets (we’ll learn more about these in [“Broadcasting
    Events Over WebSockets, and Laravel Echo”](ch16.html#broadcasting_events)).
  prefs: []
  type: TYPE_NORMAL
- en: Create a `toBroadcast()` method on your notification and return an array of
    data. If your app is correctly configured for event broadcasting, that data will
    be broadcast on a private channel named `*notifiable.id*`. The `*id*` will be
    the ID of the notifiable, and `*notifiable*` will be the notifiable’s fully qualified
    class name, with the slashes replaced by periods—​for example, the private channel
    for the `App\User` with the ID of `1` will be `App.User.1`.
  prefs: []
  type: TYPE_NORMAL
- en: SMS notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SMS notifications are sent via [Vonage](https://www.vonage.com), so if you want
    to send SMS notifications, sign up for a Vonage account and follow the instructions
    in the [notifications docs](https://oreil.ly/VzICd). Like with the other channels,
    you’ll be setting up a `toVonage()` method and customizing the SMS message there.
  prefs: []
  type: TYPE_NORMAL
- en: SMS Notification Package Install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Laravel, the SMS notification channel is a first-party package. If you want
    to use Vonage SMS notifications, simply require this package with Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Slack notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `slack` notification channel allows you to customize the appearance of your
    notifications and even attach files to them. As with the other channels, you’ll
    set up a `toSlack()` method and customize the message there.
  prefs: []
  type: TYPE_NORMAL
- en: Slack Notification Package Install
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Laravel’s Slack notification channel is a first-party package. If you want
    to use Slack notifications, simply require this package with Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Other notifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Looking to send your notifications through other channels than those that come
    out of the box? There’s a robust community effort to provide an incredible variety
    of notification channels; check out what’s on offer at the [Laravel Notifications
    Channels website](https://oreil.ly/6d4_L).
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take a look at how to test mail and notifications.
  prefs: []
  type: TYPE_NORMAL
- en: Mail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two aspects of our mail we can write assertions against: the mail’s
    content and attributes, and the fact that it was actually triggered to be sent.
    Let’s start with assertions against the mail’s content.'
  prefs: []
  type: TYPE_NORMAL
- en: Asserting against the mail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we can run assertions against the `envelope()` type data, as you can
    see in [Example 15-23](#asserting_mailable_envelope_data).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-23\. Asserting against a mailable’s envelope data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Next, we can run assertions against the contents of the message, as you can
    see in [Example 15-24](#asserting_mailable_contents).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-24\. Asserting against a mailable’s contents
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We can assert against attachments, as you can see in [Example 15-25](#asserting_mailable_attachments).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-25\. Asserting against mailable attachments
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Asserting whether the mail was sent
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To test what mail was (or wasn’t) sent, we’ll first want to run `Mail::fake()`
    to capture the mail actions for inspection. Then, we can run our various assertions,
    as you can see in [Example 15-26](#asserting_against_mail_sending).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-26\. Asserting against whether or not mail was sent
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Laravel also allows us to pass a closure as the second parameter to these assertions,
    inspecting the emails to make sure they fit what we’re expecting. Take a look
    at [Example 15-27](#examining_email_in_assertions).
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-27\. Examining an email’s properties in assertions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `hasCc()`, `hasBcc()`, `hasReplyTo()`, and `hasFrom()`.
  prefs: []
  type: TYPE_NORMAL
- en: Notifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel provides a built-in set of assertions for testing your notifications.
    [Example 15-28](#asserting_notifications_were_sent) demonstrates.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-28\. Asserting notifications were sent
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: TL;DR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel’s mail and notification features provide simple, consistent interfaces
    to a variety of messaging systems. Laravel’s mail system uses mailables, PHP classes
    that represent emails, to provide a consistent syntax to different mail drivers.
    The notification system makes it easy to build a single notification that can
    be delivered in many different media—​from emails to SMS messages to physical
    postcards.
  prefs: []
  type: TYPE_NORMAL
