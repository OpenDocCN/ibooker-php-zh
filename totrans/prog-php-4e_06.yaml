- en: Chapter 5\. Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。数组
- en: 'As we discussed in [Chapter 2](ch02.xhtml#language_basics), PHP supports both
    scalar and compound data types. In this chapter, we’ll discuss one of the compound
    types: arrays. An *array* is a collection of data values organized as an ordered
    collection of key-value pairs. It may help to think of an array, in loose terms,
    like an egg carton. Each compartment of an egg carton can hold an egg, but it
    travels around as one overall container. And, just as an egg carton doesn’t have
    to contain only eggs (you can put anything in there, like rocks, snowballs, four-leaf
    clovers, or nuts and bolts), so too an array is not limited to one type of data.
    It can hold strings, integers, Booleans, and so on. Plus, array compartments can
    also contain other arrays—but more on that later.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 2 章](ch02.xhtml#language_basics)中讨论的那样，PHP 支持标量和复合数据类型。在本章中，我们将讨论复合类型之一：数组。*数组*是一组按键值对组织的数据值的有序集合。可能有助于以宽泛的术语来思考数组，就像一个鸡蛋盒一样。鸡蛋盒的每个隔间可以容纳一个鸡蛋，但它整体上作为一个容器运行。而且，正如鸡蛋盒不仅仅可以装鸡蛋（您可以放入任何东西，比如石头、雪球、四叶草或螺丝和螺母），数组也不限于一种数据类型。它可以包含字符串、整数、布尔值等。另外，数组隔间也可以包含其他数组——但稍后再详细介绍。
- en: This chapter talks about creating an array, adding and removing elements from
    an array, and looping over the contents of an array. Because arrays are very common
    and useful, there are many built-in functions that work with them in PHP. For
    example, if you want to send email to more than one email address, you’ll store
    the email addresses in an array and then loop through the array, sending the message
    to the current email address. Also, if you have a form that permits multiple selections,
    the items the user selected are returned in an array.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论创建数组、向数组中添加和删除元素以及遍历数组内容。由于数组非常常见和有用，因此在 PHP 中有许多内置函数与数组一起使用。例如，如果您要向多个电子邮件地址发送电子邮件，则将电子邮件地址存储在数组中，然后通过数组循环，将消息发送到当前电子邮件地址。此外，如果您有一个允许多个选择的表单，用户选择的项目将以数组形式返回。
- en: Indexed Versus Associative Arrays
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引数组与关联数组
- en: 'There are two kinds of arrays in PHP: indexed and associative. The keys of
    an *indexed* array are integers, beginning at 0\. Indexed arrays are used when
    you identify things by their position. *Associative* arrays have strings as keys
    and behave more like two-column tables. The first column is the key, which is
    used to access the value.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中有两种类型的数组：索引数组和关联数组。*索引*数组的键是整数，从 0 开始。当您通过它们的位置来标识事物时使用索引数组。*关联*数组的键是字符串，更像是双列表。第一列是键，用于访问值。
- en: PHP internally stores all arrays as associative arrays; the only difference
    between associative and indexed arrays is what the keys happen to be. Some array
    features are provided mainly for use with indexed arrays because they assume that
    you have or want keys that are consecutive integers beginning at 0\. In both cases,
    the keys are unique. In other words, you can’t have two elements with the same
    key, regardless of whether the key is a string or an integer.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 内部将所有数组存储为关联数组；关联数组与索引数组之间的唯一区别在于键。某些数组特性主要用于与索引数组一起使用，因为它们假设您具有或希望键是从 0
    开始的连续整数。在两种情况下，键都是唯一的。换句话说，无论键是字符串还是整数，您都不能具有两个具有相同键的元素。
- en: PHP arrays have an internal order to their elements that is independent of the
    keys and values, and there are functions that you can use to traverse the arrays
    based on this internal order. The order is normally that in which values were
    inserted into the array, but the sorting functions described later in this chapter
    let you change the order to one based on keys, values, or anything else you choose.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 数组对其元素有内部顺序，这与键和值无关，并且有函数可用于根据此内部顺序遍历数组。顺序通常是插入到数组中的值的顺序，但是本章后面描述的排序函数允许您根据键、值或任何其他选择更改顺序。
- en: Identifying Elements of an Array
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别数组元素
- en: 'Before we look at creating an array, let’s look at the structure of an existing
    array. You can access specific values from an existing array using the array variable’s
    name, followed by the element’s key, or *index*, within square brackets:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论创建数组之前，让我们先看看现有数组的结构。您可以使用数组变量的名称访问现有数组中的特定值，后跟元素的键（或*索引*），放在方括号内：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The key can be either a string or an integer. String values that are equivalent
    to integer numbers (without leading zeros) are treated as integers. Thus, `$array[3]`
    and `$array['3']` reference the same element, but `$array['03']` references a
    different element. Negative numbers are valid keys, but they don’t specify positions
    from the end of the array as they do in Perl.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 键可以是字符串或整数。与整数数字等效的字符串值（没有前导零）被视为整数。因此，`$array[3]`和`$array['3']`引用相同的元素，但`$array['03']`引用不同的元素。负数是有效的键，但它们不像在Perl中那样指定数组末尾的位置。
- en: 'You don’t have to quote single-word strings. For instance, `$age[''fred'']`
    is the same as `$age[fred]`. However, it’s considered good PHP style to always
    use quotes, because quoteless keys are indistinguishable from constants. When
    you use a constant as an unquoted index, PHP uses the value of the constant as
    the index and emits a warning. This will throw an error in future versions of
    PHP:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您不必引用单词字符串。例如，`$age['fred']`与`$age[fred]`相同。然而，始终使用引号被认为是良好的PHP风格，因为没有引号的键与常量无法区分。当您使用常量作为未引用的索引时，PHP使用常量的值作为索引并发出警告。这在未来版本的PHP中将抛出错误：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You must use quotes if you’re using interpolation to build the array index:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用插值构建数组索引，则必须使用引号：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although it’s technically optional, you should also quote the key if you’re
    interpolating an array lookup to ensure that you get the value you expect. Consider
    this example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在插入数组查找中插入数组时理论上是可选的，但应该用引号引起键，以确保获取您期望的值。考虑以下例子：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Storing Data in Arrays
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在数组中存储数据
- en: 'Storing a value in an array will create the array if it doesn’t already exist,
    but trying to retrieve a value from an array that hasn’t been defined won’t create
    the array. For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 将值存储在数组中将创建数组（如果尚不存在），但尝试从尚未定义的数组中检索值将不会创建数组。例如：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Using simple assignment to initialize an array in your program can lead to
    code like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用简单的赋值在程序中初始化数组可能会导致这样的代码：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That’s an indexed array, with integer indices beginning at 0\. Here’s an associative
    array:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个索引数组，其整数索引从0开始。以下是一个关联数组：
- en: '[PRE6]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'An easier way to initialize an array is to use the `array()` construct, which
    builds an array from its arguments. This builds an indexed array, and the index
    values (starting at 0) are created automatically:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化数组的更简单的方法是使用`array()`结构，该结构从其参数构建数组。这将构建一个索引数组，并且索引值（从0开始）会自动创建：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To create an associative array with `array()`, use the `=>` symbol to separate
    indices (keys) from values:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`array()`创建一个关联数组，请使用`=>`符号将索引（键）与值分开：
- en: '[PRE8]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice the use of whitespace and alignment. We could have bunched up the code,
    but it wouldn’t have been as easy to read (this is equivalent to the previous
    code sample), or as easy to add or remove values:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意使用空白和对齐。我们本可以将代码挤在一起，但那样不容易阅读（这相当于之前的代码示例），也不容易添加或移除值：
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can also specify an array using a shorter, alternate syntax:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用较短的备选语法指定数组：
- en: '[PRE10]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To construct an empty array, pass no arguments to `array()`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个空数组，请将`array()`不传递参数：
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can specify an initial key with `=>` and then a list of values. The values
    are inserted into the array starting with that key, with subsequent values having
    sequential keys:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`=>`指定初始键，然后列出值的列表。从该键开始将值插入数组，随后的值具有顺序键：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the initial index is a non-numeric string, subsequent indices are integers
    beginning at 0\. Thus, the following code is probably a mistake:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果初始索引是非数字字符串，则随后的索引从0开始为整数。因此，以下代码可能是一个错误：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Appending Values to an Array
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数组附加值
- en: 'To add more values to the end of an existing indexed array, use the `[]` syntax:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要在现有索引数组的末尾添加更多值，请使用`[]`语法：
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This construct assumes the array’s indices are numbers and assigns elements
    into the next available numeric index, starting from 0\. Attempting to append
    to an associative array without appropriate keys is almost always a programmer
    mistake, but PHP will give the new elements numeric indices without issuing a
    warning:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构假定数组的索引是数字，并从0开始为下一个可用的数值索引分配元素。试图追加到关联数组而没有适当的键几乎总是程序员的错误，但PHP会为新元素分配数值索引而不发出警告：
- en: '[PRE15]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Assigning a Range of Values
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分配数值范围
- en: 'The `range()` function creates an array of consecutive integer or character
    values between and including the two values you pass to it as arguments. For example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`range()`函数创建一个包含在两个参数中传递的连续整数或字符值之间的数组。例如：'
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Only the first letter of a string argument is used to build the range:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用字符串参数的第一个字母来构建范围：
- en: '[PRE17]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Getting the Size of an Array
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取数组的大小
- en: 'The `count()` and `sizeof()` functions are identical in use and effect. They
    return the number of elements in the array. There is no stylistic preference about
    which function you use. Here’s an example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`和`sizeof()`函数在使用和效果上是相同的。它们返回数组中的元素数。对于使用哪个函数，没有风格上的偏好。这里有一个例子：'
- en: '[PRE18]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This function counts only array values that are actually set:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅计算实际设置的数组值：
- en: '[PRE19]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Padding an Array
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充数组
- en: To create an array with values initialized to the same content, use `array_pad()`.
    The first argument to `array_pad()` is the array, the second argument is the minimum
    number of elements you want the array to have, and the third argument is the value
    to give any elements that are created. The `array_pad()` function returns a new
    padded array, leaving its argument (source) array alone.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个值初始化为相同内容的数组，请使用`array_pad()`。`array_pad()`的第一个参数是数组，第二个参数是您希望数组具有的最小元素数，第三个参数是要赋予创建的任何元素的值。`array_pad()`函数返回一个新的填充数组，保留其参数（源）数组不变。
- en: 'Here’s `array_pad()` in action:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`array_pad()`的示例：
- en: '[PRE20]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice how the new values are appended to the array. If you want the new values
    added to the start of the array, use a negative second argument:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新值如何附加到数组中。如果要将新值添加到数组的开头，请使用负的第二个参数：
- en: '[PRE21]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you pad an associative array, existing keys will be preserved. New elements
    will have numeric keys starting at 0.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果填充关联数组，则现有键将被保留。新元素将具有从0开始的数值键。
- en: Multidimensional Arrays
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维数组
- en: 'The values in an array can themselves be arrays. This lets you easily create
    multidimensional arrays:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的值本身可以是数组。这使您可以轻松创建多维数组：
- en: '[PRE22]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can refer to elements of multidimensional arrays by appending more square
    brackets, `[]`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过追加更多方括号`[]`来引用多维数组的元素：
- en: '[PRE23]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To interpolate a lookup of a multidimensional array, you must enclose the entire
    array lookup in curly braces:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入多维数组的查找，必须将整个数组查找括在花括号中：
- en: '[PRE24]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Failing to use the curly braces results in output like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未使用花括号，则输出如下所示：
- en: '[PRE25]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Extracting Multiple Values
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提取多个值
- en: 'To copy all of an array’s values into variables, use the `list()` construct:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数组的所有值复制到变量中，请使用`list()`结构：
- en: '[PRE26]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The array’s values are copied into the listed variables in the array’s internal
    order. By default that’s the order in which they were inserted, but the sort functions
    described later let you change that. Here’s an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的值按照数组的内部顺序复制到列出的变量中。默认情况下，这是它们插入的顺序，但后面描述的排序函数可以改变这个顺序。这里有一个例子：
- en: '[PRE27]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'The use of the `list()` function is a common practice for picking up values
    from a database selection where only one row is returned. This automatically loads
    the data from the simple query into a series of local variables. Here is an example
    of selecting two opposing teams from a sports scheduling database:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`list()`函数是从数据库选择中获取值的常见做法，其中仅返回一行。这自动将来自简单查询的数据加载到一系列本地变量中。这里是从体育赛程数据库中选择两支对立队伍的示例：
- en: '[PRE28]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There is more coverage on databases in [Chapter 9](ch09.xhtml#databases-id00007).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.xhtml#databases-id00007)中有更多关于数据库的覆盖内容。
- en: 'If you have more values in the array than in the `list()`, the extra values
    are ignored:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在数组中有比`list()`中更多的值，则额外的值将被忽略：
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If you have more values in the `list()` than in the array, the extra values
    are set to `NULL`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在`list()`中有比数组中更多的值，额外的值将被设置为`NULL`：
- en: '[PRE30]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Two or more consecutive commas in the `list()` skip values in the array:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`list()`中的两个或多个连续逗号会跳过数组中的值：'
- en: '[PRE31]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Slicing an Array
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片数组
- en: 'To extract only a subset of the array, use the `array_slice()` function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅提取数组的子集，请使用`array_slice()`函数：
- en: '[PRE32]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The `array_slice()` function returns a new array consisting of a consecutive
    series of values from the original array. The *offset* parameter identifies the
    initial element to copy (`0` represents the first element in the array), and the
    *length* parameter identifies the number of values to copy. The new array has
    consecutive numeric keys starting at 0\. For example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_slice()`函数返回一个由原始数组中一系列连续值组成的新数组。*offset*参数标识要复制的初始元素（`0`表示数组中的第一个元素），*length*参数标识要复制的值的数量。新数组从0开始具有连续的数值键。例如：'
- en: '[PRE33]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It is generally only meaningful to use `array_slice()` on indexed arrays (i.e.,
    those with consecutive integer indices starting at 0):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常只有在索引数组上使用`array_slice()`才有意义（即具有从0开始的连续整数索引）：
- en: '[PRE34]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Combine `array_slice()` with `list()` to extract only some values to variables:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`array_slice()`和`list()`结合在变量中提取部分数值：
- en: '[PRE35]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Splitting an Array into Chunks
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数组拆分成块
- en: 'To divide an array into smaller, evenly sized arrays, use the `array_chunk()`
    function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要将数组分成较小的、均匀大小的数组，请使用`array_chunk()`函数：
- en: '[PRE36]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The function returns an array of the smaller arrays. The third argument, *preserve_keys*,
    is a Boolean value that determines whether the elements of the new arrays have
    the same keys as in the original (useful for associative arrays) or new numeric
    keys starting from 0 (useful for indexed arrays). The default is to assign new
    keys, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回较小数组的数组。第三个参数*preserve_keys*是一个布尔值，用于确定新数组的元素是否与原始数组中的相同键（对关联数组有用）或从0开始的新数字键（对索引数组有用）。默认情况下分配新键，如下所示：
- en: '[PRE37]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Keys and Values
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 键和值
- en: 'The `array_keys()` function returns an array consisting of only the keys in
    the array in internal order:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_keys()`函数按照数组内部顺序返回仅包含键的数组：'
- en: '[PRE38]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Here’s an example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE39]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'PHP also provides a (generally less useful) function to retrieve an array of
    just the values in an array, `array_values()`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: PHP还提供了一个（通常不太有用的）函数来获取数组中仅包含值的数组，即`array_values()`：
- en: '[PRE40]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As with `array_keys()`, the values are returned in the array’s internal order:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与`array_keys()`类似，值按照数组的内部顺序返回：
- en: '[PRE41]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Checking Whether an Element Exists
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查元素是否存在
- en: 'To see if an element exists in the array, use the `array_key_exists()` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看数组中是否存在元素，请使用`array_key_exists()`函数：
- en: '[PRE42]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The function returns a Boolean value that indicates whether the first argument
    is a valid key in the array given as the second argument.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个布尔值，指示第一个参数是否是作为第二个参数给出的数组中的有效键。
- en: 'It’s not sufficient to simply say:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地说：
- en: '[PRE43]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Even if there is an element in the array with the key `name`, its corresponding
    value might be false (i.e., `0`, `NULL`, or the empty string). Instead, use `array_key_exists()`,
    as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 即使数组中有一个键为`name`的元素，其对应的值可能为false（即`0`，`NULL`或空字符串）。请改用`array_key_exists()`，如下所示：
- en: '[PRE44]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Many people use the `isset()` function instead, which returns `true` if the
    element exists and is not `NULL`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人改用`isset()`函数，如果元素存在且不为`NULL`，则返回`true`：
- en: '[PRE45]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Removing and Inserting Elements in an Array
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数组中删除和插入元素
- en: 'The `array_splice()` function can remove or insert elements in an array and
    optionally create another array from the removed elements:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_splice()`函数可以从数组中删除或插入元素，并可选择从已删除元素创建另一个数组：'
- en: '[PRE46]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We’ll look at `array_splice()` using this array:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个数组查看`array_splice()`：
- en: '[PRE47]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We can remove the `"math"`, `"bio"`, and `"cs"` elements by telling `array_splice()`
    to start at position 2 and remove 3 elements:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过告诉`array_splice()`从位置2开始删除3个元素来删除`"math"`、`"bio"`和`"cs"`元素：
- en: '[PRE48]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If you omit the length, `array_splice()` removes to the end of the array:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略长度，`array_splice()`将删除到数组的末尾：
- en: '[PRE49]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you simply want to delete elements from the source array and you don’t care
    about retaining their values, you don’t need to store the results of `array_splice()`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想从源数组中删除元素，并且不关心保留它们的值，则不需要存储`array_splice()`的结果：
- en: '[PRE50]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To insert elements where others were removed, use the fourth argument:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要在移除其他元素的位置插入元素，请使用第四个参数：
- en: '[PRE51]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The size of the replacement array doesn’t have to be the same as the number
    of elements you delete. The array grows or shrinks as needed:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 替换数组的大小不必与删除元素的数量相同。数组会根据需要增长或缩小：
- en: '[PRE52]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'To insert new elements into the array while pushing existing elements to the
    right, delete zero elements:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入新元素到数组中，并将现有元素推向右侧，请删除零个元素：
- en: '[PRE53]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Although the examples so far have used an indexed array, `array_splice()` also
    works on associative arrays:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止的示例使用的是索引数组，`array_splice()`也适用于关联数组：
- en: '[PRE54]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Converting Between Arrays and Variables
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数组和变量之间的转换
- en: PHP provides two functions, `extract()` and `compact()`, that convert between
    arrays and variables. The names of the variables correspond to keys in the array,
    and the values of the variables become the values in the array. For instance,
    this array
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了两个函数`extract()`和`compact()`，用于在数组和变量之间进行转换。变量的名称对应于数组中的键，变量的值成为数组中的值。例如，这个数组
- en: '[PRE55]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'can be converted to, or built from, these variables:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 可以转换或从这些变量构建：
- en: '[PRE56]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Creating Variables from an Array
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组创建变量
- en: 'The `extract()` function automatically creates local variables from an array.
    The indices of the array elements become the variable names:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`extract()` 函数会自动从数组中创建局部变量。数组元素的索引成为变量名：'
- en: '[PRE57]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: If a variable created by the extraction has the same name as an existing one,
    the existing variable’s value is overwritten with the one from the array.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由提取创建的变量与现有变量同名，则现有变量的值将被数组中的值覆盖。
- en: 'You can modify `extract()`’s behavior by passing a second argument. The [Appendix](app01.xhtml#function_reference)
    describes the possible values for this second argument. The most useful value
    is `EXTR_PREFIX_ALL`, which indicates that the third argument to `extract()` is
    a prefix for the variable names that are created. This helps ensure that you create
    unique variable names when you use `extract()`. It is good PHP style to always
    use `EXTR_``PREFIX_ALL`, as shown here:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过传递第二个参数来修改 `extract()` 的行为。[附录](app01.xhtml#function_reference) 描述了此第二个参数可能的取值。最有用的值是
    `EXTR_PREFIX_ALL`，它指示 `extract()` 的第三个参数是在使用 `extract()` 时创建的变量名称的前缀。这有助于确保在使用
    `extract()` 时创建唯一的变量名称。在PHP中，始终使用 `EXTR_PREFIX_ALL` 是良好的编程风格，如下所示：
- en: '[PRE58]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Creating an Array from Variables
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从变量创建数组
- en: 'The `compact()` function is the reverse of `extract()`; you pass it the variable
    names to compact either as separate parameters or in an array. The `compact()`
    function creates an associative array whose keys are the variable names and whose
    values are the variable’s values. Any names in the array that do not correspond
    to actual variables are skipped. Here’s an example of `compact()` in action:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`compact()` 函数是 `extract()` 函数的反向操作；你可以将变量名作为单独的参数或者作为数组传递给 `compact()`。`compact()`
    函数创建一个关联数组，其键是变量名，值是变量的值。数组中未对应实际变量的名称将被跳过。以下是 `compact()` 的示例：'
- en: '[PRE59]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Traversing Arrays
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历数组
- en: The most common task with arrays is to do something with every element—for instance,
    sending mail to each element of an array of addresses, updating each file in an
    array of filenames, or adding up each element of an array of prices. There are
    several ways to traverse arrays in PHP, and the one you choose will depend on
    your data and the task you’re performing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数组中每个元素的最常见任务是执行某些操作，例如向地址数组中的每个元素发送邮件，更新文件名数组中的每个文件，或者将价格数组中的每个元素相加。在PHP中，有几种遍历数组的方法，你选择的方法将取决于你的数据和正在执行的任务。
- en: The foreach Construct
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`foreach` 结构'
- en: 'The most common way to loop over elements of an array is to use the `foreach`
    construct:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历数组元素的最常见方法是使用 `foreach` 结构：
- en: '[PRE60]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: PHP executes the body of the loop (the `echo` statement) once for each element
    of `$addresses` in turn, with `$value` set to the current element. Elements are
    processed by their internal order.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: PHP依次对`$addresses`数组中的每个元素执行循环体（`echo`语句），其中将`$value`设置为当前元素。元素按其内部顺序处理。
- en: 'An alternative form of `foreach` gives you access to the current key:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`的另一种形式允许你访问当前键：'
- en: '[PRE61]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this case, the key for each element is placed in `$key` and the corresponding
    value is placed in `$value`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每个元素的键都放在`$key`中，相应的值放在`$value`中。
- en: The `foreach` construct does not operate on the array itself, but rather on
    a copy of it. You can insert or delete elements in the body of a `foreach` loop,
    safe in the knowledge that the loop won’t attempt to process the deleted or inserted
    elements.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`结构不会在数组本身上操作，而是在其副本上操作。你可以在`foreach`循环的主体中插入或删除元素，安全地知道循环不会尝试处理已删除或已插入的元素。'
- en: The Iterator Functions
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代器函数
- en: 'Every PHP array keeps track of the current element you’re working with; the
    pointer to the current element is known as the *iterator*. PHP has functions to
    set, move, and reset this iterator. The iterator functions are:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个PHP数组都会跟踪你正在处理的当前元素；指向当前元素的指针称为*迭代器*。PHP具有设置、移动和重置此迭代器的函数。迭代器函数包括：
- en: '`current()`'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`current()`'
- en: Returns the element currently pointed at by the iterator.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 返回迭代器当前指向的元素。
- en: '`reset()`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset()`'
- en: Moves the iterator to the first element in the array and returns it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器移动到数组中的第一个元素并返回它。
- en: '`next()`'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`'
- en: Moves the iterator to the next element in the array and returns it.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器移动到数组中的下一个元素并返回它。
- en: '`prev()`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`prev()`'
- en: Moves the iterator to the previous element in the array and returns it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器移动到数组中的上一个元素并返回它。
- en: '`end()`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`end()`'
- en: Moves the iterator to the last element in the array and returns it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器移动到数组中的最后一个元素并返回它。
- en: '`each()`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`each()`'
- en: Returns the key and value of the current element as an array and moves the iterator
    to the next element in the array.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前元素的键和值作为数组，并将迭代器移动到数组的下一个元素。
- en: '`key()`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`key()`'
- en: Returns the key of the current element.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 返回当前元素的键。
- en: 'The `each()` function is used to loop over the elements of an array. It processes
    elements according to their internal order:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`each()`函数用于遍历数组元素。它根据它们的内部顺序处理元素：'
- en: '[PRE62]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This approach does not make a copy of the array, as `foreach` does. This is
    useful for very large arrays when you want to conserve memory.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不像`foreach`那样制作数组的副本。当处理非常大的数组并希望节省内存时，这非常有用。
- en: The iterator functions are useful when you need to consider some parts of the
    array separately from others. [Example 5-1](#example_five_onedot_building_a_table_wi)
    shows code that builds a table, treating the first index and value in an associative
    array as table column headings.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要将数组的一些部分与其他部分分开考虑时，迭代函数非常有用。[示例 5-1](#example_five_onedot_building_a_table_wi)
    展示了构建表格的代码，将关联数组中的第一个索引和值视为表格列标题。
- en: Example 5-1\. Building a table with the iterator functions
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 使用迭代函数构建表格
- en: '[PRE63]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using a for Loop
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`for`循环
- en: If you know that you are dealing with an indexed array, where the keys are consecutive
    integers beginning at 0, you can use a `for` loop to count through the indices.
    The `for` loop operates on the array itself, not on a copy of the array, and processes
    elements in key order regardless of their internal order.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你知道你在处理一个索引数组，其中键是从0开始的连续整数，你可以使用`for`循环通过索引计数。`for`循环作用于数组本身，而不是数组的副本，并且按键顺序处理元素，而不考虑它们的内部顺序。
- en: 'Here’s how to print an array using `for`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何使用`for`打印一个数组：
- en: '[PRE64]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Calling a Function for Each Array Element
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为每个数组元素调用函数
- en: 'PHP provides a mechanism, `array_walk()`, for calling a user-defined function
    once per element in an array:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了一种机制，`array_walk()`，用于在数组中的每个元素上调用用户定义的函数一次：
- en: '[PRE65]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The function you define takes in two or, optionally, three arguments: the first
    is the element’s value, the second is the element’s key, and the third is a value
    supplied to `array_walk()` when it is called. For instance, here’s another way
    to print table columns made of the values from an array:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您定义的函数接受两个或可选的三个参数：第一个是元素的值，第二个是元素的键，第三个是在调用`array_walk()`时提供给它的值。例如，这里是另一种从数组值打印表列的方法：
- en: '[PRE66]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A variation of this example specifies a background color using the optional
    third argument to `array_walk()`. This parameter gives us the flexibility we need
    to print many tables, with many background colors:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的变体使用`array_walk()`的可选第三个参数指定背景颜色。此参数为我们提供了打印许多带有不同背景颜色表格的灵活性：
- en: '[PRE67]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'If you have multiple options you want to pass into the called function, simply
    pass an array in as a third parameter:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个选项要传递给调用函数，只需将数组作为第三个参数传递：
- en: '[PRE68]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `array_walk()` function processes elements in their internal order.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_walk()`函数按其内部顺序处理元素。'
- en: Reducing an Array
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少数组
- en: 'A cousin of `array_walk()`, `array_reduce()` applies a function to each element
    of the array in turn, to build a single value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_reduce()`的衍生函数，`array_walk()`将函数依次应用于数组的每个元素，以构建单个值：'
- en: '[PRE69]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The function takes two arguments: the running total, and the current value
    being processed. It should return the new running total. For instance, to add
    up the squares of the values of an array, use:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 函数接受两个参数：运行总数和当前正在处理的值。它应该返回新的运行总数。例如，要计算数组值的平方和，使用：
- en: '[PRE70]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `array_reduce()` line makes these function calls:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_reduce()`行执行以下函数调用：'
- en: '[PRE71]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The *default* argument, if provided, is a seed value. For instance, if we change
    the call to `array_reduce()` in the previous example to:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了*default*参数，则它是一个种子值。例如，如果我们将前面示例中`array_reduce()`的调用更改为：
- en: '[PRE72]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The resulting function calls are:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的函数调用如下：
- en: '[PRE73]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If the array is empty, `array_reduce()` returns the *default* value. If no default
    value is given and the array is empty, `array_reduce()` returns `NULL`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组为空，`array_reduce()`返回*default*值。如果没有提供默认值并且数组为空，则`array_reduce()`返回`NULL`。
- en: Searching for Values
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搜索值
- en: 'The `in_array()` function returns `true` or `false`, depending on whether the
    first argument is an element in the array given as the second argument:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`in_array()`函数根据第一个参数是否是作为第二个参数给出的数组中的元素返回`true`或`false`：'
- en: '[PRE74]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If the optional third argument is `true`, the types of *to_find* and the value
    in the array must match. The default is to not check the data types.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可选的第三个参数为`true`，*to_find*的类型和数组中的值必须匹配。默认情况下不检查数据类型。
- en: 'Here’s a simple example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE75]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: PHP automatically indexes the values in arrays, so `in_array()` is generally
    much faster than a loop checking every value in the array to find the one you
    want.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 自动索引数组中的值，因此`in_array()`通常比循环检查数组中每个值来查找您想要的值要快得多。
- en: '[Example 5-2](#example_five_twodot_searching_an_array) checks whether the user
    has entered information in all the required fields in a form.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-2](#example_five_twodot_searching_an_array) 检查用户是否在表单中填写了所有必填字段。'
- en: Example 5-2\. Searching an array
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. 搜索一个数组
- en: '[PRE76]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A variation on `in_array()` is the `array_search()` function. While `in_array()`
    returns `true` if the value is found, `array_search()` returns the key of the
    element, if found:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`in_array()` 的变体是 `array_search()` 函数。`in_array()` 返回值找到时返回`true`，而 `array_search()`
    返回元素的键，如果找到的话：'
- en: '[PRE77]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `array_search()` function also takes the optional third *strict* argument,
    which requires that the types of the value being searched for and the value in
    the array match.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_search()` 函数还接受第三个 *strict* 可选参数，要求被搜索的值的类型和数组中的值匹配。'
- en: Sorting
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序
- en: Sorting changes the internal order of elements in an array and optionally rewrites
    the keys to reflect this new order. For example, you might use sorting to arrange
    a list of scores from biggest to smallest, to alphabetize a list of names, or
    to order a set of users based on how many messages they posted.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 排序改变数组元素的内部顺序，并可选择重写键以反映这种新顺序。例如，您可以使用排序将得分从大到小排列，将姓名按字母顺序排列，或者根据用户发布的消息数量对一组用户进行排序。
- en: PHP provides three ways to sort arrays—sorting by keys, sorting by values without
    changing the keys, or sorting by values and then changing the keys. Each kind
    of sort can be done in ascending order, descending order, or an order determined
    by a user-defined function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了三种排序数组的方式——按键排序、按值排序而不更改键、或按值排序然后更改键。每种排序可以按升序、降序或用户定义的函数确定的顺序进行。
- en: Sorting One Array at a Time
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逐个数组排序
- en: The functions provided by PHP to sort an array are shown in [Table 5-1](#php_functions_for_sorting_an_array).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供的用于对数组排序的函数如 [表格 5-1](#php_functions_for_sorting_an_array) 所示。
- en: Table 5-1\. PHP functions for sorting an array
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 5-1\. PHP 数组排序函数
- en: '| Effect | Ascending | Descending | User-defined order |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 效果 | 升序 | 降序 | 用户定义的顺序 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Sort array by values, then reassign indices starting with 0 | `sort()` |
    `rsort()` | `usort()` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 按值排序数组，然后重新分配从0开始的索引 | `sort()` | `rsort()` | `usort()` |'
- en: '| Sort array by values | `asort()` | `arsort()` | `uasort()` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 按值排序数组 | `asort()` | `arsort()` | `uasort()` |'
- en: '| Sort array by keys | `ksort()` | `krsort()` | `uksort()` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 按键名排序数组 | `ksort()` | `krsort()` | `uksort()` |'
- en: The `sort()`, `rsort()`, and `usort()` functions are designed to work on indexed
    arrays because they assign new numeric keys to represent the ordering. They’re
    useful when you need to answer questions such as “What are the top 10 scores?”
    and “Who’s the third person in alphabetical order?” The other sort functions can
    be used on indexed arrays, but you’ll only be able to access the sorted ordering
    by using traversal constructs such as `foreach` and `next()`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`sort()`、`rsort()` 和 `usort()` 函数设计用于处理索引数组，因为它们分配新的数字键来表示排序。当您需要回答“前十名的得分是多少？”和“按字母顺序第三个是谁？”等问题时，它们非常有用。其他排序函数可以用于索引数组，但只能通过遍历结构（如`foreach`和`next()`）访问排序顺序。'
- en: 'To sort names into ascending alphabetical order, do something like this:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要按升序字母顺序对名称进行排序，请这样做：
- en: '[PRE78]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: To get them in reverse alphabetical order, simply call `rsort()` instead of
    `sort()`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要按照逆字母顺序排列它们，只需调用`rsort()` 而不是 `sort()`。
- en: 'If you have an associative array that maps usernames to minutes of login time,
    you can use `arsort()` to display a table of the top three, as shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个将用户名映射到登录时间分钟数的关联数组，可以使用`arsort()`来显示前三名的表格，如下所示：
- en: '[PRE79]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If you want that table displayed in ascending order by username, use `ksort()`
    instead.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望按用户名升序显示该表格，请改用`ksort()`。
- en: User-defined ordering requires that you provide a function that takes two values
    and returns a value that specifies the order of the two values in the sorted array.
    The function should return `1` if the first value is greater than the second,
    `−1` if the first value is less than the second, and `0` if the values are the
    same for the purposes of your custom sort order.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的排序要求你提供一个函数，该函数接受两个值并返回一个指定排序数组中两个值顺序的值。如果第一个值大于第二个值，函数应返回`1`；如果第一个值小于第二个值，应返回`−1`；如果这两个值对于自定义排序目的相同，则返回`0`。
- en: The program in [Example 5-3](#example_five_threedot_sorting_arrays) applies
    the various sorting functions to the same data.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-3](https://example.org/example_five_threedot_sorting_arrays)中的程序将各种排序函数应用于相同的数据。'
- en: Example 5-3\. Sorting arrays
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-3\. 排序数组
- en: '[PRE80]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Natural-Order Sorting
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自然顺序排序
- en: 'PHP’s built-in sort functions correctly sort strings and numbers, but they
    don’t correctly sort strings that contain numbers. For example, if you have the
    filenames *ex10.php*, *ex5.php*, and *ex1.php*, the normal sort functions will
    rearrange them in this order: *ex1.php*, *ex10.php*, *ex5.php*. To correctly sort
    strings that contain numbers, use the `natsort()` and `natcasesort()` functions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的内置排序函数可以正确排序字符串和数字，但无法正确排序包含数字的字符串。例如，如果你有文件名*ex10.php*、*ex5.php*和*ex1.php*，正常排序函数会以这种顺序重新排列它们：*ex1.php*、*ex10.php*、*ex5.php*。要正确排序包含数字的字符串，请使用`natsort()`和`natcasesort()`函数：
- en: '[PRE81]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Sorting Multiple Arrays at Once
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一次对多个数组进行排序
- en: 'The `array_multisort()` function sorts multiple indexed arrays at once:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_multisort()`函数一次对多个索引数组进行排序：'
- en: '[PRE82]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Pass it a series of arrays and sorting orders (identified by the `SORT_ASC`
    or `SORT_DESC` constants), and it reorders the elements of all the arrays, assigning
    new indices. It is similar to a join operation on a relational database.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一系列数组和排序顺序（由`SORT_ASC`或`SORT_DESC`常量标识），它重新排序所有数组的元素，分配新索引。这类似于关系数据库上的连接操作。
- en: 'Imagine that you have a lot of people, and several pieces of data on each person:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你有很多人，每个人有几个数据片段：
- en: '[PRE83]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The first element of each array represents a single record—all the information
    known about Tom. Similarly, the second element constitutes another record—all
    the information known about Dick. The `array_multisort()` function reorders the
    elements of the arrays, preserving the records. That is, if `"Dick"` ends up first
    in the `$names` array after the sort, the rest of Dick’s information will be first
    in the other arrays too. (Note that we needed to quote Dick’s zip code to prevent
    it from being interpreted as an octal constant.)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数组的第一个元素表示一个单独的记录——关于汤姆的所有已知信息。同样，第二个元素构成另一条记录——关于迪克的所有已知信息。`array_multisort()`函数重新排列数组的元素，保留记录。也就是说，如果在排序后`$names`数组中“迪克”排在第一位，其他数组中关于迪克的信息也将排在第一位。（注意，我们需要引用迪克的邮政编码，以防止它被解释为八进制常量。）
- en: 'Here’s how to sort the records first ascending by age, then descending by zip
    code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何首先按年龄升序，然后按邮政编码降序排序记录的方法：
- en: '[PRE84]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We need to include `$names` in the function call to ensure that Dick’s name
    stays with his age and zip code. Printing out the data shows the result of the
    sort:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在函数调用中包含`$names`，以确保迪克的姓名与他的年龄和邮政编码一起。打印出数据将显示排序结果：
- en: '[PRE85]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Reversing Arrays
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颠倒数组
- en: 'The `array_reverse()` function reverses the internal order of elements in an
    array:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_reverse()`函数颠倒数组中元素的内部顺序：'
- en: '[PRE86]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Numeric keys are renumbered starting at 0, while string indices are unaffected.
    In general, it’s better to use the reverse-order sorting functions instead of
    sorting and then reversing the order of an array.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 数字键从0开始重新编号，而字符串索引不受影响。总的来说，最好使用反序排序函数而不是先排序，然后反转数组的顺序。
- en: 'The `array_flip()` function returns an array that reverses the order of each
    original element’s key-value pair:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_flip()`函数返回一个数组，反转每个原始元素的键值对的顺序：'
- en: '[PRE87]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'That is, for each element of the array whose value is a valid key, the element’s
    value becomes its key and the element’s key becomes its value. For example, if
    you have an array that maps usernames to home directories, you can use `array_flip()`
    to create an array that maps home directories to usernames:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数组中的每个元素，其值是有效键的情况下，元素的值变成其键，元素的键变成其值。例如，如果你有一个将用户名映射到主目录的数组，你可以使用`array_flip()`创建一个将主目录映射到用户名的数组：
- en: '[PRE88]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Elements whose original values are neither strings nor integers are left alone
    in the resulting array. The new array lets you discover the key in the original
    array given its value, but this technique works effectively only when the original
    array has unique values.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 其原始值既不是字符串也不是整数的元素会在结果数组中保持不变。新数组允许你根据其值在原始数组中发现键，但这种技术仅在原始数组具有唯一值时有效。
- en: Randomizing Order
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机顺序
- en: To traverse the elements in an array in random order, use the `shuffle()` function.
    It replaces all existing keys—string or numeric—with consecutive integers starting
    at 0.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 要以随机顺序遍历数组中的元素，请使用 `shuffle()` 函数。它将所有现有的键（字符串或数值）替换为从 0 开始的连续整数。
- en: 'Here’s how to randomize the order of the days of the week:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何随机排列一周中的天的方式：
- en: '[PRE89]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Obviously, the order after you `shuffle()` may not be the same as the sample
    output here due to the random nature of the function. Unless you are interested
    in getting multiple random elements from an array without repeating any specific
    item, using the `rand()` function to pick an index is more efficient.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用 `shuffle()` 后的顺序可能与此处示例输出不同，因为函数的随机性质。除非您有兴趣从数组中获取多个随机元素而不重复任何特定项，否则使用
    `rand()` 函数来选择索引更有效。
- en: Acting on Entire Arrays
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作整个数组
- en: PHP has several useful built-in functions for modifying or applying an operation
    to all elements of an array. You can calculate the sum of an array, merge multiple
    arrays, find the difference between two arrays, and more.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 中有几个有用的内置函数，用于修改或对数组的所有元素应用操作。你可以计算数组的总和，合并多个数组，找到两个数组之间的差异，等等。
- en: Calculating the Sum of an Array
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算数组的总和
- en: 'The `array_sum()` function adds up the values in an indexed or associative
    array:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_sum()` 函数将索引或关联数组中的值相加：'
- en: '[PRE90]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'For example:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE91]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Merging Two Arrays
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并两个数组
- en: 'The `array_merge()` function intelligently merges two or more arrays:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_merge()` 函数可以智能地合并两个或更多个数组：'
- en: '[PRE92]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If a numeric key from an earlier array is repeated, the value from the later
    array is assigned a new numeric key:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个早期数组中的数值键重复出现，则后来数组中的值将被分配一个新的数值键：
- en: '[PRE93]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'If a string key from an earlier array is repeated, the earlier value is replaced
    by the later value:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个早期数组中的字符串键重复出现，早期的值将被后来的值替换：
- en: '[PRE94]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Calculating the Difference Between Two Arrays
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算两个数组之间的差异
- en: 'The `array_diff()` function calculates the difference between two or more arrays,
    returning an array with values from the first array that are not present in the
    others:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`array_diff()` 函数计算两个或更多个数组之间的差异，返回一个数组，其中包含第一个数组中不在其他数组中的值：'
- en: '[PRE95]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'For example:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE96]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Values are compared using the strict comparison operator `===`, so `1` and `"1"`
    are considered different. The keys of the first array are preserved, so in `$diff`
    the key of `"bill"` is `0` and the key of `"judy"` is `4`.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 值是使用严格比较运算符 `===` 进行比较，所以 `1` 和 `"1"` 被视为不同。第一个数组的键被保留，所以在 `$diff` 中 `"bill"`
    的键是 `0`，而 `"judy"` 的键是 `4`。
- en: 'In another example, the following code returns the difference of two arrays:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个示例中，以下代码返回两个数组的差异：
- en: '[PRE97]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Filtering Elements from an Array
  id: totrans-293
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数组中筛选元素
- en: 'To identify a subset of an array based on its values, use the `array_filter()`
    function:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据其值标识数组的子集，请使用 `array_filter()` 函数：
- en: '[PRE98]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Each value of *array* is passed to the function named in *callback*. The returned
    array contains only those elements of the original array for which the function
    returns a `true` value. For example:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 *array* 的值都传递给 *callback* 中命名的函数。返回的数组仅包含原始数组中函数返回 `true` 值的元素。例如：
- en: '[PRE99]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: As you can see, the keys are preserved. This function is most useful with associative
    arrays.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，键会被保留。这个函数在关联数组中非常有用。
- en: Using Arrays to Implement Data Types
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组实现数据类型
- en: Arrays crop up in almost every PHP program. In addition to their obvious purpose
    of storing collections of values, they’re also used to implement various abstract
    data types. In this section, we show how to use arrays to implement sets and stacks.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在几乎每个 PHP 程序中都会出现。除了明显用于存储值的目的外，它们还用于实现各种抽象数据类型。在本节中，我们展示如何使用数组来实现集合和堆栈。
- en: Sets
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合
- en: 'Arrays enable you to implement the basic operations of set theory: union, intersection,
    and difference. Each set is represented by an array, and various PHP functions
    implement the set operations. The values in the set are the values in the array—the
    keys are not used, but they are generally preserved by the operations.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 数组使您能够实现集合论的基本操作：并集、交集和差集。每个集合由一个数组表示，各种PHP函数实现了这些集合操作。集合中的值是数组中的值——键未被使用，但通常由操作保留。
- en: 'The *union* of two sets is all the elements from both sets with duplicates
    removed. The `array_merge()` and `array_unique()` functions let you calculate
    the union. Here’s how to find the union of two arrays:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的*并集*是两个集合中所有元素的集合，去除重复项。使用 `array_merge()` 和 `array_unique()` 函数可以计算并集。下面是如何找到两个数组的并集：
- en: '[PRE100]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The *intersection* of two sets is the set of elements they have in common. PHP’s
    built-in `array_intersect()` function takes any number of arrays as arguments
    and returns an array of those values that exist in each. If multiple keys have
    the same value, the first key with that value is preserved.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合的*交集*是它们共有的元素集合。PHP 内置的 `array_intersect()` 函数将任意数量的数组作为参数，并返回存在于每个数组中的那些值的数组。如果多个键具有相同的值，则保留第一个具有该值的键。
- en: Stacks
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 栈
- en: Although not as common in PHP programs as in other programs, one fairly common
    data type is the last-in first-out (LIFO) stack. We can create stacks using a
    pair of PHP functions, `array_push()` and `array_pop()`. The `array_push()` function
    is identical to an assignment to `$array[]`. We use `array_push()` because it
    accentuates the fact that we’re working with stacks, and the parallelism with
    `array_pop()` makes our code easier to read. There are also `array_shift()` and
    `array_unshift()` functions for treating an array like a queue.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在PHP程序中不如其他程序常见，但一个相当常见的数据类型是后进先出（LIFO）栈。我们可以使用一对PHP函数 `array_push()` 和 `array_pop()`
    来创建栈。`array_push()` 函数与对 `$array[]` 的赋值相同。我们使用 `array_push()` 是因为它强调了我们正在处理栈，并且与
    `array_pop()` 的并行性使我们的代码更易于阅读。还有 `array_shift()` 和 `array_unshift()` 函数用于将数组视为队列。
- en: Stacks are particularly useful for maintaining state. [Example 5-4](#example_five_fourdot_state_debugger)
    provides a simple state debugger that allows you to print out a list of which
    functions have been called up to this point (i.e., the *stack trace*).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 栈对于保持状态特别有用。[示例 5-4](#example_five_fourdot_state_debugger) 提供了一个简单的状态调试器，允许您打印到目前为止调用过的函数列表（即
    *堆栈跟踪*）。
- en: Example 5-4\. State debugger
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-4\. 状态调试器
- en: '[PRE101]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Here’s the output from [Example 5-4](#example_five_fourdot_state_debugger):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是来自 [示例 5-4](#example_five_fourdot_state_debugger) 的输出：
- en: '[PRE102]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Implementing the Iterator Interface
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现迭代器接口
- en: 'Using the `foreach` construct, you can iterate not only over arrays, but also
    over instances of classes that implement the `Iterator` interface (see [Chapter 6](ch06.xhtml#objects-id00032)
    for more information on objects and interfaces). To implement the `Iterator` interface,
    you must implement five methods on your class:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `foreach` 结构，你不仅可以迭代数组，还可以迭代实现了 `Iterator` 接口的类的实例（有关对象和接口的更多信息，请参见[第6章](ch06.xhtml#objects-id00032)）。要实现
    `Iterator` 接口，必须在类中实现五个方法：
- en: '`current()`'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`current()`'
- en: Returns the element currently pointed at by the iterator.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 返回迭代器当前指向的元素。
- en: '`key()`'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '`key()`'
- en: Returns the key for the element currently pointed at by the iterator.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 返回迭代器当前指向的元素的键。
- en: '`next()`'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`'
- en: Moves the iterator to the next element in the object and returns it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器移动到对象中的下一个元素并返回它。
- en: '`rewind()`'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`rewind()`'
- en: Moves the iterator to the first element in the array.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 将迭代器移动到数组中的第一个元素。
- en: '`valid()`'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`valid()`'
- en: Returns `true` if the iterator currently points at a valid element, and `false`
    otherwise.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器当前指向有效元素，则返回 `true`，否则返回 `false`。
- en: '[Example 5-5](#example_five_fivedot_iterator_interface) reimplements a simple
    iterator class containing a static array of data.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-5](#example_five_fivedot_iterator_interface) 重新实现了一个包含静态数据数组的简单迭代器类。'
- en: Example 5-5\. Iterator interface
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 迭代器接口
- en: '[PRE103]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'When you implement the `Iterator` interface on a class, it allows you only
    to traverse elements in instances of that class using the `foreach` construct;
    it does not allow you to treat those instances as arrays or parameters to other
    methods. This, for example, rewinds the `Iterator` pointing at `$trie`’s properties
    using the built-in `rewind()` function instead of calling the `rewind()` method
    on `$trie`:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在一个类上实现`Iterator`接口时，它只允许你使用`foreach`结构遍历该类实例中的元素；它不允许你将这些实例视为数组或作为其他方法的参数。例如，使用内置的`rewind()`函数而不是在`$trie`上调用`rewind()`方法，可以重置指向`$trie`属性的`Iterator`：
- en: '[PRE104]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The optional SPL library provides a wide variety of useful iterators, including
    filesystem directory, tree, and regex matching iterators.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的SPL库提供了各种有用的迭代器，包括文件系统目录、树形和正则表达式匹配迭代器。
- en: What’s Next
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来做什么
- en: The last three chapters—on functions, strings, and arrays—have covered a lot
    of foundational ground. The next chapter builds on this foundation and takes you
    into the newish world of objects and object-oriented programming (OOP). Some argue
    that OOP is the better way to program, as it is more encapsulated and reusable
    than procedural programming. That debate continues, but once you get into the
    object-oriented approach to programming and understand its benefits, you can make
    an informed decision about how you’ll program in the future. That said, the overall
    trend in the programming world is to use OOP as much as possible.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三章——关于函数、字符串和数组——涵盖了许多基础内容。下一章将在此基础上构建，并将你带入对象和面向对象编程（OOP）的新世界。有人认为OOP是更好的编程方式，因为它比过程化编程更加封装和可重用。这场辩论仍在继续，但一旦你进入面向对象的编程方法并理解其好处，你就能对未来的编程方式做出明智的决定。话虽如此，编程世界的总体趋势是尽可能多地使用OOP。
- en: 'One word of caution before you continue: there are many situations where a
    novice OOP programmer can get lost, so be sure you’re really comfortable with
    OOP before you do anything major or mission-critical with it.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有一点需要注意：有很多情况下，初学者OOP程序员可能会迷失方向，所以确保你真正掌握了OOP之后再进行重要或关键任务。
