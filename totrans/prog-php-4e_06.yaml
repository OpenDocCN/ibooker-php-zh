- en: Chapter 5\. Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we discussed in [Chapter 2](ch02.xhtml#language_basics), PHP supports both
    scalar and compound data types. In this chapter, we’ll discuss one of the compound
    types: arrays. An *array* is a collection of data values organized as an ordered
    collection of key-value pairs. It may help to think of an array, in loose terms,
    like an egg carton. Each compartment of an egg carton can hold an egg, but it
    travels around as one overall container. And, just as an egg carton doesn’t have
    to contain only eggs (you can put anything in there, like rocks, snowballs, four-leaf
    clovers, or nuts and bolts), so too an array is not limited to one type of data.
    It can hold strings, integers, Booleans, and so on. Plus, array compartments can
    also contain other arrays—but more on that later.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter talks about creating an array, adding and removing elements from
    an array, and looping over the contents of an array. Because arrays are very common
    and useful, there are many built-in functions that work with them in PHP. For
    example, if you want to send email to more than one email address, you’ll store
    the email addresses in an array and then loop through the array, sending the message
    to the current email address. Also, if you have a form that permits multiple selections,
    the items the user selected are returned in an array.
  prefs: []
  type: TYPE_NORMAL
- en: Indexed Versus Associative Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two kinds of arrays in PHP: indexed and associative. The keys of
    an *indexed* array are integers, beginning at 0\. Indexed arrays are used when
    you identify things by their position. *Associative* arrays have strings as keys
    and behave more like two-column tables. The first column is the key, which is
    used to access the value.'
  prefs: []
  type: TYPE_NORMAL
- en: PHP internally stores all arrays as associative arrays; the only difference
    between associative and indexed arrays is what the keys happen to be. Some array
    features are provided mainly for use with indexed arrays because they assume that
    you have or want keys that are consecutive integers beginning at 0\. In both cases,
    the keys are unique. In other words, you can’t have two elements with the same
    key, regardless of whether the key is a string or an integer.
  prefs: []
  type: TYPE_NORMAL
- en: PHP arrays have an internal order to their elements that is independent of the
    keys and values, and there are functions that you can use to traverse the arrays
    based on this internal order. The order is normally that in which values were
    inserted into the array, but the sorting functions described later in this chapter
    let you change the order to one based on keys, values, or anything else you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Elements of an Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at creating an array, let’s look at the structure of an existing
    array. You can access specific values from an existing array using the array variable’s
    name, followed by the element’s key, or *index*, within square brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The key can be either a string or an integer. String values that are equivalent
    to integer numbers (without leading zeros) are treated as integers. Thus, `$array[3]`
    and `$array['3']` reference the same element, but `$array['03']` references a
    different element. Negative numbers are valid keys, but they don’t specify positions
    from the end of the array as they do in Perl.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t have to quote single-word strings. For instance, `$age[''fred'']`
    is the same as `$age[fred]`. However, it’s considered good PHP style to always
    use quotes, because quoteless keys are indistinguishable from constants. When
    you use a constant as an unquoted index, PHP uses the value of the constant as
    the index and emits a warning. This will throw an error in future versions of
    PHP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You must use quotes if you’re using interpolation to build the array index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Although it’s technically optional, you should also quote the key if you’re
    interpolating an array lookup to ensure that you get the value you expect. Consider
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Storing Data in Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Storing a value in an array will create the array if it doesn’t already exist,
    but trying to retrieve a value from an array that hasn’t been defined won’t create
    the array. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Using simple assignment to initialize an array in your program can lead to
    code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s an indexed array, with integer indices beginning at 0\. Here’s an associative
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'An easier way to initialize an array is to use the `array()` construct, which
    builds an array from its arguments. This builds an indexed array, and the index
    values (starting at 0) are created automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an associative array with `array()`, use the `=>` symbol to separate
    indices (keys) from values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the use of whitespace and alignment. We could have bunched up the code,
    but it wouldn’t have been as easy to read (this is equivalent to the previous
    code sample), or as easy to add or remove values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify an array using a shorter, alternate syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To construct an empty array, pass no arguments to `array()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can specify an initial key with `=>` and then a list of values. The values
    are inserted into the array starting with that key, with subsequent values having
    sequential keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the initial index is a non-numeric string, subsequent indices are integers
    beginning at 0\. Thus, the following code is probably a mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Appending Values to an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add more values to the end of an existing indexed array, use the `[]` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This construct assumes the array’s indices are numbers and assigns elements
    into the next available numeric index, starting from 0\. Attempting to append
    to an associative array without appropriate keys is almost always a programmer
    mistake, but PHP will give the new elements numeric indices without issuing a
    warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Assigning a Range of Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `range()` function creates an array of consecutive integer or character
    values between and including the two values you pass to it as arguments. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the first letter of a string argument is used to build the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Getting the Size of an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `count()` and `sizeof()` functions are identical in use and effect. They
    return the number of elements in the array. There is no stylistic preference about
    which function you use. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This function counts only array values that are actually set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Padding an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create an array with values initialized to the same content, use `array_pad()`.
    The first argument to `array_pad()` is the array, the second argument is the minimum
    number of elements you want the array to have, and the third argument is the value
    to give any elements that are created. The `array_pad()` function returns a new
    padded array, leaving its argument (source) array alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s `array_pad()` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how the new values are appended to the array. If you want the new values
    added to the start of the array, use a negative second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you pad an associative array, existing keys will be preserved. New elements
    will have numeric keys starting at 0.
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The values in an array can themselves be arrays. This lets you easily create
    multidimensional arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refer to elements of multidimensional arrays by appending more square
    brackets, `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To interpolate a lookup of a multidimensional array, you must enclose the entire
    array lookup in curly braces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Failing to use the curly braces results in output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Extracting Multiple Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To copy all of an array’s values into variables, use the `list()` construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The array’s values are copied into the listed variables in the array’s internal
    order. By default that’s the order in which they were inserted, but the sort functions
    described later let you change that. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The use of the `list()` function is a common practice for picking up values
    from a database selection where only one row is returned. This automatically loads
    the data from the simple query into a series of local variables. Here is an example
    of selecting two opposing teams from a sports scheduling database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: There is more coverage on databases in [Chapter 9](ch09.xhtml#databases-id00007).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have more values in the array than in the `list()`, the extra values
    are ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have more values in the `list()` than in the array, the extra values
    are set to `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Two or more consecutive commas in the `list()` skip values in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Slicing an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To extract only a subset of the array, use the `array_slice()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `array_slice()` function returns a new array consisting of a consecutive
    series of values from the original array. The *offset* parameter identifies the
    initial element to copy (`0` represents the first element in the array), and the
    *length* parameter identifies the number of values to copy. The new array has
    consecutive numeric keys starting at 0\. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'It is generally only meaningful to use `array_slice()` on indexed arrays (i.e.,
    those with consecutive integer indices starting at 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine `array_slice()` with `list()` to extract only some values to variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Splitting an Array into Chunks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To divide an array into smaller, evenly sized arrays, use the `array_chunk()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returns an array of the smaller arrays. The third argument, *preserve_keys*,
    is a Boolean value that determines whether the elements of the new arrays have
    the same keys as in the original (useful for associative arrays) or new numeric
    keys starting from 0 (useful for indexed arrays). The default is to assign new
    keys, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Keys and Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `array_keys()` function returns an array consisting of only the keys in
    the array in internal order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'PHP also provides a (generally less useful) function to retrieve an array of
    just the values in an array, `array_values()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As with `array_keys()`, the values are returned in the array’s internal order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Checking Whether an Element Exists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see if an element exists in the array, use the `array_key_exists()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The function returns a Boolean value that indicates whether the first argument
    is a valid key in the array given as the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not sufficient to simply say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Even if there is an element in the array with the key `name`, its corresponding
    value might be false (i.e., `0`, `NULL`, or the empty string). Instead, use `array_key_exists()`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Many people use the `isset()` function instead, which returns `true` if the
    element exists and is not `NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Removing and Inserting Elements in an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `array_splice()` function can remove or insert elements in an array and
    optionally create another array from the removed elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll look at `array_splice()` using this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We can remove the `"math"`, `"bio"`, and `"cs"` elements by telling `array_splice()`
    to start at position 2 and remove 3 elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you omit the length, `array_splice()` removes to the end of the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'If you simply want to delete elements from the source array and you don’t care
    about retaining their values, you don’t need to store the results of `array_splice()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert elements where others were removed, use the fourth argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The size of the replacement array doesn’t have to be the same as the number
    of elements you delete. The array grows or shrinks as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert new elements into the array while pushing existing elements to the
    right, delete zero elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Although the examples so far have used an indexed array, `array_splice()` also
    works on associative arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Converting Between Arrays and Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP provides two functions, `extract()` and `compact()`, that convert between
    arrays and variables. The names of the variables correspond to keys in the array,
    and the values of the variables become the values in the array. For instance,
    this array
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'can be converted to, or built from, these variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Creating Variables from an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `extract()` function automatically creates local variables from an array.
    The indices of the array elements become the variable names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: If a variable created by the extraction has the same name as an existing one,
    the existing variable’s value is overwritten with the one from the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can modify `extract()`’s behavior by passing a second argument. The [Appendix](app01.xhtml#function_reference)
    describes the possible values for this second argument. The most useful value
    is `EXTR_PREFIX_ALL`, which indicates that the third argument to `extract()` is
    a prefix for the variable names that are created. This helps ensure that you create
    unique variable names when you use `extract()`. It is good PHP style to always
    use `EXTR_``PREFIX_ALL`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Creating an Array from Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `compact()` function is the reverse of `extract()`; you pass it the variable
    names to compact either as separate parameters or in an array. The `compact()`
    function creates an associative array whose keys are the variable names and whose
    values are the variable’s values. Any names in the array that do not correspond
    to actual variables are skipped. Here’s an example of `compact()` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Traversing Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common task with arrays is to do something with every element—for instance,
    sending mail to each element of an array of addresses, updating each file in an
    array of filenames, or adding up each element of an array of prices. There are
    several ways to traverse arrays in PHP, and the one you choose will depend on
    your data and the task you’re performing.
  prefs: []
  type: TYPE_NORMAL
- en: The foreach Construct
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to loop over elements of an array is to use the `foreach`
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: PHP executes the body of the loop (the `echo` statement) once for each element
    of `$addresses` in turn, with `$value` set to the current element. Elements are
    processed by their internal order.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative form of `foreach` gives you access to the current key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the key for each element is placed in `$key` and the corresponding
    value is placed in `$value`.
  prefs: []
  type: TYPE_NORMAL
- en: The `foreach` construct does not operate on the array itself, but rather on
    a copy of it. You can insert or delete elements in the body of a `foreach` loop,
    safe in the knowledge that the loop won’t attempt to process the deleted or inserted
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: The Iterator Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every PHP array keeps track of the current element you’re working with; the
    pointer to the current element is known as the *iterator*. PHP has functions to
    set, move, and reset this iterator. The iterator functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`current()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the element currently pointed at by the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '`reset()`'
  prefs: []
  type: TYPE_NORMAL
- en: Moves the iterator to the first element in the array and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: '`next()`'
  prefs: []
  type: TYPE_NORMAL
- en: Moves the iterator to the next element in the array and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: '`prev()`'
  prefs: []
  type: TYPE_NORMAL
- en: Moves the iterator to the previous element in the array and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: '`end()`'
  prefs: []
  type: TYPE_NORMAL
- en: Moves the iterator to the last element in the array and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: '`each()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the key and value of the current element as an array and moves the iterator
    to the next element in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '`key()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the key of the current element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `each()` function is used to loop over the elements of an array. It processes
    elements according to their internal order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This approach does not make a copy of the array, as `foreach` does. This is
    useful for very large arrays when you want to conserve memory.
  prefs: []
  type: TYPE_NORMAL
- en: The iterator functions are useful when you need to consider some parts of the
    array separately from others. [Example 5-1](#example_five_onedot_building_a_table_wi)
    shows code that builds a table, treating the first index and value in an associative
    array as table column headings.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Building a table with the iterator functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Using a for Loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you know that you are dealing with an indexed array, where the keys are consecutive
    integers beginning at 0, you can use a `for` loop to count through the indices.
    The `for` loop operates on the array itself, not on a copy of the array, and processes
    elements in key order regardless of their internal order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to print an array using `for`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Calling a Function for Each Array Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PHP provides a mechanism, `array_walk()`, for calling a user-defined function
    once per element in an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The function you define takes in two or, optionally, three arguments: the first
    is the element’s value, the second is the element’s key, and the third is a value
    supplied to `array_walk()` when it is called. For instance, here’s another way
    to print table columns made of the values from an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'A variation of this example specifies a background color using the optional
    third argument to `array_walk()`. This parameter gives us the flexibility we need
    to print many tables, with many background colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have multiple options you want to pass into the called function, simply
    pass an array in as a third parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `array_walk()` function processes elements in their internal order.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cousin of `array_walk()`, `array_reduce()` applies a function to each element
    of the array in turn, to build a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The function takes two arguments: the running total, and the current value
    being processed. It should return the new running total. For instance, to add
    up the squares of the values of an array, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The `array_reduce()` line makes these function calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The *default* argument, if provided, is a seed value. For instance, if we change
    the call to `array_reduce()` in the previous example to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting function calls are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If the array is empty, `array_reduce()` returns the *default* value. If no default
    value is given and the array is empty, `array_reduce()` returns `NULL`.
  prefs: []
  type: TYPE_NORMAL
- en: Searching for Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `in_array()` function returns `true` or `false`, depending on whether the
    first argument is an element in the array given as the second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: If the optional third argument is `true`, the types of *to_find* and the value
    in the array must match. The default is to not check the data types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: PHP automatically indexes the values in arrays, so `in_array()` is generally
    much faster than a loop checking every value in the array to find the one you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-2](#example_five_twodot_searching_an_array) checks whether the user
    has entered information in all the required fields in a form.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. Searching an array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'A variation on `in_array()` is the `array_search()` function. While `in_array()`
    returns `true` if the value is found, `array_search()` returns the key of the
    element, if found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The `array_search()` function also takes the optional third *strict* argument,
    which requires that the types of the value being searched for and the value in
    the array match.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sorting changes the internal order of elements in an array and optionally rewrites
    the keys to reflect this new order. For example, you might use sorting to arrange
    a list of scores from biggest to smallest, to alphabetize a list of names, or
    to order a set of users based on how many messages they posted.
  prefs: []
  type: TYPE_NORMAL
- en: PHP provides three ways to sort arrays—sorting by keys, sorting by values without
    changing the keys, or sorting by values and then changing the keys. Each kind
    of sort can be done in ascending order, descending order, or an order determined
    by a user-defined function.
  prefs: []
  type: TYPE_NORMAL
- en: Sorting One Array at a Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functions provided by PHP to sort an array are shown in [Table 5-1](#php_functions_for_sorting_an_array).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. PHP functions for sorting an array
  prefs: []
  type: TYPE_NORMAL
- en: '| Effect | Ascending | Descending | User-defined order |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Sort array by values, then reassign indices starting with 0 | `sort()` |
    `rsort()` | `usort()` |'
  prefs: []
  type: TYPE_TB
- en: '| Sort array by values | `asort()` | `arsort()` | `uasort()` |'
  prefs: []
  type: TYPE_TB
- en: '| Sort array by keys | `ksort()` | `krsort()` | `uksort()` |'
  prefs: []
  type: TYPE_TB
- en: The `sort()`, `rsort()`, and `usort()` functions are designed to work on indexed
    arrays because they assign new numeric keys to represent the ordering. They’re
    useful when you need to answer questions such as “What are the top 10 scores?”
    and “Who’s the third person in alphabetical order?” The other sort functions can
    be used on indexed arrays, but you’ll only be able to access the sorted ordering
    by using traversal constructs such as `foreach` and `next()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sort names into ascending alphabetical order, do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: To get them in reverse alphabetical order, simply call `rsort()` instead of
    `sort()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have an associative array that maps usernames to minutes of login time,
    you can use `arsort()` to display a table of the top three, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: If you want that table displayed in ascending order by username, use `ksort()`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined ordering requires that you provide a function that takes two values
    and returns a value that specifies the order of the two values in the sorted array.
    The function should return `1` if the first value is greater than the second,
    `−1` if the first value is less than the second, and `0` if the values are the
    same for the purposes of your custom sort order.
  prefs: []
  type: TYPE_NORMAL
- en: The program in [Example 5-3](#example_five_threedot_sorting_arrays) applies
    the various sorting functions to the same data.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. Sorting arrays
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Natural-Order Sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PHP’s built-in sort functions correctly sort strings and numbers, but they
    don’t correctly sort strings that contain numbers. For example, if you have the
    filenames *ex10.php*, *ex5.php*, and *ex1.php*, the normal sort functions will
    rearrange them in this order: *ex1.php*, *ex10.php*, *ex5.php*. To correctly sort
    strings that contain numbers, use the `natsort()` and `natcasesort()` functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Sorting Multiple Arrays at Once
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `array_multisort()` function sorts multiple indexed arrays at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Pass it a series of arrays and sorting orders (identified by the `SORT_ASC`
    or `SORT_DESC` constants), and it reorders the elements of all the arrays, assigning
    new indices. It is similar to a join operation on a relational database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that you have a lot of people, and several pieces of data on each person:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The first element of each array represents a single record—all the information
    known about Tom. Similarly, the second element constitutes another record—all
    the information known about Dick. The `array_multisort()` function reorders the
    elements of the arrays, preserving the records. That is, if `"Dick"` ends up first
    in the `$names` array after the sort, the rest of Dick’s information will be first
    in the other arrays too. (Note that we needed to quote Dick’s zip code to prevent
    it from being interpreted as an octal constant.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to sort the records first ascending by age, then descending by zip
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to include `$names` in the function call to ensure that Dick’s name
    stays with his age and zip code. Printing out the data shows the result of the
    sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Reversing Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `array_reverse()` function reverses the internal order of elements in an
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Numeric keys are renumbered starting at 0, while string indices are unaffected.
    In general, it’s better to use the reverse-order sorting functions instead of
    sorting and then reversing the order of an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `array_flip()` function returns an array that reverses the order of each
    original element’s key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, for each element of the array whose value is a valid key, the element’s
    value becomes its key and the element’s key becomes its value. For example, if
    you have an array that maps usernames to home directories, you can use `array_flip()`
    to create an array that maps home directories to usernames:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Elements whose original values are neither strings nor integers are left alone
    in the resulting array. The new array lets you discover the key in the original
    array given its value, but this technique works effectively only when the original
    array has unique values.
  prefs: []
  type: TYPE_NORMAL
- en: Randomizing Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To traverse the elements in an array in random order, use the `shuffle()` function.
    It replaces all existing keys—string or numeric—with consecutive integers starting
    at 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to randomize the order of the days of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, the order after you `shuffle()` may not be the same as the sample
    output here due to the random nature of the function. Unless you are interested
    in getting multiple random elements from an array without repeating any specific
    item, using the `rand()` function to pick an index is more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Acting on Entire Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP has several useful built-in functions for modifying or applying an operation
    to all elements of an array. You can calculate the sum of an array, merge multiple
    arrays, find the difference between two arrays, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the Sum of an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `array_sum()` function adds up the values in an indexed or associative
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Merging Two Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `array_merge()` function intelligently merges two or more arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'If a numeric key from an earlier array is repeated, the value from the later
    array is assigned a new numeric key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'If a string key from an earlier array is repeated, the earlier value is replaced
    by the later value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Calculating the Difference Between Two Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `array_diff()` function calculates the difference between two or more arrays,
    returning an array with values from the first array that are not present in the
    others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Values are compared using the strict comparison operator `===`, so `1` and `"1"`
    are considered different. The keys of the first array are preserved, so in `$diff`
    the key of `"bill"` is `0` and the key of `"judy"` is `4`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In another example, the following code returns the difference of two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Filtering Elements from an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To identify a subset of an array based on its values, use the `array_filter()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Each value of *array* is passed to the function named in *callback*. The returned
    array contains only those elements of the original array for which the function
    returns a `true` value. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the keys are preserved. This function is most useful with associative
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Using Arrays to Implement Data Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Arrays crop up in almost every PHP program. In addition to their obvious purpose
    of storing collections of values, they’re also used to implement various abstract
    data types. In this section, we show how to use arrays to implement sets and stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Arrays enable you to implement the basic operations of set theory: union, intersection,
    and difference. Each set is represented by an array, and various PHP functions
    implement the set operations. The values in the set are the values in the array—the
    keys are not used, but they are generally preserved by the operations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *union* of two sets is all the elements from both sets with duplicates
    removed. The `array_merge()` and `array_unique()` functions let you calculate
    the union. Here’s how to find the union of two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: The *intersection* of two sets is the set of elements they have in common. PHP’s
    built-in `array_intersect()` function takes any number of arrays as arguments
    and returns an array of those values that exist in each. If multiple keys have
    the same value, the first key with that value is preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although not as common in PHP programs as in other programs, one fairly common
    data type is the last-in first-out (LIFO) stack. We can create stacks using a
    pair of PHP functions, `array_push()` and `array_pop()`. The `array_push()` function
    is identical to an assignment to `$array[]`. We use `array_push()` because it
    accentuates the fact that we’re working with stacks, and the parallelism with
    `array_pop()` makes our code easier to read. There are also `array_shift()` and
    `array_unshift()` functions for treating an array like a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks are particularly useful for maintaining state. [Example 5-4](#example_five_fourdot_state_debugger)
    provides a simple state debugger that allows you to print out a list of which
    functions have been called up to this point (i.e., the *stack trace*).
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. State debugger
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the output from [Example 5-4](#example_five_fourdot_state_debugger):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the Iterator Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the `foreach` construct, you can iterate not only over arrays, but also
    over instances of classes that implement the `Iterator` interface (see [Chapter 6](ch06.xhtml#objects-id00032)
    for more information on objects and interfaces). To implement the `Iterator` interface,
    you must implement five methods on your class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`current()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the element currently pointed at by the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '`key()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the key for the element currently pointed at by the iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '`next()`'
  prefs: []
  type: TYPE_NORMAL
- en: Moves the iterator to the next element in the object and returns it.
  prefs: []
  type: TYPE_NORMAL
- en: '`rewind()`'
  prefs: []
  type: TYPE_NORMAL
- en: Moves the iterator to the first element in the array.
  prefs: []
  type: TYPE_NORMAL
- en: '`valid()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns `true` if the iterator currently points at a valid element, and `false`
    otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 5-5](#example_five_fivedot_iterator_interface) reimplements a simple
    iterator class containing a static array of data.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. Iterator interface
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'When you implement the `Iterator` interface on a class, it allows you only
    to traverse elements in instances of that class using the `foreach` construct;
    it does not allow you to treat those instances as arrays or parameters to other
    methods. This, for example, rewinds the `Iterator` pointing at `$trie`’s properties
    using the built-in `rewind()` function instead of calling the `rewind()` method
    on `$trie`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: The optional SPL library provides a wide variety of useful iterators, including
    filesystem directory, tree, and regex matching iterators.
  prefs: []
  type: TYPE_NORMAL
- en: What’s Next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last three chapters—on functions, strings, and arrays—have covered a lot
    of foundational ground. The next chapter builds on this foundation and takes you
    into the newish world of objects and object-oriented programming (OOP). Some argue
    that OOP is the better way to program, as it is more encapsulated and reusable
    than procedural programming. That debate continues, but once you get into the
    object-oriented approach to programming and understand its benefits, you can make
    an informed decision about how you’ll program in the future. That said, the overall
    trend in the programming world is to use OOP as much as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'One word of caution before you continue: there are many situations where a
    novice OOP programmer can get lost, so be sure you’re really comfortable with
    OOP before you do anything major or mission-critical with it.'
  prefs: []
  type: TYPE_NORMAL
