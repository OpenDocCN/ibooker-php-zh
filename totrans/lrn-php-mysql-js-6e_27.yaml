- en: Chapter 24\. Introduction to React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using JavaScript, HTML, and CSS to build dynamic websites, there comes
    a time that the creation of the code required to handle the frontend of your websites
    and apps can become cumbersome and overly verbose, slowing down the speed of project
    development and potentially leading to the introduction of hard-to-find bugs.
  prefs: []
  type: TYPE_NORMAL
- en: This is where frameworks come in. Of course, since 2006 there’s been jQuery
    to help us out, and consequently it’s installed on the vast majority of production
    websites, although these days JavaScript has grown sufficiently in scope and flexibility
    that programmers need to rely on frameworks like jQuery a lot less. Also, as time
    marches on the technology continually improves, and now there are a number of
    excellent other options, such as Angular and, as discussed here, my preferred
    favorite, React.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery was designed to simplify HTML DOM tree traversal and manipulation, as
    well as event handling, CSS animation, and Ajax, but some programmers, such as
    the development team at Google, felt it still wasn’t powerful enough, and they
    came up with Angular JS in 2010, which evolved into Angular in 2016.
  prefs: []
  type: TYPE_NORMAL
- en: Angular uses a hierarchy of components as its primary architectural characteristic,
    rather than using “scope” or controllers (like Angular). Google’s massive AdWords
    platform is powered by Angular, as are Forbes, Autodesk, Indiegogo, UPS, and many
    others, and it is indeed extremely powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Facebook, on the other hand, had a different vision and came up with React (also
    known as React JS) as its framework for the development of single-page or mobile
    applications, basing it around the JSX extension (which stands for JavaScript
    XML). The React Library (first developed in 2012) divides a web page into single
    components, simplifying the development of the interface required to serve all
    of Facebook’s advertising and more, and it is now widely adopted by platforms
    across the web, such as Dropbox, Cloudflare, Airbnb, Netflix, the BBC, PayPal,
    and many more household names.
  prefs: []
  type: TYPE_NORMAL
- en: Clearly, both Angular and React were driven in their creation and design by
    solid commercial decisions and were built to handle extremely high-traffic web
    pages, where it was felt that jQuery simply did not have the oomph the developers
    were looking for.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, nowadays, as well as knowing the core technologies of JavaScript,
    HTML, CSS, a server-side language such as PHP, and a database such as MySQL, programmers
    still may find it handy to at least know a little jQuery and at least one (if
    not both) of Angular and React, and possibly other frameworks that also have their
    followings.
  prefs: []
  type: TYPE_NORMAL
- en: However, for reasons of ease of use, a not-too-steep learning curve, and general
    implementation, and also because Google Trends shows it to be the framework of
    most popular interest of the three (see [Figure 24-1](#recent-popularity-of-jquery)),
    I decided it was more important to introduce you to React. By the way, please
    don’t confuse the similarly named ReactPHP with React for JavaScript, as it is
    an entirely separate and unconnected project.
  prefs: []
  type: TYPE_NORMAL
- en: What Is the Point of React Anyway?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React allows developers to create large web applications that can easily handle
    and change data, without reloading the web page. Its main raisons d'être are speed,
    scalability, and simplicity in handling the view layer of single-page web and
    mobile applications. It also enables the creation of reusable UI components and
    manages a virtual DOM for increased performance. Some people have been quoted
    as saying you can use it as the V in the MVC (Model, View, Controller) architecture
    that separates applications into three components.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of developers having to come up with various ways to describe transactions
    on interfaces, they can simply describe the interfaces in terms of a final state,
    such that when transactions happen to that state, React updates the UI for you.
    The net results are faster, less buggy development; speed; reliability; and scalability.
    Because React is a library and not a framework, learning it is also quick, with
    just a few functions to master. After that, it’s all down to your JavaScript skills.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s get started with how to access React files.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/pmj6_2401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 24-1\. Recent popularity of jQuery, Angular, and React according to Google
    Trends
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I think jQuery is great, but I also find React very easy to use, and I suppose
    time will tell whether I’m right in my suspicion that React could eventually replace
    jQuery as the dominant framework, certainly for handling the UI, because it’s
    simply so much richer. But even if it doesn’t, by learning React you will still
    have an incredibly powerful new tool at your disposal, which many top companies
    will be looking for on your resume. And don’t dismiss Angular, either. Had there
    been room in this book, I would have covered it too, because it’s definitely worth
    understanding for debugging and maintenance of existing code, even if you don’t
    develop using it. You can learn all about it at [https://angular.io](https://angular.io)
    (and it will also look great on your resume).
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the React Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like jQuery and Angular, React is open source and entirely free to use. Also
    like these other frameworks, there are a number of services on the web that will
    serve the latest (or any) version up for you free of charge, so using it can be
    as easy as placing a couple of extra lines of code in your web page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before examining what you can do with React and how to use it, here’s how you
    include it in a web page, pulling the files from *unpkg.com*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'These lines should ideally be placed within the `<head>...</head>` section
    of a page to ensure they are loaded before the body section. They load in the
    development versions of React and React DOM to aid you with development and debugging.
    On a production website, you should replace the word `development` with `production`
    in these URLs, and, to speed up transfer, you can even change `development` to
    `production.min`, which will call up compressed versions of the files, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For ease of access and to make the code as brief as possible, I have downloaded
    the latest (version 17 as I write) of the uncompressed development files to the
    accompanying archive of examples for this book (on [GitHub](https://github.com/RobinNixon/lpmj6))
    so that all the examples will load locally and look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now that React is available to your code, what next? Well, although it is not
    strictly necessary, next we pull in the Babel JSX extension, which allows you
    to include XML text directly within JavaScript, making your life much easier.
  prefs: []
  type: TYPE_NORMAL
- en: Including babel.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Babel JSX extension adds the ability for you to use XML (very similar to
    HTML) directly within your JavaScript, saving you from having to call a function
    each time. In addition, on browsers that have earlier versions of ECMAScript (the
    official standard of JavaScript) than 6, Babel upgrades them to handle ES6 syntax,
    so it provides two great benefits in one go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again you can pull the file needed from the *unpkg.com* server, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You require only the one minimized version of the Babel code on either a development
    or a production server. For convenience I have also downloaded the latest version
    to the companion archive of example files, so examples in this book load locally
    and look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we can access the React files, let’s get on with doing something with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This chapter is intended to teach you the basics of using React to give you
    a clear understanding of how and why it works and to provide you with a good starting
    point to take your React development further. Indeed, some of the examples in
    this chapter are based on (or similar to) examples you can find in the official
    documentation at the [reactjs.org](http://reactjs.org) website so that, should
    you wish to learn React in greater depth, you can visit the website and will be
    off to a running start.
  prefs: []
  type: TYPE_NORMAL
- en: Our First React Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than teaching you all about React and JSX before actually setting about
    coding, let’s approach it from the other angle and show how easy everything is
    by jumping right into our first React project, as shown in [Example 24-1](#our-first-react-project),
    the result of which is to simply display the text “By Jeeves, it works!” in the
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-1\. Our first React project
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This is a standard HTML5 document, which loads in the two React scripts and
    the Babel script before opening an inline script. Here is where we first need
    to pay attention because, instead of not specifying a type to the `script` tag,
    or using `type=application/javascript`, the tag is given `type=text/babel`. This
    lets the browser know to allow the Babel preprocessor to run through the script,
    add ES6 functionality to it if necessary, and replace any XML encountered with
    JavaScript function calls, and only then to run the contents of the script as
    JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the script, a new class name, `One`, is created, extending the `React.component`
    class. Within the class, a `render` method is created, which returns the following
    XML (not a string):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, within the script, the `render` function of the `One` class is called,
    passing it the ID of the only `<div>` element in the body of the document, which
    has been given the ID of `div1`. The result is to render the XML into the div,
    which causes the browser to automatically update and display the contents, which
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Immediately you should see how including the XML within the JavaScript makes
    for much easier and faster-to-write code and makes it easier to understand too.
    Without the JSX extension, you would have to do all this using a sequence of JavaScript
    function calls.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: React treats components starting with lowercase letters as DOM tags. Therefore,
    for example, `<div />` represents an HTML `<div>` tag, but `<One />` represents
    a component and requires `One` to be in scope—you cannot use `one` (with a lowercase
    `o`) in the previous example and expect your code to work, as the component needs
    to start with uppercase and so does any reference to it.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Function Instead of a Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you prefer, and as is becoming the more common practice, you can use a function
    for your code instead of placing it in a class with a `render` function, as in
    [Example 24-2](#using-a-function-instead). The main reasons you may prefer to
    do this are simplicity, ease of use, and faster development.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-2\. Using a function instead of a class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The displayed result of this in the browser is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the examples that follow from this point onward, for the sake of brevity
    and simplicity, I will show only the contents of the Babel script and the body
    of the document as if they were both in the body (which works just the same),
    but the examples in the companion archive *will* be complete. So they will look
    like this from now on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Pure and Impure Code: A Golden Rule'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you write a normal JavaScript function, it is possible to write either
    what React calls *pure* or *impure* code. Pure function code does not change its
    inputs, as in the following, which returns a value calculated from its arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this function is considered impure because it modifies an argument
    and is absolutely not allowed when using React:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Expressed as a golden rule, this means that all React components must act like
    pure functions with respect to their props, as explained at [“Props and Components”](#props-and-components).
  prefs: []
  type: TYPE_NORMAL
- en: Using Both a Class and a Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can, of course, use functions and classes pretty much interchangeably (although
    there are differences between them, which I explain later in [“The Differences
    Between Using a Class and a Function”](#the-differences-between-class-function)),
    as in [Example 24-3](#using-both-classes-and).
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-3\. Using both classes and functions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here there is a class named `One` and a function named `Two`, which are the
    same as in the previous two examples. There is an additional difference, though—the
    creation of a new function called `doRender`—which considerably shortens the syntax
    of the call required to render a block of XML. The result of running this displays
    in the browser as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In addition to leaving out the surrounding HTML code of the following examples,
    I will also leave out the code for the `doRender` function to save needlessly
    repeating it many times over. So when you see a call to the `doRender` function
    in these examples, remember that it is not a built-in React function but is a
    function included in the full examples in the companion archive.
  prefs: []
  type: TYPE_NORMAL
- en: Props and Components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A great way to introduce you to what React calls *props* and *components* is
    to build a simple welcome page in which a name is passed to the script and then
    displayed. [Example 24-4](#passing-props-to-a-function)  is one way to do that. Components
    let you split the UI into separate, reusable parts and work with each part in
    isolation. They are similar to JavaScript functions and accept arbitrary inputs
    that are called *props*, returning React elements that describe how elements should
    appear in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-4\. Passing `props` to a function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `Welcome` function receives an argument of `props`, which
    stands for properties, and within its JSX `return` statement there is a section
    inside curly braces that fetches the `name` property from the `props` object,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`props` is an object in React, and next you will see one way to populate it
    with a property.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using curly braces is how you can embed expressions within JSX. In fact, you
    can place almost any JavaScript expression inside these curly braces and it will
    be evaluated (with the exception of `for` and `if` statements, which cannot be
    evaluated).
  prefs: []
  type: TYPE_NORMAL
- en: So, in place of `props.name` in this example, you could enter `76 / 13` or `"decode".substr(-4)`
    (which would evaluate to the string `"code"`). In this instance, however, the
    property `name` is retrieved from the `props` object and returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `doRender` function (which you will remember is a shorthand call
    leading to the `ReactDOM.render` function) is passed the name of the `Welcome` function,
    followed by assigning the string value `''Robin''` to its `name` property, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'React then calls the `Welcome` function (also called a *component*), passing
    it `{name: ''Robin''}` in `props`. `Welcome` then evaluates and returns `<h1>Hello,
    Robin</h1>` as its result, which is then rendered into the `div` called `hello` and
    renders in the browser like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To make your code tidier you can also, if you wish, first create an element
    containing the XML to pass to `doRender`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The Differences Between Using a Class and a Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most obvious difference between using a class and a function in React is
    the syntax. A function is simple JavaScript (possibly incorporating JSX), which
    can accept a props argument and return a component element.
  prefs: []
  type: TYPE_NORMAL
- en: A class, however, is extended from `React.Component` and requires a `render`
    method to return a component. But this additional code does come with benefits,
    in that a class allows you to use `setState` in your component, enabling (for
    example) the use of timers and other stateful features. Functions in React are
    called *functional stateless component*s. Additionally, classes allow you to use
    what React calls *life-cycle hooks and methods*. More on all of this in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, nowadays you can do pretty much everything in React using functions.
  prefs: []
  type: TYPE_NORMAL
- en: React State and Life Cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s assume you want a ticking clock to be displayed on your web page (an
    ordinary digital one for simplicity’s sake). If you are using stateless code this
    is not an easy matter, but if you set up your code to retain its state, then the
    clock counter can be updated once per second and the time rendered equally as
    often. This is where you would use a class in React rather than a function. So
    let’s build such a clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code assigns the result returned from calling the `Date` function to the
    `state` property of the constructor’s `this` object, which is `props`. The JSX
    content will now be rendered whenever the class’s `render` function is called,
    and, as long as it is rendered into the same DOM node, only a single instance
    of the class will be used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Did you see the call to `super` at the start of the constructor? By passing
    it `props`, it is now possible to refer to `props` using the `this` keyword within
    the constructor, without which call you could not.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as things stand, the time will be displayed only once, and then the
    code will stop running. So now we need to set up some interrupt-driven code to
    keep the `date` property updated, which is done by adding a *life-cycle* method
    to the class by mounting a timer using `componentDidMount`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We aren’t quite there yet, as we still need to write the `tick` function, but
    first, to explain the preceding: `*mounting*` is the term React uses to describe
    the action of adding nodes to the DOM. A class’s `componentDidMount` method is
    always called if the component is mounted successfully, so it’s the ideal place
    to set up an interrupt, and, indeed, in the preceding code, `this.timerID` is
    assigned the ID returned by calling the `SetInterval` function, passing it the
    method `this.tick` to be called every 1,000 milliseconds (or once per second).
  prefs: []
  type: TYPE_NORMAL
- en: 'When a timer is mounted, we must also provide a means for it to be *unmounted* to
    prevent wasted interrupt cycles. In this case when the DOM produced by `Clock`
    is removed (that is, the component is unmounted), the method and code we use to
    stop the interrupts looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, `componentWillUnmount` is called by React when the DOM is removed; thus,
    this is where we place the code to clear the interval stored in `this.timerID`,
    then return all those time slices back to the system, because clearing the interval
    instantly stops `tick` from being called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of the puzzle is the interrupt-driven code to be called every
    1,000 milliseconds, which is in the method `tick`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here the React `setState` function is called to update the value in the `state`
    property with the latest result of calling the `Date` function once every second.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s look at all this code together in one example, as shown in [Example 24-5](#building-a-clock-in-react).
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-5\. Building a clock in React
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `Clock` class now complete with a constructor, an interrupt starter
    and stopper, a method to update the `state` property using interrupts, and a `render`
    function, all that is now necessary is to call `doRender` to get the whole thing
    ticking away, as smooth as clockwork! The result looks like this in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The clock is automatically updated to screen each time the `setState` function
    is called, because components are rerendered by this function, so you don’t have
    to worry about doing this with your code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After the initial state setup, `setState` is the only legitimate way to update
    state, because simply modifying a state directly will *not* cause a component
    to be rerendered. Remember that the *only* place you can assign `this.state` is
    in the constructor. React may bundle multiple `setState` calls into a single update.
  prefs: []
  type: TYPE_NORMAL
- en: Using Hooks (if You Use Node.js)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are using Node.js (see [nodejs.org](http://nodejs.org/)), you can make
    use of hooks instead of having to rely so much on classes. Node.js is an open
    source server environment that runs JavaScript (and React) directly on the server
    and is a technology that would take several chapters to properly document here,
    but if you are already using it, I wanted you to know that you can also make use
    of React’s new hooks.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks were included as a new addition in React 16.8 to support accessing state
    without having to use a class. They are easy to use and are becoming a growing
    addition to React. If you would like to look into using them, you can get [more
    information online](https://reactjs.org/docs/hooks-intro.html).
  prefs: []
  type: TYPE_NORMAL
- en: Events in React
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, events are named using camelCase, and you use JSX to pass a function
    as the event handler, not a string. Also, React events do not work in exactly
    the same way as native JavaScript events, in that your handlers are passed instances
    of a cross-browser wrapper around the browser’s native event called `syntheticEvent`. The
    reason for this is that React normalizes events to have consistent properties
    across different browsers. Should you need access to the browser event, however,
    you can always use the `nativeEvent` attribute to reach it.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the use of events in React, [Example 24-6](#setting-up-an-event)
    is a simple example of an `onClick` event that removes or redisplays some text
    when clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-6\. Setting up an event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In the constructor of a new class called `Toggle`, an `isVisible` property
    is set to `true` and assigned to `this.state`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then an event handler called `handleClick` is attached to `this` using the
    `bind` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With the constructor finished, the `handleClick` event handler is next. This
    has a single-line command to toggle the state of `isVisible` between `true` and
    `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Last, there’s the call to the `render` method, which returns two elements wrapped
    inside a `<div>`. The reason for this is that render can only return a single
    component (or XML tag), so the two elements are wrapped into a single element
    to satisfy that requirement.
  prefs: []
  type: TYPE_NORMAL
- en: The elements returned are a button, which displays either the text DISPLAY if
    the following text is currently hidden (that is, `isVisible` is set to `false`)
    or HIDE if `isVisible` is set to `true` and the text is currently visible. Following
    this button, some text is displayed underneath if `isVisible` is `true`, otherwise
    nothing is shown (in fact, an empty string is returned, which is the same thing).
  prefs: []
  type: TYPE_NORMAL
- en: 'To decide what button text to display, or whether or not to show the text,
    the ternary operator is used, which you will recall follows the syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done by the single-word expression of the variable `show` (which retrieved
    its value from `this.state.isVisible`). If it evaluates to `true`, then the button
    shows HIDE and the text is displayed, otherwise the button shows DISPLAY and the
    text is not displayed. When loaded into the browser, the result looks like this
    (where `[HIDE]` and `[DISPLAY]` are buttons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'When the button is pressed, it changes to just the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using JSX Over Multiple Lines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although you can split up your JSX across many lines to improve readability,
    as in the previous example, the one thing you may not do is move the parenthesis
    following the `return` command down a line (or anywhere else). It must stay in
    its place following `return` or syntax errors will be reported. The closing parenthesis
    may, however, appear where you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Inline JSX Conditional Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In JSX there is a way to only return XML if a condition is `true`, thus enabling
    conditional rendering. This is achieved by virtue of the fact that `true && expression`
    evaluates to `expression`, while `false && expression` evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, for example, [Example 24-7](#a-conditional-jsx-statement) sets up
    two variables as if they are in part of a game. `this.highScore` is set to 90,
    and `this.currentScore` is set to 100.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-7\. A conditional JSX statement
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In this instance, if `this.currentScore` is greater than `this.highScore`,
    then the `h1` element is returned; otherwise `false` is returned. The result of
    the code looks like this in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Of course, in an actual game you would then proceed to set `this.highScore`
    to the value in `this.currentScore` and would probably do a few other things,
    too, before going back to the game code.
  prefs: []
  type: TYPE_NORMAL
- en: So, wherever something should be displayed only upon a condition being `true`,
    the `&&` operator is a great way to achieve this. And, of course, you have just
    seen (near the end of [“Events in React”](#events-in-react)) how you can also
    create an `if...then...else` block in JSX using a ternary (`?:`) expression.
  prefs: []
  type: TYPE_NORMAL
- en: Using Lists and Keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Displaying lists using React is a breeze. In [Example 24-8](#displaying-a-list)
    the array `cats` contains a list of four types of cat. This is then extracted
    in the following line of code using the `map` function, which iterates through
    the array, returning each item in turn in the variable `cat`. This results in
    each iteration being embedded in a pair of `<li>...<li>` tags and then appended
    to the `listofCats` string.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-8\. Displaying a list
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `doRender` is called, embedding `listofCats` within a pair of `<ul>...</ul>`
    tags, the result of which displays like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Unique Keys
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you had your JavaScript console open when running [Example 24-8](#displaying-a-list) (usually
    by pressing Ctrl Shift J or Option Command J on a Mac), you may have noticed the
    warning message “Each child in a list should have a unique ‘key’ prop.”
  prefs: []
  type: TYPE_NORMAL
- en: Although not necessary, React works best when you supply a unique key for each
    sibling list item, which helps it to find references to the appropriate DOM nodes
    and, when you make a small change, allows for making minor adjustments to the
    DOM, rather than requiring rerendering of larger sections. So [Example 24-9](#using-unique-keys) is
    an example of providing just such a key.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-9\. Using unique keys
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example a `uniqueId` variable has been created that is incremented
    each time it is used so that, for example, the first key will become `1`. The
    displayed output is the same as the previous example, but if you would like to
    see the keys generated (just out of interest), you can change the contents of
    the `li` element from `{cat}` to `{uniqueId - 1 + '' '' + cat}`, and you will
    see the following displayed (the `- 1` is used because `uniqueId` has already
    been incremented by the time it is referred to, so we need to see what the value
    was before incrementing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'But what is the point of this, you may ask? Well, consider the case of the
    following list structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are two sets of lists, each with four unique siblings, but between the
    lists, both the city names of “Birmingham” and “Paris” are shared at the same
    level of nesting. When React performs certain reconciliation actions (after reordering
    or modifying an element perhaps), there are instances when you can achieve speed
    gains and possibly avoid problems when sibling list items at the same level share
    the same values. To do this you can provide unique keys for all siblings, which,
    to React, could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now there is no possibility of confusing Paris in Europe with Paris in the USA
    (or at least of having to work harder to locate and possibly rerender the correct
    DOM node), as each array element has a different unique ID for React.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Don’t worry too much about why you are creating these unique keys. Just remember
    that React works at its best when you do so, and a good rule of thumb is that
    elements within a `map` call will need keys. Also, you can reuse your keys for
    different sets of siblings that are not related in any way. However, you may not
    have to create your own keys because the data you are working with could well
    supply them for you, such as book ISBN numbers. As a last resort, you can simply
    use the index of an item as its key, but reorders could be slow, and you could
    encounter other issues, so creating your own keys so you can control what they
    contain is usually the best option.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In React, `<input type='text'>`, `<textarea>`, and `<select>` all work in a
    similar way because React’s internal state becomes what is known as the “source
    of truth,” and these components are therefore called *controlled*.
  prefs: []
  type: TYPE_NORMAL
- en: With a *controlled component,* the input’s value is always driven by the React
    state. This does mean that you need to write a bit more code in React, but the
    end benefit is that you can then pass values to other UI elements or access them
    from event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, without React or any other framework or library loaded, form elements
    maintain their own state, which is updated based on input received from the user.
    In React, the mutable state is typically kept in the `state` property of components
    and should then only be updated using the `setState` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using Text Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s look at these three input types, starting with a simple text input, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This code requests a string of characters to be input, which is then submitted
    when the Submit button is clicked (or the Enter or Return key pressed). Now let’s
    change this to a controlled React component in [Example 24-10](#using-text-input-react).
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-10\. Using text input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Let me take you through this part by part. First we create a new class called
    `GetName`, which will be used to create a form that will prompt for a name to
    be entered. This class contains two event handlers called `onChange` and `onSubmit`.
    These are local handlers that are set to override the standard JavaScript handlers
    of these same named events by using the calls to `bind` in the constructor, which
    is also the place where the value in `value` is initialized to the empty string.
  prefs: []
  type: TYPE_NORMAL
- en: When called by the `onChange` interrupt, the new `onChange` handler calls the
    `setState` function to update `value` whenever the input is changed, so that `value`
    is always kept up to date with the contents in the input field.
  prefs: []
  type: TYPE_NORMAL
- en: When the `onSubmit` event is triggered, it is handled by the new `onSubmit`
    handler, which in this instance issues a pop-up `alert` window so that we can
    see it has worked. Because *we* are dealing with the event and *not* the system,
    the event is then prevented from bubbling through to the system by calling `preventDefault`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `render` method contains all the HTML code to be rendered into
    the display `<div>`. Of course, we use HTML formatted as XML to do this, as that
    is what Babel expects (namely JSX syntax). In this instance, it simply requires
    the additional self-closing of the input elements with `/>`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have not globally overridden the `onChange` and `onSubmit` events, because
    we have only bound events issued by the rendered code to local event handlers
    within the `GetName` class, so it is safe to use the same names for our event
    handlers, which helps make our code’s purpose more immediately obvious to other
    developers. But if there could ever be the possibility of any doubt, you might
    prefer to use different names for your handlers, such as `actOnSubmit`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: So, as you should see by now, `this.state.value` will always reflect the state
    of the input field because, as stated earlier, with a controlled component, `value`
    is always driven by the React state.
  prefs: []
  type: TYPE_NORMAL
- en: Using textarea
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the ideas behind using React is to maintain cross-browser control over
    the DOM for quick and simple access and also to streamline and simplify the development
    process. By using controlled components, we are in control at all times and can
    make inputting data of all types work in similar ways.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 24-11](#using-textarea-react), the previous example has been modified
    into using a `<textarea>` element for input.
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-11\. Using textarea
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is extremely similar to the text input example, with a few simple
    changes: this class is now called `GetText`, the text input in the `render` method
    is replaced with a `<textarea>` element that has been set to 40 columns wide by
    5 rows high, and a couple of `<br>` elements have been added for formatting. And
    that’s it—nothing else has required changing to enable us to have full control
    over the `<textarea>` input field. As with the previous example, `this.state.value` will
    always reflect the state of the input field.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this type of input supports the use of Enter or Return to input carriage
    returns into the field, so now the input can only be submitted by clicking the
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Using select
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before showing how to use `<select>` in React, let’s first look at a typical
    snippet of HTML code in which a few countries are offered from which the user
    must choose, with USA being the default selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In React this needs to be handled slightly differently because it uses a v`alue`
    attribute on the `select` element instead of the `selected` attribute applied
    to an `option` sub-element, as in [Example 24-12](#using-select-react).
  prefs: []
  type: TYPE_NORMAL
- en: Example 24-12\. Using select
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Once again you will see that very little has changed in this example other than
    the new class name of `GetCountry`, that `this.state.value` is assigned the default
    value of `'USA'`, and that the input type is now a `<select>` but without a `selected`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with the previous two examples, `this.state.value` always reflects the
    state of the input.
  prefs: []
  type: TYPE_NORMAL
- en: React Native
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: React also has a companion product called React Native. With it you can create
    full-blown applications for both iOS and Android phones and tablets, just using
    the JSX extended JavaScript language and without needing to understand Java or
    Kotlin (for Android) or Objective-C or Swift (for iOS).
  prefs: []
  type: TYPE_NORMAL
- en: Full details and explanations of how to do all this and have your apps up and
    running on a wide range of mobile devices are beyond the scope of this book, but
    in this section I show you where to go to get the software and information you
    need.
  prefs: []
  type: TYPE_NORMAL
- en: Creating React Native Apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To develop React Native apps, you will first need to install [Android Studio](http://developer.android.com/studio)
    and the [Java JDK](https://tinyurl.com/getjavajdk)
  prefs: []
  type: TYPE_NORMAL
- en: On a Mac you will additionally need to install Xcode from the App Store. Windows
    users have no easy options other than tricky virtualization or a “Hackintosh”
    to develop iOS apps, so it’s really best to have access to an actual Mac (or hosted
    service) for this.
  prefs: []
  type: TYPE_NORMAL
- en: Then you will need to read the [documentation on Android Studio](https://developer.android.com/docs) until
    you understand how to create an Android Virtual Device (AVD), and set up the various
    environment variables required, such as `ANDROID_HOME`, which should point to
    the installed JDK. Now you need to install Node.JS from [nodejs.org](http://nodejs.org).
  prefs: []
  type: TYPE_NORMAL
- en: Once Node is installed, read up on [the documentation](https://nodejs.org/en/docs/)
    if you don’t already know how to use it. Now you are ready to install React Native
    following the advice given in the [React Native documentation](https://reactnative.dev/docs/environment-setup).
    After this you can then work through the tutorial on [the React website](http://reactnative.dev/docs/getting-started),
    noting the differences between building apps on Windows and on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get this all working (and it can take a while before you properly understand
    everything you are doing and have it all running smoothly), you now have the fantastic
    benefit that you can (mostly) go ahead and develop your apps for both major mobile
    platforms at the same time by just using React JSX code!
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To aid you in your React Native development, here are some online tutorials
    that I feel clearly explain the process (thanks to Pabasara Jayawardhana at Medium,
    Kevin VanGelder at Infinite Red Academy, and Microsoft) and that were all online
    and working at the time of writing (or may be located at [*archive.org*](https://archive.org)
    if not). Of course, if you still need to know more, your favorite search engine
    will have what you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[React Native on Mac OS](https://tinyurl.com/reactnativemac)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[React Native on Windows](https://tinyurl.com/reactnativewindows)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Microsoft’s Guide to React Native](https://microsoft.github.io/react-native-windows/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although the latter of these three refers only to Windows in the URL, the guide
    includes macOS, too.
  prefs: []
  type: TYPE_NORMAL
- en: Taking React to the Next Level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve learned the basics of how to set up and use React, there remains
    a great deal more that you can do with it (especially if you intend to build React
    Native apps with it), which is sadly beyond the scope of this book. So to continue
    your React journey, I recommend you visit the [Reactjs.org web page](https://reactjs.org/docs/hello-world.html)
    as a good starting point, where you can review some of the things discussed here
    before moving on to even more powerful features.
  prefs: []
  type: TYPE_NORMAL
- en: And remember that you can download all the samples from this chapter (and this
    book as a whole) on [GitHub](https://github.com/RobinNixon/lpmj6).
  prefs: []
  type: TYPE_NORMAL
- en: So, with React now in our toolkit (at least enough to get us up and running),
    let’s move on to all the goodies that HTML5 brings us in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the main two ways you can incorporate the React scripts in your web
    page?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is XML incorporated into JavaScript for use with React?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of `<script type="application/javascript">`, what value for `type` should
    you use for your JSX JavaScript code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are two different ways you can extend React to your code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In React, what is meant by pure and impure code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does React keep track of state?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you embed an expression within JSX code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you change the state of a value once a class has been constructed?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What must you first do to enable referring to `props` using the `this` keyword
    within a constructor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create a conditional statement in JSX?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See [“Chapter 24 Answers”](app01_split_023.xhtml#chapter_24_answers) in the
    [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions) for the
    answers to these questions.
  prefs: []
  type: TYPE_NORMAL
