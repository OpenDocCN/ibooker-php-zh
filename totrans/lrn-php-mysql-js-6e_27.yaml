- en: Chapter 24\. Introduction to React
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第24章。React简介
- en: When using JavaScript, HTML, and CSS to build dynamic websites, there comes
    a time that the creation of the code required to handle the frontend of your websites
    and apps can become cumbersome and overly verbose, slowing down the speed of project
    development and potentially leading to the introduction of hard-to-find bugs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JavaScript、HTML和CSS构建动态网站时，随着时间推移，处理网站和应用程序前端所需代码的创建可能会变得冗长且啰嗦，从而降低项目开发速度，并可能引入难以找到的错误。
- en: This is where frameworks come in. Of course, since 2006 there’s been jQuery
    to help us out, and consequently it’s installed on the vast majority of production
    websites, although these days JavaScript has grown sufficiently in scope and flexibility
    that programmers need to rely on frameworks like jQuery a lot less. Also, as time
    marches on the technology continually improves, and now there are a number of
    excellent other options, such as Angular and, as discussed here, my preferred
    favorite, React.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是框架的用武之地。当然，自2006年以来，我们有jQuery来帮助我们，因此它被安装在绝大多数的生产网站上，尽管如今JavaScript在范围和灵活性上已经足够成熟，程序员不再需要过度依赖像jQuery这样的框架。随着技术的不断进步，现在还有许多其他出色的选择，比如Angular和我在这里讨论的我的首选，React。
- en: jQuery was designed to simplify HTML DOM tree traversal and manipulation, as
    well as event handling, CSS animation, and Ajax, but some programmers, such as
    the development team at Google, felt it still wasn’t powerful enough, and they
    came up with Angular JS in 2010, which evolved into Angular in 2016.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery的设计目的是简化HTML DOM树的遍历和操作，以及事件处理、CSS动画和Ajax，但是一些程序员，比如谷歌的开发团队，认为它仍然不够强大，因此他们在2010年推出了Angular
    JS，这在2016年演变为Angular。
- en: Angular uses a hierarchy of components as its primary architectural characteristic,
    rather than using “scope” or controllers (like Angular). Google’s massive AdWords
    platform is powered by Angular, as are Forbes, Autodesk, Indiegogo, UPS, and many
    others, and it is indeed extremely powerful.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Angular将组件层次结构作为其主要的架构特征，而不是像Angular那样使用“scope”或控制器。谷歌庞大的AdWords平台以及Forbes、Autodesk、Indiegogo、UPS等公司都在使用Angular，它确实非常强大。
- en: Facebook, on the other hand, had a different vision and came up with React (also
    known as React JS) as its framework for the development of single-page or mobile
    applications, basing it around the JSX extension (which stands for JavaScript
    XML). The React Library (first developed in 2012) divides a web page into single
    components, simplifying the development of the interface required to serve all
    of Facebook’s advertising and more, and it is now widely adopted by platforms
    across the web, such as Dropbox, Cloudflare, Airbnb, Netflix, the BBC, PayPal,
    and many more household names.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Facebook则有不同的愿景，推出了React（也称为React JS）作为其开发单页或移动应用程序的框架，并围绕JSX扩展（代表JavaScript
    XML）构建。React库（首次开发于2012年）将网页划分为单一组件，简化了开发所需的接口，以服务于Facebook所有的广告及更多内容，现在它被网上的各种平台广泛采用，如Dropbox、Cloudflare、Airbnb、Netflix、BBC、PayPal等众多知名企业。
- en: Clearly, both Angular and React were driven in their creation and design by
    solid commercial decisions and were built to handle extremely high-traffic web
    pages, where it was felt that jQuery simply did not have the oomph the developers
    were looking for.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Angular和React在它们的创作和设计过程中都受到了坚实的商业决策的驱动，并且它们都是为了处理极高流量的网页而构建的，而jQuery在开发者寻求的功能方面显得力不从心。
- en: Therefore, nowadays, as well as knowing the core technologies of JavaScript,
    HTML, CSS, a server-side language such as PHP, and a database such as MySQL, programmers
    still may find it handy to at least know a little jQuery and at least one (if
    not both) of Angular and React, and possibly other frameworks that also have their
    followings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如今，除了要了解JavaScript、HTML、CSS等核心技术，还应该掌握一些jQuery以及至少了解Angular和React其中之一（如果不是两者都要），以及可能其他一些也有自己追随者的框架，这对程序员来说可能会很有用。
- en: However, for reasons of ease of use, a not-too-steep learning curve, and general
    implementation, and also because Google Trends shows it to be the framework of
    most popular interest of the three (see [Figure 24-1](#recent-popularity-of-jquery)),
    I decided it was more important to introduce you to React. By the way, please
    don’t confuse the similarly named ReactPHP with React for JavaScript, as it is
    an entirely separate and unconnected project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，基于易用性、学习曲线不陡、普遍实施以及因 Google 趋势显示它是三者中最受欢迎的框架（见[图 24-1](#recent-popularity-of-jquery)），我决定向你介绍
    React 更为重要。顺便说一句，请不要将同名的 ReactPHP 与 JavaScript 的 React 混淆，它们是完全独立且不相关的项目。
- en: What Is the Point of React Anyway?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React 究竟有什么意义？
- en: React allows developers to create large web applications that can easily handle
    and change data, without reloading the web page. Its main raisons d'être are speed,
    scalability, and simplicity in handling the view layer of single-page web and
    mobile applications. It also enables the creation of reusable UI components and
    manages a virtual DOM for increased performance. Some people have been quoted
    as saying you can use it as the V in the MVC (Model, View, Controller) architecture
    that separates applications into three components.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: React 允许开发者创建能够轻松处理和改变数据而无需重新加载网页的大型 Web 应用程序。它的主要存在理由是速度、可扩展性以及简化处理单页 Web 和移动应用程序的视图层。它还能创建可重用的
    UI 组件，并管理虚拟 DOM 以提升性能。有人曾说过，你可以将其用作将应用程序分成三个组件（模型、视图、控制器）中的 V（视图）。
- en: Instead of developers having to come up with various ways to describe transactions
    on interfaces, they can simply describe the interfaces in terms of a final state,
    such that when transactions happen to that state, React updates the UI for you.
    The net results are faster, less buggy development; speed; reliability; and scalability.
    Because React is a library and not a framework, learning it is also quick, with
    just a few functions to master. After that, it’s all down to your JavaScript skills.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者无需费力找出各种描述接口交易的方式，只需描述最终状态下的接口，使得当交易发生在该状态时，React 会自动更新 UI。其结果是更快、更少 bug
    的开发；速度、可靠性和可扩展性。因为 React 是一个库而不是框架，学习它也很快，只需掌握几个函数。之后，一切都取决于你的 JavaScript 技能。
- en: So let’s get started with how to access React files.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始学习如何访问 React 文件。
- en: '![](Images/pmj6_2401.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pmj6_2401.png)'
- en: Figure 24-1\. Recent popularity of jQuery, Angular, and React according to Google
    Trends
  id: totrans-14
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 24-1\. 根据 Google 趋势，最近 jQuery、Angular 和 React 的受欢迎程度
- en: Note
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: I think jQuery is great, but I also find React very easy to use, and I suppose
    time will tell whether I’m right in my suspicion that React could eventually replace
    jQuery as the dominant framework, certainly for handling the UI, because it’s
    simply so much richer. But even if it doesn’t, by learning React you will still
    have an incredibly powerful new tool at your disposal, which many top companies
    will be looking for on your resume. And don’t dismiss Angular, either. Had there
    been room in this book, I would have covered it too, because it’s definitely worth
    understanding for debugging and maintenance of existing code, even if you don’t
    develop using it. You can learn all about it at [https://angular.io](https://angular.io)
    (and it will also look great on your resume).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我觉得 jQuery 很棒，但我也发现 React 非常易于使用，我认为时间会证明我对 React 最终能否取代 jQuery 成为主导框架（尤其是处理
    UI 方面）的猜测是否正确。即使不是这样，学习 React 仍将使你掌握一种非常强大的新工具，许多顶级公司都会在你的简历上看重它。同时也不要忽视 Angular。如果这本书的篇幅足够，我也会介绍
    Angular，因为了解它对于调试和维护现有代码非常重要，即使你不使用它开发。你可以在 [https://angular.io](https://angular.io)
    找到关于 Angular 的所有信息（这也会让你的简历更上一层楼）。
- en: Accessing the React Files
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 React 文件
- en: Like jQuery and Angular, React is open source and entirely free to use. Also
    like these other frameworks, there are a number of services on the web that will
    serve the latest (or any) version up for you free of charge, so using it can be
    as easy as placing a couple of extra lines of code in your web page.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 像 jQuery 和 Angular 一样，React 是开源的，完全免费使用。也像其他框架一样，在网上有许多服务可以免费为你提供最新（或任何版本）的文件，因此使用它可以像在你的网页中添加几行额外的代码一样简单。
- en: 'Before examining what you can do with React and how to use it, here’s how you
    include it in a web page, pulling the files from *unpkg.com*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨 React 的功能和如何使用它之前，先了解如何将其包含在网页中，从 *unpkg.com* 拉取文件：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'These lines should ideally be placed within the `<head>...</head>` section
    of a page to ensure they are loaded before the body section. They load in the
    development versions of React and React DOM to aid you with development and debugging.
    On a production website, you should replace the word `development` with `production`
    in these URLs, and, to speed up transfer, you can even change `development` to
    `production.min`, which will call up compressed versions of the files, like this:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行理想情况下应放在页面的 `<head>...</head>` 部分，以确保它们在 body 部分加载之前加载。它们加载了 React 和 React
    DOM 的开发版本，帮助你进行开发和调试。在生产网站上，你应该将这些 URL 中的单词 `development` 替换为 `production`，为了加快传输速度，你甚至可以将
    `development` 改为 `production.min`，这样会调用压缩版本的文件，像这样：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For ease of access and to make the code as brief as possible, I have downloaded
    the latest (version 17 as I write) of the uncompressed development files to the
    accompanying archive of examples for this book (on [GitHub](https://github.com/RobinNixon/lpmj6))
    so that all the examples will load locally and look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便访问并尽可能简化代码，我已经从本书示例的伴随存档中下载了最新的（我写作时是版本 17）未压缩开发文件的版本（在[GitHub](https://github.com/RobinNixon/lpmj6)上），因此所有示例都可以本地加载，看起来像这样：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that React is available to your code, what next? Well, although it is not
    strictly necessary, next we pull in the Babel JSX extension, which allows you
    to include XML text directly within JavaScript, making your life much easier.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用 React 编写代码了，接下来呢？虽然这不是必需的，我们接下来引入 Babel JSX 扩展，这样你就可以直接在 JavaScript
    中包含 XML 文本，使你的生活变得更加轻松。
- en: Including babel.js
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包含 babel.js
- en: The Babel JSX extension adds the ability for you to use XML (very similar to
    HTML) directly within your JavaScript, saving you from having to call a function
    each time. In addition, on browsers that have earlier versions of ECMAScript (the
    official standard of JavaScript) than 6, Babel upgrades them to handle ES6 syntax,
    so it provides two great benefits in one go.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Babel JSX 扩展允许你直接在 JavaScript 中使用类似 HTML 的 XML，而不需要每次都调用一个函数。此外，在早期版本的 ECMAScript（JavaScript
    的官方标准）低于 6 的浏览器上，Babel 将其升级以处理 ES6 语法，因此一举提供了两大好处。
- en: 'Once again you can pull the file needed from the *unpkg.com* server, like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再次从 *unpkg.com* 服务器上获取所需的文件，就像这样：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You require only the one minimized version of the Babel code on either a development
    or a production server. For convenience I have also downloaded the latest version
    to the companion archive of example files, so examples in this book load locally
    and look like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需要在开发或生产服务器上获取一个精简版本的 Babel 代码。为了方便起见，我还从示例文件的伴随存档中下载了最新版本，因此本书中的示例可以本地加载，看起来像这样：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we can access the React files, let’s get on with doing something with
    them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以访问 React 文件了，让我们开始做些实际的事情。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This chapter is intended to teach you the basics of using React to give you
    a clear understanding of how and why it works and to provide you with a good starting
    point to take your React development further. Indeed, some of the examples in
    this chapter are based on (or similar to) examples you can find in the official
    documentation at the [reactjs.org](http://reactjs.org) website so that, should
    you wish to learn React in greater depth, you can visit the website and will be
    off to a running start.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在教你使用 React 的基础知识，让你清楚地理解它的工作原理和意义，并为你提供一个良好的起点，以便进一步发展你的 React 开发。事实上，本章中的一些示例基于（或类似于）你可以在
    [reactjs.org](http://reactjs.org) 官方文档中找到的示例，因此，如果你希望更深入地学习 React，可以访问该网站，将会有一个良好的起步。
- en: Our First React Project
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个 React 项目
- en: Rather than teaching you all about React and JSX before actually setting about
    coding, let’s approach it from the other angle and show how easy everything is
    by jumping right into our first React project, as shown in [Example 24-1](#our-first-react-project),
    the result of which is to simply display the text “By Jeeves, it works!” in the
    browser.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在实际编码之前教你所有有关 React 和 JSX 的知识，让我们换个角度，通过直接跳入我们的第一个 React 项目来展示一切有多简单，如[示例 24-1](#our-first-react-project)所示，其结果仅在浏览器中显示文本“By
    Jeeves, it works!”。
- en: Example 24-1\. Our first React project
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 24-1\. 我们的第一个 React 项目
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This is a standard HTML5 document, which loads in the two React scripts and
    the Babel script before opening an inline script. Here is where we first need
    to pay attention because, instead of not specifying a type to the `script` tag,
    or using `type=application/javascript`, the tag is given `type=text/babel`. This
    lets the browser know to allow the Babel preprocessor to run through the script,
    add ES6 functionality to it if necessary, and replace any XML encountered with
    JavaScript function calls, and only then to run the contents of the script as
    JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的 HTML5 文档，在打开内联脚本之前加载了两个 React 脚本和 Babel 脚本。这里是我们首次需要注意的地方，因为 `script`
    标签不是不指定类型，也不是使用 `type=application/javascript`，而是给定了 `type=text/babel`。这告诉浏览器允许
    Babel 预处理器运行脚本，必要时添加 ES6 功能，并将遇到的任何 XML 替换为 JavaScript 函数调用，然后再将脚本内容作为 JavaScript
    运行。
- en: 'Within the script, a new class name, `One`, is created, extending the `React.component`
    class. Within the class, a `render` method is created, which returns the following
    XML (not a string):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，创建了一个名为`One`的新类，扩展了`React.component`类。在这个类内部，创建了一个`render`方法，它返回以下 XML（不是字符串）：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, within the script, the `render` function of the `One` class is called,
    passing it the ID of the only `<div>` element in the body of the document, which
    has been given the ID of `div1`. The result is to render the XML into the div,
    which causes the browser to automatically update and display the contents, which
    looks like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在脚本中调用了 `One` 类的 `render` 函数，向它传递了文档主体中唯一 `<div>` 元素的 ID，该元素的 ID 被命名为 `div1`。结果是将
    XML 渲染到 div 中，这会导致浏览器自动更新并显示内容，效果如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Immediately you should see how including the XML within the JavaScript makes
    for much easier and faster-to-write code and makes it easier to understand too.
    Without the JSX extension, you would have to do all this using a sequence of JavaScript
    function calls.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 立即你应该看到在 JavaScript 中包含 XML 如何使得编写代码更加简单和快速，并且使其更容易理解。如果没有 JSX 扩展，你将不得不使用一系列
    JavaScript 函数调用来完成所有这些工作。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: React treats components starting with lowercase letters as DOM tags. Therefore,
    for example, `<div />` represents an HTML `<div>` tag, but `<One />` represents
    a component and requires `One` to be in scope—you cannot use `one` (with a lowercase
    `o`) in the previous example and expect your code to work, as the component needs
    to start with uppercase and so does any reference to it.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: React 将以小写字母开头的组件视为 DOM 标签。因此，例如，`<div />` 表示 HTML 的 `<div>` 标签，但 `<One />`
    表示一个组件，并且需要 `One` 在作用域内 —— 你不能像之前的例子中使用小写字母 `one` 并期望你的代码能工作，因为组件的名称必须以大写字母开头，任何对它的引用也是如此。
- en: Using a Function Instead of a Class
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数而不是类
- en: If you prefer, and as is becoming the more common practice, you can use a function
    for your code instead of placing it in a class with a `render` function, as in
    [Example 24-2](#using-a-function-instead). The main reasons you may prefer to
    do this are simplicity, ease of use, and faster development.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，并且作为越来越普遍的做法，你可以使用一个函数来编写你的代码，而不是将它放在带有 `render` 函数的类中，就像在 [Example 24-2](#using-a-function-instead)
    中一样。你可能更喜欢这样做的主要原因是简单性、易用性和更快的开发速度。
- en: Example 24-2\. Using a function instead of a class
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 24-2\. 使用函数而不是类
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The displayed result of this in the browser is:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中显示的结果是：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'In the examples that follow from this point onward, for the sake of brevity
    and simplicity, I will show only the contents of the Babel script and the body
    of the document as if they were both in the body (which works just the same),
    but the examples in the companion archive *will* be complete. So they will look
    like this from now on:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始的示例中，为了简洁起见，我将只显示 Babel 脚本的内容和文档主体，好像它们都在主体中（这样也同样有效），但附带存档中的示例 *将* 是完整的。因此，从现在开始它们看起来是这样的：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Pure and Impure Code: A Golden Rule'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 纯函数与不纯函数的黄金法则
- en: 'When you write a normal JavaScript function, it is possible to write either
    what React calls *pure* or *impure* code. Pure function code does not change its
    inputs, as in the following, which returns a value calculated from its arguments:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当你写一个普通的 JavaScript 函数时，可以写出 React 称为 *pure* 或 *impure* 的代码。纯函数代码不会改变其输入，就像下面的这个例子，它返回从其参数计算得到的值：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, this function is considered impure because it modifies an argument
    and is absolutely not allowed when using React:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个函数被认为是不纯的，因为它修改了一个参数，在使用 React 时绝对不允许：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Expressed as a golden rule, this means that all React components must act like
    pure functions with respect to their props, as explained at [“Props and Components”](#props-and-components).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以黄金规则的形式表达，这意味着所有React组件必须在其props方面像纯函数一样操作，正如在[“属性和组件”](#props-and-components)中解释的那样。
- en: Using Both a Class and a Function
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同时使用类和函数
- en: You can, of course, use functions and classes pretty much interchangeably (although
    there are differences between them, which I explain later in [“The Differences
    Between Using a Class and a Function”](#the-differences-between-class-function)),
    as in [Example 24-3](#using-both-classes-and).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以几乎可以互换地使用函数和类（尽管它们之间有一些区别，稍后在[“使用类和函数的区别”](#the-differences-between-class-function)中会进行解释），就像在[示例 24-3](#using-both-classes-and)中一样。
- en: Example 24-3\. Using both classes and functions
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 24-3\. 同时使用类和函数
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here there is a class named `One` and a function named `Two`, which are the
    same as in the previous two examples. There is an additional difference, though—the
    creation of a new function called `doRender`—which considerably shortens the syntax
    of the call required to render a block of XML. The result of running this displays
    in the browser as:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个名为`One`的类和一个名为`Two`的函数，它们与前两个示例中的相同。不过，这里还有一个额外的区别——创建了一个称为`doRender`的新函数——它大大简化了呈现XML块所需的语法。运行结果在浏览器中显示为：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In addition to leaving out the surrounding HTML code of the following examples,
    I will also leave out the code for the `doRender` function to save needlessly
    repeating it many times over. So when you see a call to the `doRender` function
    in these examples, remember that it is not a built-in React function but is a
    function included in the full examples in the companion archive.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 除了以下示例中的周围HTML代码，我也将不再重复出现`doRender`函数的代码。因此，当你在这些示例中看到对`doRender`函数的调用时，请记住它不是React的内置函数，而是包含在配套档案中的函数。
- en: Props and Components
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性和组件
- en: A great way to introduce you to what React calls *props* and *components* is
    to build a simple welcome page in which a name is passed to the script and then
    displayed. [Example 24-4](#passing-props-to-a-function)  is one way to do that. Components
    let you split the UI into separate, reusable parts and work with each part in
    isolation. They are similar to JavaScript functions and accept arbitrary inputs
    that are called *props*, returning React elements that describe how elements should
    appear in the browser.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 介绍React称为*props*和*components*的一种绝佳方式，是构建一个简单的欢迎页面，其中将一个名称传递给脚本，然后显示出来。[示例 24-4](#passing-props-to-a-function) 是实现这一目标的一种方式。组件允许您将UI拆分为单独的、可重用的部分，并在隔离的环境中处理每个部分。它们类似于JavaScript函数，接受称为*props*的任意输入，返回描述元素在浏览器中如何显示的React元素。
- en: Example 24-4\. Passing `props` to a function
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 24-4\. 将`props`传递给函数
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, the `Welcome` function receives an argument of `props`, which
    stands for properties, and within its JSX `return` statement there is a section
    inside curly braces that fetches the `name` property from the `props` object,
    like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`Welcome`函数接收一个`props`参数，代表属性，在其JSX的`return`语句中有一个花括号内的部分，从`props`对象中获取了`name`属性，像这样：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`props` is an object in React, and next you will see one way to populate it
    with a property.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`props`是React中的一个对象，接下来你将看到一种将其填充为属性的方法。'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Using curly braces is how you can embed expressions within JSX. In fact, you
    can place almost any JavaScript expression inside these curly braces and it will
    be evaluated (with the exception of `for` and `if` statements, which cannot be
    evaluated).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用花括号是在JSX中嵌入表达式的方法。实际上，你几乎可以将任何JavaScript表达式放在这些花括号中进行评估（除了`for`和`if`语句，这些不能被评估）。
- en: So, in place of `props.name` in this example, you could enter `76 / 13` or `"decode".substr(-4)`
    (which would evaluate to the string `"code"`). In this instance, however, the
    property `name` is retrieved from the `props` object and returned.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，你可以输入`76 / 13`或`"decode".substr(-4)`来代替`props.name`（这将评估为字符串`"code"`）。但是，在这种情况下，属性`name`是从`props`对象中获取并返回的。
- en: 'Finally, the `doRender` function (which you will remember is a shorthand call
    leading to the `ReactDOM.render` function) is passed the name of the `Welcome` function,
    followed by assigning the string value `''Robin''` to its `name` property, like
    this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`doRender`函数（你会记得它是一个调用`ReactDOM.render`函数的简写）被传入了`Welcome`函数的名称，接着将字符串值`'Robin'`分配给它的`name`属性，就像这样：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'React then calls the `Welcome` function (also called a *component*), passing
    it `{name: ''Robin''}` in `props`. `Welcome` then evaluates and returns `<h1>Hello,
    Robin</h1>` as its result, which is then rendered into the `div` called `hello` and
    renders in the browser like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '然后React调用`Welcome`函数（也称为*组件*），将`{name: ''Robin''}`传递给它的`props`。然后`Welcome`评估并返回`<h1>Hello,
    Robin</h1>`作为其结果，然后渲染到名为`hello`的`div`中，并在浏览器中呈现如下：'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To make your code tidier you can also, if you wish, first create an element
    containing the XML to pass to `doRender`, like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要使您的代码更整洁，如果愿意，您还可以首先创建一个包含XML的元素传递给`doRender`的方法，就像这样：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The Differences Between Using a Class and a Function
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类和函数的区别
- en: The most obvious difference between using a class and a function in React is
    the syntax. A function is simple JavaScript (possibly incorporating JSX), which
    can accept a props argument and return a component element.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中使用类和函数最明显的区别是语法。函数是简单的JavaScript（可能包含JSX），可以接受props参数并返回一个组件元素。
- en: A class, however, is extended from `React.Component` and requires a `render`
    method to return a component. But this additional code does come with benefits,
    in that a class allows you to use `setState` in your component, enabling (for
    example) the use of timers and other stateful features. Functions in React are
    called *functional stateless component*s. Additionally, classes allow you to use
    what React calls *life-cycle hooks and methods*. More on all of this in the following
    section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类是从`React.Component`扩展的，需要一个`render`方法来返回一个组件。但是这些额外的代码确实带来了好处，因为类允许你在组件中使用`setState`，从而实现（例如）使用定时器和其他状态特性。在React中，函数被称为*功能状态无关组件*。此外，类允许您使用React称为*生命周期挂钩和方法*。在接下来的部分中详细讨论所有这些内容。
- en: In essence, nowadays you can do pretty much everything in React using functions.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，现在你可以使用函数在React中做几乎所有的事情。
- en: React State and Life Cycle
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React状态和生命周期
- en: 'Let’s assume you want a ticking clock to be displayed on your web page (an
    ordinary digital one for simplicity’s sake). If you are using stateless code this
    is not an easy matter, but if you set up your code to retain its state, then the
    clock counter can be updated once per second and the time rendered equally as
    often. This is where you would use a class in React rather than a function. So
    let’s build such a clock:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望在网页上显示一个滴答作响的时钟（出于简单起见，使用普通数字时钟）。如果您使用无状态的代码，这不是一件容易的事情，但如果您设置代码以保留其状态，那么时钟计数器可以每秒更新一次，并且时间也可以同样频繁地渲染。这就是您在React中使用类而不是函数的地方。因此，让我们构建这样一个时钟：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code assigns the result returned from calling the `Date` function to the
    `state` property of the constructor’s `this` object, which is `props`. The JSX
    content will now be rendered whenever the class’s `render` function is called,
    and, as long as it is rendered into the same DOM node, only a single instance
    of the class will be used.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将从调用`Date`函数返回的结果分配给构造函数的`this`对象的`state`属性，即`props`。只要调用了类的`render`函数，JSX内容就会被渲染，只会使用类的单个实例，只要它被渲染到相同的DOM节点。
- en: Note
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Did you see the call to `super` at the start of the constructor? By passing
    it `props`, it is now possible to refer to `props` using the `this` keyword within
    the constructor, without which call you could not.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否看到构造函数开头的`super`调用？通过将其传递给`props`，现在可以在构造函数内使用`this`关键字引用`props`，否则无法使用。
- en: 'However, as things stand, the time will be displayed only once, and then the
    code will stop running. So now we need to set up some interrupt-driven code to
    keep the `date` property updated, which is done by adding a *life-cycle* method
    to the class by mounting a timer using `componentDidMount`, like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就目前而言，时间将仅显示一次，然后代码将停止运行。因此，现在我们需要设置一些中断驱动的代码来保持`date`属性的更新，通过添加一个*生命周期*方法到类中，通过使用`componentDidMount`挂载一个定时器，就像这样：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We aren’t quite there yet, as we still need to write the `tick` function, but
    first, to explain the preceding: `*mounting*` is the term React uses to describe
    the action of adding nodes to the DOM. A class’s `componentDidMount` method is
    always called if the component is mounted successfully, so it’s the ideal place
    to set up an interrupt, and, indeed, in the preceding code, `this.timerID` is
    assigned the ID returned by calling the `SetInterval` function, passing it the
    method `this.tick` to be called every 1,000 milliseconds (or once per second).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成，因为我们仍然需要编写 `tick` 函数，但首先，解释前述内容：`*mounting*` 是 React 用来描述将节点添加到 DOM
    的操作。如果组件成功挂载，类的 `componentDidMount` 方法将始终被调用，因此这是设置中断的理想位置，在前述代码中，`this.timerID`
    被赋予调用 `SetInterval` 函数返回的 ID，传递给 `this.tick` 方法，以便每隔 1,000 毫秒（或每秒一次）调用它。
- en: 'When a timer is mounted, we must also provide a means for it to be *unmounted* to
    prevent wasted interrupt cycles. In this case when the DOM produced by `Clock`
    is removed (that is, the component is unmounted), the method and code we use to
    stop the interrupts looks like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装定时器时，我们还必须提供一个方法来 *卸载* 它，以防止浪费中断周期。在这种情况下，当 `Clock` 生成的 DOM 被移除（即组件被卸载）时，我们用于停止中断的方法和代码如下所示：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, `componentWillUnmount` is called by React when the DOM is removed; thus,
    this is where we place the code to clear the interval stored in `this.timerID`,
    then return all those time slices back to the system, because clearing the interval
    instantly stops `tick` from being called.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当 DOM 被移除时 React 会调用 `componentWillUnmount`；因此，我们在这里放置清除 `this.timerID`
    中存储的间隔的代码，然后将所有这些时间片段返回给系统，因为清除间隔会立即停止 `tick` 的调用。
- en: 'The last piece of the puzzle is the interrupt-driven code to be called every
    1,000 milliseconds, which is in the method `tick`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个谜题的一部分是每隔 1,000 毫秒调用一次的中断驱动代码，它位于 `tick` 方法中：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here the React `setState` function is called to update the value in the `state`
    property with the latest result of calling the `Date` function once every second.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这里调用了 React 的 `setState` 函数，以更新 `state` 属性的值，该值是调用 `Date` 函数的最新结果，每秒钟调用一次。
- en: So let’s look at all this code together in one example, as shown in [Example 24-5](#building-a-clock-in-react).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起看一个示例中的所有代码，如 [示例 24-5](#building-a-clock-in-react) 所示。
- en: Example 24-5\. Building a clock in React
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 24-5\. 在 React 中构建时钟
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With the `Clock` class now complete with a constructor, an interrupt starter
    and stopper, a method to update the `state` property using interrupts, and a `render`
    function, all that is now necessary is to call `doRender` to get the whole thing
    ticking away, as smooth as clockwork! The result looks like this in the browser:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `Clock` 类已经完成，包括构造函数、中断启动和停止器、使用中断更新 `state` 属性的方法以及 `render` 函数，现在唯一需要做的就是调用
    `doRender`，使整个时钟运行如图所示在浏览器中：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The clock is automatically updated to screen each time the `setState` function
    is called, because components are rerendered by this function, so you don’t have
    to worry about doing this with your code.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `setState` 函数时，时钟都会自动更新到屏幕，因为组件通过这个函数重新渲染，所以您不必担心在代码中执行此操作。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: After the initial state setup, `setState` is the only legitimate way to update
    state, because simply modifying a state directly will *not* cause a component
    to be rerendered. Remember that the *only* place you can assign `this.state` is
    in the constructor. React may bundle multiple `setState` calls into a single update.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始状态设置后，`setState` 是更新状态的唯一合法方式，因为简单地直接修改状态不会导致组件重新渲染。请记住，您唯一可以在构造函数中分配 `this.state`
    的地方。React 可能会将多个 `setState` 调用捆绑成单个更新。
- en: Using Hooks (if You Use Node.js)
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Hooks（如果您使用 Node.js）
- en: If you are using Node.js (see [nodejs.org](http://nodejs.org/)), you can make
    use of hooks instead of having to rely so much on classes. Node.js is an open
    source server environment that runs JavaScript (and React) directly on the server
    and is a technology that would take several chapters to properly document here,
    but if you are already using it, I wanted you to know that you can also make use
    of React’s new hooks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 Node.js（参见 [nodejs.org](http://nodejs.org/)），您可以使用 hooks 而不必过多依赖类。Node.js
    是一个在服务器上直接运行 JavaScript（和 React）的开源服务器环境，这是一个需要多个章节才能适当记录的技术，但如果您已经在使用它，我想告诉您，您也可以利用
    React 的新 hooks。
- en: Hooks were included as a new addition in React 16.8 to support accessing state
    without having to use a class. They are easy to use and are becoming a growing
    addition to React. If you would like to look into using them, you can get [more
    information online](https://reactjs.org/docs/hooks-intro.html).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks是React 16.8的一个新加入的功能，它支持在不使用类的情况下访问状态。它们易于使用，并且正在成为React的一个增长点。如果你想了解如何使用它们，你可以在线获取[更多信息](https://react.docs.org/hooks-intro.html)。
- en: Events in React
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React中的事件
- en: In React, events are named using camelCase, and you use JSX to pass a function
    as the event handler, not a string. Also, React events do not work in exactly
    the same way as native JavaScript events, in that your handlers are passed instances
    of a cross-browser wrapper around the browser’s native event called `syntheticEvent`. The
    reason for this is that React normalizes events to have consistent properties
    across different browsers. Should you need access to the browser event, however,
    you can always use the `nativeEvent` attribute to reach it.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，事件使用驼峰命名，并且你使用JSX来将函数作为事件处理程序传递，而不是字符串。此外，React事件的工作方式与原生JavaScript事件并不完全相同，因为你的处理程序是通过称为`syntheticEvent`的浏览器本地事件的跨浏览器包装实例传递的。这样做的原因是React标准化事件以在不同浏览器中具有一致的属性。然而，如果你需要访问浏览器事件，你可以始终使用`nativeEvent`属性来获取它。
- en: To illustrate the use of events in React, [Example 24-6](#setting-up-an-event)
    is a simple example of an `onClick` event that removes or redisplays some text
    when clicked.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在React中使用事件的用法，[示例 24-6](#setting-up-an-event)是一个简单的`onClick`事件的例子，当点击时移除或重新显示一些文本。
- en: Example 24-6\. Setting up an event
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 24-6\. 设置一个事件
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the constructor of a new class called `Toggle`, an `isVisible` property
    is set to `true` and assigned to `this.state`, like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`Toggle`的新类的构造函数中，设置了一个名为`isVisible`的属性为`true`并分配给`this.state`，如下所示：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then an event handler called `handleClick` is attached to `this` using the
    `bind` method:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一个名为`handleClick`的事件处理程序使用`bind`方法附加到`this`：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'With the constructor finished, the `handleClick` event handler is next. This
    has a single-line command to toggle the state of `isVisible` between `true` and
    `false`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数完成后，接下来是`handleClick`事件处理程序。这有一个单行命令来在`isVisible`之间切换`true`和`false`的状态：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Last, there’s the call to the `render` method, which returns two elements wrapped
    inside a `<div>`. The reason for this is that render can only return a single
    component (or XML tag), so the two elements are wrapped into a single element
    to satisfy that requirement.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个调用`render`方法的地方，它返回两个元素包装在`<div>`中。这样做的原因是render方法只能返回单个组件（或XML标签），所以这两个元素被包装成一个单一元素以满足该要求。
- en: The elements returned are a button, which displays either the text DISPLAY if
    the following text is currently hidden (that is, `isVisible` is set to `false`)
    or HIDE if `isVisible` is set to `true` and the text is currently visible. Following
    this button, some text is displayed underneath if `isVisible` is `true`, otherwise
    nothing is shown (in fact, an empty string is returned, which is the same thing).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的元素是一个按钮，如果以下文本当前隐藏（即`isVisible`设置为`false`），则显示文本DISPLAY，否则如果`isVisible`设置为`true`且文本当前可见，则显示文本HIDE。在此按钮之后，如果`isVisible`为`true`，则显示一些文本，否则不显示任何内容（实际上返回空字符串，这是相同的事情）。
- en: 'To decide what button text to display, or whether or not to show the text,
    the ternary operator is used, which you will recall follows the syntax:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了决定显示什么按钮文本，或者是否显示文本，使用了三元运算符，你可以回忆起其语法如下：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is done by the single-word expression of the variable `show` (which retrieved
    its value from `this.state.isVisible`). If it evaluates to `true`, then the button
    shows HIDE and the text is displayed, otherwise the button shows DISPLAY and the
    text is not displayed. When loaded into the browser, the result looks like this
    (where `[HIDE]` and `[DISPLAY]` are buttons):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过单词表达式`show`（其值从`this.state.isVisible`获取）完成的。如果评估为`true`，则按钮显示HIDE并显示文本，否则按钮显示DISPLAY并且文本不显示。加载到浏览器中时，结果如下（其中`[HIDE]`和`[DISPLAY]`是按钮）：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'When the button is pressed, it changes to just the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被按下时，它只改变为以下内容：
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using JSX Over Multiple Lines
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多行上使用JSX
- en: Although you can split up your JSX across many lines to improve readability,
    as in the previous example, the one thing you may not do is move the parenthesis
    following the `return` command down a line (or anywhere else). It must stay in
    its place following `return` or syntax errors will be reported. The closing parenthesis
    may, however, appear where you wish.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以将你的JSX跨多行拆分以提高可读性，就像前面的例子一样，但你不能将跟随`return`命令的括号移到下一行（或任何其他地方）。它必须留在跟在`return`后面的位置，否则将报告语法错误。然而，关闭括号可以出现在你希望的位置。
- en: Inline JSX Conditional Statements
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联JSX条件语句
- en: In JSX there is a way to only return XML if a condition is `true`, thus enabling
    conditional rendering. This is achieved by virtue of the fact that `true && expression`
    evaluates to `expression`, while `false && expression` evaluates to `false`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSX中，如果条件为`true`，则只返回XML，从而实现条件渲染。这是因为`true && expression`评估为`expression`，而`false
    && expression`评估为`false`。
- en: Therefore, for example, [Example 24-7](#a-conditional-jsx-statement) sets up
    two variables as if they are in part of a game. `this.highScore` is set to 90,
    and `this.currentScore` is set to 100.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，例如，[Example 24-7](#a-conditional-jsx-statement)将两个变量设置为游戏的一部分。`this.highScore`设置为90，`this.currentScore`设置为100。
- en: Example 24-7\. A conditional JSX statement
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 24-7\. 一个条件性的JSX语句
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In this instance, if `this.currentScore` is greater than `this.highScore`,
    then the `h1` element is returned; otherwise `false` is returned. The result of
    the code looks like this in the browser:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果`this.currentScore`大于`this.highScore`，则返回`h1`元素；否则返回`false`。代码的结果在浏览器中看起来像这样：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Of course, in an actual game you would then proceed to set `this.highScore`
    to the value in `this.currentScore` and would probably do a few other things,
    too, before going back to the game code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在实际游戏中，你将继续将`this.highScore`设置为`this.currentScore`的值，并可能在返回游戏代码之前执行一些其他操作。
- en: So, wherever something should be displayed only upon a condition being `true`,
    the `&&` operator is a great way to achieve this. And, of course, you have just
    seen (near the end of [“Events in React”](#events-in-react)) how you can also
    create an `if...then...else` block in JSX using a ternary (`?:`) expression.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，无论何时只有在条件为`true`时才显示某些内容，`&&`运算符都是实现此目的的好方法。当然，你刚才在[“React事件”](#events-in-react)末尾看到了如何在JSX中使用三元(`?:`)表达式创建`if...then...else`块。
- en: Using Lists and Keys
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表和键
- en: Displaying lists using React is a breeze. In [Example 24-8](#displaying-a-list)
    the array `cats` contains a list of four types of cat. This is then extracted
    in the following line of code using the `map` function, which iterates through
    the array, returning each item in turn in the variable `cat`. This results in
    each iteration being embedded in a pair of `<li>...<li>` tags and then appended
    to the `listofCats` string.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React显示列表非常简单。在[Example 24-8](#displaying-a-list)中，数组`cats`包含四种类型的猫的列表。然后，在下一行代码中使用`map`函数提取这些，该函数迭代数组，依次返回每个项目到变量`cat`中。这导致每次迭代都嵌入在一对`<li>...</li>`标签中，然后附加到`listofCats`字符串中。
- en: Example 24-8\. Displaying a list
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 24-8\. 显示列表
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, `doRender` is called, embedding `listofCats` within a pair of `<ul>...</ul>`
    tags, the result of which displays like this:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，调用`doRender`，将`listofCats`嵌入`<ul>...</ul>`标签对中，结果显示如下：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Unique Keys
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 唯一键
- en: If you had your JavaScript console open when running [Example 24-8](#displaying-a-list) (usually
    by pressing Ctrl Shift J or Option Command J on a Mac), you may have noticed the
    warning message “Each child in a list should have a unique ‘key’ prop.”
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在运行[Example 24-8](#displaying-a-list)时打开了JavaScript控制台（通常通过按下Ctrl Shift J或在Mac上按Option
    Command J），你可能会注意到警告消息“列表中的每个子元素都应有一个唯一的‘key’属性。”
- en: Although not necessary, React works best when you supply a unique key for each
    sibling list item, which helps it to find references to the appropriate DOM nodes
    and, when you make a small change, allows for making minor adjustments to the
    DOM, rather than requiring rerendering of larger sections. So [Example 24-9](#using-unique-keys) is
    an example of providing just such a key.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不是必需的，但当你为每个兄弟列表项提供唯一键时，React的工作效果最佳，这有助于它找到对应DOM节点的引用，并在进行小改动时允许对DOM进行微调，而不需要重新渲染更大的部分。所以[Example 24-9](#using-unique-keys)就是提供这样一个唯一键的示例。
- en: Example 24-9\. Using unique keys
  id: totrans-157
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 24-9\. 使用唯一键
- en: '[PRE39]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this example a `uniqueId` variable has been created that is incremented
    each time it is used so that, for example, the first key will become `1`. The
    displayed output is the same as the previous example, but if you would like to
    see the keys generated (just out of interest), you can change the contents of
    the `li` element from `{cat}` to `{uniqueId - 1 + '' '' + cat}`, and you will
    see the following displayed (the `- 1` is used because `uniqueId` has already
    been incremented by the time it is referred to, so we need to see what the value
    was before incrementing):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，创建了一个`uniqueId`变量，每次使用时都会递增，因此，例如，第一个键将变为`1`。显示的输出与前一个示例相同，但是如果您想查看生成的键（仅出于兴趣），可以将`li`元素的内容从`{cat}`更改为`{uniqueId
    - 1 + ' ' + cat}`，然后您将看到以下内容显示（使用`- 1`是因为在引用它时`uniqueId`已经递增了，所以我们需要看到递增之前的值）：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'But what is the point of this, you may ask? Well, consider the case of the
    following list structure:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，您可能会问，这有什么意义呢？好吧，考虑以下列表结构的情况：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here are two sets of lists, each with four unique siblings, but between the
    lists, both the city names of “Birmingham” and “Paris” are shared at the same
    level of nesting. When React performs certain reconciliation actions (after reordering
    or modifying an element perhaps), there are instances when you can achieve speed
    gains and possibly avoid problems when sibling list items at the same level share
    the same values. To do this you can provide unique keys for all siblings, which,
    to React, could look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两组列表，每组都有四个唯一的兄弟姐妹，但在列表之间，包括“伯明翰”和“巴黎”这两个城市名称在同一层次的嵌套中是共享的。当React执行某些协调操作（例如重新排序或修改元素后），存在一些情况可以实现速度增益，并且在同一级别的兄弟列表项共享相同值时可能避免问题。为此，您可以为所有兄弟姐妹提供唯一的键，对于React而言，可能如下所示：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now there is no possibility of confusing Paris in Europe with Paris in the USA
    (or at least of having to work harder to locate and possibly rerender the correct
    DOM node), as each array element has a different unique ID for React.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不可能将欧洲的巴黎与美国的巴黎混淆（或者至少需要更加努力来定位并且可能重新渲染正确的DOM节点），因为每个数组元素对于React都有一个不同的唯一ID。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t worry too much about why you are creating these unique keys. Just remember
    that React works at its best when you do so, and a good rule of thumb is that
    elements within a `map` call will need keys. Also, you can reuse your keys for
    different sets of siblings that are not related in any way. However, you may not
    have to create your own keys because the data you are working with could well
    supply them for you, such as book ISBN numbers. As a last resort, you can simply
    use the index of an item as its key, but reorders could be slow, and you could
    encounter other issues, so creating your own keys so you can control what they
    contain is usually the best option.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心为什么要创建这些唯一键。只需记住，在这样做时React表现最佳，一个好的经验法则是在`map`调用中的元素将需要键。此外，您可以为不相关的不同兄弟集合重复使用您的键。然而，您可能不必创建自己的键，因为您正在处理的数据可能会为您提供它们，例如书籍ISBN号码。作为最后的手段，您可以简单地使用项目的索引作为其键，但重新排序可能会很慢，并且您可能会遇到其他问题，因此通常创建自己的键以便控制它们包含的内容是最佳选择。
- en: Handling Forms
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表单
- en: In React, `<input type='text'>`, `<textarea>`, and `<select>` all work in a
    similar way because React’s internal state becomes what is known as the “source
    of truth,” and these components are therefore called *controlled*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，`<input type='text'>`，`<textarea>`和`<select>`都以类似的方式工作，因为React的内部状态成为所谓的“真实数据源”，因此这些组件被称为*受控组件*。
- en: With a *controlled component,* the input’s value is always driven by the React
    state. This does mean that you need to write a bit more code in React, but the
    end benefit is that you can then pass values to other UI elements or access them
    from event handlers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*受控组件*，输入的值始终由React状态驱动。这确实意味着您需要在React中编写更多的代码，但最终的好处是您可以将值传递给其他UI元素或从事件处理程序中访问它们。
- en: Normally, without React or any other framework or library loaded, form elements
    maintain their own state, which is updated based on input received from the user.
    In React, the mutable state is typically kept in the `state` property of components
    and should then only be updated using the `setState` function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，没有加载React或任何其他框架或库时，表单元素会维护自己的状态，该状态基于用户输入进行更新。在React中，可变状态通常保留在组件的`state`属性中，并且应仅使用`setState`函数更新它。
- en: Using Text Input
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文本输入
- en: 'Let’s look at these three input types, starting with a simple text input, like
    this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看这三种输入类型，首先是简单的文本输入，就像这样：
- en: '[PRE43]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This code requests a string of characters to be input, which is then submitted
    when the Submit button is clicked (or the Enter or Return key pressed). Now let’s
    change this to a controlled React component in [Example 24-10](#using-text-input-react).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码请求输入一串字符，然后在单击提交按钮（或按下Enter或Return键）时提交。现在让我们将其改为受控React组件在[示例24-10](#using-text-input-react)中。
- en: Example 24-10\. Using text input
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例24-10\. 使用文本输入
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Let me take you through this part by part. First we create a new class called
    `GetName`, which will be used to create a form that will prompt for a name to
    be entered. This class contains two event handlers called `onChange` and `onSubmit`.
    These are local handlers that are set to override the standard JavaScript handlers
    of these same named events by using the calls to `bind` in the constructor, which
    is also the place where the value in `value` is initialized to the empty string.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我逐步为你解释这一部分。首先我们创建一个名为`GetName`的新类，用于创建一个表单，提示输入名字。这个类包含两个事件处理器`onChange`和`onSubmit`。这些都是本地处理程序，通过在构造函数中使用`bind`调用来覆盖这些同名事件的标准JavaScript处理程序，同时在构造函数中也将`value`的值初始化为空字符串。
- en: When called by the `onChange` interrupt, the new `onChange` handler calls the
    `setState` function to update `value` whenever the input is changed, so that `value`
    is always kept up to date with the contents in the input field.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 当被`onChange`中断调用时，新的`onChange`处理程序调用`setState`函数以更新`value`，以便始终保持`value`与输入字段中的内容保持同步。
- en: When the `onSubmit` event is triggered, it is handled by the new `onSubmit`
    handler, which in this instance issues a pop-up `alert` window so that we can
    see it has worked. Because *we* are dealing with the event and *not* the system,
    the event is then prevented from bubbling through to the system by calling `preventDefault`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发`onSubmit`事件时，它由新的`onSubmit`处理程序处理，在这种情况下，它发出一个弹出的`alert`窗口，以便我们可以看到它已经起作用。因为我们处理事件而不是系统，所以通过调用`preventDefault`来防止事件冒泡到系统。
- en: Finally, the `render` method contains all the HTML code to be rendered into
    the display `<div>`. Of course, we use HTML formatted as XML to do this, as that
    is what Babel expects (namely JSX syntax). In this instance, it simply requires
    the additional self-closing of the input elements with `/>`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`render`方法包含所有要渲染到显示`<div>`中的HTML代码。当然，我们使用XML格式化的HTML来做这件事，因为这是Babel期望的（即JSX语法）。在这种情况下，它只需要额外的自闭合输入元素`/>`。
- en: Note
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We have not globally overridden the `onChange` and `onSubmit` events, because
    we have only bound events issued by the rendered code to local event handlers
    within the `GetName` class, so it is safe to use the same names for our event
    handlers, which helps make our code’s purpose more immediately obvious to other
    developers. But if there could ever be the possibility of any doubt, you might
    prefer to use different names for your handlers, such as `actOnSubmit`, etc.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有全局地覆盖`onChange`和`onSubmit`事件，因为我们仅将由渲染的代码发出的事件绑定到`GetName`类内部的本地事件处理程序，因此可以安全地使用相同的名称作为我们的事件处理程序，这有助于使我们的代码目的对其他开发人员更加明显。但如果可能会有任何疑问的可能性，你可能更喜欢为你的处理程序使用不同的名称，比如`actOnSubmit`等。
- en: So, as you should see by now, `this.state.value` will always reflect the state
    of the input field because, as stated earlier, with a controlled component, `value`
    is always driven by the React state.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，正如你现在应该看到的那样，`this.state.value`将始终反映输入字段的状态，因为在受控组件中，`value`始终由React状态驱动。
- en: Using textarea
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用文本区域
- en: One of the ideas behind using React is to maintain cross-browser control over
    the DOM for quick and simple access and also to streamline and simplify the development
    process. By using controlled components, we are in control at all times and can
    make inputting data of all types work in similar ways.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用React的一个理念是在DOM上保持跨浏览器控制，以便快速简单地访问，并且简化开发流程。通过使用受控组件，我们始终控制并可以使所有类型的数据输入以类似的方式工作。
- en: In [Example 24-11](#using-textarea-react), the previous example has been modified
    into using a `<textarea>` element for input.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例24-11](#using-textarea-react)中，上一个示例已修改为使用`<textarea>`元素进行输入。
- en: Example 24-11\. Using textarea
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例24-11\. 使用文本区域
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This code is extremely similar to the text input example, with a few simple
    changes: this class is now called `GetText`, the text input in the `render` method
    is replaced with a `<textarea>` element that has been set to 40 columns wide by
    5 rows high, and a couple of `<br>` elements have been added for formatting. And
    that’s it—nothing else has required changing to enable us to have full control
    over the `<textarea>` input field. As with the previous example, `this.state.value` will
    always reflect the state of the input field.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与文本输入示例非常相似，只有几个简单的更改：现在这个类被称为`GetText`，`render`方法中的文本输入被替换为一个设置为40列宽和5行高的`<textarea>`元素，并添加了一些`<br>`元素进行格式化。就是这样——没有其他改动就能让我们完全控制`<textarea>`输入字段。与前面的例子一样，`this.state.value`始终反映输入字段的状态。
- en: Of course, this type of input supports the use of Enter or Return to input carriage
    returns into the field, so now the input can only be submitted by clicking the
    button.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，此类型的输入支持使用Enter或Return键输入换行符到字段中，因此现在只能通过单击按钮提交输入。
- en: Using select
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用select
- en: 'Before showing how to use `<select>` in React, let’s first look at a typical
    snippet of HTML code in which a few countries are offered from which the user
    must choose, with USA being the default selection:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示如何在React中使用`<select>`之前，让我们先看一下典型的HTML代码片段，在这个片段中，用户必须从几个国家中选择，其中USA是默认选择：
- en: '[PRE46]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In React this needs to be handled slightly differently because it uses a v`alue`
    attribute on the `select` element instead of the `selected` attribute applied
    to an `option` sub-element, as in [Example 24-12](#using-select-react).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在React中，这需要稍微处理一下，因为它在`select`元素上使用`value`属性而不是应用于`option`子元素的`selected`属性，如[示例24-12](#using-select-react)中所示。
- en: Example 24-12\. Using select
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例24-12\. 使用select
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once again you will see that very little has changed in this example other than
    the new class name of `GetCountry`, that `this.state.value` is assigned the default
    value of `'USA'`, and that the input type is now a `<select>` but without a `selected`
    attribute.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看到，除了`GetCountry`的新类名之外，几乎没有改变，`this.state.value`被赋予了默认值`'USA'`，并且输入类型现在是`<select>`但没有`selected`属性。
- en: Just as with the previous two examples, `this.state.value` always reflects the
    state of the input.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前两个例子一样，`this.state.value`始终反映输入的状态。
- en: React Native
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: React Native
- en: React also has a companion product called React Native. With it you can create
    full-blown applications for both iOS and Android phones and tablets, just using
    the JSX extended JavaScript language and without needing to understand Java or
    Kotlin (for Android) or Objective-C or Swift (for iOS).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: React还有一个名为React Native的伴侣产品。通过它，您可以只使用扩展的JSX JavaScript语言创建适用于iOS和Android手机和平板电脑的完整应用程序，而无需了解Java或Kotlin（用于Android）或Objective-C或Swift（用于iOS）。
- en: Full details and explanations of how to do all this and have your apps up and
    running on a wide range of mobile devices are beyond the scope of this book, but
    in this section I show you where to go to get the software and information you
    need.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如何做到这一点并在各种移动设备上运行您的应用程序的完整详细信息和解释超出了本书的范围，但在本节中，我向您展示了获取所需软件和信息的位置。
- en: Creating React Native Apps
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建React Native应用程序
- en: To develop React Native apps, you will first need to install [Android Studio](http://developer.android.com/studio)
    and the [Java JDK](https://tinyurl.com/getjavajdk)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要开发React Native应用程序，首先需要安装[Android Studio](http://developer.android.com/studio)和[Java
    JDK](https://tinyurl.com/getjavajdk)。
- en: On a Mac you will additionally need to install Xcode from the App Store. Windows
    users have no easy options other than tricky virtualization or a “Hackintosh”
    to develop iOS apps, so it’s really best to have access to an actual Mac (or hosted
    service) for this.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上，您还需要从App Store安装Xcode。Windows用户除了棘手的虚拟化或“Hackintosh”外，没有简单的选项来开发iOS应用程序，因此真正最好的选择是拥有实际的Mac（或托管服务）。
- en: Then you will need to read the [documentation on Android Studio](https://developer.android.com/docs) until
    you understand how to create an Android Virtual Device (AVD), and set up the various
    environment variables required, such as `ANDROID_HOME`, which should point to
    the installed JDK. Now you need to install Node.JS from [nodejs.org](http://nodejs.org).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您需要阅读[Android Studio文档](https://developer.android.com/docs)，直到理解如何创建Android虚拟设备（AVD）并设置所需的各种环境变量，例如`ANDROID_HOME`，它应指向已安装的JDK。现在您需要从[nodejs.org](http://nodejs.org)安装Node.JS。
- en: Once Node is installed, read up on [the documentation](https://nodejs.org/en/docs/)
    if you don’t already know how to use it. Now you are ready to install React Native
    following the advice given in the [React Native documentation](https://reactnative.dev/docs/environment-setup).
    After this you can then work through the tutorial on [the React website](http://reactnative.dev/docs/getting-started),
    noting the differences between building apps on Windows and on macOS.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Node，如果你还不知道如何使用它，请阅读[文档](https://nodejs.org/en/docs/)。现在你可以根据[React Native
    文档](https://reactnative.dev/docs/environment-setup)的建议安装 React Native。之后，你可以通过[React
    网站上的教程](http://reactnative.dev/docs/getting-started)来学习，在构建 Windows 和 macOS 上的应用程序之间注意其中的差异。
- en: Once you get this all working (and it can take a while before you properly understand
    everything you are doing and have it all running smoothly), you now have the fantastic
    benefit that you can (mostly) go ahead and develop your apps for both major mobile
    platforms at the same time by just using React JSX code!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有工作都正常运行（在完全理解并顺利运行之前可能需要一些时间），你现在可以使用 React JSX 代码（大部分情况下）同时为两个主要移动平台开发应用程序了！
- en: Further Reading
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To aid you in your React Native development, here are some online tutorials
    that I feel clearly explain the process (thanks to Pabasara Jayawardhana at Medium,
    Kevin VanGelder at Infinite Red Academy, and Microsoft) and that were all online
    and working at the time of writing (or may be located at [*archive.org*](https://archive.org)
    if not). Of course, if you still need to know more, your favorite search engine
    will have what you need:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你进行 React Native 开发，这里有一些在线教程，我认为它们清楚地解释了这个过程（感谢 Medium 上的 Pabasara Jayawardhana，Infinite
    Red Academy 上的 Kevin VanGelder，以及 Microsoft），并且在撰写时都是在线并且可用（如果不可用，则可以在[*archive.org*](https://archive.org)找到）。当然，如果你仍然需要更多信息，你喜欢的搜索引擎将会给你所需的一切：
- en: '[React Native on Mac OS](https://tinyurl.com/reactnativemac)'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React Native on Mac OS](https://tinyurl.com/reactnativemac)'
- en: '[React Native on Windows](https://tinyurl.com/reactnativewindows)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[React Native on Windows](https://tinyurl.com/reactnativewindows)'
- en: '[Microsoft’s Guide to React Native](https://microsoft.github.io/react-native-windows/)'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Microsoft''s Guide to React Native](https://microsoft.github.io/react-native-windows/)'
- en: Although the latter of these three refers only to Windows in the URL, the guide
    includes macOS, too.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这三个中的后者仅在 URL 中提到了 Windows，但指南也包括 macOS。
- en: Taking React to the Next Level
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 React 提升到下一个水平
- en: Now that you’ve learned the basics of how to set up and use React, there remains
    a great deal more that you can do with it (especially if you intend to build React
    Native apps with it), which is sadly beyond the scope of this book. So to continue
    your React journey, I recommend you visit the [Reactjs.org web page](https://reactjs.org/docs/hello-world.html)
    as a good starting point, where you can review some of the things discussed here
    before moving on to even more powerful features.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何设置和使用 React 的基础知识，还有很多其他内容可以做（特别是如果你打算用它构建 React Native 应用程序），这超出了本书的范围。因此，为了继续你的
    React 之旅，我建议你访问[Reactjs.org 网页](https://reactjs.org/docs/hello-world.html)，这是一个很好的起点，在这里你可以回顾一些在这里讨论的内容，然后进一步了解更强大的功能。
- en: And remember that you can download all the samples from this chapter (and this
    book as a whole) on [GitHub](https://github.com/RobinNixon/lpmj6).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 而且请记住，你可以从[GitHub](https://github.com/RobinNixon/lpmj6)下载本章节（以及整本书）的所有示例。
- en: So, with React now in our toolkit (at least enough to get us up and running),
    let’s move on to all the goodies that HTML5 brings us in the following chapter.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们工具箱中有了 React（至少足够让我们启动和运行），让我们继续下一章，探索 HTML5 带给我们的所有好东西。
- en: Questions
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the main two ways you can incorporate the React scripts in your web
    page?
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪两种主要方法可以将 React 脚本整合到你的网页中？
- en: How is XML incorporated into JavaScript for use with React?
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: XML 如何与 JavaScript 结合以在 React 中使用？
- en: Instead of `<script type="application/javascript">`, what value for `type` should
    you use for your JSX JavaScript code?
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 JSX JavaScript 代码中，你应该使用什么值来替换`<script type="application/javascript">`中的`type`？
- en: What are two different ways you can extend React to your code?
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪两种不同的方法可以将 React 扩展到你的代码中？
- en: In React, what is meant by pure and impure code?
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 React 中，纯代码和非纯代码是什么意思？
- en: How does React keep track of state?
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: React 如何跟踪状态？
- en: How can you embed an expression within JSX code?
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 JSX 代码中嵌入表达式？
- en: How can you change the state of a value once a class has been constructed?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦类构造完成，你如何改变一个值的状态？
- en: What must you first do to enable referring to `props` using the `this` keyword
    within a constructor?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数内使用 `this` 关键字引用 `props` 之前，你首先必须做什么？
- en: How can you create a conditional statement in JSX?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在 JSX 中创建条件语句？
- en: See [“Chapter 24 Answers”](app01_split_023.xhtml#chapter_24_answers) in the
    [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions) for the
    answers to these questions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在[附录 A](app01_split_000.xhtml#solutions_to_the_chapter_questions)中查看 [“第 24
    章答案”](app01_split_023.xhtml#chapter_24_answers) 来获取这些问题的答案。
