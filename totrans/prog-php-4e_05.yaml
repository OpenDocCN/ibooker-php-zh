- en: Chapter 4\. Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。字符串
- en: Most data you encounter as you program will be sequences of characters, or *strings*.
    Strings can hold people’s names, passwords, addresses, credit card numbers, links
    to photographs, purchase histories, and more. For that reason, PHP has an extensive
    selection of functions for working with strings.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中遇到的大多数数据都是字符序列，或*字符串*。字符串可以包含人名、密码、地址、信用卡号码、照片链接、购买历史等。因此，PHP 提供了丰富的函数来处理字符串。
- en: This chapter shows the many ways to create strings in your programs, including
    the sometimes tricky subject of *interpolation* (placing a variable’s value into
    a string), then covers functions for changing, quoting, manipulating, and searching
    strings. By the end of this chapter, you’ll be a string-handling expert.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了在程序中创建字符串的许多方法，包括有时棘手的*插值*主题（将变量的值放入字符串中），然后涵盖了用于更改、引用、操作和搜索字符串的函数。通过本章，您将成为处理字符串的专家。
- en: Quoting String Constants
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用字符串常量
- en: 'There are four ways to write a string literal in your PHP code: using single
    quotes, double quotes, the *here document* (*heredoc*) format derived from the
    Unix shell, and its “cousin” *now document* (*nowdoc*). These methods differ in
    whether they recognize special *escape sequences* that let you encode other characters
    or interpolate variables.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写 PHP 代码中，有四种方法可以写字符串文字：使用单引号、双引号，从 Unix shell 派生的*here document*（heredoc）格式，以及其“堂兄弟”*now
    document*（nowdoc）。这些方法在是否识别特殊的*转义序列*以及插入变量方面有所不同。
- en: Variable Interpolation
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量插值
- en: When you define a string literal using double quotes or a heredoc, the string
    is subject to *variable interpolation*. Interpolation is the process of replacing
    variable names in the string with their contained values. There are two ways to
    interpolate variables into strings.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用双引号或heredoc定义字符串文字时，该字符串将被*变量插值*处理。插值是将字符串中的变量名替换为它们包含的值的过程。有两种方法将变量插值到字符串中。
- en: 'The simpler of the two ways is to put the variable name in a double-quoted
    string or in a heredoc:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 两种插值变量的方式中，较简单的一种是将变量名放在双引号字符串或heredoc中：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The other way is to surround the variable being interpolated with curly braces.
    Using this syntax ensures the correct variable is interpolated. The classic use
    of curly braces is to disambiguate the variable name from any surrounding text:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方式是用花括号包围要插值的变量。使用这种语法可以确保正确地插值变量。花括号的经典用法是消除变量名与周围文本的歧义：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Without the curly braces, PHP would try to print the value of the `$nth` variable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有花括号，PHP 将尝试打印 `$nth` 变量的值。
- en: 'Unlike in some shell environments, in PHP, strings are not repeatedly processed
    for interpolation. Instead, any interpolations in a double-quoted string are processed
    first and the result is used as the value of the string:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些 shell 环境不同，在 PHP 中，字符串不会重复处理插值。相反，在双引号字符串中首先处理任何插值，然后使用结果作为字符串的值：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Single-Quoted Strings
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单引号字符串
- en: 'Single-quoted strings and nowdocs do not interpolate variables. Thus, the variable
    name in the following string is not expanded because the string literal in which
    it occurs is single-quoted:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号字符串和nowdoc不会插值变量。因此，以下字符串中的变量名不会被扩展，因为它出现在单引号字符串文字中：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The only escape sequences that work in single-quoted strings are `\''`, which
    puts a single quote in a single-quoted string, and `\\`, which puts a backslash
    in a single-quoted string. Any other occurrence of a backslash is interpreted
    simply as a backslash:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在单引号字符串中，唯一有效的转义序列是 `\'`，用于在单引号字符串中插入单引号，以及 `\\`，用于在单引号字符串中插入反斜杠。任何其他反斜杠的出现都会简单地被解释为一个反斜杠：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Double-Quoted Strings
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 双引号字符串
- en: Double-quoted strings interpolate variables and expand the many PHP escape sequences.
    [Table 4-1](#escape_sequences_in_double_quoted_strin) lists the escape sequences
    recognized by PHP in double-quoted strings.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 双引号字符串会插入变量并扩展许多 PHP 转义序列。[Table 4-1](#escape_sequences_in_double_quoted_strin)
    列出了 PHP 在双引号字符串中识别的转义序列。
- en: Table 4-1\. Escape sequences in double-quoted strings
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1。双引号字符串中的转义序列
- en: '| Escape sequence | Character represented |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 表示的字符 |'
- en: '| --- | --- |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `\"` | Double quotes |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 |'
- en: '| `\n` | Newline |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 |'
- en: '| `\r` | Carriage return |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符 |'
- en: '| `\t` | Tab |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 |'
- en: '| `\\` | Backslash |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 |'
- en: '| `\$` | Dollar sign |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `\$` | 美元符号 |'
- en: '| `\{` | Left curly brace |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `\{` | 左花括号 |'
- en: '| `\}` | Right curly brace |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `\}` | 右花括号 |'
- en: '| `\[` | Left square bracket |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `\[` | 左方括号 |'
- en: '| `\]` | Right square bracket |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `\]` | 右方括号 |'
- en: '| `\0` through `\777` | ASCII character represented by octal value |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `\0` 到 `\777` | 由八进制值表示的ASCII字符 |'
- en: '| `\x0` through `\xFF` | ASCII character represented by hex value |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `\x0` 到 `\xFF` | 由十六进制值表示的ASCII字符 |'
- en: '| `\u` | UTF-8 encoding |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `\u` | UTF-8编码 |'
- en: 'If an unknown escape sequence (i.e., a backslash followed by a character that
    is not one of those in [Table 4-1](#escape_sequences_in_double_quoted_strin))
    is found in a double-quoted string literal, it is ignored (if you have the warning
    level `E_NOTICE` set, a warning is generated for such unknown escape sequences):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在双引号字符串字面量中发现未知的转义序列（即反斜杠后面跟一个不属于[表4-1](#escape_sequences_in_double_quoted_strin)中的字符），则将其忽略（如果设置了警告级别`E_NOTICE`，则会生成警告以表示此类未知转义序列）：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here Documents
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Here Documents
- en: 'You can easily put multiline strings into your program with a heredoc, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用heredoc轻松将多行字符串放入程序中，如下所示：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `<<<` identifier token tells the PHP parser that you’re writing a heredoc.
    You get to pick the identifier (`EndOfQuote` in this case), and you can put it
    in double quotes if you wish (e.g., `"EndOfQuote"`). The next line starts the
    text being quoted by the heredoc, which continues until it reaches a line containing
    only the identifier. To ensure the quoted text is displayed in the output area
    exactly as you’ve laid it out, turn on plain-text mode by adding this command
    at the top of your code file:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<<`标识符令牌告诉PHP解析器你正在编写heredoc。你可以选择标识符（在本例中为`EndOfQuote`），如果愿意，可以用双引号括起来（例如，`"EndOfQuote"`）。接下来的一行开始了heredoc引用的文本，直到遇到只包含标识符的行为止。为了确保引用的文本在输出区域中显示为你所编排的样子，可以通过在代码文件顶部添加此命令来打开纯文本模式：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Alternately, if you have control of your server settings, you could set `default_mimetype`
    to `plain` in the *php.ini* file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你可以控制服务器设置，你可以在*php.ini*文件中将`default_mimetype`设置为`plain`。
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is not recommended, however, as it puts *all* output from the server in
    plain-text mode, which would affect the layout of most of your web code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不推荐，因为它会将服务器的*所有*输出都置于纯文本模式，这会影响大多数Web代码的布局。
- en: If you do not set plain-text mode for your heredoc, the default is typically
    HTML mode, which simply displays the output all on one line.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为heredoc设置纯文本模式，默认通常是HTML模式，这会将输出显示为单行。
- en: 'When using a heredoc for a simple expression, you can put a semicolon after
    the terminating identifier to end the statement (as shown in the first example).
    If you are using a heredoc in a more complex expression, however, you’ll need
    to continue the expression on the next line, as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用heredoc表示一个简单表达式时，你可以在终止标识符后加上分号来结束语句（正如第一个例子所示）。然而，如果你在更复杂的表达式中使用heredoc，你需要在下一行继续表达式，就像这里所示：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Single and double quotes in a heredoc are preserved:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在heredoc中，单引号和双引号都是被保留的：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As is whitespace:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如空格所示：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'New to PHP 7.3 is the indentation of the heredoc terminator. This allows for
    more legible formatting in the case of embedded code, as in the following function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7.3中引入了heredoc结束标记的缩进功能。这允许在嵌入代码的情况下更易读地格式化，就像以下函数所示：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The newline before the trailing terminator is removed, so these two assignments
    are identical:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结束标识符之前的换行符被移除，因此这两个赋值是相同的：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you want a newline to end your heredoc-quoted string, you’ll need to add
    one yourself:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在heredoc引用的字符串末尾添加一个换行符，你需要自己添加一个：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Printing Strings
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打印字符串
- en: There are four ways to send output to the browser. The `echo` construct lets
    you print many values at once, while `print()` prints only one value. The `printf()`
    function builds a formatted string by inserting values into a template. The `print_r()`
    function is useful for debugging; it prints the contents of arrays, objects, and
    other things in a more or less human-readable form.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方式将输出发送到浏览器。`echo`结构允许你一次打印多个值，而`print()`只打印一个值。`printf()`函数通过将值插入模板中构建格式化字符串。`print_r()`函数对于调试很有用；它以更或少人类可读的形式打印数组、对象和其他内容。
- en: echo
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: echo
- en: 'To put a string into the HTML of a PHP-generated page, use `echo`. While it
    looks—and for the most part behaves—like a function, `echo` is a language construct.
    This means that you can omit the parentheses, so the following expressions are
    equivalent:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字符串放入PHP生成页面的HTML中，请使用`echo`。虽然看起来——并且在大多数情况下行为也像一个函数——`echo`是一个语言结构。这意味着你可以省略括号，因此以下表达式是等效的：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can specify multiple items to print by separating them with commas:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过用逗号分隔它们来指定要打印的多个项目：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It is a parse error to use parentheses when trying to echo multiple values:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试回显多个值时使用括号会导致解析错误：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Because `echo` is not a true function, you can’t use it as part of a larger
    expression:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `echo` 不是真正的函数，所以不能将其作为较大表达式的一部分使用：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can easily remedy such errors by using the `print()` or `printf()` functions.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `print()` 或 `printf()` 函数，您可以轻松纠正此类错误。
- en: print()
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: print()
- en: 'The `print()` function sends one value (its argument) to the browser:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`print()` 函数将一个值（其参数）发送到浏览器：'
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: printf()
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: printf()
- en: The `printf()` function outputs a string built by substituting values into a
    template (the *format string*). It is derived from the function of the same name
    in the standard C library. The first argument to `printf()` is the format string.
    The remaining arguments are the values to be substituted. A `%` character in the
    format string indicates a substitution.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`printf()` 函数通过将值替换到模板（*格式字符串*）中来输出一个字符串。它源自标准C库中同名函数。`printf()` 的第一个参数是格式字符串。其余参数是要替换的值。格式字符串中的
    `%` 字符表示一个替换位置。'
- en: Format modifiers
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 格式修饰符
- en: 'Each substitution marker in the template consists of a percent sign (`%`),
    possibly followed by modifiers from the following list, and ends with a type specifier.
    (Use `%%` to get a single percent character in the output.) The modifiers must
    appear in the order in which they are listed here:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 模板中的每个替换标记均以百分号（`%`）开头，可能后跟以下列表中的修饰符，并以类型指示符结尾。（使用 `%%` 可在输出中获取单个百分号字符。）修饰符必须按照以下顺序出现：
- en: A padding specifier denoting the character to use to pad the results to the
    appropriate string size. Specify `0`, a space, or any character prefixed with
    a single quote. Padding with spaces is the default.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充修饰符表示用于将结果填充到适当字符串大小的字符。指定 `0`、空格或任何以单引号前缀的字符。默认情况下使用空格进行填充。
- en: A sign. This has a different effect on strings than on numbers. For strings,
    a minus (`–`) here forces the string to be left-justified (the default is right-justified).
    For numbers, a plus (`+`) here forces positive numbers to be printed with a leading
    plus sign (e.g., `35` will be printed as `+35`).
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 符号。对于字符串与数字的影响不同。对于字符串，此处的减号（`–`）会强制字符串左对齐（默认为右对齐）。对于数字，此处的加号（`+`）会强制正数带有前导加号（例如，`35`
    将打印为 `+35`）。
- en: The minimum number of characters that this element should contain. If the result
    would be less than this number of characters, the sign and padding specifier govern
    how to pad to this length.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此元素应包含的最小字符数。如果结果少于这些字符数，则符号和填充修饰符将决定如何填充到此长度。
- en: For floating-point numbers, a precision specifier consisting of a period and
    a number; this dictates how many decimal digits will be displayed. For types other
    than double, this specifier is ignored.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于浮点数，精度修饰符包含一个点和一个数字；这决定了将显示多少位小数。对于除double以外的类型，此修饰符将被忽略。
- en: Type specifiers
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型指示符
- en: The type specifier tells `printf()` what type of data is being substituted.
    This determines the interpretation of the previously listed modifiers. There are
    eight types, as listed in [Table 4-2](#printfleft_parenthesisright_parenthesis).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 类型指示符告诉 `printf()` 正在替换的数据类型。这决定了先前列出的修饰符的解释。共有八种类型，如 [表4-2](#printfleft_parenthesisright_parenthesis)
    所列。
- en: Table 4-2\. printf() type specifiers
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2\. printf() 类型指示符
- en: '| Specifier | Meaning |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 指示符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%` | Displays the percent sign. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 显示百分号。 |'
- en: '| `b` | The argument is an integer and is displayed as a binary number. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 参数为整数，并以二进制数显示。 |'
- en: '| `c` | The argument is an integer and is displayed as the character with that
    value. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 参数为整数，并按该值显示为字符。 |'
- en: '| `d` | The argument is an integer and is displayed as a decimal number. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 参数为整数，并以十进制数显示。 |'
- en: '| `e` | The argument is a double and is displayed in scientific notation. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `e` | 参数为双精度浮点数，并以科学计数法显示。 |'
- en: '| `E` | The argument is a double and is displayed in scientific notation using
    uppercase letters. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `E` | 参数为双精度浮点数，并以大写字母科学计数法显示。 |'
- en: '| `f` | The argument is a floating-point number and is displayed as such in
    the current locale’s format. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 参数为浮点数，并以当前区域设置的格式显示。 |'
- en: '| `F` | The argument is a floating-point number and is displayed as such. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `F` | 参数为浮点数，并以此类形式显示。 |'
- en: '| `g` | The argument is a double and is displayed either in scientific notation
    (as with the `%e` type specifier) or as a floating-point number (as with the `%f`
    type specifier), whichever is shorter. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 参数是双精度浮点数，显示为科学计数法（如 `%e` 类型说明符）或浮点数（如 `%f` 类型说明符），以较短的方式显示。 |'
- en: '| `G` | The argument is a double and is displayed either in scientific notation
    (as with the `%E` type specifier) or as a floating-point number (as with the `%f`
    type specifier), whichever is shorter. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `G` | 参数是双精度浮点数，显示为科学计数法（如 `%E` 类型说明符）或浮点数（如 `%f` 类型说明符），以较短的方式显示。 |'
- en: '| `o` | The argument is an integer and is displayed as an octal (base-8) number.
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `o` | 参数是整数，以八进制（基数 8）数显示。 |'
- en: '| `s` | The argument is a string and is displayed as such. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 参数是字符串，显示为该字符串。 |'
- en: '| `u` | The argument is an unsigned integer and is displayed as a decimal number.
    |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `u` | 参数是无符号整数，以十进制数显示。 |'
- en: '| `x` | The argument is an integer and is displayed as a hexadecimal (base-16)
    number; lowercase letters are used. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 参数是整数，以十六进制（基数 16）数显示；使用小写字母。 |'
- en: '| `X` | The argument is an integer and is displayed as a hexadecimal (base-16)
    number; uppercase letters are used. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 参数是整数，以十六进制（基数 16）数显示；使用大写字母。 |'
- en: 'The `printf()` function looks outrageously complex to people who aren’t C programmers.
    Once you get used to it, though, you’ll find it a powerful formatting tool. Here
    are some examples:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不是C程序员的人来说，`printf()` 函数看起来异常复杂。不过一旦你习惯了，你会发现它是一个非常强大的格式化工具。以下是一些示例：
- en: 'A floating-point number to two decimal places:'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留到小数点后两位的浮点数：
- en: '[PRE20]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Decimal and hexadecimal output:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 十进制和十六进制输出：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Padding an integer to three decimal places:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数填充到三位小数：
- en: '[PRE22]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Formatting a date:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化日期：
- en: '[PRE23]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A percentage:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 百分比：
- en: '[PRE24]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Padding a floating-point number:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点数填充：
- en: '[PRE25]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `sprintf()` function takes the same arguments as `printf()` but returns
    the built-up string instead of printing it. This lets you save the string in a
    variable for later use:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`sprintf()` 函数与 `printf()` 接受相同的参数，但返回构建好的字符串而不是将其打印出来。这让你可以将字符串保存在变量中以供后续使用：'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: print_r() and var_dump()
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: print_r() 和 var_dump()
- en: 'The `print_r()` function intelligently displays what is passed to it, rather
    than casting everything to a string, as `echo` and `print()` do. Strings and numbers
    are simply printed. Arrays appear as parenthesized lists of keys and values, prefaced
    by `Array`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`print_r()` 函数会智能地显示传递给它的内容，而不像 `echo` 和 `print()` 那样将一切都转换为字符串。字符串和数字会直接打印出来。数组显示为带有键和值的括号列表，前面有
    `Array` 字样：'
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using `print_r()` on an array moves the internal iterator to the position of
    the last element in the array. See [Chapter 5](ch05.xhtml#array) for more on iterators
    and arrays.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在数组上使用 `print_r()` 会将内部迭代器移动到数组中最后一个元素的位置。参见[第 5 章](ch05.xhtml#array)了解更多有关迭代器和数组的信息。
- en: 'When you `print_r()` an object, you see the word `Object`, followed by the
    initialized properties of the object displayed as an array:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对对象使用 `print_r()` 时，你会看到单词 `Object`，然后显示作为数组的初始化属性：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Boolean values and `NULL` are not meaningfully displayed by `print_r()`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值和 `NULL` 对于 `print_r()` 来说没有实际意义：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'For this reason, `var_dump()` is preferred over `print_r()` for debugging.
    The `var_dump()` function displays any PHP value in a human-readable format:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于调试，推荐使用 `var_dump()` 而不是 `print_r()`。`var_dump()` 函数可以以人类可读的格式显示 PHP 中的任何值：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Beware of using `print_r()` or `var_dump()` on a recursive structure such as
    `$GLOBALS` (which has an entry for `GLOBALS` that points back to itself). The
    `print_r()` function loops infinitely, while `var_dump()` cuts off after visiting
    the same element three times.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 谨防在递归结构（例如 `$GLOBALS`，它有一个指向自身的 `GLOBALS` 条目）上使用 `print_r()` 或 `var_dump()`。`print_r()`
    函数会无限循环，而 `var_dump()` 则在访问同一元素三次后截断。
- en: Accessing Individual Characters
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问单个字符
- en: 'The `strlen()` function returns the number of characters in a string:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`strlen()` 函数返回字符串中的字符数：'
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You can use the string offset syntax on a string to address individual characters:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用字符串偏移语法来访问字符串的各个字符：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Cleaning Strings
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清理字符串
- en: Often, the strings we get from files or users need to be cleaned up before we
    can use them. Two common problems with raw data are the presence of extraneous
    whitespace and incorrect capitalization (uppercase versus lowercase).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，我们从文件或用户那里获得的字符串在使用前需要清理。原始数据常见的问题是存在多余的空白和不正确的大写（大写与小写之间的区分）。
- en: Removing Whitespace
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除空白
- en: 'You can remove leading or trailing whitespace with the `trim()`, `ltrim()`,
    and `rtrim()` functions:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`trim()`、`ltrim()`和`rtrim()`函数删除前导或尾随的空白字符：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`trim()` returns a copy of *string* with whitespace removed from the beginning
    and the end. `ltrim()` (the *l* is for *left*) does the same, but removes whitespace
    only from the start of the string. `rtrim()` (the *r* is for *right*) removes
    whitespace only from the end of the string. The optional *charlist* argument is
    a string that specifies all the characters to strip. The default characters to
    strip are given in [Table 4-3](#default_characters_removed_by_trimleft).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`trim()`返回从*string*中删除开头和结尾的空白的副本。 `ltrim()`（*l*代表*左*）执行相同的操作，但仅删除字符串开头的空白。
    `rtrim()`（*r*代表*右*）仅从字符串结尾删除空白。 可选的*charlist*参数是一个字符串，用于指定要删除的所有字符。 默认要删除的字符在[表
    4-3](#default_characters_removed_by_trimleft)中给出。'
- en: Table 4-3\. Default characters removed by trim(), ltrim(), and rtrim()
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-3\. 由trim()、ltrim()和rtrim()移除的默认字符
- en: '| Character | ASCII value | Meaning |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 字符 | ASCII 值 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `" "` | 0x20 | Space |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `" "` | 0x20 | 空格 |'
- en: '| `"\t"` | 0x09 | Tab |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `"\t"` | 0x09 | 制表符 |'
- en: '| `"\n"` | 0x0A | Newline (line feed) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `"\n"` | 0x0A | 换行符（换行） |'
- en: '| `"\r"` | 0x0D | Carriage return |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| `"\r"` | 0x0D | 回车符 |'
- en: '| `"\0"` | 0x00 | NUL-byte |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `"\0"` | 0x00 | NUL字节 |'
- en: '| `"\x0B"` | 0x0B | Vertical tab |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `"\x0B"` | 0x0B | 垂直制表符 |'
- en: 'For example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Given a line of tab-separated data, use the *charlist* argument to remove leading
    or trailing whitespace without deleting the tabs:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个以制表符分隔的数据行，请使用*charlist*参数删除前导或尾随的空白而不删除制表符：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Changing Case
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改大小写
- en: 'PHP has several functions for changing the case of strings: `strtolower()`
    and `strtoupper()` operate on entire strings, `ucfirst()` operates only on the
    first character of the string, and `ucwords()` operates on the first character
    of each word in the string. Each function takes a string to operate on as an argument
    and returns a copy of that string, appropriately changed. For example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: PHP有几个函数可以改变字符串的大小写：`strtolower()`和`strtoupper()`作用于整个字符串，`ucfirst()`仅作用于字符串的第一个字符，`ucwords()`作用于字符串中每个单词的第一个字符。每个函数接受一个要操作的字符串作为参数，并返回相应修改后的副本。例如：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you’ve got a mixed-case string that you want to convert to “title case,”
    where the first letter of each word is in uppercase and the rest of the letters
    are in lowercase (and you’re not sure what case the string is in to begin with),
    use a combination of `strtolower()` and `ucwords()`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个混合大小写的字符串，并且想要将其转换为“标题案例”，其中每个单词的第一个字母大写，其余字母小写（并且您不确定字符串最初的大小写），请使用`strtolower()`和`ucwords()`的组合：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Encoding and Escaping
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编码与转义
- en: Because PHP programs often interact with HTML pages, web addresses (URLs), and
    databases, there are functions to help you work with those types of data. HTML,
    web addresses, and database commands are all strings, but they each require different
    characters to be escaped in different ways. For instance, a space in a web address
    must be written as `%20`, while a literal less-than sign (`<`) in an HTML document
    must be written as `&lt;`. PHP has a number of built-in functions to convert to
    and from these encodings.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因为PHP程序通常与HTML页面、网址（URL）和数据库交互，所以有一些函数可以帮助您处理这些类型的数据。HTML、网址和数据库命令都是字符串，但它们每个都需要以不同的方式进行不同的字符转义。例如，网址中的空格必须写成`%20`，而HTML文档中的文字小于号(`<`)必须写成`&lt;`。PHP有许多内置函数用于在这些编码之间进行转换。
- en: HTML
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML
- en: 'Special characters in HTML are represented by *entities* such as `&amp;` (`&`)
    and `&lt;` (`<`). There are two PHP functions that turn special characters in
    a string into their entities: one for removing HTML tags, and one for extracting
    only meta tags.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: HTML中的特殊字符由*实体*表示，如`&amp;`（`&`）和`&lt;`（`<`）。有两个PHP函数将字符串中的特殊字符转换为它们的实体：一个用于移除HTML标签，另一个用于仅提取元标签。
- en: Entity-quoting all special characters
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对所有特殊字符进行实体引用
- en: The `htmlentities()` function changes all characters with HTML entity equivalents
    into those equivalents (with the exception of the space character). This includes
    the less-than sign (`<`), the greater-than sign (`>`), the ampersand (`&`), and
    accented characters.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`htmlentities()`函数将所有具有HTML实体等效项的字符转换为这些等效项（空格字符除外）。这包括小于号(`<`)、大于号(`>`)、和带重音的字符。'
- en: 'For example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The entity-escaped version, `&uuml;` (seen by viewing the source), correctly
    displays as ü in the rendered web page. As you can see, the space has not been
    turned into `&nbsp;`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 实体转义版本，`&uuml;`（查看源代码可见），在渲染的网页中正确显示为ü。正如你所见，空格没有被转换成`&nbsp;`。
- en: 'The `htmlentities()` function actually takes up to three arguments:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`htmlentities()`函数实际上可以接受最多三个参数：'
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The *encoding* parameter, if given, identifies the character set. The default
    is “UTF-8.” The *flags* parameter controls whether single and double quotes are
    turned into their entity forms. `ENT_COMPAT` (the default) converts only double
    quotes, `ENT_QUOTES` converts both types of quotes, and `ENT_NOQUOTES` converts
    neither. There is no option to convert only single quotes. For example:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*encoding*参数，如果给出，标识字符集。默认为“UTF-8”。*flags*参数控制是否将单引号和双引号转换为它们的实体形式。`ENT_COMPAT`（默认）仅转换双引号，`ENT_QUOTES`转换两种引号类型，`ENT_NOQUOTES`既不转换单引号也不转换双引号。没有选项只转换单引号。例如：'
- en: '[PRE40]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Entity-quoting only HTML syntax characters
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅对HTML语法字符进行实体引用
- en: 'The `htmlspecialchars()` function converts the smallest set of entities possible
    to generate valid HTML. The following entities are converted:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`htmlspecialchars()`函数将尽可能少地转换实体以生成有效的HTML。以下实体被转换：'
- en: Ampersands (`&`) are converted to `&amp;`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ampersands (`&`) are converted to `&amp;`
- en: Double quotes (`"`) are converted to `&quot;`
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双引号(`"`)被转换为`&quot;`
- en: Single quotes (`'`) are converted to `&#039;` (if `ENT_QUOTES` is on, as described
    for `htmlentities()`)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单引号(`'`)如果`ENT_QUOTES`打开，则被转换为`&#039;`（如`htmlentities()`所述）
- en: Less-than signs (`<`) are converted to `&lt;`
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于号(`<`)被转换为`&lt;`
- en: Greater-than signs (`>`) are converted to `&gt;`
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于号(`>`)被转换为`&gt;`
- en: If you have an application that displays data that a user has entered in a form,
    you need to run that data through `htmlspecialchars()` before displaying or saving
    it. If you don’t, and the user enters a string like `"angle < 30"` or `"sturm
    & drang"`, the browser will think the special characters are HTML, resulting in
    a garbled page.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个显示用户在表单中输入的数据的应用程序，则需要在显示或保存数据之前将该数据通过`htmlspecialchars()`运行。如果不这样做，用户输入像`"angle
    < 30"`或`"sturm & drang"`这样的字符串，浏览器将认为特殊字符是HTML，导致页面混乱。
- en: 'Like `htmlentities()`, `htmlspecialchars()` can take up to three arguments:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 像`htmlentities()`一样，`htmlspecialchars()`最多可以接受三个参数：
- en: '[PRE41]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The *flags* and *encoding* arguments have the same meaning that they do for
    `html``entities()`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags*和*encoding*参数具有与`htmlentities()`相同的含义。'
- en: 'There are no functions specifically for converting back from the entities to
    the original text, because this is rarely needed. There is a relatively simple
    way to do this, though. Use the `get_html_translation_table()` function to fetch
    the translation table used by either of these functions in a given quote style.
    For example, to get the translation table that `html``entities()` uses, do this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 没有专门用于将实体转换回原始文本的函数，因为这很少需要。不过，有一种相对简单的方法可以做到这一点。使用`get_html_translation_table()`函数获取由这些函数之一在给定引用样式中使用的翻译表。例如，要获取`htmlentities()`使用的翻译表，可以这样做：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To get the table for `htmlspecialchars()` in `ENT_NOQUOTES` mode, use:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`htmlspecialchars()`中`ENT_NOQUOTES`模式下的表格，请使用：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A nice trick is to use this translation table, flip it using `array_flip()`,
    and feed it to `strtr()` to apply it to a string, thereby effectively doing the
    reverse of `html``entities()`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不错的技巧是使用这个翻译表，用`array_flip()`来翻转它，并将其传递给`strtr()`以将其应用到字符串中，从而有效地执行`htmlentities()`的反向操作：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can, of course, also fetch the translation table, add whatever other translations
    you want to it, and then do the `strtr()`. For example, if you wanted `htmlentities()`
    to also encode each space to `&nbsp;`, you would do:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您也可以获取翻译表，添加您想要的任何其他翻译，并使用`strtr()`。例如，如果您想要`htmlentities()`还将每个空格编码为`&nbsp;`，可以这样做：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Removing HTML tags
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除HTML标签
- en: 'The `strip_tags()` function removes HTML tags from a string:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip_tags()`函数从字符串中删除HTML标签：'
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The function may take a second argument that specifies a string of tags to
    leave in the string. List only the opening forms of the tags. The closing forms
    of tags listed in the second parameter are also preserved:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数可能接受第二个参数，该参数指定要在字符串中保留的标记字符串。只列出标记的开放形式。列在第二个参数中的标记的闭合形式也会被保留：
- en: '[PRE47]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Attributes in preserved tags are not changed by `strip_tags()`. Because attributes
    such as `style` and `onmouseover` can affect the look and behavior of web pages,
    preserving some tags with `strip_tags()` won’t necessarily remove the potential
    for abuse.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 保留标签中的属性不会被`strip_tags()`改变。因为诸如`style`和`onmouseover`之类的属性可能会影响网页的外观和行为，所以用`strip_tags()`保留一些标签不一定会消除滥用的可能性。
- en: Extracting meta tags
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提取元标签
- en: 'The `get_meta_tags()` function returns an array of the meta tags for an HTML
    page, specified as a local filename or URL. The name of the meta tag (`keywords`,
    `author`, `description`, etc.) becomes the key in the array, and the content of
    the meta tag becomes the corresponding value:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_meta_tags()`函数返回指定为本地文件名或URL的HTML页面的meta标签数组。meta标签的名称（`keywords`、`author`、`description`等）成为数组中的键，而meta标签的内容成为相应的值：'
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The general form of the function is:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的一般形式是：
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Pass a `true` value for *use_include_path* to let PHP attempt to open the file
    using the standard include path.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 传递`true`值给*use_include_path*，让PHP尝试使用标准包含路径打开文件。
- en: URLs
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL
- en: PHP provides functions to convert to and from URL encoding, which allows you
    to build and decode URLs. There are actually two types of URL encoding, which
    differ in how they treat spaces. The first (specified by RFC 3986) treats a space
    as just another illegal character in a URL and encodes it as `%20`. The second
    (implementing the `application/x-www-form-urlencoded` system) encodes a space
    as a `+` and is used in building query strings.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: PHP提供了用于转换到和从URL编码的函数，这使您能够构建和解码URL。实际上有两种类型的URL编码，它们在如何处理空格方面有所不同。第一种（由RFC
    3986指定）将空格视为URL中的另一个非法字符，并将其编码为`%20`。第二种（实现`application/x-www-form-urlencoded`系统）将空格编码为`+`，用于构建查询字符串。
- en: 'Note that you don’t want to use these functions on a complete URL, such as
    *[*http://www.example.com/hello*](http://www.example.com/hello)*, as they will
    escape the colons and slashes to produce:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您不应在完整URL上使用这些函数，例如[*http://www.example.com/hello*](http://www.example.com/hello)，因为它们将转义冒号和斜杠以生成：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Encode only partial URLs (the bit after *http://www.example.com/*) and add the
    protocol and domain name later.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 仅对部分URL进行编码（*http://www.example.com/*之后的部分），稍后添加协议和域名。
- en: RFC 3986 encoding and decoding
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RFC 3986编码和解码
- en: 'To encode a string according to the URL conventions, use `rawurlencode()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据URL约定对字符串进行编码，请使用`rawurlencode()`：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This function takes a string and returns a copy with illegal URL characters
    encoded in the `%dd` convention.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个字符串，并返回一个使用`%dd`约定编码的副本，其中包含非法的URL字符。
- en: 'If you are dynamically generating hypertext references for links in a page,
    you need to convert them with `rawurlencode()`:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在为页面中的链接动态生成超文本引用，需要使用`rawurlencode()`进行转换：
- en: '[PRE52]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `rawurldecode()` function decodes URL-encoded strings:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`rawurldecode()`函数解码URL编码的字符串：'
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Query-string encoding
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询字符串编码
- en: 'The `urlencode()` and `urldecode()` functions differ from their raw counterparts
    only in that they encode spaces as plus signs (`+`) instead of as the sequence
    `%20`. This is the format for building query strings and cookie values. These
    functions can be useful in supplying form-like URLs in the HTML. PHP automatically
    decodes query strings and cookie values, so you don’t need to use these functions
    to process those values. The functions are useful for generating query strings:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlencode()`和`urldecode()`函数与其原始版本唯一的区别在于它们将空格编码为加号(`+`)而不是`%20`序列。这是构建查询字符串和cookie值的格式。这些函数在HTML中提供类似表单的URL时非常有用。PHP会自动解码查询字符串和cookie值，因此您不需要使用这些函数来处理这些值。这些函数在生成查询字符串时非常有用：'
- en: '[PRE54]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: SQL
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL
- en: 'Most database systems require that string literals in your SQL queries be escaped.
    SQL’s encoding scheme is pretty simple—single quotes, double quotes, NUL-bytes,
    and backslashes need to be preceded by a backslash. The `addslashes()` function
    adds these slashes, and the `stripslashes()` function removes them:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据库系统要求SQL查询中的字符串字面值进行转义。SQL的编码方案相当简单——单引号、双引号、NUL字节和反斜杠需要在前面加上反斜杠。`addslashes()`函数添加这些反斜杠，而`stripslashes()`函数则将其移除：
- en: '[PRE55]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: C-String Encoding
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C字符串编码
- en: The `addcslashes()` function escapes arbitrary characters by placing backslashes
    before them. With the exception of the characters in [Table 4-4](#single_character_escapes_recognized_by),
    characters with ASCII values less than 32 or above 126 are encoded with their
    octal values (e.g., `"\002"`). The `addcslashes()` and `stripcslashes()` functions
    are used with nonstandard database systems that have their own ideas of which
    characters need to be escaped.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`addcslashes()` 函数通过在特定字符前加上反斜杠来转义任意字符。除了 [Table 4-4](https://wiki.example.org/single_character_escapes_recognized_by)
    中的字符外，ASCII 值小于 32 或大于 126 的字符会用它们的八进制值进行编码（例如 `"\002"`）。`addcslashes()` 和 `stripcslashes()`
    函数用于非标准数据库系统，这些系统有自己的想法，即哪些字符需要转义。'
- en: Table 4-4\. Single-character escapes recognized by addcslashes() and stripcslashes()
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Table 4-4\. `addcslashes()` 和 `stripcslashes()` 识别的单字符转义
- en: '| ASCII value | Encoding |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| ASCII 值 | 编码 |'
- en: '| --- | --- |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| 7 | `\a` |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 7 | `\a` |'
- en: '| 8 | `\b` |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 8 | `\b` |'
- en: '| 9 | `\t` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| 9 | `\t` |'
- en: '| 10 | `\n` |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| 10 | `\n` |'
- en: '| 11 | `\v` |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 11 | `\v` |'
- en: '| 12 | `\f` |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 12 | `\f` |'
- en: '| 13 | `\r` |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 13 | `\r` |'
- en: 'Call `addcslashes()` with two arguments—the string to encode and the characters
    to escape:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个参数调用 `addcslashes()` —— 要编码的字符串和要转义的字符：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Specify a range of characters to escape with the `".."` construct:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `".."` 结构指定要转义的字符范围：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Beware of specifying `'0'`, `'a'`, `'b'`, `'f'`, `'n'`, `'r'`, `'t'`, or `'v'`
    in the character set, as they will be turned into `'\0'`, `'\a'`, and so on. These
    escapes are recognized by C and PHP and may cause confusion.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 警告在字符集中指定 `'0'`, `'a'`, `'b'`, `'f'`, `'n'`, `'r'`, `'t'`, 或 `'v'`，因为它们会转换为
    `'\0'`, `'\a'` 等。这些转义符由 C 和 PHP 识别，可能会引起混淆。
- en: '`stripcslashes()` takes a string and returns a copy with the escapes expanded:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`stripcslashes()` 接受一个字符串，并返回一个带有扩展转义的副本：'
- en: '[PRE58]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'For example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Comparing Strings
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较字符串
- en: PHP has two operators and six functions for comparing strings to each other.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 有两个操作符和六个函数用于比较字符串：
- en: Exact Comparisons
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精确比较
- en: 'You can compare two strings for equality with the `==` and `===` operators.
    These operators differ in how they deal with nonstring operands. The `==` operator
    casts string operands to numbers, so it reports that `3` and `"3"` are equal.
    Due to the rules for casting strings to numbers, it would also report that `3`
    and `"3b"` are equal, as only the portion of the string up to a non-number character
    is used in casting. The `===` operator does not cast, and returns `false` if the
    data types of the arguments differ:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `==` 和 `===` 操作符可以比较两个字符串是否相等。这两个操作符在处理非字符串操作数时有所不同。`==` 操作符会将字符串操作数转换为数字，因此会报告
    `3` 和 `"3"` 是相等的。根据将字符串转换为数字的规则，它也会报告 `3` 和 `"3b"` 是相等的，因为只使用字符串中非数字字符之前的部分进行转换。而
    `===` 操作符不进行类型转换，如果参数的数据类型不同，则返回 `false`：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The comparison operators (`<`, `<=`, `>`, `>=`) also work on strings:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 比较操作符 (`<`, `<=`, `>`, `>=`) 也适用于字符串：
- en: '[PRE61]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'However, the comparison operators give unexpected results when comparing strings
    and numbers:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当比较字符串和数字时，比较操作符会给出意外的结果：
- en: '[PRE62]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: When one argument to a comparison operator is a number, the other argument is
    cast to a number. This means that `"PHP Rocks"` is cast to a number, giving `0`
    (since the string does not start with a number). Because 0 is less than 5, PHP
    prints `"PHP Rocks < 5"`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较操作符的一个参数是数字时，另一个参数会被转换为数字。这意味着 `"PHP Rocks"` 被转换为数字，得到 `0`（因为字符串不以数字开头）。因为
    0 小于 5，PHP 输出 `"PHP Rocks < 5"`。
- en: 'To explicitly compare two strings as strings, casting numbers to strings if
    necessary, use the `strcmp()` function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 若要明确将两个字符串作为字符串比较，必要时将数字转换为字符串，请使用 `strcmp()` 函数：
- en: '[PRE63]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The function returns a number less than 0 if *string_1* sorts before *string_2*,
    greater than 0 if *string_2* sorts before *string_1*, or 0 if they are the same:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数返回一个小于 0 的数，如果 *string_1* 在 *string_2* 前排序；如果 *string_2* 在 *string_1* 前排序，则返回大于
    0 的数；如果它们相同，则返回 0：
- en: '[PRE64]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A variation on `strcmp()` is `strcasecmp()`, which converts strings to lowercase
    before comparing them. Its arguments and return values are the same as those for
    `strcmp()`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcmp()` 的变体是 `strcasecmp()`，它在比较之前将字符串转换为小写。它的参数和返回值与 `strcmp()` 相同：'
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Another variation on string comparison is to compare only the first few characters
    of the string. The `strncmp()` and `strncasecmp()` functions take an additional
    argument, the initial number of characters to use for the comparisons:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种字符串比较的变体是仅比较字符串的前几个字符。`strncmp()` 和 `strncasecmp()` 函数需要额外的参数，即用于比较的初始字符数：
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The final variation on these functions is *natural-order* comparison with `strnatcmp()`
    and `strnatcasecmp()`, which take the same arguments as `strcmp()` and return
    the same kinds of values. Natural-order comparison identifies numeric portions
    of the strings being compared and sorts the string parts separately from the numeric
    parts.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的最后一种变体是 *自然顺序* 比较，使用 `strnatcmp()` 和 `strnatcasecmp()`，它们与 `strcmp()` 使用相同的参数并返回相同类型的值。自然顺序比较识别被比较字符串中的数字部分，并将字符串部分与数字部分分别排序。
- en: '[Table 4-5](#natural_order_versus_ascii_order) shows strings in natural order
    and ASCII order.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 4-5](#natural_order_versus_ascii_order) 展示了自然顺序和ASCII顺序中的字符串。'
- en: Table 4-5\. Natural order versus ASCII order
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-5\. 自然顺序与ASCII顺序
- en: '| Natural order | ASCII order |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 自然顺序 | ASCII 顺序 |'
- en: '| --- | --- |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `pic1.jpg` | `pic1.jpg` |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `pic1.jpg` | `pic1.jpg` |'
- en: '| `pic5.jpg` | `pic10.jpg` |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `pic5.jpg` | `pic10.jpg` |'
- en: '| `pic10.jpg` | `pic5.jpg` |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `pic10.jpg` | `pic5.jpg` |'
- en: '| `pic50.jpg` | `pic50.jpg` |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `pic50.jpg` | `pic50.jpg` |'
- en: Approximate Equality
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 近似相等
- en: 'PHP provides several functions that let you test whether two strings are approximately
    equal—`soundex()`, `metaphone()`, `similar_text()`, and `levenshtein()`:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了几个函数，允许您测试两个字符串是否近似相等 — `soundex()`、`metaphone()`、`similar_text()` 和
    `levenshtein()`：
- en: '[PRE67]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The Soundex and Metaphone algorithms each yield a string that represents roughly
    how a word is pronounced in English. To see whether two strings are approximately
    equal with these algorithms, compare their pronunciations. You can compare Soundex
    values only to Soundex values and Metaphone values only to Metaphone values. The
    Metaphone algorithm is generally more accurate, as the following example demonstrates:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Soundex 和 Metaphone 算法各自生成一个字符串，大致表示一个英语单词的发音。要查看这些算法是否将两个字符串近似视为相等，请比较它们的发音。只能将
    Soundex 值与 Soundex 值比较，将 Metaphone 值与 Metaphone 值比较。如下示例所示，Metaphone 算法通常更准确：
- en: '[PRE68]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The `similar_text()` function returns the number of characters that its two
    string arguments have in common. The third argument, if present, is a variable
    in which to store the commonality as a percentage:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`similar_text()` 函数返回它的两个字符串参数共有的字符数。如果存在第三个参数，则将共性以百分比存储在其中：'
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The Levenshtein algorithm calculates the similarity of two strings based on
    how many characters you must add, substitute, or remove to make them the same.
    For instance, `"cat"` and `"cot"` have a Levenshtein distance of 1, because you
    need to change only one character (the `"a"` to an `"o"`) to make them the same:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Levenshtein 算法根据需要添加、替换或删除的字符数计算两个字符串的相似性。例如，`"cat"` 和 `"cot"` 的 Levenshtein
    距离为 1，因为您只需更改一个字符（将 `"a"` 改为 `"o"`）使它们相同：
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This measure of similarity is generally quicker to calculate than that used
    by the `similar_text()` function. Optionally, you can pass three values to the
    `leven``shtein()` function to individually weight insertions, deletions, and replacements—for
    instance, to compare a word against a contraction.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 此相似性度量通常比 `similar_text()` 函数使用的更快速。可选地，您可以将三个值传递给 `leven``shtein()` 函数，以分别加权插入、删除和替换
    —— 例如，比较一个单词与一个缩写。
- en: 'This example excessively weights insertions when comparing a string against
    its possible contraction, because contractions should never insert characters:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在比较字符串与其可能的缩写时过度加权插入，因为缩写不应插入字符：
- en: '[PRE71]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Manipulating and Searching Strings
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作和搜索字符串
- en: PHP has many functions to work with strings. The most commonly used functions
    for searching and modifying strings are those that use regular expressions to
    describe the string in question. The functions described in this section do not
    use regular expressions—they are faster than regular expressions, but they work
    only when you’re looking for a fixed string (for instance, if you’re looking for
    `"12/11/01"` rather than “any numbers separated by slashes”).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了许多用于处理字符串的函数。对于搜索和修改字符串最常用的函数是那些使用正则表达式来描述被查询字符串的函数。本节描述的函数不使用正则表达式 ——
    它们比正则表达式更快，但仅适用于寻找固定字符串（例如，如果您要查找 `"12/11/01"` 而不是 "由斜杠分隔的任意数字"）。
- en: Substrings
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子字符串
- en: 'If you know where the data that you are interested in lies in a larger string,
    you can copy it out with the `substr()` function:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道感兴趣的数据位于较大字符串的哪个位置，可以使用 `substr()` 函数将其复制出来：
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The *start* argument is the position in *string* at which to begin copying,
    with `0` meaning the start of the string. The *length* argument is the number
    of characters to copy (the default is to copy until the end of the string). For
    example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '*start* 参数是在 *string* 中开始复制的位置，`0` 表示字符串的开头。*length* 参数是要复制的字符数（默认是复制直到字符串的末尾）。例如：'
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To learn how many times a smaller string occurs within a larger one, use `substr_count()`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解较大字符串中较小字符串出现的次数，请使用 `substr_count()`：
- en: '[PRE74]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For example:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The `substr_replace()` function permits many kinds of string modifications:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `substr_replace()` 允许进行多种类型的字符串修改：
- en: '[PRE76]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The function replaces the part of *original* indicated by the *start* (`0` means
    the start of the string) and *length* values with the string *new*. If no fourth
    argument is given, `substr_replace()` removes the text from *start* to the end
    of the string.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 函数替换 *original* 指定部分，该部分由 *start*（`0` 表示字符串的开头）和 *length* 值与字符串 *new* 替换。如果未给出第四个参数，`substr_replace()`
    将删除从 *start* 到字符串末尾的文本。
- en: 'For instance:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE77]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Use a *length* of `0` to insert without deleting:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *length* 为 `0` 进行插入而不删除：
- en: '[PRE78]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Use a replacement of `""` to delete without inserting:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换 `""` 进行删除而不插入：
- en: '[PRE79]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Here’s how you can insert at the beginning of the string:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在字符串开头插入的方法：
- en: '[PRE80]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'A negative value for *start* indicates the number of characters from the end
    of the string from which to start the replacement:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*start* 的负值表示从字符串末尾开始替换的字符数：'
- en: '[PRE81]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'A negative *length* indicates the number of characters from the end of the
    string at which to stop deleting:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 负数 *length* 表示从字符串末尾停止删除的字符数：
- en: '[PRE82]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Miscellaneous String Functions
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 杂项字符串函数
- en: 'The `strrev()` function takes a string and returns a reversed copy of it:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `strrev()` 接受一个字符串并返回其反转副本：
- en: '[PRE83]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'For example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE84]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The `str_repeat()` function takes a string and a count and returns a new string
    consisting of the argument *string* repeated *count* times:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `str_repeat()` 接受一个字符串和一个计数，并返回一个由参数 *string* 重复 *count* 次的新字符串：
- en: '[PRE85]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'For example, to build a crude wavy horizontal rule:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，构建一个简陋的波浪形水平线：
- en: '[PRE86]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The `str_pad()` function pads one string with another. Optionally, you can
    say what string to pad with, and whether to pad on the left, right, or both:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `str_pad()` 使用一个字符串填充另一个字符串。可选地，您可以指定用于填充的字符串，以及是在左侧、右侧还是两侧填充：
- en: '[PRE87]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The default is to pad on the right with spaces:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 默认在右侧填充空格：
- en: '[PRE88]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The optional third argument is the string to pad with:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的第三个参数是要填充的字符串：
- en: '[PRE89]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The optional fourth argument can be `STR_PAD_RIGHT` (the default), `STR_PAD_LEFT`,
    or `STR_PAD_BOTH` (to center). For example:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的第四个参数可以是 `STR_PAD_RIGHT`（默认值）、`STR_PAD_LEFT` 或 `STR_PAD_BOTH`（居中）。例如：
- en: '[PRE90]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Decomposing a String
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解字符串
- en: PHP provides several functions to let you break a string into smaller components.
    In increasing order of complexity, they are `explode()`, `strtok()`, and `sscanf()`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 提供了几个函数，可以让你将一个字符串拆分成较小的组件。按复杂性递增的顺序，它们是 `explode()`、`strtok()` 和 `sscanf()`。
- en: Exploding and imploding
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分解和爆炸
- en: 'Data often arrives as strings, which must be broken down into an array of values.
    For instance, you might want to split up the comma-separated fields from a string
    such as `"Fred,25,Wilma`.`"` In these situations, use the `explode()` function:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 数据通常以字符串形式到达，必须将其拆分为值数组。例如，您可能想要从字符串 `"Fred,25,Wilma"` 中拆分逗号分隔的字段。在这些情况下，使用
    `explode()` 函数：
- en: '[PRE91]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The first argument, *separator*, is a string containing the field separator.
    The second argument, *string*, is the string to split. The optional third argument,
    *limit*, is the maximum number of values to return in the array. If the limit
    is reached, the last element of the array contains the remainder of the string:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数 *separator* 是包含字段分隔符的字符串。第二个参数 *string* 是要拆分的字符串。可选的第三个参数 *limit* 是在数组中返回的最大值数。如果达到限制，数组的最后一个元素包含字符串的其余部分：
- en: '[PRE92]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The `implode()` function does the exact opposite of `explode()`—it creates
    a large string from an array of smaller strings:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `implode()` 做与 `explode()` 正好相反的操作——它从较小字符串的数组创建一个大字符串：
- en: '[PRE93]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The first argument, *separator*, is the string to put between the elements
    of the second argument, *array*. To reconstruct the simple comma-separated value
    string, simply say:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数 *separator* 是要放在第二个参数 *array* 元素之间的字符串。要重建简单的逗号分隔值字符串，只需说：
- en: '[PRE94]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The `join()` function is an alias for `implode()`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `join()` 是 `implode()` 的别名。
- en: Tokenizing
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标记化
- en: 'The `strtok()` function lets you iterate through a string, getting a new chunk
    (token) each time. The first time you call it, you need to pass two arguments:
    the string to iterate over and the token separator. For example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `strtok()` 允许您遍历字符串，每次获取一个新的块（标记）。第一次调用它时，您需要传递两个参数：要遍历的字符串和标记分隔符。例如：
- en: '[PRE95]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'To retrieve the rest of the tokens, repeatedly call `strtok()` with only the
    separator:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索其余的标记，请反复调用 `strtok()`，只带分隔符：
- en: '[PRE96]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'For instance, consider this invocation:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下调用：
- en: '[PRE97]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The `strtok()` function returns `false` when there are no more tokens to be
    returned.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多标记可返回时，函数 `strtok()` 返回 `false`。
- en: Call `strtok()` with two arguments to reinitialize the iterator. This restarts
    the tokenizer from the start of the string.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个参数调用 `strtok()` 重新初始化迭代器。这会从字符串的开头重新启动标记化器。
- en: sscanf()
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sscanf()
- en: 'The `sscanf()` function decomposes a string according to a `printf()`-like
    template:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `sscanf()` 根据类似 `printf()` 的模板分解字符串：
- en: '[PRE98]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If used without the optional variables, `sscanf()` returns an array of fields:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有使用可选变量，`sscanf()` 返回字段数组：
- en: '[PRE99]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Pass references to variables to have the fields stored in those variables.
    The number of fields assigned is returned:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引用传递变量，使字段存储在这些变量中。返回分配的字段数：
- en: '[PRE100]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: String-Searching Functions
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串搜索函数
- en: 'Several functions find a string or character within a larger string. They come
    in three families: `strpos()` and `strrpos()`, which return a position; `strstr()`,
    `strchr()`, and friends, which return the string they find; and `strspn()` and
    `strcspn()`, which return how much of the start of the string matches a mask.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 几个函数在一个较大的字符串中查找字符串或字符。它们分为三类：`strpos()` 和 `strrpos()`，它们返回位置；`strstr()`、`strchr()`
    和相关函数，它们返回找到的字符串；以及 `strspn()` 和 `strcspn()`，它们返回字符串开头匹配掩码的数量。
- en: 'In all cases, if you specify a number as the “string” to search for, PHP treats
    that number as the ordinal value of the character to search for. Thus, these function
    calls are identical because 44 is the ASCII value of the comma:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，如果您指定一个数字作为要搜索的“字符串”，PHP 将该数字视为要搜索的字符的序数值。因此，这些函数调用是相同的，因为44是逗号的ASCII值：
- en: '[PRE101]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'All the string-searching functions return `false` if they can’t find the substring
    you specified. If the substring occurs at the beginning of the string, the functions
    return `0`. Because `false` casts to the number `0`, always compare the return
    value with `===` when testing for failure:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的字符串搜索函数在无法找到指定的子字符串时都返回 `false`。如果子字符串出现在字符串的开头，这些函数返回 `0`。因为 `false` 转换为数字
    `0`，在测试失败时始终使用 `===` 比较返回值：
- en: '[PRE102]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Searches returning position
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回位置的搜索
- en: 'The `strpos()` function finds the first occurrence of a small string in a larger
    string:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `strpos()` 在较大字符串中查找小字符串的第一次出现：
- en: '[PRE103]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: If the small string isn’t found, `strpos()` returns `false`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未找到小字符串，`strpos()` 返回 `false`。
- en: The `strrpos()` function finds the last occurrence of a character in a string.
    It takes the same arguments and returns the same type of value as `strpos()`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `strrpos()` 在字符串中查找字符的最后一个出现。它接受与 `strpos()` 相同的参数并返回相同类型的值。
- en: 'For instance:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE104]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Searches returning rest of string
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回其余字符串的搜索
- en: 'The `strstr()` function finds the first occurrence of a small string in a larger
    string and returns from that small string on. For instance:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `strstr()` 查找较大字符串中第一次出现的小字符串，并从该小字符串开始返回。例如：
- en: '[PRE105]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The variations on `strstr()` are:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '`strstr()` 的变体有：'
- en: '`stristr()`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`stristr()`'
- en: Case-insensitive `strstr()`
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 不区分大小写的 `strstr()`
- en: '`strchr()`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`strchr()`'
- en: Alias for `strstr()`
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`strstr()` 的别名'
- en: '`strrchr()`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`strrchr()`'
- en: Finds last occurrence of a character in a string
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 查找字符串中最后一个字符的出现
- en: As with `strrpos()`, `strrchr()` searches backward in the string, but only for
    a single character, not for an entire string.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `strrpos()` 类似，`strrchr()` 向后搜索字符串，但仅针对单个字符，而不是整个字符串。
- en: Searches using masks
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用掩码进行搜索
- en: 'If you thought `strrchr()` was esoteric, you haven’t seen anything yet. The
    `strspn()` and `strcspn()` functions tell you how many characters at the beginning
    of a string are composed of certain characters:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为 `strrchr()` 很奇怪，那么您还没见过。`strspn()` 和 `strcspn()` 函数告诉您字符串开头有多少字符由特定字符组成：
- en: '[PRE106]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'For example, this function tests whether a string holds an octal number:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此函数测试字符串是否包含八进制数：
- en: '[PRE107]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'The *c* in `strcspn()` stands for *complement*—it tells you how much of the
    start of the string is not composed of the characters in the character set. Use
    it when the number of interesting characters is greater than the number of uninteresting
    characters. For example, this function tests whether a string has any NUL-bytes,
    tabs, or carriage returns:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`strcspn()`中的*c*代表*complement*，表示字符串开头不包含字符集中字符的长度。当有趣字符的数量大于无趣字符的数量时使用它。例如，此函数测试字符串是否包含任何NUL字节、制表符或回车符：'
- en: '[PRE108]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Decomposing URLs
  id: totrans-383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解析URL
- en: 'The `parse_url()` function returns an array of components of a URL:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`parse_url()`函数返回URL的各个组成部分的数组：'
- en: '[PRE109]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'For example:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE110]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The possible keys of the hash are `scheme`, `host`, `port`, `user`, `pass`,
    `path`, `query`, and `fragment`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希的可能键包括`scheme`、`host`、`port`、`user`、`pass`、`path`、`query`和`fragment`。
- en: Regular Expressions
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正则表达式
- en: If you need more complex searching functionality than the previous methods provide,
    you can use a regular expression—a string that represents a *pattern*. The regular
    expression functions compare that pattern to another string and see if any of
    the string matches the pattern. Some functions tell you whether there was a match,
    while others make changes to the string.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要比前面的方法提供更复杂的搜索功能，可以使用正则表达式——它是表示*模式*的字符串。正则表达式函数会将该模式与另一个字符串进行比较，并查看字符串中是否有任何匹配模式的部分。一些函数告诉您是否有匹配，而其他函数则对字符串进行更改。
- en: 'There are three uses for regular expressions: matching, which can also be used
    to extract information from a string; substituting new text for matching text;
    and splitting a string into an array of smaller chunks. PHP has functions for
    all. For instance, `preg_match()` does a regular expression match.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式有三个用途：匹配，也可以用于从字符串中提取信息；用新文本替换匹配文本；将字符串分割成较小块的数组。PHP有适用于所有这些情况的函数。例如，`preg_match()`执行正则表达式匹配。
- en: Perl has long been considered the benchmark for powerful regular expressions.
    PHP uses a C library called *pcre* to provide almost complete support for Perl’s
    arsenal of regular expression features. Perl regular expressions act on arbitrary
    binary data, so you can safely match with patterns or strings that contain the
    NUL-byte (`\x00`).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，Perl一直被认为是功能强大的正则表达式的基准。PHP使用称为*pcre*的C库来几乎完全支持Perl的正则表达式功能集合。Perl正则表达式作用于任意二进制数据，因此您可以安全地使用包含NUL字节（`\x00`）的模式或字符串进行匹配。
- en: The Basics
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础知识
- en: Most characters in a regular expression are literal characters, meaning that
    they match only themselves. For instance, if you search for the regular expression
    `"/cow/"` in the string `"Dave was a cowhand"`, you get a match because `"cow"`
    occurs in that string.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中的大多数字符都是字面字符，意味着它们仅匹配它们自己。例如，如果您在字符串`"Dave was a cowhand"`中搜索正则表达式`"/cow/"`，您会得到一个匹配，因为该字符串中包含`"cow"`。
- en: 'Some characters have special meanings in regular expressions. For instance,
    a caret (`^`) at the beginning of a regular expression indicates that it must
    match the beginning of the string (or, more precisely, *anchors* the regular expression
    to the beginning of the string):'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 一些字符在正则表达式中具有特殊含义。例如，正则表达式开头的插入符号（`^`）表示它必须匹配字符串的开头（或者更准确地说，将正则表达式锚定到字符串的开头）：
- en: '[PRE111]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Similarly, a dollar sign (`$`) at the end of a regular expression means that
    it must match the end of the string (i.e., anchors the regular expression to the
    end of the string):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，正则表达式末尾的美元符号（`$`）表示它必须匹配字符串的末尾（即将正则表达式锚定到字符串的末尾）：
- en: '[PRE112]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'A period (`.`) in a regular expression matches any single character:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式中的句点（`.`）匹配任意单个字符：
- en: '[PRE113]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'If you want to match one of these special characters (called a *metacharacter*),
    you have to escape it with a backslash:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想匹配这些特殊字符中的一个（称为*元字符*），您必须使用反斜杠进行转义：
- en: '[PRE114]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Regular expressions are case-sensitive by default, so the regular expression
    `"/cow/"` doesn’t match the string `"COW"`. If you want to perform a case-insensitive
    match, you specify a flag to indicate that (as you’ll see later in this chapter).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，正则表达式区分大小写，因此正则表达式`"/cow/"`不匹配字符串`"COW"`。如果您想执行不区分大小写的匹配，可以指定一个标志（稍后在本章中将会看到）。
- en: 'So far, we haven’t done anything we couldn’t have done with the string functions
    we’ve already seen, like `strstr()`. The real power of regular expressions comes
    from their ability to specify abstract patterns that can match many different
    character sequences. You can specify three basic types of abstract patterns in
    a regular expression:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有做任何与我们已经看过的字符串函数（如 `strstr()`）无法完成的事情。正则表达式的真正威力来自于它们能够指定抽象模式，这些模式可以匹配许多不同的字符序列。您可以在正则表达式中指定三种基本类型的抽象模式：
- en: A set of acceptable characters that can appear in the string (e.g., alphabetic
    characters, numeric characters, specific punctuation characters)
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以出现在字符串中的可接受字符集（例如，字母字符、数字字符、特定标点字符）
- en: A set of alternatives for the string (e.g., `"com"`, `"edu"`, `"net"`, or `"org"`)
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组字符串的替代项（例如 `"com"`、`"edu"`、`"net"` 或 `"org"`）
- en: A repeating sequence in the string (e.g., at least one but not more than five
    numeric characters)
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串中的重复序列（例如，至少一个但不超过五个数字字符）
- en: These three kinds of patterns can be combined in countless ways to create regular
    expressions that match such things as valid phone numbers and URLs.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种类型的模式可以以无数种方式结合在一起，以创建能够匹配有效电话号码和URL等内容的正则表达式。
- en: Character Classes
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符类
- en: 'To specify a set of acceptable characters in your pattern, you can either build
    a character class yourself or use a predefined one. You can build your own character
    class by enclosing the acceptable characters in square brackets:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模式中指定一组可接受的字符集，您可以自己构建一个字符类或使用预定义的字符类。您可以通过将可接受的字符括在方括号中来构建自己的字符类：
- en: '[PRE115]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The regular expression engine finds a `"c"`, then checks that the next character
    is one of `"a"`, `"e"`, `"i"`, `"o"`, or `"u"`. If it isn’t a vowel, the match
    fails and the engine goes back to looking for another `"c"`. If a vowel is found,
    the engine checks that the next character is a `"t"`. If it is, the engine is
    at the end of the match and returns `true`. If the next character isn’t a `"t"`,
    the engine goes back to looking for another `"c"`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式引擎找到一个 `"c"`，然后检查下一个字符是否是 `"a"`、`"e"`、`"i"`、`"o"` 或 `"u"` 中的一个元音字母。如果不是元音字母，则匹配失败，引擎会回到寻找另一个
    `"c"`。如果找到一个元音字母，则引擎检查下一个字符是否是 `"t"`。如果是，则引擎处于匹配的末尾并返回 `true`。如果下一个字符不是 `"t"`，则引擎会回到寻找另一个
    `"c"`。
- en: 'You can negate a character class with a caret (`^`) at the start:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在开头使用插入符 (`^`) 来否定一个字符类：
- en: '[PRE116]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: In this case, the regular expression engine is looking for a `"c"` followed
    by a character that isn’t a vowel, followed by a `"t"`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，正则表达式引擎正在寻找一个以 `"c"` 开头的字符，后面跟着一个不是元音字母的字符，然后是一个 `"t"`。
- en: 'You can define a range of characters with a hyphen (`-`). This simplifies character
    classes like “all letters” and “all digits”:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用连字符 (`-`) 定义字符的范围。这简化了字符类，例如“所有字母”和“所有数字”：
- en: '[PRE117]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: When you are specifying a character class, some special characters lose their
    meaning, while others take on new meanings. In particular, the `$` anchor and
    the period lose their meaning in a character class, while the `^` character is
    no longer an anchor but negates the character class if it is the first character
    after the open bracket. For instance, `[^\]]` matches any nonclosing bracket character,
    while `[$.^]` matches any dollar sign, period, or caret.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定字符类时，一些特殊字符失去其含义，而其他字符则具有新的含义。特别地，`$` 锚点和句点在字符类中失去其含义，而 `^` 字符如果是开方括号后的第一个字符，则不再是锚点，而是否定字符类。例如，`[^\]]`
    匹配任何非闭合括号字符，而 `[$.^]` 匹配任何美元符号、句点或插入符。
- en: The various regular expression libraries define shortcuts for character classes,
    including digits, alphabetic characters, and whitespace.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 各种正则表达式库定义了字符类的快捷方式，包括数字、字母字符和空白字符。
- en: Alternatives
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替代项
- en: 'You can use the vertical pipe (`|`) character to specify alternatives in a
    regular expression:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用竖线 (`|`) 字符来指定正则表达式中的替代项：
- en: '[PRE118]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The precedence of alternation can be a surprise: `"/^cat|dog$/"` selects from
    `"^cat"` and `"dog$"`, meaning that it matches a line that either starts with
    `"cat"` or ends with `"dog"`. If you want a line that contains just `"cat"` or
    `"dog"`, you need to use the regular expression `"/^(cat|dog)$/"`.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 替代的优先级可能会让人感到意外：`"/^cat|dog$/"` 会从 `"^cat"` 和 `"dog$"` 中选择，意味着它匹配以 `"cat"` 开头或以
    `"dog"` 结尾的行。如果您希望匹配仅包含 `"cat"` 或 `"dog"` 的行，则需要使用正则表达式 `"/^(cat|dog)$/"`。
- en: 'You can combine character classes and alternation to, for example, check for
    strings that don’t start with a capital letter:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以结合字符类和替代项，例如检查不以大写字母开头的字符串：
- en: '[PRE119]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Repeating Sequences
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复序列
- en: To specify a repeating pattern, you use a *quantifier*. The quantifier goes
    after the pattern that’s repeated and says how many times to repeat that pattern.
    [Table 4-6](#regular_expression_quantifiers) shows the quantifiers that are supported
    by PHP’s regular expressions.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定重复模式，需要使用*量词*。量词跟在要重复的模式之后，并指定重复该模式的次数。[表格 4-6](#regular_expression_quantifiers)
    显示了 PHP 正则表达式支持的量词。
- en: Table 4-6\. Regular expression quantifiers
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 4-6\. 正则表达式量词
- en: '| Quantifier | Meaning |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 量词 | 含义 |'
- en: '| --- | --- |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `?` | 0 or 1 |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 0 或 1 次 |'
- en: '| `*` | 0 or more |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 0 或更多次 |'
- en: '| `+` | 1 or more |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 1 或更多次 |'
- en: '| `{` *n* `}` | Exactly *n* times |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| `{` *n* `}` | 恰好 *n* 次 |'
- en: '| `{` *n* `,` *m* `}` | At least *n*, no more than *m* times |'
  id: totrans-435
  prefs: []
  type: TYPE_TB
  zh: '| `{` *n* `,` *m* `}` | 至少 *n* 次，不超过 *m* 次 |'
- en: '| `{` *n* `,}` | At least *n* times |'
  id: totrans-436
  prefs: []
  type: TYPE_TB
  zh: '| `{` *n* `,}` | 至少 *n* 次 |'
- en: 'To repeat a single character, simply put the quantifier after the character:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 要重复单个字符，只需将量词放在字符后面：
- en: '[PRE120]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'With quantifiers and character classes, we can actually do something useful,
    like matching valid US telephone numbers:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 使用量词和字符类，我们实际上可以做一些有用的事情，比如匹配有效的美国电话号码：
- en: '[PRE121]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Subpatterns
  id: totrans-441
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子模式
- en: 'You can use parentheses to group bits of a regular expression together to be
    treated as a single unit called a *subpattern*:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用括号将正则表达式的各部分分组，以便将其作为称为*子模式*的单个单元处理：
- en: '[PRE122]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The parentheses also cause the substring that matches the subpattern to be
    captured. If you pass an array as the third argument to a match function, the
    array is populated with any captured substrings:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 括号还会导致匹配子模式的子字符串被捕获。如果将数组作为 match 函数的第三个参数传递，数组将填充任何捕获的子字符串：
- en: '[PRE123]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The zeroth element of the array is set to the entire string being matched against.
    The first element is the substring that matched the first subpattern (if there
    is one), the second element is the substring that matched the second subpattern,
    and so on.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的零号元素设置为整个匹配的字符串。第一个元素是匹配第一个子模式（如果有的话）的子字符串，第二个元素是匹配第二个子模式的子字符串，依此类推。
- en: Delimiters
  id: totrans-447
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定界符
- en: 'Perl-style regular expressions emulate the Perl syntax for patterns, which
    means that each pattern must be enclosed in a pair of delimiters. Traditionally,
    the forward slash (`/`) character is used; for example, `/`*pattern*`/`. However,
    any nonalphanumeric character other than the backslash character (`\`) can be
    used to delimit a Perl-style pattern. This is useful for matching strings containing
    slashes, such as filenames. For example, the following are equivalent:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: Perl 风格的正则表达式模拟了 Perl 模式的语法，这意味着每个模式必须用一对定界符括起来。传统上，正斜杠 (`/`) 字符被使用；例如，`/`*模式*`/`。然而，除反斜杠
    (`\`) 字符之外的任何非字母数字字符都可以用于分隔 Perl 风格的模式。这对于匹配包含斜杠的字符串（例如文件名）非常有用。例如，以下两者是等价的：
- en: '[PRE124]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Parentheses (`()`), curly braces (`{}`), square brackets (`[]`), and angle
    brackets (`<>`) can be used as pattern delimiters:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 括号 (`()`)、大括号 (`{}`)、方括号 (`[]`) 和尖括号 (`<>`) 可以用作模式定界符：
- en: '[PRE125]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The section [“Trailing Options”](#trailing_options) discusses the single-character
    modifiers you can put after the closing delimiter to modify the behavior of the
    regular expression engine. A very useful one is `x`, which makes the regular expression
    engine strip whitespace and `#`-marked comments from the regular expression before
    matching. These two patterns are the same, but one is much easier to read:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 章节 [“尾随选项”](#trailing_options) 讨论了你可以在结束定界符后添加的单字符修饰符，以修改正则表达式引擎的行为。一个非常有用的选项是
    `x`，它使正则表达式引擎在匹配之前从正则表达式中去除空白和 `#` 标记的注释。这两个模式是相同的，但一个更易于阅读：
- en: '[PRE126]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Match Behavior
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匹配行为
- en: 'The period (`.`) matches any character except for a newline (`\n`). The dollar
    sign (`$`) matches at the end of the string or, if the string ends with a newline,
    just before that newline:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 句点 (`.`) 匹配除换行符 (`\n`) 外的任何字符。美元符号 (`$`) 匹配字符串的末尾，或者如果字符串以换行符结尾，则在该换行符之前：
- en: '[PRE127]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Character Classes
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符类
- en: As shown in [Table 4-7](#character_classes-id00004), Perl-compatible regular
    expressions define a number of named sets of characters that you can use in character
    classes. The expansions in [Table 4-7](#character_classes-id00004) are for English.
    The actual letters vary from locale to locale.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [表格 4-7](#character_classes-id00004) 所示，Perl 兼容的正则表达式定义了一些命名字符集，你可以在字符类中使用这些字符集。[表格 4-7](#character_classes-id00004)
    中的扩展是针对英文的。实际字母根据地区而有所不同。
- en: 'aEach `[:` *something* `:]` class can be used in place of a character in a
    character class. For instance, to find any character that’s a digit, an uppercase
    letter, or an “at” sign (`@`), use the following regular expression:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `[:` *something* `:]` 类可以用于字符类中的字符位置。例如，要查找任何数字、大写字母或“at”符号 (`@`) 的字符，请使用以下正则表达式：
- en: '[PRE128]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'However, you can’t use a character class as the endpoint of a range:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不能使用字符类作为范围的结束点：
- en: '[PRE129]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Some locales consider certain character sequences as if they were a single
    character—these are called *collating sequences*. To match one of these multicharacter
    sequences in a character class, enclose it with `[.` and `.]`. For example, if
    your locale has the collating sequence `ch`, you can match `s`, `t`, or `ch` with
    this character class:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 某些区域设置认为某些字符序列就像它们是一个单独的字符一样 — 这些称为*整理序列*。要在字符类中匹配其中一个多字符序列，请用 `[.` 和 `.]` 括起来。例如，如果你的区域设置有整理序列
    `ch`，你可以用这个字符类匹配 `s`、`t` 或 `ch`：
- en: '[PRE130]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: The final extension to character classes is the *equivalence class*, which you
    specify by enclosing the character within `[=` and `=]`. Equivalence classes match
    characters that have the same collating order, as defined in the current locale.
    For example, a locale may define `a`, `á`, and `ä` as having the same sorting
    precedence. To match any one of them, the equivalence class is `[=a=]`.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符类的最终扩展是*等价类*，你可以通过将字符括在 `[=` 和 `=]` 中指定。等价类匹配具有相同排序顺序的字符，如当前区域设置中定义的那样。例如，某个区域设置可能将
    `a`、`á` 和 `ä` 定义为具有相同排序优先级。要匹配它们中的任何一个，等价类是 `[=a=]`。
- en: Table 4-7\. Character classes
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-7\. 字符类
- en: '| Class | Description | Expansion |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| 类别 | 描述 | 扩展 |'
- en: '| --- | --- | --- |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `[:alnum:]` | Alphanumeric characters | `[0-9a-zA-Z]` |'
  id: totrans-469
  prefs: []
  type: TYPE_TB
  zh: '| `[:alnum:]` | 字母数字字符 | `[0-9a-zA-Z]` |'
- en: '| `[:alpha:]` | Alphabetic characters (letters) | `[a-zA-Z]` |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '| `[:alpha:]` | 字母字符（字母） | `[a-zA-Z]` |'
- en: '| `[:ascii:]` | 7-bit ASCII | `[\x01-\x7F]` |'
  id: totrans-471
  prefs: []
  type: TYPE_TB
  zh: '| `[:ascii:]` | 7位 ASCII | `[\x01-\x7F]` |'
- en: '| `[:blank:]` | Horizontal whitespace (space, tab) | `[ \t]` |'
  id: totrans-472
  prefs: []
  type: TYPE_TB
  zh: '| `[:blank:]` | 水平空白（空格、制表符） | `[ \t]` |'
- en: '| `[:cntrl:]` | Control characters | `[\x01-\x1F]` |'
  id: totrans-473
  prefs: []
  type: TYPE_TB
  zh: '| `[:cntrl:]` | 控制字符 | `[\x01-\x1F]` |'
- en: '| `[:digit:]` | Digits | `[0-9]` |'
  id: totrans-474
  prefs: []
  type: TYPE_TB
  zh: '| `[:digit:]` | 数字 | `[0-9]` |'
- en: '| `[:graph:]` | Characters that use ink to print (nonspace, noncontrol) | `[^\x01-\x20]`
    |'
  id: totrans-475
  prefs: []
  type: TYPE_TB
  zh: '| `[:graph:]` | 使用墨水打印的字符（非空格、非控制字符） | `[^\x01-\x20]` |'
- en: '| `[:lower:]` | Lowercase letter | `[a-z]` |'
  id: totrans-476
  prefs: []
  type: TYPE_TB
  zh: '| `[:lower:]` | 小写字母 | `[a-z]` |'
- en: '| `[:print:]` | Printable character (graph class plus space and tab) | `[\t\x20-\xFF]`
    |'
  id: totrans-477
  prefs: []
  type: TYPE_TB
  zh: '| `[:print:]` | 可打印字符（图形类加空格和制表符） | `[\t\x20-\xFF]` |'
- en: '| `[:punct:]` | Any punctuation character, such as the period (`.`) and the
    semicolon (`;`) | `[-!"#$%&''()*+,./:;<=>?@[\\\]^_''{&#124;}~]` |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '| `[:punct:]` | 任何标点字符，如句点（`.`）和分号（`;`） | `[-!"#$%&''()*+,./:;<=>?@[\\\]^_''{&#124;}~]`
    |'
- en: '| `[:space:]` | Whitespace (newline, carriage return, tab, space, vertical
    tab) | `[\n\r\t \x0B]` |'
  id: totrans-479
  prefs: []
  type: TYPE_TB
  zh: '| `[:space:]` | 空白字符（换行符、回车符、制表符、空格、垂直制表符） | `[\n\r\t \x0B]` |'
- en: '| `[:upper:]` | Uppercase letter | `[A-Z]` |'
  id: totrans-480
  prefs: []
  type: TYPE_TB
  zh: '| `[:upper:]` | 大写字母 | `[A-Z]` |'
- en: '| `[:xdigit:]` | Hexadecimal digit | `[0-9a-fA-F]` |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '| `[:xdigit:]` | 十六进制数字 | `[0-9a-fA-F]` |'
- en: '| `\s` | Whitespace | `[\r\n \t]` |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 空白字符 | `[\r\n \t]` |'
- en: '| `\S` | Nonwhitespace | `[^\r\n \t]` |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 非空白 | `[^\r\n \t]` |'
- en: '| `\w` | Word (identifier) character | `[0-9A-Za-z_]` |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 单词（标识符）字符 | `[0-9A-Za-z_]` |'
- en: '| `\W` | Nonword (identifier) character | `[^0-9A-Za-z_]` |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 非单词（标识符）字符 | `[^0-9A-Za-z_]` |'
- en: '| `\d` | Digit | `[0-9]` |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 数字 | `[0-9]` |'
- en: '| `\D` | Nondigit | `[^0-9]` |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 非数字 | `[^0-9]` |'
- en: Anchors
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锚点
- en: An anchor limits a match to a particular location in the string (anchors do
    not match actual characters in the target string). [Table 4-8](#anchor) lists
    the anchors supported by regular expressions.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 锚点限定了正则表达式匹配到字符串中的特定位置（锚点并不匹配目标字符串中的实际字符）。正则表达式支持的锚点列在[表 4-8](#anchor)中。
- en: Table 4-8\. Anchors
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-8\. 锚点
- en: '| Anchor | Matches |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| 锚点 | 匹配 |'
- en: '| --- | --- |'
  id: totrans-492
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `^` | Start of string |'
  id: totrans-493
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 字符串开始 |'
- en: '| `$` | End of string |'
  id: totrans-494
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 字符串结尾 |'
- en: '| `[[:<:]]` | Start of word |'
  id: totrans-495
  prefs: []
  type: TYPE_TB
  zh: '| `[[:<:]]` | 单词开头 |'
- en: '| `[[:>:]]` | End of word |'
  id: totrans-496
  prefs: []
  type: TYPE_TB
  zh: '| `[[:>:]]` | 单词结尾 |'
- en: '| `\b` | Word boundary (between `\w` and `\W` or at start or end of string)
    |'
  id: totrans-497
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 单词边界（在 `\w` 和 `\W` 之间或在字符串开头或结尾） |'
- en: '| `\B` | Nonword boundary (between `\w` and `\w`, or `\W` and `\W`) |'
  id: totrans-498
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 非单词边界（在 `\w` 和 `\w` 之间，或 `\W` 和 `\W` 之间） |'
- en: '| `\A` | Beginning of string |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '| `\A` | 字符串开始 |'
- en: '| `\Z` | End of string or before `\n` at end |'
  id: totrans-500
  prefs: []
  type: TYPE_TB
  zh: '| `\Z` | 字符串结束或在末尾的 `\n` 之前 |'
- en: '| `\z` | End of string |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '| `\z` | 字符串结尾 |'
- en: '| `^` | Start of line (or after `\n` if `/m` flag is enabled) |'
  id: totrans-502
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 行开始（或在启用 `/m` 标志时的 `\n` 之后） |'
- en: '| `$` | End of line (or before `\n` if `/m` flag is enabled) |'
  id: totrans-503
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 行尾（或在启用 `/m` 标志时的 `\n` 之前） |'
- en: 'A word boundary is defined as the point between a whitespace character and
    an identifier (alphanumeric or underscore) character:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 词边界被定义为空白字符和标识符（字母数字或下划线）字符之间的点：
- en: '[PRE131]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Note that the beginning and end of a string also qualify as word boundaries.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字符串的开头和结尾也被视为词边界。
- en: Quantifiers and Greed
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 量词和贪婪
- en: 'Regular expression quantifiers are typically *greedy*. That is, when faced
    with a quantifier, the engine matches as much as it can while still satisfying
    the rest of the pattern. For instance:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式量词通常是*贪婪*的。也就是说，当遇到量词时，引擎会尽可能多地匹配，同时仍满足模式的其余部分。例如：
- en: '[PRE132]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The regular expression matches from the first less-than sign to the last greater-than
    sign. In effect, the `.*` matches everything after the first less-than sign, and
    the engine backtracks to make it match less and less until finally there’s a greater-than
    sign to be matched.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式从第一个小于号匹配到最后一个大于号。实际上，`.*`匹配第一个小于号之后的所有内容，然后引擎回溯以使其匹配越来越少，直到最终有一个大于号需要匹配。
- en: This greediness can be a problem. Sometimes you need *minimal (nongreedy) matching*—that
    is, quantifiers that match as few times as possible to satisfy the rest of the
    pattern. Perl provides a parallel set of quantifiers that match minimally. They’re
    easy to remember, because they’re the same as the greedy quantifiers, but with
    a question mark (`?`) appended. [Table 4-9](#greedy_and_nongreedy_quantifiers_in_per)
    shows the corresponding greedy and nongreedy quantifiers supported by Perl-style
    regular expressions.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 这种贪婪性可能会成为问题。有时您需要*最小（非贪婪）匹配*，即尽可能少地匹配以满足模式的其余部分。Perl提供了一组与贪婪量词对应的最小匹配量词。它们很容易记住，因为它们与贪婪量词相同，只是附加了一个问号（`?`）。[表4-9](#greedy_and_nongreedy_quantifiers_in_per)显示了Perl风格正则表达式支持的相应贪婪和非贪婪量词。
- en: Table 4-9\. Greedy and nongreedy quantifiers in Perl-compatible regular expressions
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-9\. Perl兼容正则表达式中的贪婪和非贪婪量词
- en: '| Greedy quantifier | Nongreedy quantifier |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
  zh: '| 贪婪量词 | 非贪婪量词 |'
- en: '| --- | --- |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `?` | `??` |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
  zh: '| `?` | `??` |'
- en: '| `*` | `*?` |'
  id: totrans-516
  prefs: []
  type: TYPE_TB
  zh: '| `*` | `*?` |'
- en: '| `+` | `+?` |'
  id: totrans-517
  prefs: []
  type: TYPE_TB
  zh: '| `+` | `+?` |'
- en: '| `{m}` | `{m}?` |'
  id: totrans-518
  prefs: []
  type: TYPE_TB
  zh: '| `{m}` | `{m}?` |'
- en: '| `{m,}` | `{m,}?` |'
  id: totrans-519
  prefs: []
  type: TYPE_TB
  zh: '| `{m,}` | `{m,}?` |'
- en: '| `{m,n}` | `{m,n}?` |'
  id: totrans-520
  prefs: []
  type: TYPE_TB
  zh: '| `{m,n}` | `{m,n}?` |'
- en: 'Here’s how to match a tag using a nongreedy quantifier:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何使用非贪婪量词匹配标签的方法：
- en: '[PRE133]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Another, faster way is to use a character class to match every non-greater-than
    character up to the next greater-than sign:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种更快的方法是使用字符类来匹配下一个大于号之前的每个非大于号字符：
- en: '[PRE134]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Noncapturing Groups
  id: totrans-525
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非捕获组
- en: 'If you enclose a part of a pattern in parentheses, the text that matches that
    subpattern is captured and can be accessed later. Sometimes, though, you want
    to create a subpattern without capturing the matching text. In Perl-compatible
    regular expressions, you can do this using the `(?:` *subpattern* `)` construct:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将模式的一部分括在括号中，则匹配该子模式的文本将被捕获并可以在以后访问。但有时，您想创建一个不捕获匹配文本的子模式。在兼容Perl的正则表达式中，您可以使用`(?:`
    *子模式* `)`结构来实现这一点：
- en: '[PRE135]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Backreferences
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向引用
- en: 'You can refer to text captured earlier in a pattern with a *backreference*:
    `\1` refers to the contents of the first subpattern, `\2` refers to the second,
    and so on. If you nest subpatterns, the first begins with the first opening parenthesis,
    the second begins with the second opening parenthesis, and so on.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*反向引用*在模式中引用先前捕获的文本：`\1`引用第一个子模式的内容，`\2`引用第二个，依此类推。如果嵌套子模式，第一个从第一个左括号开始，第二个从第二个左括号开始，依此类推。
- en: 'For instance, this identifies doubled words:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这可以识别重复的单词：
- en: '[PRE136]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: The `preg_match()` function captures at most 99 subpatterns; subpatterns after
    the 99th are ignored.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`preg_match()`函数最多捕获99个子模式；第99个之后的子模式将被忽略。'
- en: Trailing Options
  id: totrans-533
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尾部选项
- en: 'Perl-style regular expressions let you put single-letter options (flags) after
    the regular expression pattern to modify the interpretation, or behavior, of the
    match. For instance, to match case-insensitively, simply use the `i` flag:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: Perl风格的正则表达式允许您在正则表达式模式后面放置单个字母选项（标志），以修改匹配的解释或行为。例如，要进行不区分大小写匹配，只需使用`i`标志：
- en: '[PRE137]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[Table 4-10](#perl_flags) shows which Perl modifiers are supported in Perl-compatible
    regular expressions.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '[表4-10](#perl_flags)显示了哪些Perl修饰符在兼容Perl的正则表达式中受支持。'
- en: Table 4-10\. Perl flags
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-10\. Perl标志
- en: '| Modifier | Meaning |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| 修饰符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/`*regexp*`/i` | Match case-insensitively |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/i` | 不区分大小写匹配 |'
- en: '| `/`*regexp*`/s` | Make period (`.`) match any character, *including* newline
    (`\n`) |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/s` | 使句点（`.`）匹配任何字符，*包括*换行符（`\n`） |'
- en: '| `/`*regexp*`/x` | Remove whitespace and comments from the pattern |'
  id: totrans-542
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/x` | 从模式中去除空格和注释 |'
- en: '| `/`*regexp*`/m` | Make caret (`^`) match after, and dollar sign (`$`) match
    before, internal newlines (`\n`) |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/m` | 使插入符号（`^`）匹配内部换行符（`\n`）后，以及美元符号（`$`）匹配内部换行符（`\n`）前 |'
- en: '| `/`*regexp*`/e` | If the replacement string is PHP code, `eval()` it to get
    the actual replacement string |'
  id: totrans-544
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/e` | 如果替换字符串是PHP代码，则使用`eval()`执行它以获取实际替换字符串 |'
- en: PHP’s Perl-compatible regular expression functions also support other modifiers
    that aren’t supported by Perl, as listed in [Table 4-11](#additional_php_flags).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的Perl兼容正则表达式函数还支持Perl不支持的其他修饰符，如[表 4-11](#additional_php_flags)所列。
- en: Table 4-11\. Additional PHP flags
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-11\. 其他PHP标志
- en: '| Modifier | Meaning |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| Modifier | Meaning |'
- en: '| --- | --- |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `/`*regexp*`/U` | Reverses the greediness of the subpattern; `*` and `+`
    now match as little as possible, instead of as much as possible |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/U` | 反转子模式的贪婪性；`*`和`+`现在尽可能少地匹配，而不是尽可能多地匹配 |'
- en: '| `/`*regexp*`/u` | Causes pattern strings to be treated as UTF-8 |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/u` | 使模式字符串被视为UTF-8 |'
- en: '| `/`*regexp*`/X` | Causes a backslash followed by a character with no special
    meaning to emit an error |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/X` | 使反斜杠后跟一个没有特殊含义的字符时发生错误 |'
- en: '| `/`*regexp*`/A` | Causes the beginning of the string to be anchored as if
    the first character of the pattern were `^` |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/A` | 使字符串的开头锚定，就好像模式的第一个字符是`^` |'
- en: '| `/`*regexp*`/D` | Causes the `$` character to match only at the end of a
    line |'
  id: totrans-553
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/D` | 使`$`字符只匹配行尾 |'
- en: '| `/`*regexp*`/S` | Causes the expression parser to more carefully examine
    the structure of the pattern, so it may run slightly faster the next time (such
    as in a loop) |'
  id: totrans-554
  prefs: []
  type: TYPE_TB
  zh: '| `/`*regexp*`/S` | 使表达式解析器更仔细地检查模式的结构，因此在下一次运行（例如在循环中）时可能运行得稍快些 |'
- en: 'It’s possible to use more than one option in a single pattern, as demonstrated
    in the following example:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在单个模式中使用多个选项，如以下示例所示：
- en: '[PRE138]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Inline Options
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联选项
- en: 'In addition to specifying pattern-wide options after the closing pattern delimiter,
    you can specify options within a pattern to have them apply only to part of the
    pattern. The syntax for this is:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在闭合模式定界符后指定整体模式选项外，还可以在模式中的部分指定选项以仅应用于模式的一部分。其语法为：
- en: '[PRE139]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'For example, only the word “PHP” is case-insensitive in this example:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在此示例中只有单词“PHP”是大小写不敏感的：
- en: '[PRE140]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'The `i`, `m`, `s`, `U`, `x`, and `X` options can be applied internally in this
    fashion. You can use multiple options at once:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`、`m`、`s`、`U`、`x`和`X`选项可以以这种方式在内部应用。你可以同时使用多个选项：'
- en: '[PRE141]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Prefix an option with a hyphen (`-`) to turn it off:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 使用连字符（`-`）前缀来关闭一个选项：
- en: '[PRE142]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'An alternative form enables or disables the flags until the end of the enclosing
    subpattern or pattern:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 替代形式可以启用或禁用标志，直到封闭子模式或模式结束：
- en: '[PRE143]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Inline flags do not enable capturing. You need an additional set of capturing
    parentheses to do that.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 内联标志不启用捕获。你需要额外的捕获括号来实现这一点。
- en: Lookahead and Lookbehind
  id: totrans-569
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前瞻和后顾
- en: In patterns it’s sometimes useful to be able to say “match here if this is next.”
    This is particularly common when you are splitting a string. The regular expression
    describes the separator, which is not returned. You can use *lookahead* to make
    sure (without matching it, thus preventing it from being returned) that there’s
    more data after the separator. Similarly, *lookbehind* checks the preceding text.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式中，有时可以很有用地说“如果接下来是这样，则在此处匹配”。这在分割字符串时特别常见。正则表达式描述了分隔符，但分隔符本身不会被返回。你可以使用*前瞻*来确保（不进行匹配，从而防止它被返回）分隔符后还有更多数据。同样地，*后顾*检查前面的文本。
- en: 'Lookahead and lookbehind come in two forms: *positive* and *negative*. A positive
    lookahead or lookbehind says “the next/preceding text must be like this.” A negative
    lookahead or lookbehind indicates “the next/preceding text must not be like this.”
    [Table 4-12](#lookahead_and_lookbehind_assertions) shows the four constructs you
    can use in Perl-compatible patterns. None of these constructs captures text.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 前瞻和后顾有两种形式：*正向*和*负向*。正向前瞻或后顾表示“下一个/前一个文本必须是这样”。负向前瞻或后顾表示“下一个/前一个文本不能是这样”。[表 4-12](#lookahead_and_lookbehind_assertions)展示了在兼容Perl的模式中可用的四种构造。这些构造都不捕获文本。
- en: Table 4-12\. Lookahead and lookbehind assertions
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-12\. 前瞻和后顾断言
- en: '| Construct | Meaning |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| Construct | Meaning |'
- en: '| --- | --- |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `(?=`*subpattern*`)` | Positive lookahead |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| `(?=`*subpattern*`)` | 正向预查 |'
- en: '| `(?!`*subpattern*`)` | Negative lookahead |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '| `(?!`*subpattern*`)` | 负向预查 |'
- en: '| `(?<=`*subpattern*`)` | Positive lookbehind |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| `(?<=`*subpattern*`)` | 正向回顾后断言 |'
- en: '| `(?<!`*subpattern*`)` | Negative lookbehind |'
  id: totrans-578
  prefs: []
  type: TYPE_TB
  zh: '| `(?<!`*subpattern*`)` | 负向回顾后断言 |'
- en: 'A simple use of positive lookahead is splitting a Unix mbox mail file into
    individual messages. The word `"From"` starting a line by itself indicates the
    start of a new message, so you can split the mailbox into messages by specifying
    the separator as the point where the next text is `"From"` at the start of a line:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 正向预查的一个简单用法是将Unix mbox邮件文件拆分为单独的消息。单独起始一行的单词`"From"`指示新消息的开始，因此可以通过指定分隔符为下一文本在行首为`"From"`来将邮箱拆分为消息：
- en: '[PRE144]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'A simple use of negative lookbehind is to extract quoted strings that contain
    quoted delimiters. For instance, here’s how to extract a single-quoted string
    (note that the regular expression is commented using the `x` modifier):'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 使用负回顾后断言的一个简单用法是提取包含带引号定界符的引号字符串。例如，以下是提取单引号字符串的方法（注意使用`x`修饰符注释正则表达式）：
- en: '[PRE145]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The only tricky part is that to get a pattern that looks behind to see if the
    last character was a backslash, we need to escape the backslash to prevent the
    regular expression engine from seeing `\)`, which would mean a literal close parenthesis.
    In other words, we have to backslash that backslash: `\\)`. But PHP’s string-quoting
    rules say that `\\` produces a literal single backslash, so we end up requiring
    *four* backslashes to get one through the regular expression! This is why regular
    expressions have a reputation for being hard to read.'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一棘手的部分是，为了得到一个向后查看以查看最后一个字符是否为反斜杠的模式，我们需要转义反斜杠以防止正则表达式引擎看到`\)`，这将意味着文字的右括号。换句话说，我们必须反斜杠那个反斜杠：`\\)`。但是PHP的字符串引用规则表示`\\`会生成一个文字上的单个反斜杠，所以我们最终需要*四个*反斜杠来传递给正则表达式！这就是为什么正则表达式以难以阅读而闻名。
- en: Perl limits lookbehind to constant-width expressions. That is, the expressions
    cannot contain quantifiers, and if you use alternation, all the choices must be
    the same length. The Perl-compatible regular expression engine also forbids quantifiers
    in lookbehind, but does permit alternatives of different lengths.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: Perl限制回顾后断言为常数宽度表达式。也就是说，表达式不能包含量词，如果使用选择，所有选择必须具有相同的长度。Perl兼容的正则表达式引擎也禁止在回顾后断言中使用量词，但允许不同长度的选择。
- en: Cut
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cut
- en: The rarely used once-only subpattern, or *cut*, prevents worst-case behavior
    by the regular expression engine on some kinds of patterns. The subpattern is
    never backed out of once matched.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 很少使用的一次性子模式或*cut*通过阻止某些类型模式在正则表达式引擎中的最坏情况行为。一旦匹配，该子模式将不再回溯。
- en: 'The common use for the once-only subpattern is when you have a repeated expression
    that may itself be repeated:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性子模式的常见用法是当你有一个可能本身重复的重复表达式时：
- en: '[PRE146]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'This code snippet takes several seconds to report failure:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段需要几秒钟来报告失败：
- en: '[PRE147]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This is because the regular expression engine tries all the different places
    to start the match, but has to backtrack out of each one, which takes time. If
    you know that once something is matched it should never be backed out of, you
    should mark it with `(?>*subpattern*)`:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式引擎尝试所有不同的起始匹配位置，但必须回溯每一个，这需要时间。如果你知道一旦某些内容匹配就不应该回溯，你应该用`(?>*subpattern*)`标记它：
- en: '[PRE148]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The cut never changes the outcome of the match; it simply makes it fail faster.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 剪切永远不会改变匹配的结果；它只是让匹配失败更快。
- en: Conditional Expressions
  id: totrans-594
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件表达式
- en: 'A conditional expression is like an `if` statement in a regular expression.
    The general form is:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 条件表达式就像正则表达式中的`if`语句。一般形式是：
- en: '[PRE149]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: If the assertion succeeds, the regular expression engine matches the *yespattern*.
    With the second form, if the assertion doesn’t succeed, the regular expression
    engine skips the *yespattern* and tries to match the *nopattern*.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果断言成功，正则表达式引擎匹配*yespattern*。第二种形式，如果断言不成功，正则表达式引擎跳过*yespattern*，尝试匹配*nopattern*。
- en: 'The assertion can be one of two types: either a backreference, or a lookahead
    or lookbehind match. To reference a previously matched substring, the assertion
    is a number from 1 to 99 (the most backreferences available). The condition uses
    the pattern in the assertion only if the backreference was matched. If the assertion
    is not a backreference, it must be a positive or negative lookahead or lookbehind
    assertion.'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 断言可以是两种类型之一：回溯引用，或者前瞻或后顾匹配。要引用先前匹配的子字符串，断言是从 1 到 99 的数字（可用的最多回溯引用）。如果断言是一个回溯引用，条件只有在回溯引用匹配时才使用断言中的模式。如果断言不是回溯引用，则必须是正向或负向前瞻或后顾断言。
- en: Functions
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'There are five classes of functions that work with Perl-compatible regular
    expressions: matching, replacing, splitting, filtering, and a utility function
    for quoting text.'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 有五类函数与 Perl 兼容的正则表达式一起使用：匹配、替换、分割、过滤，以及用于引用文本的实用函数。
- en: Matching
  id: totrans-601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配
- en: 'The `preg_match()` function performs Perl-style pattern matching on a string.
    It’s the equivalent of the `m//` operator in Perl. The `preg_match`_all`()` function
    takes the same arguments and gives the same return value as the `preg_match()`
    function, except that it takes a Perl-style pattern instead of a standard pattern:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '`preg_match()` 函数在字符串上执行 Perl 风格的模式匹配。它相当于 Perl 中的 `m//` 操作符。`preg_match_all()`
    函数接受与 `preg_match()` 函数相同的参数，并返回相同的值，只是它接受 Perl 风格的模式而不是标准模式：'
- en: '[PRE150]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'For example:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE151]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'While there’s a `preg_match()` function to match case-insensitively, there’s
    no `preg_matchi()` function. Instead, use the `i` flag on the pattern:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有一个 `preg_match()` 函数来进行不区分大小写的匹配，但没有 `preg_matchi()` 函数。相反，可以在模式上使用 `i` 标志：
- en: '[PRE152]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The `preg_match_all()` function repeatedly matches from where the last match
    ended, until no more matches can be made:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`preg_match_all()` 函数会重复匹配从上一次匹配结束的地方开始，直到不能再进行匹配为止：'
- en: '[PRE153]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The *order* value, either `PREG_PATTERN_ORDER` or `PREG_SET_ORDER`, determines
    the layout of *matches*. We’ll look at both, using this code as a guide:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '*order* 值，可以是 `PREG_PATTERN_ORDER` 或 `PREG_SET_ORDER`，决定了 *matches* 的布局。我们将使用这段代码作为指南查看两者：'
- en: '[PRE154]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: With `PREG_PATTERN_ORDER` (the default), each element of the array corresponds
    to a particular capturing subpattern. So `$m1[0]` is an array of all the substrings
    that matched the pattern, `$m1[1]` is an array of all the substrings that matched
    the first subpattern (the numbers), and `$m1[2]` is an array of all the substrings
    that matched the second subpattern (the words). The array `$m1` has one more element
    than it has subpatterns.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PREG_PATTERN_ORDER`（默认），数组的每个元素对应于特定的捕获子模式。因此，`$m1[0]` 是所有匹配模式的子字符串数组，`$m1[1]`
    是匹配第一个子模式的所有子字符串数组（即数字），`$m1[2]` 是匹配第二个子模式的所有子字符串数组（即单词）。数组 `$m1` 比子模式多一个元素。
- en: With `PREG_SET_ORDER`, each element of the array corresponds to the next attempt
    to match the whole pattern. So `$m2[0]` is an array of the first set of matches
    (`'13 dogs'`, `'13'`, `'dogs'`), `$m2[1]` is an array of the second set of matches
    (`'12 rabbits'`, `'12'`, `'rabbits'`), and so on. The array `$m2` has as many
    elements as there were successful matches of the entire pattern.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `PREG_SET_ORDER`，数组的每个元素对应于下一次尝试匹配整个模式。因此，`$m2[0]` 是第一组匹配的数组（`'13 dogs'`,
    `'13'`, `'dogs'`），`$m2[1]` 是第二组匹配的数组（`'12 rabbits'`, `'12'`, `'rabbits'`），依此类推。数组
    `$m2` 的元素数量与整个模式的成功匹配次数相同。
- en: '[Example 4-1](#example_four_onedot_extracting_urls_fro) fetches the HTML at
    a particular web address into a string and extracts the URLs from that HTML. For
    each URL, it generates a link back to the program that will display the URLs at
    that address.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-1](#example_four_onedot_extracting_urls_fro) 获取特定网址的 HTML 到一个字符串中，并从该
    HTML 中提取 URLs。对于每个 URL，它生成一个链接返回到显示该地址 URLs 的程序中。'
- en: Example 4-1\. Extracting URLs from an HTML page
  id: totrans-615
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1\. 从 HTML 页面提取 URLs
- en: '[PRE155]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Replacing
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换
- en: 'The `preg_replace()` function behaves like the search-and-replace operation
    in your text editor. It finds all occurrences of a pattern in a string and changes
    those occurrences to something else:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '`preg_replace()` 函数的行为类似于文本编辑器中的查找和替换操作。它找到字符串中所有模式的出现，并将这些出现更改为其他内容：'
- en: '[PRE156]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'The most common usage has all the argument strings except for the integer *limit*.
    The limit is the maximum number of occurrences of the pattern to replace (the
    default, and the behavior when a limit of `−1` is passed, is all occurrences):'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的用法是所有参数字符串，除了整数 *limit*。限制是要替换的模式的最大出现次数（当传递 `-1` 时，默认情况和当一个限制为 `−1` 时的行为都是所有出现）：
- en: '[PRE157]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'Pass an array of strings as *subject* to make the substitution on all of them.
    The new strings are returned from `preg_replace()`:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个字符串数组作为*subject*传递给`preg_replace()`以对所有字符串进行替换。新字符串从中返回：
- en: '[PRE158]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'To perform multiple substitutions on the same string or array of strings with
    one call to `preg_replace()`, pass arrays of patterns and replacements:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 要对同一个字符串或字符串数组执行多次替换，只需一次调用`preg_replace()`并传递模式和替换的数组即可：
- en: '[PRE159]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'If you give fewer replacements than patterns, text matching the extra patterns
    is deleted. This is a handy way to delete a lot of things at once:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供的替换少于模式，则匹配额外模式的文本将被删除。这是一种方便的批量删除方式：
- en: '[PRE160]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'If you give an array of patterns but a single string replacement, the same
    replacement is used for every pattern:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给定了一个模式数组但只有一个字符串替换，则每个模式都将使用相同的替换：
- en: '[PRE161]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The replacement can use backreferences. Unlike backreferences in patterns,
    though, the preferred syntax for backreferences in replacements is `$1`, `$2`,
    `$3`, and so on. For example:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 替换可以使用反向引用。不过，与模式中的反向引用不同，替换中首选的语法是`$1`、`$2`、`$3`等。例如：
- en: '[PRE162]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The `/e` modifier makes `preg_replace()` treat the replacement string as PHP
    code that returns the actual string to use in the replacement. For example, this
    converts every Celsius temperature to Fahrenheit:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '`/e`修饰符使得`preg_replace()`将替换字符串视为PHP代码，返回实际用于替换的字符串。例如，这会将每个摄氏温度转换为华氏温度：'
- en: '[PRE163]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'This more complex example expands variables in a string:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更复杂的示例会展开字符串中的变量：
- en: '[PRE164]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Each match isolates the name of a variable (`$name`, `$age`). The `$1` in the
    replacement refers to those names, so the PHP code actually executed is `$name`
    and `$age`. That code evaluates to the value of the variable, which is what’s
    used as the replacement. Whew!
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 每个匹配项都会分离变量的名称（`$name`、`$age`）。替换中的`$1`指的是这些名称，因此实际执行的PHP代码是`$name`和`$age`。该代码会评估变量的值，这就是替换时使用的内容。呼！
- en: 'A variation on `preg_replace()` is `preg_replace_callback()`. This calls a
    function to get the replacement string. The function is passed an array of matches
    (the zeroth element is all the text that matched the pattern, the first is the
    contents of the first captured subpattern, and so on). For example:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '`preg_replace_callback()`是`preg_replace()`的一种变体。它调用一个函数来获取替换字符串。该函数会传递一个匹配数组（零号元素是匹配模式的全部文本，第一个是第一个捕获子模式的内容，依此类推）。例如：'
- en: '[PRE165]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Splitting
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分割
- en: 'Whereas you use `preg_match_all()` to extract chunks of a string when you know
    what those chunks are, use `preg_split()` to extract chunks when you know what
    *separates* the chunks from each other:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 当你知道要提取字符串的部分时，可以使用`preg_match_all()`，而当你知道如何*分隔*这些部分时，则可以使用`preg_split()`：
- en: '[PRE166]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The *pattern* matches a separator between two chunks. By default, the separators
    are not returned. The optional *limit* specifies the maximum number of chunks
    to return (`−1` is the default, which means all chunks). The *flags* argument
    is a bitwise OR combination of the flags `PREG_SPLIT_NO_EMPTY` (empty chunks are
    not returned) and `PREG_SPLIT_DELIM_CAPTURE` (parts of the string captured in
    the pattern are returned).
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '*模式*匹配两个部分之间的分隔符。默认情况下，分隔符不会被返回。可选的*limit*参数指定要返回的最大部分数（默认值为`−1`，表示所有部分）。*flags*参数是标志位OR组合，包括`PREG_SPLIT_NO_EMPTY`（不返回空部分）和`PREG_SPLIT_DELIM_CAPTURE`（在模式中捕获的字符串部分会被返回）。'
- en: 'For example, to extract just the operands from a simple numeric expression,
    use:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要从简单的数字表达式中仅提取操作数，请使用：
- en: '[PRE167]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'To extract the operands and the operators, use:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 要提取操作数和操作符，请使用：
- en: '[PRE168]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'An empty pattern matches at every boundary between characters in the string,
    and at the start and end of the string. This lets you split a string into an array
    of characters:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 空模式在字符串中的每个字符边界以及字符串的开头和结尾匹配。这使您可以将字符串拆分为字符数组：
- en: '[PRE169]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Filtering an array with a regular expression
  id: totrans-649
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用正则表达式过滤数组
- en: 'The `preg_grep()` function returns those elements of an array that match a
    given pattern:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`preg_grep()`函数返回一个数组中与给定模式匹配的元素：'
- en: '[PRE170]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'For instance, to get only the filenames that end in *.txt*, use:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要仅获取以*.txt*结尾的文件名，请使用：
- en: '[PRE171]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Quoting for regular expressions
  id: totrans-654
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正则表达式引用
- en: 'The `preg_quote()` function creates a regular expression that matches only
    a given string:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`preg_quote()`函数创建一个仅匹配给定字符串的正则表达式：'
- en: '[PRE172]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Every character in *string* that has special meaning inside a regular expression
    (e.g., `*` or `$`) is prefaced with a backslash:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '*string*中的每个特殊含义字符（例如`*`或`$`）都会用反斜杠作为前缀：'
- en: '[PRE173]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'The optional second argument is an extra character to be quoted. Usually, you
    pass your regular expression delimiter here:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的第二个参数是一个要转义的额外字符。通常，你会在这里传递你的正则表达式分隔符：
- en: '[PRE174]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Differences from Perl Regular Expressions
  id: totrans-661
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Perl 正则表达式的差异
- en: 'Although very similar, PHP’s implementation of Perl-style regular expressions
    has a few minor differences from actual Perl regular expressions:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管非常相似，PHP 实现的 Perl 风格正则表达式与实际 Perl 正则表达式有一些细微差异：
- en: The NULL character (ASCII 0) is not allowed as a literal character within a
    pattern string. You can reference it in other ways, however (`\000`, `\x00`, etc.).
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不允许在模式字符串中作为文字字符使用空字符（ASCII 0）。但是你可以通过其他方式引用它（如`\000`、`\x00`等）。
- en: The `\E`, `\G`, `\L`, `\l`, `\Q`, `\u`, and `\U` options are not supported.
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持`\E`、`\G`、`\L`、`\l`、`\Q`、`\u`和`\U`选项。
- en: The `(?{` *some perl code* `})` construct is not supported.
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不支持使用`(?{` *一些 Perl 代码* `})` 结构。
- en: The `/D`, `/G`, `/U`, `/u`, `/A`, and `/X` modifiers are supported.
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持`/D`、`/G`、`/U`、`/u`、`/A`和`/X`修饰符。
- en: The vertical tab `\v` counts as a whitespace character.
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 垂直制表符`\v`被视为空白字符。
- en: Lookahead and lookbehind assertions cannot be repeated using `*`, `+`, or `?`.
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前瞻断言和后顾断言不能使用`*`、`+`或`?`进行重复。
- en: Parenthesized submatches within negative assertions are not remembered.
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在负向断言中的括号子匹配不会被记住。
- en: Alternation branches within a lookbehind assertion can be of different lengths.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后顾断言中的交替分支可以有不同的长度。
- en: What’s Next
  id: totrans-671
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步计划
- en: Now that you know everything there is to know about strings and working with
    them, the next major part of PHP we’ll focus on is arrays. These compound data
    types will challenge you, but you need to get well acquainted with them, as PHP
    works with them in many areas. Learning how to add array elements, sort arrays,
    and deal with multidimensional forms of arrays is essential to being a good PHP
    developer.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了关于字符串及其操作的所有内容，PHP 的下一个主要部分我们将关注的是数组。这些复合数据类型会让你挑战，但你需要对它们非常熟悉，因为 PHP
    在许多领域都使用它们。学习如何添加数组元素、对数组进行排序以及处理多维数组形式对于成为一个优秀的 PHP 开发者是至关重要的。
