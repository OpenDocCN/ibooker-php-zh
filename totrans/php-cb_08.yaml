- en: Chapter 8\. Classes and Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The earliest versions of PHP didn’t support class definition or object orientation.
    PHP 4 was the first real attempt at an object interface.^([1](ch08.html#idm45875158208880))
    It wasn’t until PHP 5, though, that developers had the complex object interfaces
    they know and use today.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are defined using the `class` keyword followed by a full description
    of the constants, properties, and methods inherent to the class. [Example 8-1](#basic_php_class)
    introduces a basic class construct in PHP, complete with a scoped constant value,
    a property, and callable methods.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-1\. Basic PHP class with properties and methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: An object can be instantiated with the `new` keyword and the name of the class;
    instantiation looks somewhat like a function call. Any parameters passed into
    this instantiation are transparently passed into the class constructor (the `__construct()`
    method) to define the object’s initial state. [Example 8-2](#basic_php_class_instantiation)
    illustrates how the class definition from [Example 8-1](#basic_php_class) could
    be instantiated either with or without default property values.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-2\. Instantiating a basic PHP class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Instantiating an object without passing a parameter will still invoke the constructor
    but will leverage its default parameters. If no defaults are provided in the function
    signature, this would result in an error.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Passing a parameter during instantiation will provide this parameter to the
    constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This prints `hello world` by using the constructor’s defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This prints `hello universe` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_classes_and_objects_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Constants are referenced directly from the class name. This will print a literal
    `42` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors and properties are covered in Recipes [8.1](#object_instantiation)
    and [8.2](#constructors_with_defaults).
  prefs: []
  type: TYPE_NORMAL
- en: Procedural Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most developers’ first experience with PHP is through its more procedural interfaces.
    Example routines, simple scripts, tutorials—all of these typically leverage functions
    and variables defined within the global scope. This isn’t a bad thing, but it
    does limit the flexibility of the programs you can produce.
  prefs: []
  type: TYPE_NORMAL
- en: Procedural programming often results in stateless applications. There is little
    to no ability to keep track of what’s happened before between function calls,
    so you pass some reference to the application’s state throughout your code. Again,
    this isn’t necessarily a bad thing. The only drawback is that *complex* applications
    become difficult to analyze or understand.
  prefs: []
  type: TYPE_NORMAL
- en: Object-Oriented Programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative paradigm is to leverage objects as containers of state. A common
    practical example is to consider objects as ways to define *things*. A car is
    an object. So is a bus. And a bicycle. They are discrete *things* that have characteristics
    (such as color, number of wheels, and type of drive) and capabilities (such as
    go, stop, and turn).
  prefs: []
  type: TYPE_NORMAL
- en: In the programming world, this is among the easiest ways to describe objects.
    In PHP, you create objects by first defining a `class` to describe the type of
    object. A class describes the properties (characteristics) and methods (capabilities)
    that an object of that type will have.
  prefs: []
  type: TYPE_NORMAL
- en: Like things in the real world, objects in a programming space can inherit from
    more primitive type descriptions. A car, bus, and bicycle are all types of vehicles,
    so they can all descend from a specific type. [Example 8-3](#php_class_abstraction)
    demonstrates how PHP might construct that kind of object inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-3\. Class abstraction in PHP
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Instantiating an object creates a typed variable that represents both an initial
    state and methods for manipulating that state. Object *inheritance* presents the
    possibility to use one or more types as alternatives to one another in other code.
    [Example 8-4](#interchangeable_classes) illustrates how the three types of vehicles
    introduced in [Example 8-2](#basic_php_class_instantiation) could be used interchangeably
    because of inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-4\. Classes with similar inheritance can be used interchangeably
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: All three of the vehicle subtypes can be used as valid replacements for `Vehicle`
    in function calls. This means you could commute by bus, car, or bicycle, and any
    choice would be equally valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: At times you might need to be more precise and use a child type directly. Neither
    `Bus` nor `Car` nor any other subclass of the `Vehicle` class will be valid for
    exercise besides a `Bicycle`.
  prefs: []
  type: TYPE_NORMAL
- en: Class inheritance is covered at a deeper level by Recipes [8.6](#class_inheritance),
    [8.7](#class_interfaces), and [8.8](#class_abstraction).
  prefs: []
  type: TYPE_NORMAL
- en: Multiparadigm Languages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP is considered a *multiparadigm* language, as you can write code following
    either of the preceding paradigms. A valid PHP program can be purely procedural.
    Or it can be strictly focused on object definitions and custom classes. The program
    could ultimately use a mix of both paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: The open source WordPress content management system (CMS) is one of the most
    popular PHP projects on the internet.^([2](ch08.html#idm45875157813808)) It’s
    coded to heavily leverage objects for common abstractions like database objects
    or remote requests. However, WordPress also stems from a long history of procedural
    programming—much of the codebase is still heavily influenced by that style. WordPress
    is a key example not just of the success of PHP itself, but of the flexibility
    of the language’s support for multiple paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: There is no single right answer for how an application should be assembled.
    Most are hybrids of approaches that benefit from PHP’s strong support of multiple
    paradigms. Even in a majority-procedural application, though, you will still likely
    see a handful of objects as that’s how the language’s standard library [implements
    much of its functionality](https://oreil.ly/krXrW).
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 6](ch06.html#chapter_datetime) illustrated the use of both the functional
    and object-oriented interfaces for PHP’s date system. Error handling, which is
    covered more in [Chapter 13](ch13.html#chapter_debugging), heavily leverages internal
    `Exception` and `Error` classes. The `yield` keyword in an otherwise procedural
    implementation automatically creates instances of the `Generator` class.'
  prefs: []
  type: TYPE_NORMAL
- en: Even if you never define a class in your program directly, the chances are good
    that you will leverage one defined either by PHP itself or by a third-party library
    your program requires.^([3](ch08.html#idm45875157805424))
  prefs: []
  type: TYPE_NORMAL
- en: Visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes also introduce the concept of *visibility* into PHP. Properties, methods,
    and even constants can be defined with an optional visibility modifier to change
    their level of access from other parts of the application. Anything declared `public`
    is accessible to any other class or function in your application. Both methods
    and properties can be declared `protected`, making them accessible only to an
    instance of either the class itself or classes that descend from it. Finally,
    the `private` declaration means a member of the class can be accessed only by
    instances of that class itself.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, anything not explicitly scoped to be private or protected is automatically
    public, so you might see some developers skip declaring member visibility entirely.
  prefs: []
  type: TYPE_NORMAL
- en: While member visibility can be directly overridden via reflection,^([4](ch08.html#idm45875157792800))
    it’s typically a sound way to clarify which parts of a class’s interface are intended
    to be used by other code elements. [Example 8-5](#intro_visibility_demonstration)
    illustrates how each visibility modifier can be leveraged to build a complex application.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-5\. Class member visibility overview
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints `Bob`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints `Portland`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints `2023`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a `Warning` as the `::$value` property is private and inaccessible.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_classes_and_objects_CO3-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints `hello`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_classes_and_objects_CO3-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints `world`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_classes_and_objects_CO3-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Throws an `Error` as the `::universe()` method is protected and inaccessible
    outside the class instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](assets/8.png)](#co_classes_and_objects_CO3-8)'
  prefs: []
  type: TYPE_NORMAL
- en: This line would not even execute because of the error thrown on the previous
    line. If the previous line did *not* throw an error, this one would, as the `::abyss()`
    method is private and inaccessible outside the class instance.
  prefs: []
  type: TYPE_NORMAL
- en: The following recipes further illustrate the preceding concepts and cover some
    of the most common use cases and implementations of objects in PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 8.1 Instantiating Objects from Custom Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define a custom class and create a new object instance from it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define the class and its properties and methods with the `class` keyword, then
    use `new` to create an instance of it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Solution example illustrates several key characteristics of objects:'
  prefs: []
  type: TYPE_NORMAL
- en: Objects can have properties that define the internal state of the object itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These objects can have specific visibility. In the Solution example, objects
    are `public`, meaning they can be accessed by any code within the application.^([5](ch08.html#idm45875157450624))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The magic `::__construct()` method can accept parameters only when the object
    is first instantiated. These parameters can be used to define the initial state
    of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods can have visibility similar to the properties of the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This particular version of class definition is the default many developers have
    been using since PHP 5, when true object-oriented primitives were first introduced.
    However, [Example 8-6](#constructor_promotion) demonstrates a newer and simpler
    way to define a simple object like the one in the Solution example. Rather than
    independently declaring and then directly assigning the properties that carry
    the object’s state, PHP 8 (and later) allows for defining everything within the
    constructor itself.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-6\. Constructor promotion in PHP 8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Solution example and [Example 8-6](#constructor_promotion) are functionally
    equivalent and will result in objects of the same internal structure being created
    at runtime. PHP’s ability to promote constructor arguments to object properties,
    however, dramatically reduces the amount of repetitive code you need to type while
    defining a class.
  prefs: []
  type: TYPE_NORMAL
- en: Each constructor argument also permits the same types of visibility (`public`/`pro⁠tected`/`private`)
    that object properties do.^([6](ch08.html#idm45875157386544)) The shorthand syntax
    means you don’t need to declare properties, then define parameters, then map the
    parameters onto those properties upon object instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on [classes and objects](https://oreil.ly/TfrNb) and the [original
    RFC on constructor promotion](https://oreil.ly/nzD0s).
  prefs: []
  type: TYPE_NORMAL
- en: 8.2 Constructing Objects to Define Defaults
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define default values for your object’s properties.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define default values for the constructor’s arguments as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The constructor function within a class definition behaves more or less like
    any other function in PHP, except it does not return a value. You can define default
    arguments similarly to how you would with a standard function. You can even reference
    the names of the constructor arguments to accept default values for *some* parameters
    while defining others later in the function signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Solution example explicitly defines the class properties by using constructor
    promotion for brevity, but the older-style verbose constructor definition is equally
    valid as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, if *not* using constructor promotion, you can initialize object
    properties directly by assigning a default value when they’re defined. When doing
    so, you would usually leave those parameters off the constructor and manipulate
    them elsewhere in the program, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As will be discussed in [Recipe 8.3](#read_only_properties), you cannot initialize
    a `readonly` class property directly with a default. This is equivalent to a class
    constant, and the syntax is therefore disallowed.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 3.2](ch03.html#function_default_parameters) for more on default function
    parameters, [Recipe 3.3](ch03.html#named_function_parameters) for named function
    parameters, and documentation on [constructors and destructors](https://oreil.ly/WJvYY).'
  prefs: []
  type: TYPE_NORMAL
- en: 8.3 Defining Read-Only Properties in a Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define your class in such a way that properties defined at instantiation
    cannot be changed after the object exists.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `readonly` keyword on a typed property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If using constructor promotion, place the keyword along with the property type
    within the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `readonly` keyword was introduced in PHP 8.1 and was aimed at reducing the
    need for more verbose workarounds originally required to achieve the same functionality.
    With this keyword, a property can only be initialized with a value *once*, and
    only while the object is being instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Read-only properties cannot have a default value. This would make them functionally
    equivalent to class constants, which already exist, so the functionality is unavailable
    and the syntax is unsupported. Promoted constructor properties can, however, leverage
    default values within the argument definition as these are evaluated at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The keyword is also valid only for typed properties. Types are typically optional
    in PHP (except when strict typing is being used^([7](ch08.html#idm45875156595712)))
    to aid in flexibility, so it’s possible a property on your class *can’t* be set
    to one or another type. In those instances, use the `mixed` type instead so you
    can set a read-only property without other type constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: At the time of this writing, read-only declarations are *not* supported on static
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: As a read-only property can only be instantiated once, it cannot be unset or
    modified by other subsequent code. All of the code in [Example 8-7](#erroneous_readonly_modification)
    will result in the throwing of an `Error` exception.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-7\. Erroneous attempts to modify a read-only property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Example` object will have an uninitialized `::$prop` property that cannot
    be accessed (accessing a property before initialization throws an `Error` exception).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: As the object is already instantiated, attempting to write to a read-only property
    throws an `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `::$count` property is read-only, so you cannot assign a new value to it
    without an `Error`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: As the `::$count` property is read-only, you cannot increment it directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_classes_and_objects_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot increment in either direction with a read-only property.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_classes_and_objects_CO4-6)'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot unset a read-only property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The properties within a class can, however, be other classes themselves. In
    those situations, a read-only declaration on the property means that property
    cannot be overwritten or unset, but has no impact on the properties of the child
    class. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The increment of the internal counter will succeed as the `::$counter` property
    is itself not declared as read-only.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `::$inner` property is read-only and cannot be overridden. Attempts to do
    so result in an `Error` exception.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on [read-only properties](https://oreil.ly/P-AwN).
  prefs: []
  type: TYPE_NORMAL
- en: 8.4 Deconstructing Objects to Clean Up After the Object Is No Longer Needed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your class definition wraps an expensive resource that must be carefully cleaned
    up when the object goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define a class destructor to clean up after the object is removed from memory
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When an object falls out of scope, PHP will automatically garbage-collect any
    memory or other resources that object used to represent. There might be times,
    however, when you want to force a specific action when that object goes out of
    scope. This might be releasing a database handle, as with the Solution example.
    It could be explicitly logging an event to a file. Or perhaps *deleting* a temporary
    file from the system, as shown in [Example 8-8](#destruct_delete_temp_file).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-8\. Removing a temporary file in a destructor
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The object will automatically create a file in the current directory with a
    name similar to *tmp_test_1650837172.tmp*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Every new log entry is written as a new line in the temporary log file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the logs will create a second handle on the same file, but for reading.
    The object exposes this handle through a generator that enumerates over every
    line in the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: When the logger is removed from scope (or explicitly unset), the destructor
    will close the open file handle and automatically delete the file as well.
  prefs: []
  type: TYPE_NORMAL
- en: This more sophisticated example demonstrates both how a destructor would be
    written and how it would be invoked. PHP will look for a `::__destruct()` method
    on any object when it goes out of scope and will invoke it at that point in time.
    This destructor explicitly dereferences the object by calling `unset()` to remove
    it from the program. You could just as easily have set the variable referencing
    the object to `null` with the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike object constructors, destructors do not accept any parameters. If your
    object needs to act on any external state while cleaning up after itself, be sure
    that state is referenced through a property on the object itself. Otherwise, you
    will not have access to that information.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on [constructors and destructors](https://oreil.ly/fJMGM).
  prefs: []
  type: TYPE_NORMAL
- en: 8.5 Using Magic Methods to Provide Dynamic Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define a custom class without predefining the properties it supports.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use magic getters and setters to handle dynamically defined properties as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you reference a property on an object that does not exist, PHP falls back
    on a set of *magic methods* to fill in the blanks on implementation. The getter
    is used automatically when attempting to reference a property, while the corresponding
    setter is used when assigning a value to a property.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Property overloading by way of magic methods only works on instantiated objects.
    It does not work on the static class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Internally, you then control the behavior of getting and setting data in its
    entirety. The Solution example stores its data in a private associative array.
    You can further flesh out this example by fully implementing magic methods for
    handling `isset()` and `unset()`. [Example 8-9](#full_magic_method_example) demonstrates
    how magic methods can be used to fully replicate a standard class definition,
    but without the need to predeclare all properties.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-9\. Full object definition with magic methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 8-9](#full_magic_method_example), the two objects are functionally
    equivalent if and only if the only dynamic properties used on a `Magic` instance
    are those already defined by `Basic`. This dynamic nature is what makes the approach
    so valuable even if the class definitions are painfully verbose. You might choose
    to wrap a remote API in a class implementing magic methods in order to expose
    that API’s data to your application in an object-oriented manner.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on [magic methods](https://oreil.ly/1ZtlE).
  prefs: []
  type: TYPE_NORMAL
- en: 8.6 Extending Classes to Define Additional Functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define a class that adds functionality to an existing class definition.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `extends` keyword to define additional methods or override existing
    functionality as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Object inheritance is a common concept for any high-level language; it’s a way
    you build new objects on top of other, often simpler object definitions. The Solution
    example illustrates how a class can *inherit* method definitions from a parent
    class, which is the core functionality of PHP’s inheritance model.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: PHP does not support inheriting from multiple parent classes. To pull in code
    implementations from multiple sources, PHP leverages *traits*, which are covered
    by [Recipe 8.13](#classes_traits).
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a child class inherits every public and protected method, property,
    and constant from its parent class (the class it’s extending). Private methods,
    properties, and constants are *never* inherited by a child class.^([8](ch08.html#idm45875155649632))
  prefs: []
  type: TYPE_NORMAL
- en: A child class can also override its parent’s implementation of a particular
    method. In practice, you would do this to change the internal logic of a particular
    method, but the method signature exposed by the child class must match that defined
    by the parent. [Example 8-10](#child_overrides) demonstrates how a child class
    would override its parent’s implementation of a method.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-10\. Overriding a parent method implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints `Good morning, Alice`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints `Howdy, Bob`
  prefs: []
  type: TYPE_NORMAL
- en: 'An overridden child method does not lose all sense of the parent’s implementation,
    though. Inside a class, you reference the `$this` variable to refer to that particular
    instance of the object. Likewise, you can reference the `parent` keyword to refer
    to the parent implementation of a function. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation and discussion of PHP’s [object inheritance model](https://oreil.ly/nsAM3).
  prefs: []
  type: TYPE_NORMAL
- en: 8.7 Forcing Classes to Exhibit Specific Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define the methods on a class that will be used elsewhere in your
    application while leaving the actual method implementations up to someone else.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Define an object interface and leverage that interface in your application
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An interface looks similar to a class definition, except it only defines the
    *signatures* of specific methods rather than their implementations. The interface
    does, however, define a type that can be used elsewhere in your application—so
    long as a class directly implements a given interface, an instance of that class
    can be used as if it were the same type as the interface itself.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are several situations in which you might have two classes that implement
    the same methods and expose the same signatures to your application. However,
    unless these classes explicitly implement the same interface (as evidenced by
    the `implements` keyword), they cannot be used interchangeably in a strictly typed
    application.
  prefs: []
  type: TYPE_NORMAL
- en: An implementation must use the `implements` keyword to tell the PHP compiler
    what’s going on. The Solution example illustrates how an interface is defined
    and how another part of the code can leverage that interface. [Example 8-11](#interface_implementation)
    demonstrates how the `ArtifactRepository` interface might be implemented using
    an in-memory array for data storage.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-11\. Explicit interface implementation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Throughout your application, any method can declare a type on a parameter by
    using the interface itself. The Solution example’s `Museum` class takes a concrete
    implementation of the `ArtifactRepository` as its only parameter. This class can
    then operate knowing what the exposed API of the repository will look like. The
    code doesn’t care *how* each method is implemented, only that it matches the interface’s
    defined signature exactly.
  prefs: []
  type: TYPE_NORMAL
- en: A class definition can implement many different interfaces at once. This allows
    for a complex object to be used in different situations by different pieces of
    code. Note that, if two or more interfaces define the same method name, their
    defined signatures must be identical, as illustrated by [Example 8-12](#multiple_interface_inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-12\. Implementing multiple interfaces at once
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: As both `A` and `B` define the same method signature, this implementation is
    valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Since `A` and `C` define different return types, there is no way, even with
    union types, to define a class that implements both interfaces. Attempting to
    do so causes a fatal error.
  prefs: []
  type: TYPE_NORMAL
- en: Remember also that interfaces look somewhat like classes so, like classes, they
    can be extended.^([9](ch08.html#idm45875154877776)) This is done through the same
    `extends` keyword and results in an interface that is a composition of two or
    more interfaces, as demonstrated in [Example 8-13](#composite_interfaces).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-13\. Composite interfaces
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Any class implementing `A` must define the `foo()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Any class implementing `B` must implement both `bar()` and `foo()` from `A`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on [object interfaces](https://oreil.ly/A8hkg).
  prefs: []
  type: TYPE_NORMAL
- en: 8.8 Creating Abstract Base Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a class to implement a specific interface but also want to define some
    other specific functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Rather than implementing an interface, define an abstract base class that can
    be extended as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints something like `6ec2aff42d5904e0ccef15536d8548dc`
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An abstract class looks somewhat like an interface and a regular class definition
    smashed together. It has some unimplemented methods living alongside concrete
    implementations. As with an interface, you cannot instantiate an abstract class
    directly—you have to extend it first and implement any abstract methods it defines.
    As with a class, however, you will automatically have access to any public or
    protected members of the base class in the child implementation.^([10](ch08.html#idm45875154437296))
  prefs: []
  type: TYPE_NORMAL
- en: One key difference between interfaces and abstract classes is that the latter
    can bundle properties and method definitions with it. Abstract classes are, in
    fact, classes that are merely incomplete implementations. An interface cannot
    have properties—it merely defines the functional interface with which any implementing
    object must comply.
  prefs: []
  type: TYPE_NORMAL
- en: Another difference is that you can implement multiple interfaces simultaneously,
    but you can only extend one class at a time. This limitation alone helps characterize
    when you would leverage an abstract base class versus an interface—but you can
    also mix and match both!
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible for an abstract class to define *private* members (which
    are not inherited by any child class) that are otherwise leveraged by accessible
    methods, as illustrated by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: By making your data private, it is only accessible within the context of `A`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: As `::getData()` is itself defined by `A`, the `$data` property is still accessible.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Though `::viewData()` is defined in the scope of `B`, it is accessing a public
    method from the scope of `A`. No code in `B` would have direct access to `A`’s
    private members.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: This will print `this is a secret` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation and discussion of [class abstraction](https://oreil.ly/FMkcT).
  prefs: []
  type: TYPE_NORMAL
- en: 8.9 Preventing Changes to Classes and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to prevent anyone from modifying the implementation of your class or
    extending it with a child class.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `final` keyword to indicate that a class is not extensible, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or use the `final` keyword to mark a particular method as unchangeable, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `final` keyword is a way to explicitly *prevent* object extension like the
    mechanisms discussed in the previous two recipes. It’s useful when you want to
    ensure that a specific implementation of a method or an entire class is used throughout
    a codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Marking a method as `final` means that any class extensions are incapable of
    overriding that method’s implementation. The following example will throw a fatal
    error due to the `Child` class’s attempt to override a `final` method in the `Base`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, merely omitting the definition of `unsafe()` from
    the child class will allow the code to execute as expected. If, however, you wanted
    to prevent any class from extending the base class, you could add the `final`
    keyword to the class definition itself as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The only time you should leverage `final` in your code is when overriding a
    specific method or class implementation will break your application. This is somewhat
    rare in practice but is useful when creating a flexible interface. A specific
    example would be when your application introduces an interface as well as concrete
    implementations of that interface.^([11](ch08.html#idm45875154091840)) Your API
    would then be constructed to accept any valid interface implementation, but you
    might want to prevent subclassing your own concrete implementations (again because
    doing so might break your application). [Example 8-14](#interfaces_and_concrete_classes)
    demonstrates how these dependencies might be constructed in a real application.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-14\. Interfaces and concrete classes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The application describes an interface that any data abstraction layer must
    implement.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: One concrete implementation stores data explicitly in a database.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Another implementation uses flat files for data storage.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The application doesn’t care what implementation you use so long as it implements
    the base interface. You can use either the provided (`final`) classes or define
    your own implementation.
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, you might come across a `final` class you need to extend
    anyway. In those cases, the only means at your disposal are to leverage a decorator.
    A *decorator* is a class that takes another class as a constructor property and
    “decorates” its methods with additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In some circumstances, decorators will not allow you to sidestep the `final`
    nature of a class. This happens if type hinting and strict typing require an instance
    of that exact class be passed to a function or another object within the application.
  prefs: []
  type: TYPE_NORMAL
- en: Assume, for example, that a library in your application defines a `Note` class
    that implements a `::publish()` method that publishes a given piece of data to
    social media (say, Twitter). You want this method to *also* produce a static PDF
    artifact of the given data and would normally extend the class itself, as shown
    in [Example 8-15](#final_extending_regular_class).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-15\. Typical class extension without the `final` keyword
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than instantiating a `Note` object, you can instantiate a `StaticNote`
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: When you call the object’s `::publish()` method, *both* class definitions are
    used.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Note` class is instead `final`, you will be unable to extend the class
    directly. [Example 8-16](#final_decorating_class) demonstrates how a new class
    can be created that *decorates* the `Note` class and indirectly extends its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-16\. Customizing hte behavior of a `final` class with a decorator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than instantiating `StaticNote` directly, you use this class to *wrap*
    (or *decorate*) a regular `Note` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: When you call the object’s `::publish()` method, *both* class definitions are
    used.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the [`final` keyword](https://oreil.ly/k2ZGz).
  prefs: []
  type: TYPE_NORMAL
- en: 8.10 Cloning Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a distinct copy of an object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `clone` keyword to create a second copy of the object—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, PHP will copy objects *by reference* when assigned to a new variable.
    This reference means the new variable literally points to the same object in memory.
    [Example 8-17](#obj_copy_by_reference) illustrates how, even though it might appear
    that you’ve created a copy of an object, you’re really dealing with just two references
    to the same data.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-17\. The assignment operator copies an object by reference
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This particular syntax is shorthand, valid as of PHP 5.4, that dynamically converts
    a new associative array to an instance of the built-in `stdClass` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Attempt to copy the first object to a new instance by using the assignment operator.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Make a change to the internal state of the “copied” object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO15-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the original object shows that its internal state has changed. Both
    `$obj1` and `$obj2` point to the same space in memory; you merely copied a reference
    to the object, not the object itself!
  prefs: []
  type: TYPE_NORMAL
- en: Rather than copy an object reference, the `clone` keyword copies an object to
    a new variable *by value*. This means all of the properties are copied to a new
    instance of the same class that has all of the methods of the original object
    as well. [Example 8-18](#obj_copy_by_value) illustrates how the two objects are
    now entirely decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-18\. The `clone` keyword copies an object by value
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than use strict assignment, leverage the `clone` keyword to create a
    by-value copy of the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Again make a change to the internal state of the copy.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO16-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the state of the original object shows no changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO16-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The cloned and changed object, however, illustrates the property modification
    made earlier.
  prefs: []
  type: TYPE_NORMAL
- en: An important caveat here is to understand that, as used in the preceding examples,
    `clone` is a *shallow clone* of the data. The operation does not traverse down
    into more complex properties like nested objects. Even with proper `clone` usage,
    it is possible to be left with two different variables referencing the same object
    in memory. [Example 8-19](#obj_nested_clone_reference) illustrates what happens
    if the object to be copied contains a more complex object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-19\. Shallow clones of complex data structures
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: When comparing objects, strict comparison only resolves as `true` when the statements
    on either side of the comparison reference the same object. In this case, you’ve
    properly cloned your object and created an entirely new instance, so this comparison
    is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Loose type comparison between objects resolves as `true` when the *values* on
    either side of the operator are the same, even between discrete instances. This
    statement evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO17-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Since `clone` is a shallow operation, the `::$child` property on both of your
    objects points to the same child object in memory. This statement evaluates to
    `true`!
  prefs: []
  type: TYPE_NORMAL
- en: To support a deeper clone, the class being cloned must implement a `__clone()`
    magic method that tells PHP what to do when leveraging `clone`. If this method
    exists, PHP will invoke it automatically when closing an instance of the class.
    [Example 8-20](#obj_nested_deep_clone) shows exactly how this might work while
    still working with dynamic classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is not possible to dynamically define methods on instances of `stdClass`.
    If you want to support deep cloning of objects in your application, you must either
    define a class directly or leverage an anonymous class, as illustrated by [Example 8-20](#obj_nested_deep_clone).
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-20\. Deep cloning of objects
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_chapter_title_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The objects are different references; therefore, this evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_chapter_title_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The parent and clone objects have the same data, so this evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_chapter_title_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `::$child` properties were also cloned internally, so the properties reference
    different object instances. This evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_chapter_title_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Both `::$child` properties contain the same data, so this evaluates to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: In most applications, you will generally be working with custom class definitions
    and not anonymous classes. In that case, you can still implement the magic `__clone()`
    method to instruct PHP on how to clone the more complex properties of your object
    where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the [`clone` keyword](https://oreil.ly/LqOE2).
  prefs: []
  type: TYPE_NORMAL
- en: 8.11 Defining Static Properties and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define a method or property on a class that is available to all
    instances of that class.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `static` keyword to define properties or methods that can be accessed
    outside an object instance—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static members of a class are accessible to any part of your code (assuming
    proper levels of visibility) directly from the class definition, whether or not
    an instance of that class exists as an object. Static properties are useful since
    they behave more or less like global variables but are scoped to a specific class
    definition. [Example 8-21](#static_properties_vs_globals) illustrates the difference
    in invoking a global variable versus a static class property in another function.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-21\. Static properties versus global variables
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: To access a global variable within another scope, you must explicitly refer
    to the global scope. Given that you can have separate variables in a narrower
    scope that match the names of global variables, this can become potentially confusing
    in practice.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A class-scoped property, however, can be accessed directly based on the name
    of the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: More usefully, static methods provide ways to invoke utility functionality bound
    to a class prior to instantiating an object of that class directly. One common
    example is when constructing value objects that should represent serialized data
    where it would be difficult to construct an object from scratch directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 8-22](#static_method_instantiation) demonstrates a class that does
    not allow for direct instantiation. Instead, you must create an instance by unserializing
    some fixed data. The constructor is inaccessible outside of the class’s interior
    scope, so a static method is the only means of creating an object.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-22\. Static method object instantiation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A private constructor can be accessed only from within the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Within a static method, you can still create a new object instance by leveraging
    the special `self` keyword to refer to the class. This permits you to access your
    private constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO19-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The magic `__toString()` method is invoked whenever PHP tries to coerce an object
    into a string directly (i.e., when you try to `echo` it to the console).
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO19-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Rather than creating an object with the `new` keyword, leverage a purpose-built
    static deserialization method.
  prefs: []
  type: TYPE_NORMAL
- en: Both static methods and properties are subject to the same visibility constraints
    as their nonstatic peers. Note that marking either as `private` means they can
    only be referenced by one another or by nonstatic methods within the class itself.
  prefs: []
  type: TYPE_NORMAL
- en: As static methods and properties aren’t tied directly to an object instance,
    you can’t use regular object-bound accessors to reach them. Instead, leverage
    the class name directly and the scope resolution operator (a double colon, or
    `::`)—for example, `Foo::$bar` for properties or `Foo::bar()` for methods. Within
    the class definition itself, you can leverage `self` as a shorthand for the class
    name or `parent` as a shorthand for the parent class name (if using inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you have access to an object instance of the class, you can use that object’s
    name rather than the class name to access its static members as well. For example,
    you can use `$foo::bar()` to access the static `bar()` method on the class definition
    for the object named `$foo`. While this works, it can make it more difficult for
    other developers to understand what class definition you’re working with, so this
    syntax should be used sparingly if at all.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on the [`static` keyword](https://oreil.ly/tlxjn).
  prefs: []
  type: TYPE_NORMAL
- en: 8.12 Introspecting Private Properties or Methods Within an Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to enumerate the properties or methods of an object and leverage its
    private members.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use PHP’s Reflection API to enumerate properties and methods. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP’s Reflection API grants developers vast power to inspect all elements of
    their application. You can enumerate methods, properties, constants, function
    arguments, and more. You can also ignore the privacy afforded to each at will
    and directly invoke private methods on objects. [Example 8-23](#reflection_privacy)
    illustrates how an explicitly private method can be invoked directly with the
    Reflection API.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-23\. Using Reflection to violate class privacy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The example class has a single, private property to maintain an internal counter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO20-2)'
  prefs: []
  type: TYPE_NORMAL
- en: You want to increment the counter a bit past its default. Now it’s `1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO20-5)'
  prefs: []
  type: TYPE_NORMAL
- en: An additional increment sets the counter to `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO20-6)'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, printing out the counter’s state will confirm it’s `2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_classes_and_objects_CO20-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Attempting to interact with the counter *directly* will result in a thrown `Error`,
    as the property is private.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_classes_and_objects_CO20-8)'
  prefs: []
  type: TYPE_NORMAL
- en: Through reflection, you can interact with object members regardless of their
    privacy setting.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_classes_and_objects_CO20-9)'
  prefs: []
  type: TYPE_NORMAL
- en: Now you demonstrate the counter was truly reset to `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection is a truly powerful way to get around visibility modifiers in the
    API exposed by a class. However, its use in a production application likely points
    to a poorly constructed interface or system. If your code needs access to a private
    member of a class, either that member should be public to begin with or you need
    to create an appropriate accessor method.
  prefs: []
  type: TYPE_NORMAL
- en: The only legitimate use of Reflection is in inspecting and modifying the internal
    state of an object. In an application, this behavior should be limited to the
    class’s exposed API. In *testing*, however, it might be necessary to modify an
    object’s state between test runs in ways the API doesn’t support during regular
    operation.^([12](ch08.html#idm45875152569072)) Those rare circumstances might
    require resetting internal counters or invoking otherwise private cleanup methods
    housed within the class. It’s then that Reflection proves its utility.
  prefs: []
  type: TYPE_NORMAL
- en: In regular application development, though, Reflection paired with functional
    calls like [`var_dump()`](https://oreil.ly/HXVwr) helps to disambiguate the internal
    operation of classes defined in imported vendor code. It might prove useful to
    introspect serialized objects or third-party integrations, but take care not to
    ship this kind of introspection to production.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Overview of PHP’s [Reflection API](https://oreil.ly/C49RP).
  prefs: []
  type: TYPE_NORMAL
- en: 8.13 Reusing Arbitrary Code Between Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to share a particular piece of functionality between multiple classes
    without leveraging a class extension.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import a Trait with a `use` statement—for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Account` class imports the logging functionality from your `Logger` trait
    and can use its methods as if they were native to its own definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO21-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, the `User` class has native-level access to `Logger`’s methods, even
    though it extends a base `Person` class with additional functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [Recipe 8.6](#class_inheritance), a class in PHP can descend
    from at most one other class. This is referred to as *single inheritance* and
    is a characteristic of languages other than PHP as well. Luckily, PHP exposes
    an additional mechanism for code reuse called *Traits*. Traits allow for the encapsulation
    of some functionality in a separate class-like definition that can be easily imported
    without breaking single inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: A Trait looks somewhat like a class but cannot be instantiated directly. Instead,
    the methods defined by a Trait are imported into another class definition by the
    `use` statement. This permits code reuse between classes that do not share an
    inheritance tree.
  prefs: []
  type: TYPE_NORMAL
- en: Traits empower you to define common methods (with differing method visibility)
    and properties that are shared between definitions. You can also override the
    default visibility from a Trait in the class that imports it. [Example 8-24](#trait_visibility_override)
    shows how an otherwise public method defined in a Trait can be imported as a protected
    or even private method in another class.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-24\. Overriding the visibility of methods defined in a Trait
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This syntax will import every method defined in `Foo` but will explicitly make
    its `::bar()` method protected within the scope of class `A`. This means only
    instances of class `A` (or its descendants) will be able to invoke the method.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO22-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, class `B` changes the visibility of its imported `::foo()` method
    to private so only instances of `B` can access that method directly.
  prefs: []
  type: TYPE_NORMAL
- en: Traits can be composed together as deeply as you want, meaning a Trait can `use`
    another Trait just as easily as a class can. Likewise, there is no limit to the
    number of Traits that can be imported either by other Traits or by class definitions.
  prefs: []
  type: TYPE_NORMAL
- en: If the class importing a Trait (or multiple Traits) defines a method also named
    in the Trait, then the class’s version takes precedence and is used by default.
    [Example 8-25](#trait_precedence) illustrates how this precedence works by default.
  prefs: []
  type: TYPE_NORMAL
- en: Example 8-25\. Method precedence in Traits
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In some circumstances, you might import multiple Traits that all define the
    same method. In those situations, you can explicitly identify which version of
    a method you want to leverage in your final class when you define your `use` statement
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Like class definitions, Traits can also define properties or even static members.
    They provide an efficient means by which you can abstract operational logic definitions
    into reusable code blocks and share that logic between classes in your application.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Documentation on [Traits](https://oreil.ly/syk0E).
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch08.html#idm45875158208880-marker)) PHP 3 included some primitive object
    functionality, but the language wasn’t really considered object-oriented by most
    developers until the delivery of 4.0.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch08.html#idm45875157813808-marker)) At the time of this writing, WordPress
    was used to power [43% of all websites](https://oreil.ly/tEaN8).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch08.html#idm45875157805424-marker)) Libraries and extensions are discussed
    at length in [Chapter 15](ch15.html#chapter_extensions).
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch08.html#idm45875157792800-marker)) See [Recipe 8.12](#classes_reflection)
    for more on the Reflection API.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch08.html#idm45875157450624-marker)) Review [“Visibility”](#property_and_method_visibility)
    for more background on visibility within classes.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch08.html#idm45875157386544-marker)) See [Recipe 8.3](#read_only_properties)
    for details on how these properties could further be made read-only.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch08.html#idm45875156595712-marker)) See [Recipe 3.4](ch03.html#argument_and_return_typing)
    for more on strict type enforcement.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch08.html#idm45875155649632-marker)) For more on property and method visibility,
    review [“Visibility”](#property_and_method_visibility).
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch08.html#idm45875154877776-marker)) Review [Recipe 8.6](#class_inheritance)
    for more on class inheritance and extension.
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch08.html#idm45875154437296-marker)) See [Recipe 8.6](#class_inheritance)
    for more on class inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: ^([11](ch08.html#idm45875154091840-marker)) See [Recipe 8.7](#class_interfaces)
    for more on interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: ^([12](ch08.html#idm45875152569072-marker)) Both testing and debugging are discussed
    at length in [Chapter 13](ch13.html#chapter_debugging).
  prefs: []
  type: TYPE_NORMAL
