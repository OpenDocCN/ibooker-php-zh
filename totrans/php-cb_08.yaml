- en: Chapter 8\. Classes and Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章\. 类和对象
- en: The earliest versions of PHP didn’t support class definition or object orientation.
    PHP 4 was the first real attempt at an object interface.^([1](ch08.html#idm45875158208880))
    It wasn’t until PHP 5, though, that developers had the complex object interfaces
    they know and use today.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的早期版本不支持类定义或面向对象。PHP 4 是第一个真正尝试实现对象接口的版本。^([1](ch08.html#idm45875158208880))
    直到 PHP 5，开发者才拥有今天所知道和使用的复杂对象接口。
- en: Classes are defined using the `class` keyword followed by a full description
    of the constants, properties, and methods inherent to the class. [Example 8-1](#basic_php_class)
    introduces a basic class construct in PHP, complete with a scoped constant value,
    a property, and callable methods.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 类使用 `class` 关键字定义，后跟类中固有的常量、属性和方法的完整描述。[示例 8-1](#basic_php_class) 在 PHP 中引入了一个基本的类结构，包括作用域常量值、属性和可调用方法。
- en: Example 8-1\. Basic PHP class with properties and methods
  id: totrans-3
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-1\. 带有属性和方法的基本 PHP 类
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An object can be instantiated with the `new` keyword and the name of the class;
    instantiation looks somewhat like a function call. Any parameters passed into
    this instantiation are transparently passed into the class constructor (the `__construct()`
    method) to define the object’s initial state. [Example 8-2](#basic_php_class_instantiation)
    illustrates how the class definition from [Example 8-1](#basic_php_class) could
    be instantiated either with or without default property values.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `new` 关键字和类的名称实例化对象；实例化看起来有点像函数调用。任何传递到此实例化的参数都会透明地传递到类构造函数（`__construct()`
    方法），以定义对象的初始状态。[示例 8-2](#basic_php_class_instantiation) 演示了如何从 [示例 8-1](#basic_php_class)
    中的类定义实例化类，无论是使用还是不使用默认属性值。
- en: Example 8-2\. Instantiating a basic PHP class
  id: totrans-6
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-2\. 实例化一个基本的 PHP 类
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO1-1)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO1-1)'
- en: Instantiating an object without passing a parameter will still invoke the constructor
    but will leverage its default parameters. If no defaults are provided in the function
    signature, this would result in an error.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在不传递参数实例化对象时，仍会调用构造函数，但会利用其默认参数。如果函数签名中没有提供默认值，将导致错误。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO1-2)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO1-2)'
- en: Passing a parameter during instantiation will provide this parameter to the
    constructor.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例化期间传递参数将向构造函数提供该参数。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO1-3)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO1-3)'
- en: This prints `hello world` by using the constructor’s defaults.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这会通过使用构造函数的默认值打印 `hello world`。
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO1-4)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO1-4)'
- en: This prints `hello universe` to the console.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这会在控制台打印 `hello universe`。
- en: '[![5](assets/5.png)](#co_classes_and_objects_CO1-5)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_classes_and_objects_CO1-5)'
- en: Constants are referenced directly from the class name. This will print a literal
    `42` to the console.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 常量直接从类名引用。这会在控制台打印字面值 `42`。
- en: Constructors and properties are covered in Recipes [8.1](#object_instantiation)
    and [8.2](#constructors_with_defaults).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和属性在第 [8.1](#object_instantiation) 和 [8.2](#constructors_with_defaults)
    节中有详细说明。
- en: Procedural Programming
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过程式编程
- en: Most developers’ first experience with PHP is through its more procedural interfaces.
    Example routines, simple scripts, tutorials—all of these typically leverage functions
    and variables defined within the global scope. This isn’t a bad thing, but it
    does limit the flexibility of the programs you can produce.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者对 PHP 的第一次接触是通过其更多的过程式接口。示例例程、简单脚本、教程——所有这些通常都利用在全局范围内定义的函数和变量。这并不是坏事，但它限制了您可以生成的程序的灵活性。
- en: Procedural programming often results in stateless applications. There is little
    to no ability to keep track of what’s happened before between function calls,
    so you pass some reference to the application’s state throughout your code. Again,
    this isn’t necessarily a bad thing. The only drawback is that *complex* applications
    become difficult to analyze or understand.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 过程式编程经常导致无状态应用程序。在函数调用之间，几乎没有能力跟踪之前发生的事情，因此需要通过代码中的某些参考来传递应用程序的状态。再次强调，这并不一定是坏事。唯一的缺点是*复杂*应用程序变得难以分析或理解。
- en: Object-Oriented Programming
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向对象编程
- en: An alternative paradigm is to leverage objects as containers of state. A common
    practical example is to consider objects as ways to define *things*. A car is
    an object. So is a bus. And a bicycle. They are discrete *things* that have characteristics
    (such as color, number of wheels, and type of drive) and capabilities (such as
    go, stop, and turn).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种范式是利用对象作为状态的容器。一个常见的实际例子是将对象视为定义*事物*的方式。汽车是一个对象。公共汽车也是。自行车也是。它们是具有特征（如颜色、轮子数量和驱动类型）和功能（如前进、停止和转弯）的离散*事物*。
- en: In the programming world, this is among the easiest ways to describe objects.
    In PHP, you create objects by first defining a `class` to describe the type of
    object. A class describes the properties (characteristics) and methods (capabilities)
    that an object of that type will have.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程世界中，这是描述对象最简单的方式之一。在 PHP 中，你首先通过定义`class`来创建对象，以描述该类型的对象将具有的属性（特征）和方法（能力）。
- en: Like things in the real world, objects in a programming space can inherit from
    more primitive type descriptions. A car, bus, and bicycle are all types of vehicles,
    so they can all descend from a specific type. [Example 8-3](#php_class_abstraction)
    demonstrates how PHP might construct that kind of object inheritance.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就像现实世界中的事物一样，编程空间中的对象可以继承自更原始的类型描述。汽车、公共汽车和自行车都是车辆的类型，因此它们都可以从特定类型继承。[示例 8-3](#php_class_abstraction)
    展示了 PHP 可能如何构建这种对象继承。
- en: Example 8-3\. Class abstraction in PHP
  id: totrans-26
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-3\. PHP 中的类抽象
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Instantiating an object creates a typed variable that represents both an initial
    state and methods for manipulating that state. Object *inheritance* presents the
    possibility to use one or more types as alternatives to one another in other code.
    [Example 8-4](#interchangeable_classes) illustrates how the three types of vehicles
    introduced in [Example 8-2](#basic_php_class_instantiation) could be used interchangeably
    because of inheritance.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化对象将创建一个类型化变量，表示初始状态和用于操作该状态的方法。对象*继承*提供了在其他代码中使用一个或多个类型作为替代品的可能性。[示例 8-4](#interchangeable_classes)
    说明了由于继承关系，介绍的三种车辆类型可以互换使用。
- en: Example 8-4\. Classes with similar inheritance can be used interchangeably
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-4\. 具有类似继承的类可以互换使用
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO2-1)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO2-1)'
- en: All three of the vehicle subtypes can be used as valid replacements for `Vehicle`
    in function calls. This means you could commute by bus, car, or bicycle, and any
    choice would be equally valid.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 三种车辆子类型都可以作为函数调用中`Vehicle`的有效替换。这意味着你可以选择乘坐公共汽车、轿车或自行车，任何选择都同样有效。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO2-2)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO2-2)'
- en: At times you might need to be more precise and use a child type directly. Neither
    `Bus` nor `Car` nor any other subclass of the `Vehicle` class will be valid for
    exercise besides a `Bicycle`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，您可能需要更精确，并直接使用子类型。除了`Bicycle`，`Bus`、`Car`或任何`Vehicle`类的其他子类都不会被视为有效练习。
- en: Class inheritance is covered at a deeper level by Recipes [8.6](#class_inheritance),
    [8.7](#class_interfaces), and [8.8](#class_abstraction).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类继承在“Recipes”中更深入地介绍，包括 [8.6](#class_inheritance)、[8.7](#class_interfaces) 和
    [8.8](#class_abstraction)。
- en: Multiparadigm Languages
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多范式语言
- en: PHP is considered a *multiparadigm* language, as you can write code following
    either of the preceding paradigms. A valid PHP program can be purely procedural.
    Or it can be strictly focused on object definitions and custom classes. The program
    could ultimately use a mix of both paradigms.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 被视为*多范式*语言，因为你可以按照前述的任一范式编写代码。一个有效的 PHP 程序可以是纯过程化的。或者它可以严格依赖于对象定义和自定义类。该程序最终可能会混合使用这两种范式。
- en: The open source WordPress content management system (CMS) is one of the most
    popular PHP projects on the internet.^([2](ch08.html#idm45875157813808)) It’s
    coded to heavily leverage objects for common abstractions like database objects
    or remote requests. However, WordPress also stems from a long history of procedural
    programming—much of the codebase is still heavily influenced by that style. WordPress
    is a key example not just of the success of PHP itself, but of the flexibility
    of the language’s support for multiple paradigms.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 开源的 WordPress 内容管理系统（CMS）是互联网上最流行的 PHP 项目之一。^([2](ch08.html#idm45875157813808))
    它被编码为大量利用对象来实现常见抽象，如数据库对象或远程请求。然而，WordPress 也源自长期的过程化编程历史 —— 其代码库的很大一部分仍受到这种风格的深刻影响。WordPress
    不仅是 PHP 本身成功的关键例子，也展示了语言对多种范式支持的灵活性。
- en: There is no single right answer for how an application should be assembled.
    Most are hybrids of approaches that benefit from PHP’s strong support of multiple
    paradigms. Even in a majority-procedural application, though, you will still likely
    see a handful of objects as that’s how the language’s standard library [implements
    much of its functionality](https://oreil.ly/krXrW).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一种固定的方法来组装应用程序。大多数都是多范式支持的混合体，受益于PHP对多种编程范式的强力支持。即使在绝大多数程序化应用程序中，您也可能会看到一些对象，因为这是语言标准库[实现其大部分功能的方式](https://oreil.ly/krXrW)。
- en: '[Chapter 6](ch06.html#chapter_datetime) illustrated the use of both the functional
    and object-oriented interfaces for PHP’s date system. Error handling, which is
    covered more in [Chapter 13](ch13.html#chapter_debugging), heavily leverages internal
    `Exception` and `Error` classes. The `yield` keyword in an otherwise procedural
    implementation automatically creates instances of the `Generator` class.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 6 章](ch06.html#chapter_datetime)展示了PHP日期系统的功能和面向对象接口的使用。错误处理在[第 13 章](ch13.html#chapter_debugging)中有更详细的讨论，重点利用内部的`Exception`和`Error`类。在一个否定程序化实现中，`yield`关键字会自动创建`Generator`类的实例。'
- en: Even if you never define a class in your program directly, the chances are good
    that you will leverage one defined either by PHP itself or by a third-party library
    your program requires.^([3](ch08.html#idm45875157805424))
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您在程序中从未直接定义类，您很可能会使用PHP本身定义的类或程序所需的第三方库定义的类。^([3](ch08.html#idm45875157805424))
- en: Visibility
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可见性
- en: Classes also introduce the concept of *visibility* into PHP. Properties, methods,
    and even constants can be defined with an optional visibility modifier to change
    their level of access from other parts of the application. Anything declared `public`
    is accessible to any other class or function in your application. Both methods
    and properties can be declared `protected`, making them accessible only to an
    instance of either the class itself or classes that descend from it. Finally,
    the `private` declaration means a member of the class can be accessed only by
    instances of that class itself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: PHP中类还引入了*可见性*的概念。属性、方法甚至常量都可以使用可选的可见性修饰符进行定义，以改变它们在应用程序其他部分中的访问级别。声明为`public`的内容可以被应用程序中的任何其他类或函数访问。方法和属性可以声明为`protected`，使它们仅对类的实例或从它继承的类的实例可见。最后，`private`声明意味着类的成员只能被类本身的实例访问。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: By default, anything not explicitly scoped to be private or protected is automatically
    public, so you might see some developers skip declaring member visibility entirely.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，未显式声明为私有或受保护的内容默认为公共，因此您可能会看到一些开发人员跳过声明成员可见性的步骤。
- en: While member visibility can be directly overridden via reflection,^([4](ch08.html#idm45875157792800))
    it’s typically a sound way to clarify which parts of a class’s interface are intended
    to be used by other code elements. [Example 8-5](#intro_visibility_demonstration)
    illustrates how each visibility modifier can be leveraged to build a complex application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然成员可见性可以通过反射直接覆盖，^([4](ch08.html#idm45875157792800)) 但通常通过明确声明类的接口的哪些部分可供其他代码元素使用，是一个明智的方式。
    [示例 8-5](#intro_visibility_demonstration)演示了如何利用每种可见性修饰符来构建复杂应用程序。
- en: Example 8-5\. Class member visibility overview
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-5\. 类成员可见性概述
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO3-1)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO3-1)'
- en: Prints `Bob`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`Bob`。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO3-2)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO3-2)'
- en: Prints `Portland`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`Portland`。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO3-3)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO3-3)'
- en: Prints `2023`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`2023`。
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO3-4)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO3-4)'
- en: Returns a `Warning` as the `::$value` property is private and inaccessible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个`Warning`，因为`::$value`属性是私有且不可访问的。
- en: '[![5](assets/5.png)](#co_classes_and_objects_CO3-5)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_classes_and_objects_CO3-5)'
- en: Prints `hello`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`hello`。
- en: '[![6](assets/6.png)](#co_classes_and_objects_CO3-6)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_classes_and_objects_CO3-6)'
- en: Prints `world`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`world`。
- en: '[![7](assets/7.png)](#co_classes_and_objects_CO3-7)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_classes_and_objects_CO3-7)'
- en: Throws an `Error` as the `::universe()` method is protected and inaccessible
    outside the class instance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出一个`Error`，因为`::universe()`方法是受保护的且在类实例外部不可访问。
- en: '[![8](assets/8.png)](#co_classes_and_objects_CO3-8)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[![8](assets/8.png)](#co_classes_and_objects_CO3-8)'
- en: This line would not even execute because of the error thrown on the previous
    line. If the previous line did *not* throw an error, this one would, as the `::abyss()`
    method is private and inaccessible outside the class instance.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前一行抛出了错误，这一行甚至不会执行。如果前一行没有抛出错误，则这一行会抛出错误，因为 `::abyss()` 方法是私有的，无法在类实例外部访问。
- en: The following recipes further illustrate the preceding concepts and cover some
    of the most common use cases and implementations of objects in PHP.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例进一步说明了前述概念，并涵盖了 PHP 中对象的一些最常见用例和实现。
- en: 8.1 Instantiating Objects from Custom Classes
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 从自定义类实例化对象
- en: Problem
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define a custom class and create a new object instance from it.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望定义一个自定义类并从中创建一个新的对象实例。
- en: Solution
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Define the class and its properties and methods with the `class` keyword, then
    use `new` to create an instance of it as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `class` 关键字定义类及其属性和方法，然后使用 `new` 创建实例，如下所示：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Discussion
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The Solution example illustrates several key characteristics of objects:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例展示了对象的几个关键特征：
- en: Objects can have properties that define the internal state of the object itself.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象可以具有定义对象内部状态的属性。
- en: These objects can have specific visibility. In the Solution example, objects
    are `public`, meaning they can be accessed by any code within the application.^([5](ch08.html#idm45875157450624))
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些对象可以具有特定的可见性。在解决方案示例中，对象是 `public` 的，这意味着可以被应用程序中的任何代码访问。
- en: The magic `::__construct()` method can accept parameters only when the object
    is first instantiated. These parameters can be used to define the initial state
    of the object.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 魔术 `::__construct()` 方法只能在首次实例化对象时接受参数。这些参数可用于定义对象的初始状态。
- en: Methods can have visibility similar to the properties of the object.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以具有与对象属性类似的可见性。
- en: This particular version of class definition is the default many developers have
    been using since PHP 5, when true object-oriented primitives were first introduced.
    However, [Example 8-6](#constructor_promotion) demonstrates a newer and simpler
    way to define a simple object like the one in the Solution example. Rather than
    independently declaring and then directly assigning the properties that carry
    the object’s state, PHP 8 (and later) allows for defining everything within the
    constructor itself.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 自 PHP 5 开始，这种特定版本的类定义是许多开发者使用的默认方式，当时首次引入了真正的面向对象基元。然而，[示例 8-6](#constructor_promotion)
    展示了一种更新且更简单的定义简单对象的方式。与独立声明并直接赋值对象状态的属性不同，PHP 8（及更高版本）允许在构造函数中定义所有内容。
- en: Example 8-6\. Constructor promotion in PHP 8
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-6\. PHP 8 中的构造函数提升
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Solution example and [Example 8-6](#constructor_promotion) are functionally
    equivalent and will result in objects of the same internal structure being created
    at runtime. PHP’s ability to promote constructor arguments to object properties,
    however, dramatically reduces the amount of repetitive code you need to type while
    defining a class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例和 [示例 8-6](#constructor_promotion) 在功能上是等效的，将导致在运行时创建具有相同内部结构的对象。然而，PHP
    能够将构造函数参数提升为对象属性，大大减少了在定义类时需要输入的重复代码量。
- en: Each constructor argument also permits the same types of visibility (`public`/`pro⁠tected`/`private`)
    that object properties do.^([6](ch08.html#idm45875157386544)) The shorthand syntax
    means you don’t need to declare properties, then define parameters, then map the
    parameters onto those properties upon object instantiation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个构造函数参数也允许与对象属性相同的可见性（`public`/`protected`/`private`）。简写语法意味着您不需要在实例化对象时先声明属性，然后定义参数，然后将参数映射到这些属性。
- en: See Also
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on [classes and objects](https://oreil.ly/TfrNb) and the [original
    RFC on constructor promotion](https://oreil.ly/nzD0s).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[类和对象的文档](https://oreil.ly/TfrNb) 和 [构造函数提升的原始 RFC](https://oreil.ly/nzD0s)
    的文档。'
- en: 8.2 Constructing Objects to Define Defaults
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.2 构造对象以定义默认值
- en: Problem
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define default values for your object’s properties.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望为对象的属性定义默认值。
- en: Solution
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Define default values for the constructor’s arguments as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为构造函数的参数定义默认值如下：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Discussion
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The constructor function within a class definition behaves more or less like
    any other function in PHP, except it does not return a value. You can define default
    arguments similarly to how you would with a standard function. You can even reference
    the names of the constructor arguments to accept default values for *some* parameters
    while defining others later in the function signature.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义中的构造函数行为与PHP中的任何其他函数基本相同，除了它不返回值。你可以定义默认参数，类似于标准函数的方式。你甚至可以引用构造函数参数的名称，在函数签名中接受一些参数的默认值，同时在后续定义其他参数时。
- en: 'The Solution example explicitly defines the class properties by using constructor
    promotion for brevity, but the older-style verbose constructor definition is equally
    valid as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案示例通过使用构造函数提升明确定义了类属性，以简洁为目标，但旧式冗长的构造函数定义同样有效，如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, if *not* using constructor promotion, you can initialize object
    properties directly by assigning a default value when they’re defined. When doing
    so, you would usually leave those parameters off the constructor and manipulate
    them elsewhere in the program, as shown in the following example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果*不*使用构造函数提升，可以在定义时直接给对象属性赋默认值。这样做时，通常会在构造函数中省略这些参数，并在程序的其他地方进行操作，如下例所示：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Warning
  id: totrans-97
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As will be discussed in [Recipe 8.3](#read_only_properties), you cannot initialize
    a `readonly` class property directly with a default. This is equivalent to a class
    constant, and the syntax is therefore disallowed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如将在[Recipe 8.3](#read_only_properties)中讨论的那样，你不能直接使用默认值初始化`readonly`类属性。这与类常量等效，因此语法不允许。
- en: See Also
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[Recipe 3.2](ch03.html#function_default_parameters) for more on default function
    parameters, [Recipe 3.3](ch03.html#named_function_parameters) for named function
    parameters, and documentation on [constructors and destructors](https://oreil.ly/WJvYY).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[Recipe 3.2](ch03.html#function_default_parameters) 详细说明了默认函数参数，[Recipe 3.3](ch03.html#named_function_parameters)
    则介绍了命名函数参数，以及关于[构造函数和析构函数](https://oreil.ly/WJvYY)的文档。'
- en: 8.3 Defining Read-Only Properties in a Class
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 在类中定义只读属性
- en: Problem
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define your class in such a way that properties defined at instantiation
    cannot be changed after the object exists.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望以某种方式定义类，以便在对象存在后无法更改已定义的属性。
- en: Solution
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `readonly` keyword on a typed property:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在已定义类型的属性上使用`readonly`关键字：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If using constructor promotion, place the keyword along with the property type
    within the constructor:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用构造函数提升，请将关键字与属性类型一起放在构造函数中：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Discussion
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `readonly` keyword was introduced in PHP 8.1 and was aimed at reducing the
    need for more verbose workarounds originally required to achieve the same functionality.
    With this keyword, a property can only be initialized with a value *once*, and
    only while the object is being instantiated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`readonly`关键字在PHP 8.1中引入，旨在减少原本需要更多冗长变通方法来实现相同功能的需求。使用此关键字，属性只能在对象实例化时初始化*一次*。'
- en: Note
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Read-only properties cannot have a default value. This would make them functionally
    equivalent to class constants, which already exist, so the functionality is unavailable
    and the syntax is unsupported. Promoted constructor properties can, however, leverage
    default values within the argument definition as these are evaluated at runtime.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 只读属性不能有默认值。这将使它们在功能上等同于类常量，这已经存在，因此该功能不可用，语法不支持。然而，提升的构造函数属性可以利用参数定义中的默认值，因为这些值在运行时进行评估。
- en: The keyword is also valid only for typed properties. Types are typically optional
    in PHP (except when strict typing is being used^([7](ch08.html#idm45875156595712)))
    to aid in flexibility, so it’s possible a property on your class *can’t* be set
    to one or another type. In those instances, use the `mixed` type instead so you
    can set a read-only property without other type constraints.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 该关键字仅对已定义类型的属性有效。在PHP中，类型通常是可选的（除非使用严格类型检查^([7](ch08.html#idm45875156595712))），以增强灵活性，因此可能*不能*将类的属性设置为一个或另一个类型。在这些情况下，请使用`mixed`类型，以便可以设置一个只读属性而不受其他类型约束。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of this writing, read-only declarations are *not* supported on static
    properties.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此刻，只读声明*不*支持静态属性。
- en: As a read-only property can only be instantiated once, it cannot be unset or
    modified by other subsequent code. All of the code in [Example 8-7](#erroneous_readonly_modification)
    will result in the throwing of an `Error` exception.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于只读属性只能实例化一次，因此不能由后续代码取消或修改。在[示例 8-7](#erroneous_readonly_modification)中的所有代码将导致抛出`Error`异常。
- en: Example 8-7\. Erroneous attempts to modify a read-only property
  id: totrans-117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-7\. 修改只读属性的错误尝试
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO4-1)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO4-1)'
- en: The `Example` object will have an uninitialized `::$prop` property that cannot
    be accessed (accessing a property before initialization throws an `Error` exception).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Example` 对象将具有未初始化的 `::$prop` 属性，无法访问（在初始化之前访问属性会抛出 `Error` 异常）。'
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO4-2)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO4-2)'
- en: As the object is already instantiated, attempting to write to a read-only property
    throws an `Error`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对象已经实例化，尝试写入只读属性会抛出 `Error`。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO4-3)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO4-3)'
- en: The `::$count` property is read-only, so you cannot assign a new value to it
    without an `Error`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`::$count` 属性是只读的，因此您无法为其分配新值，会导致 `Error`。'
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO4-4)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO4-4)'
- en: As the `::$count` property is read-only, you cannot increment it directly.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `::$count` 属性是只读的，因此无法直接对其进行增量操作。
- en: '[![5](assets/5.png)](#co_classes_and_objects_CO4-5)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_classes_and_objects_CO4-5)'
- en: You cannot increment in either direction with a read-only property.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 不能通过只读属性进行增量递增或递减。
- en: '[![6](assets/6.png)](#co_classes_and_objects_CO4-6)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_classes_and_objects_CO4-6)'
- en: You cannot unset a read-only property.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 不能取消只读属性。
- en: 'The properties within a class can, however, be other classes themselves. In
    those situations, a read-only declaration on the property means that property
    cannot be overwritten or unset, but has no impact on the properties of the child
    class. For example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 类中的属性可能是其他类自身。在这些情况下，属性上的只读声明意味着该属性无法被重写或取消，但不影响子类的属性。例如：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO5-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO5-1)'
- en: The increment of the internal counter will succeed as the `::$counter` property
    is itself not declared as read-only.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `::$counter` 属性本身未声明为只读，因此内部计数器的增量将成功。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO5-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO5-2)'
- en: The `::$inner` property is read-only and cannot be overridden. Attempts to do
    so result in an `Error` exception.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`::$inner` 属性是只读的，不能被覆盖。尝试这样做将导致 `Error` 异常。'
- en: See Also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on [read-only properties](https://oreil.ly/P-AwN).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[只读属性文档](https://oreil.ly/P-AwN)。'
- en: 8.4 Deconstructing Objects to Clean Up After the Object Is No Longer Needed
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.4 拆解对象以在不再需要对象时进行清理
- en: Problem
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: Your class definition wraps an expensive resource that must be carefully cleaned
    up when the object goes out of scope.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义封装了一个昂贵的资源，在对象超出范围时必须小心清理。
- en: Solution
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Define a class destructor to clean up after the object is removed from memory
    as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个类析构函数，在对象从内存中移除后进行清理：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Discussion
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When an object falls out of scope, PHP will automatically garbage-collect any
    memory or other resources that object used to represent. There might be times,
    however, when you want to force a specific action when that object goes out of
    scope. This might be releasing a database handle, as with the Solution example.
    It could be explicitly logging an event to a file. Or perhaps *deleting* a temporary
    file from the system, as shown in [Example 8-8](#destruct_delete_temp_file).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象超出范围时，PHP 将自动回收该对象用于表示的任何内存或其他资源。然而，在对象超出范围时，可能希望强制执行特定操作。例如释放数据库句柄，就像解决方案示例中那样。或者显式记录事件到文件中。或者从系统中*删除*临时文件，正如[示例 8-8](#destruct_delete_temp_file)所示。
- en: Example 8-8\. Removing a temporary file in a destructor
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-8\. 在析构函数中删除临时文件
- en: '[PRE15]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO6-1)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO6-1)'
- en: The object will automatically create a file in the current directory with a
    name similar to *tmp_test_1650837172.tmp*.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对象将自动在当前目录中创建一个文件，其名称类似于 *tmp_test_1650837172.tmp*。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO6-2)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO6-2)'
- en: Every new log entry is written as a new line in the temporary log file.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个新的日志条目都作为临时日志文件中的新行写入。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO6-3)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO6-3)'
- en: Accessing the logs will create a second handle on the same file, but for reading.
    The object exposes this handle through a generator that enumerates over every
    line in the file.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 访问日志将创建文件的第二个句柄，但用于读取。对象通过生成器公开此句柄，该生成器枚举文件中的每一行。
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO6-4)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO6-4)'
- en: When the logger is removed from scope (or explicitly unset), the destructor
    will close the open file handle and automatically delete the file as well.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当记录器从作用域中删除（或显式取消引用）时，析构函数将关闭打开的文件句柄，并自动删除文件。
- en: This more sophisticated example demonstrates both how a destructor would be
    written and how it would be invoked. PHP will look for a `::__destruct()` method
    on any object when it goes out of scope and will invoke it at that point in time.
    This destructor explicitly dereferences the object by calling `unset()` to remove
    it from the program. You could just as easily have set the variable referencing
    the object to `null` with the same result.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更复杂的示例展示了析构函数的编写方式以及在何时调用它。当 PHP 在对象超出范围时会查找 `::__destruct()` 方法，并在那时调用它。此析构函数通过调用
    `unset()` 明确取消引用对象来删除对象。您也可以通过将引用对象的变量设置为 `null` 来达到同样的结果。
- en: Unlike object constructors, destructors do not accept any parameters. If your
    object needs to act on any external state while cleaning up after itself, be sure
    that state is referenced through a property on the object itself. Otherwise, you
    will not have access to that information.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象构造函数不同，析构函数不接受任何参数。如果您的对象在清理自身之后需要处理任何外部状态，请确保该状态通过对象本身的属性引用。否则，您将无法访问该信息。
- en: See Also
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on [constructors and destructors](https://oreil.ly/fJMGM).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[构造函数和析构函数](https://oreil.ly/fJMGM)的文档。'
- en: 8.5 Using Magic Methods to Provide Dynamic Properties
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.5 使用魔术方法提供动态属性
- en: Problem
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define a custom class without predefining the properties it supports.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望定义一个自定义类，而不预先定义其支持的属性。
- en: Solution
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use magic getters and setters to handle dynamically defined properties as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 使用魔术获取器和设置器来处理动态定义的属性如下：
- en: '[PRE16]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discussion
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: When you reference a property on an object that does not exist, PHP falls back
    on a set of *magic methods* to fill in the blanks on implementation. The getter
    is used automatically when attempting to reference a property, while the corresponding
    setter is used when assigning a value to a property.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当您引用不存在的对象属性时，PHP 将回退到一组*魔术方法*来填补实现中的空白。当尝试引用属性时，自动使用 getter，而在向属性分配值时使用相应的
    setter。
- en: Note
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Property overloading by way of magic methods only works on instantiated objects.
    It does not work on the static class definition.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过魔术方法进行属性重载仅适用于已实例化的对象。它不适用于静态类定义。
- en: Internally, you then control the behavior of getting and setting data in its
    entirety. The Solution example stores its data in a private associative array.
    You can further flesh out this example by fully implementing magic methods for
    handling `isset()` and `unset()`. [Example 8-9](#full_magic_method_example) demonstrates
    how magic methods can be used to fully replicate a standard class definition,
    but without the need to predeclare all properties.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，您可以控制获取和设置数据的行为。解决方案示例将其数据存储在私有关联数组中。您可以通过完全实现处理`isset()`和`unset()`的魔术方法来进一步完善此示例。[示例 8-9](#full_magic_method_example)演示了如何使用魔术方法完全复制标准类定义，而无需预先声明所有属性。
- en: Example 8-9\. Full object definition with magic methods
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-9\. 完整对象定义与魔术方法
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In [Example 8-9](#full_magic_method_example), the two objects are functionally
    equivalent if and only if the only dynamic properties used on a `Magic` instance
    are those already defined by `Basic`. This dynamic nature is what makes the approach
    so valuable even if the class definitions are painfully verbose. You might choose
    to wrap a remote API in a class implementing magic methods in order to expose
    that API’s data to your application in an object-oriented manner.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 8-9](#full_magic_method_example) 中，如果仅当 `Magic` 实例上使用的动态属性是 `Basic` 已定义的属性时，这两个对象功能上是等价的。这种动态特性使得这种方法非常有价值，即使类定义非常冗长。您可能选择在实现魔术方法的类中封装远程
    API，以便以面向对象的方式向应用程序公开该 API 的数据。
- en: See Also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on [magic methods](https://oreil.ly/1ZtlE).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[魔术方法](https://oreil.ly/1ZtlE)的文档。'
- en: 8.6 Extending Classes to Define Additional Functionality
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.6 扩展类以定义额外功能
- en: Problem
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define a class that adds functionality to an existing class definition.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望定义一个类来为现有类定义添加功能。
- en: Solution
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `extends` keyword to define additional methods or override existing
    functionality as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `extends` 关键字定义额外方法或覆盖现有功能如下：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Discussion
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Object inheritance is a common concept for any high-level language; it’s a way
    you build new objects on top of other, often simpler object definitions. The Solution
    example illustrates how a class can *inherit* method definitions from a parent
    class, which is the core functionality of PHP’s inheritance model.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对象继承是任何高级语言的常见概念；它是在其他、通常更简单的对象定义之上构建新对象的一种方式。解决方案示例展示了一个类如何从父类*继承*方法定义，这是 PHP
    继承模型的核心功能。
- en: Warning
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: PHP does not support inheriting from multiple parent classes. To pull in code
    implementations from multiple sources, PHP leverages *traits*, which are covered
    by [Recipe 8.13](#classes_traits).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 不支持从多个父类继承。为了从多个来源引入代码实现，PHP 使用*特性*，这在 [配方 8.13](#classes_traits) 中有所涉及。
- en: In fact, a child class inherits every public and protected method, property,
    and constant from its parent class (the class it’s extending). Private methods,
    properties, and constants are *never* inherited by a child class.^([8](ch08.html#idm45875155649632))
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，子类会继承其父类（扩展的类）的每个公共和受保护方法、属性和常量。私有方法、属性和常量*永远*不会被子类继承。^([8](ch08.html#idm45875155649632))
- en: A child class can also override its parent’s implementation of a particular
    method. In practice, you would do this to change the internal logic of a particular
    method, but the method signature exposed by the child class must match that defined
    by the parent. [Example 8-10](#child_overrides) demonstrates how a child class
    would override its parent’s implementation of a method.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 子类也可以覆盖其父类对特定方法的实现。在实践中，您可能会这样做来改变特定方法的内部逻辑，但子类暴露的方法签名必须与父类定义的相匹配。[示例 8-10](#child_overrides)
    展示了一个子类如何覆盖其父类方法的实现。
- en: Example 8-10\. Overriding a parent method implementation
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-10\. 覆盖父方法实现
- en: '[PRE19]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO7-1)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO7-1)'
- en: Prints `Good morning, Alice`
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 `Good morning, Alice`
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO7-2)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO7-2)'
- en: Prints `Howdy, Bob`
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 `Howdy, Bob`
- en: 'An overridden child method does not lose all sense of the parent’s implementation,
    though. Inside a class, you reference the `$this` variable to refer to that particular
    instance of the object. Likewise, you can reference the `parent` keyword to refer
    to the parent implementation of a function. For example:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的子方法并不完全失去父类实现的意义。在类内部，您可以使用 `$this` 变量引用对象的特定实例。同样，您可以使用 `parent` 关键字引用函数的父类实现。例如：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: See Also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation and discussion of PHP’s [object inheritance model](https://oreil.ly/nsAM3).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的 [对象继承模型](https://oreil.ly/nsAM3) 的文档和讨论。
- en: 8.7 Forcing Classes to Exhibit Specific Behavior
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.7 强制类表现特定行为
- en: Problem
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define the methods on a class that will be used elsewhere in your
    application while leaving the actual method implementations up to someone else.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在一个类上定义方法，而将实际的方法实现留给其他人完成。
- en: Solution
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Define an object interface and leverage that interface in your application
    as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 定义对象接口并在应用程序中利用该接口如下：
- en: '[PRE21]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Discussion
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: An interface looks similar to a class definition, except it only defines the
    *signatures* of specific methods rather than their implementations. The interface
    does, however, define a type that can be used elsewhere in your application—so
    long as a class directly implements a given interface, an instance of that class
    can be used as if it were the same type as the interface itself.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 接口看起来类似于类定义，但它只定义了特定方法的*签名*，而不是它们的实现。然而，接口确实定义了可以在应用程序中其他地方使用的类型——只要一个类直接实现给定接口，该类的实例就可以像接口本身的类型一样使用。
- en: Warning
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: There are several situations in which you might have two classes that implement
    the same methods and expose the same signatures to your application. However,
    unless these classes explicitly implement the same interface (as evidenced by
    the `implements` keyword), they cannot be used interchangeably in a strictly typed
    application.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种情况下，您可能会有两个类实现了相同的方法并向应用程序公开了相同的签名。但是，除非这些类显式地实现了相同的接口（通过`implements`关键字作为证据），否则它们不能在严格类型的应用程序中互换使用。
- en: An implementation must use the `implements` keyword to tell the PHP compiler
    what’s going on. The Solution example illustrates how an interface is defined
    and how another part of the code can leverage that interface. [Example 8-11](#interface_implementation)
    demonstrates how the `ArtifactRepository` interface might be implemented using
    an in-memory array for data storage.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 实现必须使用`implements`关键字告诉 PHP 编译器发生了什么。解决方案示例说明了如何定义一个接口以及代码的另一部分如何利用该接口。[Example 8-11](#interface_implementation)演示了如何使用内存数组实现`ArtifactRepository`接口。
- en: Example 8-11\. Explicit interface implementation
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-11\. 显式接口实现
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Throughout your application, any method can declare a type on a parameter by
    using the interface itself. The Solution example’s `Museum` class takes a concrete
    implementation of the `ArtifactRepository` as its only parameter. This class can
    then operate knowing what the exposed API of the repository will look like. The
    code doesn’t care *how* each method is implemented, only that it matches the interface’s
    defined signature exactly.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，任何方法都可以通过使用接口本身在参数上声明类型。解决方案示例的`Museum`类将`ArtifactRepository`的具体实现作为唯一参数。然后，这个类可以操作，知道仓库暴露的
    API 将是什么样子。代码并不关心 *每个* 方法是如何实现的，只关心它是否与接口定义的签名完全匹配。
- en: A class definition can implement many different interfaces at once. This allows
    for a complex object to be used in different situations by different pieces of
    code. Note that, if two or more interfaces define the same method name, their
    defined signatures must be identical, as illustrated by [Example 8-12](#multiple_interface_inheritance).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义可以同时实现多个不同的接口。这允许一个复杂的对象在不同的代码片段中被用于不同的情境。请注意，如果两个或更多接口定义了相同的方法名，则它们定义的签名必须完全相同，正如[Example 8-12](#multiple_interface_inheritance)所示。
- en: Example 8-12\. Implementing multiple interfaces at once
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-12\. 一次实现多个接口
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO8-1)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO8-1)'
- en: As both `A` and `B` define the same method signature, this implementation is
    valid.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`A`和`B`定义了相同的方法签名，因此此实现是有效的。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO8-2)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO8-2)'
- en: Since `A` and `C` define different return types, there is no way, even with
    union types, to define a class that implements both interfaces. Attempting to
    do so causes a fatal error.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`A`和`C`定义了不同的返回类型，即使使用联合类型也无法定义一个同时实现这两个接口的类。试图这样做会导致致命错误。
- en: Remember also that interfaces look somewhat like classes so, like classes, they
    can be extended.^([9](ch08.html#idm45875154877776)) This is done through the same
    `extends` keyword and results in an interface that is a composition of two or
    more interfaces, as demonstrated in [Example 8-13](#composite_interfaces).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，接口看起来有点像类，因此像类一样，它们也可以被扩展。^([9](ch08.html#idm45875154877776)) 这通过相同的`extends`关键字完成，结果是一个由两个或更多接口组成的接口，如[Example 8-13](#composite_interfaces)所示。
- en: Example 8-13\. Composite interfaces
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 8-13\. 复合接口
- en: '[PRE24]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO9-1)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO9-1)'
- en: Any class implementing `A` must define the `foo()` method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现`A`的类必须定义`foo()`方法。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO9-2)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO9-2)'
- en: Any class implementing `B` must implement both `bar()` and `foo()` from `A`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现`B`的类必须从`A`中同时实现`bar()`和`foo()`方法。
- en: See Also
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on [object interfaces](https://oreil.ly/A8hkg).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有关[对象接口](https://oreil.ly/A8hkg)的文档。
- en: 8.8 Creating Abstract Base Classes
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.8 创建抽象基类
- en: Problem
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want a class to implement a specific interface but also want to define some
    other specific functionality.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您想让一个类实现特定的接口，但也想定义一些其他特定的功能。
- en: Solution
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Rather than implementing an interface, define an abstract base class that can
    be extended as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是实现一个接口，定义一个抽象基类可以扩展如下：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO10-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO10-1)'
- en: Prints something like `6ec2aff42d5904e0ccef15536d8548dc`
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 打印类似于`6ec2aff42d5904e0ccef15536d8548dc`的内容。
- en: Discussion
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: An abstract class looks somewhat like an interface and a regular class definition
    smashed together. It has some unimplemented methods living alongside concrete
    implementations. As with an interface, you cannot instantiate an abstract class
    directly—you have to extend it first and implement any abstract methods it defines.
    As with a class, however, you will automatically have access to any public or
    protected members of the base class in the child implementation.^([10](ch08.html#idm45875154437296))
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类看起来有点像接口和常规类定义的结合体。它具有一些未实现的方法和与之相对应的具体实现。与接口一样，您不能直接实例化抽象类——您必须首先扩展它并实现其定义的任何抽象方法。但是，与类一样，在子类实现中，您将自动访问基类的任何公共或受保护成员。^([10](ch08.html#idm45875154437296))
- en: One key difference between interfaces and abstract classes is that the latter
    can bundle properties and method definitions with it. Abstract classes are, in
    fact, classes that are merely incomplete implementations. An interface cannot
    have properties—it merely defines the functional interface with which any implementing
    object must comply.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和抽象类之间的一个关键区别在于后者可以将属性和方法定义捆绑在一起。抽象类实际上是仅部分实现的类。接口不能有属性——它仅定义了任何实现对象必须遵循的功能接口。
- en: Another difference is that you can implement multiple interfaces simultaneously,
    but you can only extend one class at a time. This limitation alone helps characterize
    when you would leverage an abstract base class versus an interface—but you can
    also mix and match both!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区别是您可以同时实现多个接口，但一次只能扩展一个类。这一限制本身有助于确定何时使用抽象基类而不是接口——但您也可以混合使用两者！
- en: 'It’s also possible for an abstract class to define *private* members (which
    are not inherited by any child class) that are otherwise leveraged by accessible
    methods, as illustrated by the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类也可以定义*私有*成员（这些成员不会被任何子类继承），否则这些成员将通过可访问的方法进行操作，如下例所示：
- en: '[PRE26]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO11-1)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO11-1)'
- en: By making your data private, it is only accessible within the context of `A`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使您的数据私有，它只能在`A`的上下文中访问。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO11-2)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO11-2)'
- en: As `::getData()` is itself defined by `A`, the `$data` property is still accessible.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`::getData()`是由`A`定义的，所以`$data`属性仍然是可访问的。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO11-3)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO11-3)'
- en: Though `::viewData()` is defined in the scope of `B`, it is accessing a public
    method from the scope of `A`. No code in `B` would have direct access to `A`’s
    private members.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`::viewData()`在`B`的作用域中定义，但它正在访问`A`的公共方法。`B`中的任何代码都无法直接访问`A`的私有成员。
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO11-4)'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO11-4)'
- en: This will print `this is a secret` to the console.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台打印`this is a secret`。
- en: See Also
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation and discussion of [class abstraction](https://oreil.ly/FMkcT).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[类抽象](https://oreil.ly/FMkcT)的文档和讨论。'
- en: 8.9 Preventing Changes to Classes and Methods
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.9 防止类和方法的更改
- en: Problem
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to prevent anyone from modifying the implementation of your class or
    extending it with a child class.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望阻止任何人修改你的类的实现或者用子类扩展它。
- en: Solution
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `final` keyword to indicate that a class is not extensible, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`final`关键字来指示一个类不可扩展，如下所示：
- en: '[PRE27]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or use the `final` keyword to mark a particular method as unchangeable, as
    follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用`final`关键字标记特定方法为不可更改，如下所示：
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Discussion
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `final` keyword is a way to explicitly *prevent* object extension like the
    mechanisms discussed in the previous two recipes. It’s useful when you want to
    ensure that a specific implementation of a method or an entire class is used throughout
    a codebase.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`final`关键字是显式*阻止*对象扩展的一种方式，类似于前两个示例中讨论的机制。在想要确保方法的特定实现或整个类在整个代码库中被使用时非常有用。'
- en: 'Marking a method as `final` means that any class extensions are incapable of
    overriding that method’s implementation. The following example will throw a fatal
    error due to the `Child` class’s attempt to override a `final` method in the `Base`
    class:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将方法标记为`final`意味着任何类扩展都无法覆盖该方法的实现。以下示例将由于`Child`类尝试覆盖`Base`类中的`final`方法而抛出致命错误：
- en: '[PRE29]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the preceding example, merely omitting the definition of `unsafe()` from
    the child class will allow the code to execute as expected. If, however, you wanted
    to prevent any class from extending the base class, you could add the `final`
    keyword to the class definition itself as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果仅仅从子类中省略了`unsafe()`方法的定义，代码将按预期执行。但是，如果你想要阻止任何类扩展基类，你可以在类定义本身添加`final`关键字，如下所示：
- en: '[PRE30]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The only time you should leverage `final` in your code is when overriding a
    specific method or class implementation will break your application. This is somewhat
    rare in practice but is useful when creating a flexible interface. A specific
    example would be when your application introduces an interface as well as concrete
    implementations of that interface.^([11](ch08.html#idm45875154091840)) Your API
    would then be constructed to accept any valid interface implementation, but you
    might want to prevent subclassing your own concrete implementations (again because
    doing so might break your application). [Example 8-14](#interfaces_and_concrete_classes)
    demonstrates how these dependencies might be constructed in a real application.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中，唯一需要利用`final`的时机是当重写特定方法或类实现会破坏你的应用程序时。这在实践中有些罕见，但在创建灵活接口时非常有用。一个具体的例子是，当你的应用程序引入一个接口及其接口的具体实现时。^([11](ch08.html#idm45875154091840))
    你的 API 将被构建为接受任何有效的接口实现，但你可能希望阻止子类化自己的具体实现（这样做可能会破坏你的应用程序）。[示例 8-14](#interfaces_and_concrete_classes)
    展示了这些依赖项如何在真实应用程序中构建。
- en: Example 8-14\. Interfaces and concrete classes
  id: totrans-268
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-14\. 接口和具体类
- en: '[PRE31]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO12-1)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO12-1)'
- en: The application describes an interface that any data abstraction layer must
    implement.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序描述了任何数据抽象层必须实现的接口。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO12-2)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO12-2)'
- en: One concrete implementation stores data explicitly in a database.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的一个实现将数据显式存储在数据库中。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO12-3)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO12-3)'
- en: Another implementation uses flat files for data storage.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式是使用平面文件进行数据存储。
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO12-4)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO12-4)'
- en: The application doesn’t care what implementation you use so long as it implements
    the base interface. You can use either the provided (`final`) classes or define
    your own implementation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序不关心你使用哪种实现，只要它实现了基础接口。你可以使用提供的（`final`）类，也可以定义自己的实现方式。
- en: In some situations, you might come across a `final` class you need to extend
    anyway. In those cases, the only means at your disposal are to leverage a decorator.
    A *decorator* is a class that takes another class as a constructor property and
    “decorates” its methods with additional functionality.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能会遇到需要扩展的`final`类。在这种情况下，你唯一可以使用的方式是利用装饰器。*装饰器*是一个以另一个类作为构造函数属性并“装饰”其方法的类。
- en: Note
  id: totrans-279
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In some circumstances, decorators will not allow you to sidestep the `final`
    nature of a class. This happens if type hinting and strict typing require an instance
    of that exact class be passed to a function or another object within the application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，装饰器不允许你绕过类的`final`属性。如果类型提示和严格类型要求将该类的实例传递给应用程序中的函数或另一个对象，则会发生这种情况。
- en: Assume, for example, that a library in your application defines a `Note` class
    that implements a `::publish()` method that publishes a given piece of data to
    social media (say, Twitter). You want this method to *also* produce a static PDF
    artifact of the given data and would normally extend the class itself, as shown
    in [Example 8-15](#final_extending_regular_class).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你的应用程序中的一个库定义了一个 `Note` 类，该类实现了一个 `::publish()` 方法，用于将给定的数据发布到社交媒体（比如
    Twitter）。你希望这个方法*同时*生成给定数据的静态 PDF 文档，通常会扩展该类本身，就像在 [示例 8-15](#final_extending_regular_class)
    中所示。
- en: Example 8-15\. Typical class extension without the `final` keyword
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-15\. 典型的类扩展，没有使用`final`关键字
- en: '[PRE32]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO13-1)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO13-1)'
- en: Rather than instantiating a `Note` object, you can instantiate a `StaticNote`
    directly.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是实例化`Note`对象，你可以直接实例化`StaticNote`。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO13-2)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO13-2)'
- en: When you call the object’s `::publish()` method, *both* class definitions are
    used.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用对象的 `::publish()` 方法时，*同时*使用了这两个类定义。
- en: If the `Note` class is instead `final`, you will be unable to extend the class
    directly. [Example 8-16](#final_decorating_class) demonstrates how a new class
    can be created that *decorates* the `Note` class and indirectly extends its functionality.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Note`类被标记为`final`，你将无法直接扩展该类。[示例 8-16](#final_decorating_class)演示了如何创建一个新的类，*装饰*`Note`类并间接扩展其功能。
- en: Example 8-16\. Customizing hte behavior of a `final` class with a decorator
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-16\. 使用装饰器自定义`final`类的行为
- en: '[PRE33]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO14-1)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO14-1)'
- en: Rather than instantiating `StaticNote` directly, you use this class to *wrap*
    (or *decorate*) a regular `Note` instance.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接实例化`StaticNote`，你可以使用这个类来*包装*（或*装饰*）一个常规的`Note`实例。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO14-2)'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO14-2)'
- en: When you call the object’s `::publish()` method, *both* class definitions are
    used.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用对象的`::publish()`方法时，*两个*类定义都被使用。
- en: See Also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on the [`final` keyword](https://oreil.ly/k2ZGz).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[`final` 关键字的文档](https://oreil.ly/k2ZGz)。'
- en: 8.10 Cloning Objects
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.10 对象克隆
- en: Problem
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a distinct copy of an object.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 想要创建一个对象的独立副本。
- en: Solution
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `clone` keyword to create a second copy of the object—for example:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`clone`关键字创建对象的第二个副本，例如：
- en: '[PRE34]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Discussion
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: By default, PHP will copy objects *by reference* when assigned to a new variable.
    This reference means the new variable literally points to the same object in memory.
    [Example 8-17](#obj_copy_by_reference) illustrates how, even though it might appear
    that you’ve created a copy of an object, you’re really dealing with just two references
    to the same data.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当对象分配给新变量时，PHP会*通过引用*复制对象。这个引用意味着新变量实际上指向内存中的同一对象。[示例 8-17](#obj_copy_by_reference)说明了，尽管看起来你创建了对象的副本，但实际上只是处理了两个对同一数据的引用。
- en: Example 8-17\. The assignment operator copies an object by reference
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-17\. 赋值操作符通过引用复制对象
- en: '[PRE35]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO15-1)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO15-1)'
- en: This particular syntax is shorthand, valid as of PHP 5.4, that dynamically converts
    a new associative array to an instance of the built-in `stdClass` class.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此特定语法是 PHP 5.4 以来的简写，可以动态将新的关联数组转换为内置的`stdClass`类的实例。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO15-2)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO15-2)'
- en: Attempt to copy the first object to a new instance by using the assignment operator.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试通过赋值操作符将第一个对象复制到一个新实例。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO15-3)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO15-3)'
- en: Make a change to the internal state of the “copied” object.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 修改“复制”的对象的内部状态。
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO15-4)'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO15-4)'
- en: Inspecting the original object shows that its internal state has changed. Both
    `$obj1` and `$obj2` point to the same space in memory; you merely copied a reference
    to the object, not the object itself!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 检查原始对象显示其内部状态已更改。`$obj1`和`$obj2`都指向内存中的同一空间；你只是复制了对象的引用，而不是对象本身！
- en: Rather than copy an object reference, the `clone` keyword copies an object to
    a new variable *by value*. This means all of the properties are copied to a new
    instance of the same class that has all of the methods of the original object
    as well. [Example 8-18](#obj_copy_by_value) illustrates how the two objects are
    now entirely decoupled.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是复制对象引用，`clone` 关键字通过值将对象复制到新变量中。这意味着所有属性都复制到同一类的新实例中，并具有原始对象的所有方法。[示例 8-18](#obj_copy_by_value)说明了这两个对象现在完全解耦。
- en: Example 8-18\. The `clone` keyword copies an object by value
  id: totrans-316
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-18\. `clone` 关键字通过值复制对象
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO16-1)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO16-1)'
- en: Rather than use strict assignment, leverage the `clone` keyword to create a
    by-value copy of the object.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用严格的赋值，利用`clone`关键字创建对象的按值副本。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO16-2)'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO16-2)'
- en: Again make a change to the internal state of the copy.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 再次更改副本的内部状态。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO16-3)'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO16-3)'
- en: Inspecting the state of the original object shows no changes.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 检查原始对象的状态显示没有变化。
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO16-4)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO16-4)'
- en: The cloned and changed object, however, illustrates the property modification
    made earlier.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，克隆并更改的对象展示了之前进行的属性修改。
- en: An important caveat here is to understand that, as used in the preceding examples,
    `clone` is a *shallow clone* of the data. The operation does not traverse down
    into more complex properties like nested objects. Even with proper `clone` usage,
    it is possible to be left with two different variables referencing the same object
    in memory. [Example 8-19](#obj_nested_clone_reference) illustrates what happens
    if the object to be copied contains a more complex object itself.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要注意事项是要理解，在前面的示例中使用的`clone`是数据的*浅克隆*。此操作不会深入到像嵌套对象这样的更复杂属性中。即使使用适当的`clone`，可能仍然会留下两个不同的变量引用同一个内存中的对象。[示例 8-19](#obj_nested_clone_reference)说明了如果要复制的对象本身包含一个更复杂的对象会发生什么。
- en: Example 8-19\. Shallow clones of complex data structures
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-19\. 复杂数据结构的浅克隆
- en: '[PRE37]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO17-1)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO17-1)'
- en: When comparing objects, strict comparison only resolves as `true` when the statements
    on either side of the comparison reference the same object. In this case, you’ve
    properly cloned your object and created an entirely new instance, so this comparison
    is `false`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在比较对象时，严格比较只有在比较符号两侧引用同一个对象时才评估为`true`。在这种情况下，您已经正确克隆了对象并创建了一个全新的实例，因此这个比较是`false`。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO17-2)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO17-2)'
- en: Loose type comparison between objects resolves as `true` when the *values* on
    either side of the operator are the same, even between discrete instances. This
    statement evaluates to `true`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象之间进行宽松类型比较时，当操作符两侧的*值*相同时，即使是不同的实例，也会评估为`true`。这个语句评估为`true`。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO17-3)'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO17-3)'
- en: Since `clone` is a shallow operation, the `::$child` property on both of your
    objects points to the same child object in memory. This statement evaluates to
    `true`!
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`clone`是一种浅操作，所以在两个对象上的`::$child`属性指向内存中相同的子对象。这个语句评估为`true`！
- en: To support a deeper clone, the class being cloned must implement a `__clone()`
    magic method that tells PHP what to do when leveraging `clone`. If this method
    exists, PHP will invoke it automatically when closing an instance of the class.
    [Example 8-20](#obj_nested_deep_clone) shows exactly how this might work while
    still working with dynamic classes.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要支持更深层次的克隆，被克隆的类必须实现一个`__clone()`魔术方法，告诉PHP在使用`clone`时该做什么。如果这个方法存在，PHP会在关闭类的实例时自动调用它。[示例 8-20](#obj_nested_deep_clone)
    明确展示了这个过程，同时还在处理动态类。
- en: Note
  id: totrans-336
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is not possible to dynamically define methods on instances of `stdClass`.
    If you want to support deep cloning of objects in your application, you must either
    define a class directly or leverage an anonymous class, as illustrated by [Example 8-20](#obj_nested_deep_clone).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 不能动态地在`stdClass`的实例上定义方法。如果您希望在应用程序中支持对象的深度克隆，必须直接定义一个类或利用匿名类，就像[示例 8-20](#obj_nested_deep_clone)所演示的那样。
- en: Example 8-20\. Deep cloning of objects
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-20\. 对象的深度克隆
- en: '[PRE38]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_chapter_title_CO1-1)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_chapter_title_CO1-1)'
- en: The objects are different references; therefore, this evaluates to `false`.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象是不同的引用，因此评估为`false`。
- en: '[![2](assets/2.png)](#co_chapter_title_CO1-2)'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_chapter_title_CO1-2)'
- en: The parent and clone objects have the same data, so this evaluates to `true`.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 父对象和克隆对象具有相同的数据，因此这评估为`true`。
- en: '[![3](assets/3.png)](#co_chapter_title_CO1-3)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_chapter_title_CO1-3)'
- en: The `::$child` properties were also cloned internally, so the properties reference
    different object instances. This evaluates to `false`.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`::$child`属性也被内部克隆了，因此属性引用了不同的对象实例。这评估为`false`。'
- en: '[![4](assets/4.png)](#co_chapter_title_CO1-4)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_chapter_title_CO1-4)'
- en: Both `::$child` properties contain the same data, so this evaluates to `true`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`::$child`属性包含相同的数据，因此这评估为`true`。
- en: In most applications, you will generally be working with custom class definitions
    and not anonymous classes. In that case, you can still implement the magic `__clone()`
    method to instruct PHP on how to clone the more complex properties of your object
    where necessary.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序中，您通常会使用自定义类定义，而不是匿名类。在这种情况下，您仍然可以实现魔术`__clone()`方法，在必要时告诉PHP如何克隆对象的更复杂属性。
- en: See Also
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on the [`clone` keyword](https://oreil.ly/LqOE2).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`clone`关键字](https://oreil.ly/LqOE2)的文档。
- en: 8.11 Defining Static Properties and Methods
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.11 定义静态属性和方法
- en: Problem
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to define a method or property on a class that is available to all
    instances of that class.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望为一个类定义一个方法或属性，这些方法或属性对该类的所有实例都可用。
- en: Solution
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `static` keyword to define properties or methods that can be accessed
    outside an object instance—for example:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static`关键字来定义可以在对象实例外部访问的属性或方法，例如：
- en: '[PRE39]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Discussion
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Static members of a class are accessible to any part of your code (assuming
    proper levels of visibility) directly from the class definition, whether or not
    an instance of that class exists as an object. Static properties are useful since
    they behave more or less like global variables but are scoped to a specific class
    definition. [Example 8-21](#static_properties_vs_globals) illustrates the difference
    in invoking a global variable versus a static class property in another function.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 类的静态成员可以在代码的任何部分（假设可见性正确）直接从类定义中访问，而不管该类是否作为对象存在。静态属性非常有用，因为它们的行为几乎类似于全局变量，但作用域仅限于特定的类定义。[Example 8-21](#static_properties_vs_globals)说明了在另一个函数中调用全局变量与静态类属性的区别。
- en: Example 8-21\. Static properties versus global variables
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-21\. 静态属性与全局变量
- en: '[PRE40]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO18-1)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO18-1)'
- en: To access a global variable within another scope, you must explicitly refer
    to the global scope. Given that you can have separate variables in a narrower
    scope that match the names of global variables, this can become potentially confusing
    in practice.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 要在另一个作用域内访问全局变量，必须显式引用全局作用域。鉴于您可以在较窄的作用域内拥有与全局变量名称匹配的单独变量，这在实践中可能会变得令人困惑。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO18-2)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO18-2)'
- en: A class-scoped property, however, can be accessed directly based on the name
    of the class itself.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，类范围的属性可以根据类本身的名称直接访问。
- en: More usefully, static methods provide ways to invoke utility functionality bound
    to a class prior to instantiating an object of that class directly. One common
    example is when constructing value objects that should represent serialized data
    where it would be difficult to construct an object from scratch directly.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 更有用的是，静态方法提供了在直接实例化该类对象之前调用与类绑定的实用功能的方法。一个常见的例子是构造应该表示序列化数据的值对象，在这种情况下，直接从头开始构造对象可能会很困难。
- en: '[Example 8-22](#static_method_instantiation) demonstrates a class that does
    not allow for direct instantiation. Instead, you must create an instance by unserializing
    some fixed data. The constructor is inaccessible outside of the class’s interior
    scope, so a static method is the only means of creating an object.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 8-22](#static_method_instantiation)演示了一个不允许直接实例化的类。相反，您必须通过反序列化一些固定数据来创建一个实例。构造函数在类的内部作用域之外是不可访问的，因此静态方法是创建对象的唯一手段。'
- en: Example 8-22\. Static method object instantiation
  id: totrans-367
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-22\. 静态方法中的对象实例化
- en: '[PRE41]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO19-1)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO19-1)'
- en: A private constructor can be accessed only from within the class itself.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 私有构造函数只能从类本身内部访问。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO19-2)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO19-2)'
- en: Within a static method, you can still create a new object instance by leveraging
    the special `self` keyword to refer to the class. This permits you to access your
    private constructor.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态方法中，您仍然可以通过利用特殊的`self`关键字来引用类，从而创建一个新的对象实例。这允许您访问私有构造函数。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO19-3)'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO19-3)'
- en: The magic `__toString()` method is invoked whenever PHP tries to coerce an object
    into a string directly (i.e., when you try to `echo` it to the console).
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的神奇`__toString()`方法在 PHP 尝试直接将对象强制转换为字符串时调用（例如，当您尝试将其`echo`到控制台时）。
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO19-4)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO19-4)'
- en: Rather than creating an object with the `new` keyword, leverage a purpose-built
    static deserialization method.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 与其使用`new`关键字创建对象，不如利用一个专门的静态反序列化方法。
- en: Both static methods and properties are subject to the same visibility constraints
    as their nonstatic peers. Note that marking either as `private` means they can
    only be referenced by one another or by nonstatic methods within the class itself.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法和属性与它们的非静态同行一样受到可见性约束。请注意，将它们标记为`private`意味着它们只能被彼此或类本身内部的非静态方法引用。
- en: As static methods and properties aren’t tied directly to an object instance,
    you can’t use regular object-bound accessors to reach them. Instead, leverage
    the class name directly and the scope resolution operator (a double colon, or
    `::`)—for example, `Foo::$bar` for properties or `Foo::bar()` for methods. Within
    the class definition itself, you can leverage `self` as a shorthand for the class
    name or `parent` as a shorthand for the parent class name (if using inheritance).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 由于静态方法和属性并不直接绑定到对象实例，因此无法使用常规的对象绑定访问器来访问它们。而是直接使用类名和作用域解析操作符（双冒号，或`::`）——例如，对于属性可以使用`Foo::$bar`，对于方法可以使用`Foo::bar()`。在类定义内部，您可以使用`self`作为类名的简写，或者使用`parent`作为父类名的简写（如果使用继承）。
- en: Note
  id: totrans-379
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you have access to an object instance of the class, you can use that object’s
    name rather than the class name to access its static members as well. For example,
    you can use `$foo::bar()` to access the static `bar()` method on the class definition
    for the object named `$foo`. While this works, it can make it more difficult for
    other developers to understand what class definition you’re working with, so this
    syntax should be used sparingly if at all.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以访问类的对象实例，您可以使用该对象的名称而不是类名来访问其静态成员。例如，您可以使用`$foo::bar()`来访问命名为`$foo`的对象的类定义中的静态方法`bar()`。虽然这样可以工作，但可能会让其他开发人员更难理解您正在使用哪个类定义，因此如果可能的话，应该尽量少使用这种语法。
- en: See Also
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Documentation on the [`static` keyword](https://oreil.ly/tlxjn).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[`static` 关键字](https://oreil.ly/tlxjn)的文档。'
- en: 8.12 Introspecting Private Properties or Methods Within an Object
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.12 检查对象内部的私有属性或方法
- en: Problem
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to enumerate the properties or methods of an object and leverage its
    private members.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望枚举对象的属性或方法，并利用其私有成员。
- en: Solution
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use PHP’s Reflection API to enumerate properties and methods. For example:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PHP 的反射 API 枚举属性和方法。例如：
- en: '[PRE42]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Discussion
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP’s Reflection API grants developers vast power to inspect all elements of
    their application. You can enumerate methods, properties, constants, function
    arguments, and more. You can also ignore the privacy afforded to each at will
    and directly invoke private methods on objects. [Example 8-23](#reflection_privacy)
    illustrates how an explicitly private method can be invoked directly with the
    Reflection API.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的反射 API 赋予开发人员检查应用程序所有元素的强大能力。您可以枚举方法、属性、常量、函数参数等等。您还可以随意忽略每个元素的隐私性，并直接调用对象上的私有方法。[示例 8-23](#reflection_privacy)
    演示了如何使用反射 API 直接调用显式私有方法。
- en: Example 8-23\. Using Reflection to violate class privacy
  id: totrans-391
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 8-23\. 使用反射违反类的私有性
- en: '[PRE43]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO20-1)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO20-1)'
- en: The example class has a single, private property to maintain an internal counter.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 示例类具有单个私有属性，用于维护内部计数器。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO20-2)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO20-2)'
- en: You want to increment the counter a bit past its default. Now it’s `1`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将计数器增加到稍超过其默认值。现在它是`1`。
- en: '[![3](assets/3.png)](#co_classes_and_objects_CO20-5)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_classes_and_objects_CO20-5)'
- en: An additional increment sets the counter to `2`.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个增量将计数器设置为`2`。
- en: '[![4](assets/4.png)](#co_classes_and_objects_CO20-6)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_classes_and_objects_CO20-6)'
- en: At this point, printing out the counter’s state will confirm it’s `2`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，打印出计数器的状态将确认它是`2`。
- en: '[![5](assets/5.png)](#co_classes_and_objects_CO20-7)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_classes_and_objects_CO20-7)'
- en: Attempting to interact with the counter *directly* will result in a thrown `Error`,
    as the property is private.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试直接与计数器进行交互将导致抛出`Error`，因为该属性是私有的。
- en: '[![6](assets/6.png)](#co_classes_and_objects_CO20-8)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_classes_and_objects_CO20-8)'
- en: Through reflection, you can interact with object members regardless of their
    privacy setting.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 通过反射，您可以与对象成员进行交互，而不受其隐私设置的限制。
- en: '[![7](assets/7.png)](#co_classes_and_objects_CO20-9)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[![7](assets/7.png)](#co_classes_and_objects_CO20-9)'
- en: Now you demonstrate the counter was truly reset to `0`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您展示计数器确实已重置为`0`。
- en: Reflection is a truly powerful way to get around visibility modifiers in the
    API exposed by a class. However, its use in a production application likely points
    to a poorly constructed interface or system. If your code needs access to a private
    member of a class, either that member should be public to begin with or you need
    to create an appropriate accessor method.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Reflection 是绕过类公开 API 中可见性修饰符的强大方式。然而，在生产应用程序中使用它很可能表明接口或系统设计不当。如果您的代码需要访问类的私有成员，要么该成员应该从一开始就是公开的，要么您需要创建一个适当的访问器方法。
- en: The only legitimate use of Reflection is in inspecting and modifying the internal
    state of an object. In an application, this behavior should be limited to the
    class’s exposed API. In *testing*, however, it might be necessary to modify an
    object’s state between test runs in ways the API doesn’t support during regular
    operation.^([12](ch08.html#idm45875152569072)) Those rare circumstances might
    require resetting internal counters or invoking otherwise private cleanup methods
    housed within the class. It’s then that Reflection proves its utility.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: Reflection 的唯一合法用途是检查和修改对象的内部状态。在应用程序中，此行为应限制于类的公开 API。然而，在*测试*中，可能需要以 API 不支持的方式在测试运行之间修改对象的状态。[^12](ch08.html#idm45875152569072)
    这些罕见情况可能需要重置内部计数器或调用类中私有清理方法。Reflection 在这时显得非常有用。
- en: In regular application development, though, Reflection paired with functional
    calls like [`var_dump()`](https://oreil.ly/HXVwr) helps to disambiguate the internal
    operation of classes defined in imported vendor code. It might prove useful to
    introspect serialized objects or third-party integrations, but take care not to
    ship this kind of introspection to production.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在常规应用程序开发中，Reflection 结合像 [`var_dump()`](https://oreil.ly/HXVwr) 这样的功能调用有助于澄清导入供应商代码中定义的类的内部操作。它可能对检查序列化对象或第三方集成有用，但要注意不要将这种内省应用到生产环境中。
- en: See Also
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Overview of PHP’s [Reflection API](https://oreil.ly/C49RP).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的 [Reflection API 概述](https://oreil.ly/C49RP)。
- en: 8.13 Reusing Arbitrary Code Between Classes
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.13 在类之间重用任意代码
- en: Problem
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to share a particular piece of functionality between multiple classes
    without leveraging a class extension.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在多个类之间共享特定功能而不是利用类扩展。
- en: Solution
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Import a Trait with a `use` statement—for example:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `use` 语句导入 Trait，例如：
- en: '[PRE44]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO21-1)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO21-1)'
- en: The `Account` class imports the logging functionality from your `Logger` trait
    and can use its methods as if they were native to its own definition.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`Account` 类从您的 `Logger` 特性导入日志记录功能，并可以像其本身定义的原生方法一样使用其方法。'
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO21-2)'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO21-2)'
- en: Likewise, the `User` class has native-level access to `Logger`’s methods, even
    though it extends a base `Person` class with additional functionality.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`User` 类可以本地级别访问 `Logger` 的方法，即使它扩展了一个带有附加功能的基础 `Person` 类。
- en: Discussion
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: As discussed in [Recipe 8.6](#class_inheritance), a class in PHP can descend
    from at most one other class. This is referred to as *single inheritance* and
    is a characteristic of languages other than PHP as well. Luckily, PHP exposes
    an additional mechanism for code reuse called *Traits*. Traits allow for the encapsulation
    of some functionality in a separate class-like definition that can be easily imported
    without breaking single inheritance.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [8.6 节](#class_inheritance) 中所讨论的，PHP 中的类最多可以从一个其他类继承。这被称为*单继承*，也是除 PHP 外其他语言的特征。幸运的是，PHP
    还提供了一种称为*Traits* 的代码重用机制。Traits 允许在单独的类似定义中封装某些功能，可以轻松导入而不会破坏单继承。
- en: A Trait looks somewhat like a class but cannot be instantiated directly. Instead,
    the methods defined by a Trait are imported into another class definition by the
    `use` statement. This permits code reuse between classes that do not share an
    inheritance tree.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: Trait 看起来有点像类，但不能直接实例化。相反，Trait 定义的方法通过 `use` 语句导入到另一个类定义中。这允许在不共享继承树的类之间进行代码重用。
- en: Traits empower you to define common methods (with differing method visibility)
    and properties that are shared between definitions. You can also override the
    default visibility from a Trait in the class that imports it. [Example 8-24](#trait_visibility_override)
    shows how an otherwise public method defined in a Trait can be imported as a protected
    or even private method in another class.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 特性使您能够定义共享的常见方法（具有不同的方法可见性）和属性。您还可以在导入特性的类中覆盖特性中的默认可见性。[示例8-24](#trait_visibility_override)展示了如何将特性中原本为公共方法的方法导入为受保护甚至私有方法的方法。
- en: Example 8-24\. Overriding the visibility of methods defined in a Trait
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-24\. 覆盖特性中方法的可见性
- en: '[PRE45]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[![1](assets/1.png)](#co_classes_and_objects_CO22-1)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_classes_and_objects_CO22-1)'
- en: This syntax will import every method defined in `Foo` but will explicitly make
    its `::bar()` method protected within the scope of class `A`. This means only
    instances of class `A` (or its descendants) will be able to invoke the method.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 此语法将导入`Foo`中定义的每个方法，但会在类`A`的范围内显式地将其`::bar()`方法设为受保护。这意味着只有类`A`（或其子类）的实例才能调用该方法。
- en: '[![2](assets/2.png)](#co_classes_and_objects_CO22-2)'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_classes_and_objects_CO22-2)'
- en: Likewise, class `B` changes the visibility of its imported `::foo()` method
    to private so only instances of `B` can access that method directly.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，类`B`将其导入的`::foo()`方法的可见性更改为私有，因此只有`B`的实例可以直接访问该方法。
- en: Traits can be composed together as deeply as you want, meaning a Trait can `use`
    another Trait just as easily as a class can. Likewise, there is no limit to the
    number of Traits that can be imported either by other Traits or by class definitions.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 特性可以深度组合在一起，这意味着特性可以像类一样轻松地`use`另一个特性。同样，导入特性的数量没有限制，可以由其他特性或类定义导入。
- en: If the class importing a Trait (or multiple Traits) defines a method also named
    in the Trait, then the class’s version takes precedence and is used by default.
    [Example 8-25](#trait_precedence) illustrates how this precedence works by default.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果导入特性（或多个特性）的类也定义了与特性中同名的方法，则类的版本将优先使用，并成为默认的方法。[示例8-25](#trait_precedence)说明了这种优先级是如何默认工作的。
- en: Example 8-25\. Method precedence in Traits
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例8-25\. 特性中方法的优先级
- en: '[PRE46]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In some circumstances, you might import multiple Traits that all define the
    same method. In those situations, you can explicitly identify which version of
    a method you want to leverage in your final class when you define your `use` statement
    as follows:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能会导入多个特性，它们都定义了相同的方法。在这些情况下，您可以在定义`use`语句时明确指定要在最终类中利用的方法版本，如下所示：
- en: '[PRE47]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Like class definitions, Traits can also define properties or even static members.
    They provide an efficient means by which you can abstract operational logic definitions
    into reusable code blocks and share that logic between classes in your application.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 与类定义类似，特性（Traits）也可以定义属性甚至静态成员。它们为您提供了一种有效的方式，将操作逻辑定义为可重用的代码块，并在应用程序中的类之间共享该逻辑。
- en: See Also
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Documentation on [Traits](https://oreil.ly/syk0E).
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 有关[特性](https://oreil.ly/syk0E)的文档
- en: ^([1](ch08.html#idm45875158208880-marker)) PHP 3 included some primitive object
    functionality, but the language wasn’t really considered object-oriented by most
    developers until the delivery of 4.0.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch08.html#idm45875158208880-marker)) PHP 3包含了一些原始的对象功能，但直到4.0的发布之前，大多数开发人员并没有真正将该语言视为面向对象的语言。
- en: ^([2](ch08.html#idm45875157813808-marker)) At the time of this writing, WordPress
    was used to power [43% of all websites](https://oreil.ly/tEaN8).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch08.html#idm45875157813808-marker)) 在撰写本文时，WordPress用于驱动[所有网站的43%](https://oreil.ly/tEaN8)。
- en: ^([3](ch08.html#idm45875157805424-marker)) Libraries and extensions are discussed
    at length in [Chapter 15](ch15.html#chapter_extensions).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch08.html#idm45875157805424-marker)) 长篇章节中详细讨论了库和扩展功能，请参见[第15章](ch15.html#chapter_extensions)。
- en: ^([4](ch08.html#idm45875157792800-marker)) See [Recipe 8.12](#classes_reflection)
    for more on the Reflection API.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ^([4](ch08.html#idm45875157792800-marker)) 详见[配方8.12](#classes_reflection)，了解有关反射API的更多信息。
- en: ^([5](ch08.html#idm45875157450624-marker)) Review [“Visibility”](#property_and_method_visibility)
    for more background on visibility within classes.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: ^([5](ch08.html#idm45875157450624-marker)) 回顾[“可见性”](#property_and_method_visibility)，以获取有关类内可见性的更多背景信息。
- en: ^([6](ch08.html#idm45875157386544-marker)) See [Recipe 8.3](#read_only_properties)
    for details on how these properties could further be made read-only.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: ^([6](ch08.html#idm45875157386544-marker)) 详见[配方8.3](#read_only_properties)，了解如何进一步将这些属性设置为只读。
- en: ^([7](ch08.html#idm45875156595712-marker)) See [Recipe 3.4](ch03.html#argument_and_return_typing)
    for more on strict type enforcement.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: ^([7](ch08.html#idm45875156595712-marker)) 想要了解更多关于严格类型强制的内容，请参阅[Recipe 3.4](ch03.html#argument_and_return_typing)。
- en: ^([8](ch08.html#idm45875155649632-marker)) For more on property and method visibility,
    review [“Visibility”](#property_and_method_visibility).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: ^([8](ch08.html#idm45875155649632-marker)) 关于属性和方法可见性的更多信息，请查看[“可见性”](#property_and_method_visibility)。
- en: ^([9](ch08.html#idm45875154877776-marker)) Review [Recipe 8.6](#class_inheritance)
    for more on class inheritance and extension.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ^([9](ch08.html#idm45875154877776-marker)) 想要了解更多关于类继承和扩展的内容，请参阅[Recipe 8.6](#class_inheritance)。
- en: ^([10](ch08.html#idm45875154437296-marker)) See [Recipe 8.6](#class_inheritance)
    for more on class inheritance.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ^([10](ch08.html#idm45875154437296-marker)) 想要了解更多关于类继承的内容，请参阅[Recipe 8.6](#class_inheritance)。
- en: ^([11](ch08.html#idm45875154091840-marker)) See [Recipe 8.7](#class_interfaces)
    for more on interfaces.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: ^([11](ch08.html#idm45875154091840-marker)) 想要了解更多关于接口的内容，请查看[Recipe 8.7](#class_interfaces)。
- en: ^([12](ch08.html#idm45875152569072-marker)) Both testing and debugging are discussed
    at length in [Chapter 13](ch13.html#chapter_debugging).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: ^([12](ch08.html#idm45875152569072-marker)) 测试和调试内容详细讨论见[第13章](ch13.html#chapter_debugging)。
