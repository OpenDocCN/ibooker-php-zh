- en: Chapter 5\. Databases and Eloquent
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章\. 数据库和 Eloquent
- en: Laravel provides a suite of tools for interacting with your application’s databases,
    the most notable of which is Eloquent, Laravel’s ActiveRecord ORM.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 提供了一套工具来与你的应用程序数据库进行交互，其中最显著的是 Eloquent，Laravel 的 ActiveRecord ORM。
- en: Eloquent is one of Laravel’s most popular and influential features. It’s a great
    example of how Laravel is different from the majority of PHP frameworks; in a
    world of DataMapper ORMs that are powerful but complex, Eloquent stands out for
    its simplicity. There’s one class per table, which is responsible for retrieving,
    representing, and persisting data in that table.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 是 Laravel 最受欢迎和有影响力的功能之一。它是 Laravel 与大多数 PHP 框架不同之处的一个很好的例子；在强大但复杂的
    DataMapper ORM 的世界中，Eloquent 因其简洁而脱颖而出。每个表格对应一个类，负责在该表格中检索、表示和持久化数据。
- en: 'Whether or not you choose to use Eloquent, you’ll still get a ton of benefit
    from the other database tools Laravel provides. So before we dig into Eloquent,
    we’ll start by covering the basics of Laravel’s database functionality: migrations,
    seeders, and the query builder.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择使用 Eloquent 与否，你仍然会从 Laravel 提供的其他数据库工具中获得很多好处。因此，在深入研究 Eloquent 之前，我们将首先介绍
    Laravel 数据库功能的基础：迁移、填充器和查询构建器。
- en: 'Then we’ll cover Eloquent: defining your models; inserting, updating, and deleting;
    customizing your responses with accessors, mutators, and attribute casting; and,
    finally, relationships. There’s a lot going on here, and it’s easy to get overwhelmed,
    but if we take it one step at a time, we’ll make it through.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将涵盖 Eloquent：定义你的模型；插入、更新和删除；使用访问器、修改器和属性转换自定义你的响应；最后是关系。这里涉及很多内容，很容易感到不知所措，但如果我们一步一个脚印地进行，我们一定能够成功。
- en: Configuration
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置
- en: Before we get into how to use Laravel’s database tools, let’s pause for a second
    and go over how to configure your database credentials and connections.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入了解 Laravel 的数据库工具如何使用之前，让我们暂停片刻，回顾一下如何配置你的数据库凭据和连接。
- en: The configuration for database access lives in *config/database.php* and *.env*.
    Like many other configuration areas in Laravel, you can define multiple “connections”
    and then decide which the code will use by default.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库访问的配置位于 *config/database.php* 和 *.env* 中。像 Laravel 的许多其他配置区域一样，你可以定义多个“连接”，然后决定代码默认使用哪一个。
- en: Database Connections
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库连接
- en: By default, there’s one connection for each of the drivers, as you can see in
    [Example 5-1](#EX801).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个驱动程序都有一个连接，如你可以在 [示例 5-1](#EX801) 中看到的。
- en: Example 5-1\. The default database connections list
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-1\. 默认的数据库连接列表
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Nothing is stopping you from deleting or modifying these named connections or
    creating your own. You can create new named connections, and you’ll be able to
    set the drivers (MySQL, PostgreSL, etc.) in them. So although there’s one connection
    per driver by default, that’s not a constraint; you could have five different
    connections, all with the `mysql` driver, if you wanted.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么能阻止你删除或修改这些命名连接或创建自己的连接。你可以创建新的命名连接，并且可以在其中设置驱动程序（MySQL、PostgreSQL 等）。因此，尽管默认情况下每个驱动程序只有一个连接，但这并不是限制；如果你愿意，你可以拥有五个不同的连接，都使用
    `mysql` 驱动程序。
- en: Each connection allows you to define the properties necessary for connecting
    to and customizing each connection type.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接都允许你定义连接到和定制每种连接类型所需的属性。
- en: There are a few reasons for the idea of multiple drivers. To start with, the
    “connections” section as it comes out of the box is a simple template that makes
    it easy to start apps that use any of the supported database connection types.
    In many apps, you can pick the database connection you’ll be using, fill out its
    information, and even delete the others if you’d like. I usually just keep them
    all there, in case I might eventually use them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多驱动程序的想法有几个原因。首先，“连接”部分是一个简单的模板，使得启动使用任何支持的数据库连接类型的应用程序变得简单。在许多应用程序中，你可以选择你将使用的数据库连接，填写它的信息，甚至如果愿意，删除其他的连接。我通常会把它们都保留在那里，以防以后可能会用到它们。
- en: But there are also some cases where you might need multiple connections within
    the same application. For example, you might use different database connections
    for two different types of data, or you might read from one and write to another.
    Support for multiple connections makes this possible.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有一些情况下，你可能需要在同一个应用程序中使用多个连接。例如，你可能会为两种不同类型的数据使用不同的数据库连接，或者你可能会从一个数据库读取并向另一个数据库写入。支持多连接使这成为可能。
- en: URL Configurations
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URL 配置
- en: 'Often services like Heroku will provide an environment variable with a URL
    that contains all of the information you need to connect to the database. It’ll
    look something like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Heroku 这样的服务通常会提供一个环境变量，其中包含连接到数据库所需的所有信息。它看起来像这样：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You don’t have to write code to parse this URL out; instead, pass it in as the
    `DATABASE_URL` environment variable, and Laravel will understand it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您无需编写代码来解析此 URL；相反，将其作为 `DATABASE_URL` 环境变量传递给 Laravel，它将理解它。
- en: Other Database Configuration Options
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他数据库配置选项
- en: The *config/database.php* configuration section has quite a few other configuration
    settings. You can configure Redis access, customize the table name used for migrations,
    determine the default connection, and toggle whether non-Eloquent calls return
    `stdClass` or array instances.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*config/database.php* 配置部分有许多其他配置设置。您可以配置 Redis 访问、自定义迁移表名称、确定默认连接，并切换非 Eloquent
    调用返回 `stdClass` 或数组实例。'
- en: 'With any service in Laravel that allows connections from multiple sources—sessions
    can be backed by the database or file storage, the cache can use Redis or Memcached,
    databases can use MySQL or PostgreSQL—you can define multiple connections and
    also choose that a particular connection will be the “default,” meaning it will
    be used any time you don’t explicitly ask for a particular connection. Here’s
    how you ask for a specific connection, if you want to:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Laravel 中，任何允许来自多个源的连接的服务 —— 会话可以由数据库或文件存储支持，缓存可以使用 Redis 或 Memcached，数据库可以使用
    MySQL 或 PostgreSQL —— 您可以定义多个连接，并选择特定连接将成为“默认”连接，这意味着任何时候不显式请求特定连接时将使用该连接。以下是如何请求特定连接的示例：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Migrations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移
- en: Modern frameworks like Laravel make it easy to define your database structure
    with code-driven migrations. Every new table, column, index, and key can be defined
    in code, and any new environment can be brought from bare database to your app’s
    perfect schema in seconds.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现代框架如 Laravel 使得使用代码驱动的迁移轻松定义数据库结构。每个新表、列、索引和键都可以在代码中定义，任何新环境都可以在几秒钟内从空白数据库带到应用程序的完美架构。
- en: Defining Migrations
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义迁移
- en: 'A migration is a single file that defines two things: the modifications desired
    when running this migration *up* and, optionally, the modifications desired when
    running this migration *down*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是一个单独的文件，定义了两件事情：运行此迁移时所需的修改（*向上*），以及可选的运行此迁移时所需的修改（*向下*）。
- en: '[Example 5-2](#EX802) shows what the default “create users table” migration
    that comes with Laravel looks like.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-2](#EX802) 展示了 Laravel 默认的“创建用户表”迁移的样子。'
- en: Example 5-2\. Laravel’s default “create users table” migration
  id: totrans-29
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-2\. Laravel 默认的“创建用户表”迁移
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Email Verification
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件验证
- en: The `email_verified_at` column stores a timestamp indicating when the user verified
    their email address.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`email_verified_at` 列存储了用户验证其电子邮件地址的时间戳。'
- en: As you can see, we have an `up()` method and a `down()` method. `up()` tells
    the migration to create a new table named `users` with a few fields, and `down()`
    tells it to drop the `users` table.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有一个 `up()` 方法和一个 `down()` 方法。`up()` 告诉迁移创建一个名为 `users` 的新表，并带有几个字段，而
    `down()` 则告诉它删除 `users` 表。
- en: Creating a migration
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建迁移
- en: As you will see in [Chapter 8](ch08.html#artisan_and_tinker), Laravel provides
    a series of command-line tools you can use to interact with your app and generate
    boilerplate files. One of these commands allows you to create a migration file.
    You can run it using `php artisan make:migration`, and it has a single parameter,
    which is the name of the migration. For example, to create the table we just covered,
    you would run `php artisan make:migration create_users_table`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在[第 8 章](ch08.html#artisan_and_tinker)中看到的，Laravel 提供了一系列命令行工具，您可以使用它们与应用程序交互并生成样板文件。其中一个命令允许您创建迁移文件。您可以使用
    `php artisan make:migration` 运行它，并且它有一个参数，即迁移的名称。例如，要创建我们刚刚讨论过的表，您可以运行 `php artisan
    make:migration create_users_table`。
- en: There are two flags you can optionally pass to this command. `--create=*table_name*`
    prefills the migration with code designed to create a table named `*table_name*`,
    and `--table=*table_name*` just prefills the migration for modifications to an
    existing table.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可以选择向此命令传递两个标志。`--create=*table_name*` 参数将填充迁移，用于创建名为 `*table_name*` 的表，而 `--table=*table_name*`
    则仅填充迁移以修改现有表。
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating tables
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建表
- en: We already saw in the default `create_users_table` migration that our migrations
    depend on the `Schema` facade and its methods. Everything we can do in these migrations
    will rely on the methods of `Schema`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在默认的`create_users_table`迁移中看到，我们的迁移依赖于`Schema`门面及其方法。我们可以在这些迁移中做的一切都依赖于`Schema`的方法。
- en: 'To create a new table in a migration, use the `create()` method—the first parameter
    is the table name, and the second is a closure that defines its columns:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要在迁移中创建新表格，请使用`create()`方法—第一个参数是表名，第二个是定义其列的闭包：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating columns
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建列
- en: 'To create new columns in a table, whether in a create table call or a modify
    table call, use the instance of `Blueprint` that’s passed into your closure:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要在表格中创建新列，无论是在创建表格调用还是修改表格调用中，都可以使用传递到闭包中的`Blueprint`实例：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let’s look at the various methods available on `Blueprint` instances for creating
    columns. I’ll describe how they work in MySQL, but if you’re using another database,
    Laravel will just use the closest equivalent.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Blueprint`实例上可用的各种方法来创建列。我将描述它们在MySQL中的工作方式，但如果您使用的是其他数据库，Laravel将使用最接近的等效方法。
- en: 'The following are the simple field `Blueprint` methods:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是简单字段`Blueprint`方法：
- en: '`id()`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`id()`'
- en: An alias for `$table->bigIncrements('id')`
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`$table->bigIncrements(''id'')`的别名'
- en: '`integer(*colName*)`, `tinyInteger(*colName*)`, `smallInteger(*colName*)`,
    `mediumInteger(*colName*)`, `bigInteger(*colName*)`, `unsignedTinyInteger(*colName*)`,
    `unsignedSmallInteger(*colName*)`, `unsignedMediumInteger(*colName*)`,'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`integer(*colName*)`, `tinyInteger(*colName*)`, `smallInteger(*colName*)`,
    `mediumInteger(*colName*)`, `bigInteger(*colName*)`, `unsignedTinyInteger(*colName*)`,
    `unsignedSmallInteger(*colName*)`, `unsignedMediumInteger(*colName*)`,'
- en: '`unsignedBigInteger(*colName*)`'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsignedBigInteger(*colName*)`'
- en: Adds an `INTEGER` type column, or one of its many variations
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`INTEGER`类型列，或其许多变体之一
- en: '`string(*colName*, *length*)`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`string(*colName*, *length*)`'
- en: Adds a `VARCHAR` type column with an optional length
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个带有可选长度的`VARCHAR`类型列
- en: '`binary(*colName*)`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`binary(*colName*)`'
- en: Adds a `BLOB` type column
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`BLOB`类型列
- en: '`boolean(*colName*)`'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`boolean(*colName*)`'
- en: Adds a `BOOLEAN` type column (a `TINYINT(1)` in MySQL)
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`BOOLEAN`类型列（在MySQL中为`TINYINT(1)`）
- en: '`char(*colName*, *length*)`'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`char(*colName*, *length*)`'
- en: Adds a `CHAR` column with an optional length
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个带有可选长度的`CHAR`类型列
- en: '`date(*colName*)`, `datetime(*colName*)`, `dateTimeTz(*colName*)`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`date(*colName*)`, `datetime(*colName*)`, `dateTimeTz(*colName*)`'
- en: Adds a `DATE` or `DATETIME` column; if time zone awareness is needed, use the
    `dateTimeTz()` method to create a `DATETIME` column with time zone
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`DATE`或`DATETIME`类型列；如果需要时区感知，请使用`dateTimeTz()`方法来创建带有时区的`DATETIME`列
- en: '`decimal(*colName*, *precision*, *scale*)`,'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`decimal(*colName*, *precision*, *scale*)`,'
- en: '`unsignedDecimal(*colName*, *precision*, *scale*)`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsignedDecimal(*colName*, *precision*, *scale*)`'
- en: Adds a `DECIMAL` column, with precision and scale—for example, `decimal('*amount*',
    *5*, *2*)` specifies a precision of 5 and a scale of 2; for an unsigned column,
    use the unsignedDecimal method
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个带有精度和比例的`DECIMAL`类型列—例如，`decimal('*amount*', *5*, *2*)`指定了精度为5，比例为2；对于无符号列，请使用`unsignedDecimal`方法
- en: '`double(*colName*, *total digits*, *digits after decimal*)`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`double(*colName*, *total digits*, *digits after decimal*)`'
- en: Adds a `DOUBLE` column—​for example, `double('*tolerance*', *12*, *8*)` specifies
    12 digits long, with 8 of those digits to the right of the decimal place, as in
    `7204.05691739`
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`DOUBLE`类型的列—例如，`double('*tolerance*', *12*, *8*)`指定了总长度为12位，其中小数点后有8位，比如`7204.05691739`
- en: '`enum(*colName*, [*choiceOne*, *choiceTwo*])`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum(*colName*, [*choiceOne*, *choiceTwo*])`'
- en: Adds an `ENUM` column, with provided choices
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个带有提供的选择的`ENUM`类型列
- en: '`float(*colName*, *precision*, *scale*)`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`float(*colName*, *precision*, *scale*)`'
- en: Adds a `FLOAT` column (same as `double` in MySQL)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`FLOAT`类型列（与MySQL中的`double`相同）
- en: '`foreignId(*colName*)`, `foreignUuid(*colName*)`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreignId(*colName*)`, `foreignUuid(*colName*)`'
- en: Adds an `UNSIGNED BIGINT` or a `UUID` column, with provided choices
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`UNSIGNED BIGINT`类型或`UUID`列，提供了选择
- en: '`foreignIdFor(*colName*)`'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreignIdFor(*colName*)`'
- en: Adds an `UNSIGNED BIG INT` column with the name *`colName`*
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用名称为*`colName`*的`UNSIGNED BIG INT`类型列
- en: '`geometry(*colName*)`, `geometryCollection(*colName*)`'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`geometry(*colName*)`, `geometryCollection(*colName*)`'
- en: Adds a `GEOMETRY` or a `GEOMETRYCOLLECTION` column
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`GEOMETRY`或`GEOMETRYCOLLECTION`类型列
- en: '`ipAddress(*colName*)`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ipAddress(*colName*)`'
- en: Adds a `VARCHAR` column
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`VARCHAR`类型列
- en: '`json(*colName*)`, `jsonb(*colName*)`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`json(*colName*)`, `jsonb(*colName*)`'
- en: Adds a `JSON` or `JSONB` column
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`JSON`或`JSONB`类型列
- en: '`lineString(*colName*)`, `multiLineString(*colName*)`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`lineString(*colName*)`, `multiLineString(*colName*)`'
- en: Adds a `LINESTRING` or `MULTILINESTRING` column with the given *`colName`*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的*`colName`*添加一个`LINESTRING`或`MULTILINESTRING`类型列
- en: '`text(*colName*)`, `tinyText(*colName*)`, `mediumText(*colName*)`, `longText(*colName*)`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`text(*colName*)`、`tinyText(*colName*)`、`mediumText(*colName*)`、`longText(*colName*)`'
- en: Adds a `TEXT` column (or its various sizes)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`TEXT`列（或其不同大小的变体）
- en: '`macAddress(*colName*)`'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`macAddress(*colName*)`'
- en: Adds a `MACADDRESS` column in the databases that support it (like PostgreSQL);
    on other database systems, it creates a string equivalent
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持它的数据库（如PostgreSQL）中添加一个`MACADDRESS`列；在其他数据库系统中，它创建一个字符串等效
- en: '`multiPoint(*colName*)`, `multiPolygon(*colName*)`, `polygon(*colName*)`,'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiPoint(*colName*)`、`multiPolygon(*colName*)`、`polygon(*colName*)`'
- en: '`point(*colName*)`'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`point(*colName*)`'
- en: Adds columns of the types `MULTIPOINT`, `MULTIPOLYGON`, `POLYGON`, and `POINT`,
    respectively
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 分别添加`MULTIPOINT`、`MULTIPOLYGON`、`POLYGON`和`POINT`类型的列
- en: '`set(*colName*, *membersArray*)`'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`set(*colName*, *membersArray*)`'
- en: Creates a `SET` column with the *`colName`* name and *`membersArray`* as members
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为*`colName`*的`SET`列，*`membersArray`*作为成员
- en: '`time(*colName*, *precision*), timeTz(*colName*, *precision*)`'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`time(*colName*, *precision*), timeTz(*colName*, *precision*)`'
- en: Adds a `TIME` column with *`colName`* name; for time zone awareness, use the
    `timeTz()` method
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个带有*`colName`*名称的`TIME`列；要进行时区感知，请使用`timeTz()`方法
- en: '`timestamp(*colName*, *precision*)`,'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestamp(*colName*, *precision*)`'
- en: '`timestampTz(*colName*, *precision*)`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestampTz(*colName*, *precision*)`'
- en: Adds a `TIMESTAMP` column; for time zone awareness, use the `timestampTz()`
    method
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`TIMESTAMP`列；要进行时区感知，请使用`timestampTz()`方法
- en: '`uuid(*colName*)`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuid(*colName*)`'
- en: Adds a `UUID` column (`CHAR(36)` in MySQL)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`UUID`列（在MySQL中为`CHAR(36)`）
- en: '`year()`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`year()`'
- en: Adds a `YEAR` column
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`YEAR`列
- en: 'And these are the special (joined) `Blueprint` methods:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是特殊（联合）的`Blueprint`方法：
- en: '`increments(*colName*)`, `tinyIncrements(*colName*)`, `smallIncrements(*colName*)`,
    `mediumIncrements(*colName*)`, `bigIncrements(*colName*)`'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`increments(*colName*)`、`tinyIncrements(*colName*)`、`smallIncrements(*colName*)`、`mediumIncrements(*colName*)`、`bigIncrements(*colName*)`'
- en: Adds an unsigned incrementing `INTEGER` primary key ID, or one of its many variations
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个无符号增量的`INTEGER`主键ID，或其多种变体之一
- en: '`timestamps(*precision*)`, `nullableTimestamps(*precision*)`,'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestamps(*precision*)`、`nullableTimestamps(*precision*)`'
- en: '`timestampsTz(*precision*)`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`timestampsTz(*precision*)`'
- en: Adds `created_at` and `updated_at` timestamp columns with optional precision,
    nullable, and time zone–aware variations
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 添加具有可选精度、可空和时区感知变体的`created_at`和`updated_at`时间戳列
- en: '`rememberToken()`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`rememberToken()`'
- en: Adds a `remember_token` column (`VARCHAR(100)`) for user “remember me” tokens
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为用户“记住我”令牌添加一个`remember_token`列（`VARCHAR(100)`）
- en: '`softDeletes(*colName*, *precision*)`, `softDeletesTz(*colName*, *precision*)`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`softDeletes(*colName*, *precision*)`、`softDeletesTz(*colName*, *precision*)`'
- en: Adds a `deleted_at` timestamp for use with soft deletes with optional precision
    and time zone–aware variations
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`deleted_at`时间戳以用于软删除，具有可选的精度和时区感知变体
- en: '`morphs(*colName*)`, `nullableMorphs(*colName*)`, `uuidMorphs(*relationshipName*)`,'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`morphs(*colName*)`, `nullableMorphs(*colName*)`, `uuidMorphs(*relationshipName*)`,'
- en: '`nullableUuidMorphs(*relationshipName*)`'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`nullableUuidMorphs(*relationshipName*)`'
- en: For a provided *`colName`*, adds an integer `colName_id` and a string `colName_type`
    (e.g., `morphs(tag)` adds integer `tag_id` and string `tag_type`); for use in
    polymorphic relationships, using IDs or UUIDs, and can be set as nullable as per
    method name
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于提供的*`colName`*，添加一个整数`colName_id`和一个字符串`colName_type`（例如，`morphs(tag)`添加整数`tag_id`和字符串`tag_type`）；用于多态关系中使用ID或UUID，并可以根据方法名称设置为可空
- en: Building extra properties fluently
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 流畅地构建额外的属性
- en: 'Most of the properties of a field definition—its length, for example—are set
    as the second parameter of the field creation method, as we saw in the previous
    section. But there are a few other properties that we’ll set by chaining more
    method calls after the creation of the column. For example, this `email` field
    is nullable and will be placed (in MySQL) right after the `last_name` field:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 字段定义的大多数属性——例如其长度——作为字段创建方法的第二个参数设置，就像我们在前一节中看到的那样。但是还有一些其他属性，我们将在创建列后通过更多方法调用链设置。例如，此`email`字段可空，并将（在MySQL中）放在`last_name`字段后面：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The following methods are some of those used to set additional properties of
    a field; look to the [migrations docs](https://oreil.ly/4Z-gC) for an exhaustive
    list.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法是用于设置字段的附加属性的一些方法；请参阅[migrations docs](https://oreil.ly/4Z-gC)获取详尽列表。
- en: '`nullable()`'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`nullable()`'
- en: Allows `NULL` values to be inserted into this column
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 允许将`NULL`值插入此列
- en: '`default(''*default content*'')`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`default(''*default content*'')`'
- en: Specifies the default content for this column if no value is provided
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 指定此列的默认内容（如果未提供值）
- en: '`unsigned()`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsigned()`'
- en: Marks integer columns as unsigned (not negative or positive, but just an integer)
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将整数列标记为无符号（不是负数或正数，而是整数）
- en: '`first()` (MySQL only)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`first()`（仅适用于MySQL）'
- en: Places the column first in the column order
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将列名放在列顺序的最前面
- en: '`after(*colName*)` (MySQL only)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`after(*colName*)`（仅适用于MySQL）'
- en: Places the column after another column in the column order
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 将列放在列顺序的另一列之后
- en: '`charset(*charset*)` (MySQL only)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`charset(*charset*)`（仅适用于MySQL）'
- en: Sets the charset for a column
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为列设置字符集
- en: '`collation(*collation*)`'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`collation(*collation*)`'
- en: Sets the collation for a column
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为列设置排序规则
- en: '`invisible()` (MySQL only)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`invisible()`（仅适用于MySQL）'
- en: Makes the column invisible to `SELECT` queries
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 将列对`SELECT`查询不可见
- en: '`useCurrent()`'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`useCurrent()` '
- en: Used on `TIMESTAMP` columns to use `CURRENT_TIMESTAMP` as the default value
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 用于`TIMESTAMP`列，使用`CURRENT_TIMESTAMP`作为默认值
- en: '`isGeometry()` (PostgreSQL only)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`isGeometry()`（仅适用于PostgreSQL）'
- en: Sets a column type to `GEOMETRY` (the default is `GEOGRAPHY`)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 将列类型设置为`GEOMETRY`（默认为`GEOGRAPHY`）
- en: '`unique()`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`unique()`'
- en: Adds a `UNIQUE` index
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`UNIQUE`索引
- en: '`primary()`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`primary()`'
- en: Adds a primary key index
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 添加主键索引
- en: '`index()`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`index()`'
- en: Adds a basic index
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 添加基本索引
- en: Note that `unique()`, `primary()`, and `index()` can also be used outside of
    the fluent column building context, which we’ll cover later.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`unique()`、`primary()`和`index()`也可以在流畅的列构建上下文之外使用，我们稍后会讨论这一点。
- en: Dropping tables
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除表
- en: 'If you want to drop a table, use the `dropIfExists()` method on `Schema`, which
    takes one parameter, the table name:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要删除表，请在`Schema`上使用`dropIfExists()`方法，该方法接受一个参数，即表名：
- en: '[PRE8]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Modifying columns
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改列
- en: To modify a column, just write the code you would write to create the column
    as if it were new, and then append a call to the `change()` method after it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改列，只需编写代码，就像创建新列一样，然后在其后追加一个`change()`方法的调用。
- en: Required Dependency Before Modifying Columns
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改列之前的必需依赖项
- en: If you are not using a database that natively supports renaming and dropping
    columns (the latest versions of the most common databases support these operations),
    before you can modify any columns, you’ll need to run `composer require doctrine/dbal`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用原生支持重命名和删除列的数据库（大多数常见数据库的最新版本支持这些操作），在修改任何列之前，您需要运行`composer require
    doctrine/dbal`。
- en: 'So, if we have a string column named `name` that has a length of `255` and
    we want to change its length to `100`, this is how we would write it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果我们有一个名为`name`的字符串列，长度为`255`，我们想把它的长度改为`100`，写法如下：
- en: '[PRE9]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same is true if we want to adjust any of its properties that aren’t defined
    in the method name. To make a field nullable, we do this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要调整未在方法名中定义的任何字段属性，使其可为空，我们可以这样做：
- en: '[PRE10]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here’s how we rename a column:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何重命名列的方法：
- en: '[PRE11]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And this is how we drop a column:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何删除列的方法：
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Squashing migrations
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 压缩迁移
- en: If you have too many migrations to reason with, you can merge them all into
    a single SQL file that Laravel will run before it runs any future migrations.
    This is called “squashing” your migrations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迁移过多而无法理解，可以将它们全部合并到一个单独的SQL文件中，Laravel将在运行任何未来迁移之前运行该文件。这称为“压缩”您的迁移。
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Laravel only runs these dumps if it detects no migrations have been run so far.
    That means you can squash your migrations and it won’t break your already-deployed
    applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel仅在检测到到目前为止未运行迁移时才运行这些转储。这意味着您可以压缩您的迁移，而不会破坏已部署的应用程序。
- en: Warning
  id: totrans-164
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you use schema dumps, you can’t use in-memory SQLite; it only works on MySQL,
    PostgreSQL, and local file SQLite.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用模式转储，则无法在内存中使用SQLite；它仅适用于MySQL、PostgreSQL和本地文件SQLite。
- en: Indexes and foreign keys
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引和外键
- en: We’ve covered how to create, modify, and delete columns. Let’s move on to indexing
    and relating them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了如何创建、修改和删除列。现在让我们继续索引和关联它们。
- en: If you’re not familiar with indexes, your databases can survive if you just
    never use them, but they’re pretty important for performance optimization and
    for some data integrity controls with regard to related tables. I’d recommend
    reading up on them, but if you absolutely must, you can skip this section for
    now.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对索引不熟悉，您的数据库可以在不使用它们的情况下运行，但它们对性能优化非常重要，并且对于一些关于相关表的数据完整性控制也很重要。我建议您详细了解一下它们，但如果您确实需要，您可以暂时跳过此部分。
- en: Adding indexes
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加索引
- en: Check out [Example 5-3](#adding-col-ix) for examples of how to add indexes to
    your column.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[示例5-3](#adding-col-ix)了解如何向列添加索引的示例。
- en: Example 5-3\. Adding column indexes in migrations
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-3。在迁移中添加列索引
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the first example, `primary()`, is not necessary if you’re using the
    `increments()` or `bigIncrements()` methods to create your index; this will automatically
    add a primary key index for you.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果你使用`increments()`或`bigIncrements()`方法创建索引，那么`primary()`的第一个示例是不必要的；这会自动为你添加一个主键索引。
- en: Removing indexes
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除索引
- en: We can remove indexes as shown in [Example 5-4](#rm-col-ix).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以如示例5-4中所示移除索引（#rm-col-ix）。
- en: Example 5-4\. Removing column indexes in migrations
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-4. 在迁移中移除列索引
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Adding and removing foreign keys
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加和移除外键
- en: 'To add a foreign key that defines that a particular column references a column
    on another table, Laravel’s syntax is simple and clear:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个外键，定义一个特定列引用另一张表上的列，Laravel的语法简单清晰：
- en: '[PRE16]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here we’re adding a `foreign` index on the `user_id` column, showing that it
    references the `id` column on the `users` table. Couldn’t get much simpler.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`user_id`列上添加一个`foreign`索引，显示它引用了`users`表上的`id`列。再简单不过了。
- en: 'If we want to specify foreign key constraints, we can do that too, with `cascadeOnUpdate()`,
    `restrictOnUpdate()`, `cascadeOnDelete()`, `restrictOnDelete()`, and `nullOnDelete()`.
    For example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想指定外键约束，也可以，比如`cascadeOnUpdate()`，`restrictOnUpdate()`，`cascadeOnDelete()`，`restrictOnDelete()`和`nullOnDelete()`。例如：
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is also an alias for creating foreign key constraints. Using it, the
    above example can be written like so:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个别名用于创建外键约束。使用它，上面的示例可以这样写：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To drop a foreign key, we can either delete it by referencing its index name
    (which is automatically generated by combining the names of the columns and tables
    being referenced):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除外键，我们可以通过引用其索引名称来删除它（该名称是通过组合引用的列和表的名称自动生成的）：
- en: '[PRE19]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'or by passing it an array of the fields that it’s referencing in the local
    table:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 或者通过传递一个数组，其中包含它在本地表中引用的字段：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Running Migrations
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行迁移
- en: 'Once you have your migrations defined, how do you run them? There’s an Artisan
    command for that:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了迁移之后，如何运行它们？有一个Artisan命令可以做到：
- en: '[PRE21]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command runs all “outstanding” migrations (by running the `up()` method
    on each). Laravel keeps track of which migrations you have run and which you haven’t.
    Every time you run this command, it checks whether you’ve run all available migrations,
    and if you haven’t, it’ll run any that remain.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令运行所有“未完成”的迁移（通过在每个上运行`up()`方法）。Laravel会跟踪你已经运行和未运行的迁移。每次运行此命令时，它会检查是否已运行所有可用的迁移，如果没有，则运行任何未完成的迁移。
- en: 'There are a few options in this namespace that you can work with. First, you
    can run your migrations *and* your seeds (which we’ll cover next):'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命名空间中有几个选项可以使用。首先，你可以运行你的迁移*和*你的种子（我们将在下文中介绍）：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can also run any of the following commands:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以运行以下任何命令：
- en: '`migrate:install`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrate:install`'
- en: Creates the database table that keeps track of which migrations you have and
    haven’t run; this is run automatically when you run your migrations, so you can
    basically ignore it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个数据库表，用来跟踪你已经和未运行的迁移；当你运行迁移时，这会自动运行，所以基本上你可以忽略它。
- en: '`migrate:reset`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrate:reset`'
- en: Rolls back every database migration you’ve run on this instance.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚你在此实例上运行的每个数据库迁移。
- en: '`migrate:refresh`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrate:refresh`'
- en: Rolls back every database migration you’ve run on this instance, and then runs
    every migration available. It’s the same as running `migrate:reset` followed by
    `migrate`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 回滚你在此实例上运行的每个数据库迁移，然后运行所有可用的迁移。这与运行`migrate:reset`然后`migrate`相同。
- en: '`migrate:fresh`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrate:fresh`'
- en: Drops all of your tables and runs every migration again. It’s the same as `refresh`
    but doesn’t bother with the “down” migrations—​it just deletes the tables and
    then runs the “up” migrations again.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 删除所有表并再次运行每个迁移。这与`refresh`相同，但不涉及“下”迁移，它只是删除表然后再次运行“上”迁移。
- en: '`migrate:rollback`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrate:rollback`'
- en: Rolls back *just* the migrations that ran the last time you ran `migrate`, or,
    with the added option `--step=*n*`, rolls back the number of migrations you specify.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 仅回滚上次运行`migrate`的迁移，或者使用添加的选项`--step=*n*`，回滚指定数量的迁移。
- en: '`migrate:status`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`migrate:status`'
- en: Shows a table listing every migration, with a `Y` or `N` next to each indicating
    whether or not it has run yet in this environment.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 显示一个表格，列出每个迁移，每个旁边都有一个`Y`或`N`，表示此环境中是否已经运行。
- en: Migrating with Homestead/Vagrant
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Homestead/Vagrant进行迁移
- en: If you’re running migrations on your local machine and your *.env* file points
    to a database in a Vagrant box, your migrations will fail. You’ll need to `ssh`
    into your Vagrant box and then run the migrations from there. The same is true
    for seeds and any other Artisan commands that affect or read from the database.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在本地计算机上运行迁移，并且您的 *.env* 文件指向 Vagrant 盒子中的数据库，则迁移将失败。您需要通过 SSH 进入您的 Vagrant
    盒子，然后从那里运行迁移。对于种子和任何其他会影响或从数据库读取的 Artisan 命令也是如此。
- en: Inspecting Your Database
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查您的数据库
- en: 'If you want to dig into the status or definition of your database, its tables,
    and its models, there are a few Artisan commands for exactly that purpose:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想深入了解数据库的状态或定义，包括其表和模型，那么有一些专门的 Artisan 命令可以帮到您：
- en: '`db:show`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`db:show`'
- en: Shows a table overview of your entire database, including the connection details,
    tables, size, and open connections
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 显示整个数据库的表概览，包括连接详细信息、表、大小和开放连接数
- en: '`db:table {*tableName*}`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`db:table {*tableName*}`'
- en: Passed a table name, shows the size and lists the columns
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 给定表名，显示大小并列出列
- en: '`db:monitor`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`db:monitor`'
- en: List, the number of open connections to the database
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列出数据库的开放连接数目
- en: Seeding
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充
- en: Seeding with Laravel is so simple, it has gained widespread adoption as a part
    of normal development workflows in a way it hasn’t in previous PHP frameworks.
    There’s a *database/seeders* folder that comes with a `DatabaseSeeder` class,
    which has a `run()` method that is called when you call the seeder.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Laravel 进行填充是如此简单，以至于它作为正常开发工作流程的一部分得到了广泛采用，这在以前的 PHP 框架中并不常见。有一个 *database/seeders*
    文件夹，其中包含一个 `DatabaseSeeder` 类，该类在调用填充器时会调用其 `run()` 方法。
- en: 'There are two primary ways to run the seeders: along with a migration or separately.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 运行填充器有两种主要方式：与迁移一起或单独运行。
- en: 'To run a seeder along with a migration, just add `--seed` to any migration
    call:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 要与迁移一起运行填充器，只需在任何迁移调用中添加 `--seed`：
- en: '[PRE23]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'And to run it independently:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要独立运行填充器：
- en: '[PRE24]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This will call the `run()` method of the `DatabaseSeeder` by default, or the
    seeder class specified when you pass in a class name.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这将默认调用 `DatabaseSeeder` 的 `run()` 方法，或者在传递类名时指定的填充器类。
- en: Creating a Seeder
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个填充器
- en: 'To create a seeder, use the `make:seeder` Artisan command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个填充器，请使用 `make:seeder` Artisan 命令：
- en: '[PRE25]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You’ll now see a `ContactsTableSeeder` class show up in the *database/seeders*
    directory. Before we edit it, let’s add it to the `DatabaseSeeder` class, as shown
    in [Example 5-5](#EX5x), so it will run when we run our seeders.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在将在 *database/seeders* 目录中看到一个 `ContactsTableSeeder` 类。在我们编辑它之前，让我们将它添加到 `DatabaseSeeder`
    类中，就像 [示例 5-5](#EX5x) 中所示的那样，这样当我们运行填充器时它就会运行。
- en: Example 5-5\. Calling a custom seeder from DatabaseSeeder.php
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-5\. 从 DatabaseSeeder.php 调用自定义填充器
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now let’s edit the seeder itself. The simplest thing we can do there is manually
    insert a record using the `DB` facade, as illustrated in [Example 5-6](#EX5y).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们编辑填充器本身。在那里，我们可以做的最简单的事情是使用`DB`门面手动插入记录，就像 [示例 5-6](#EX5y) 中所示的那样。
- en: Example 5-6\. Inserting database records in a custom seeder
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-6\. 在自定义填充器中插入数据库记录
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will get us a single record, which is a good start. But for truly functional
    seeds, you’ll likely want to loop over some sort of random generator and run this
    `insert()` many times, right? Laravel has a feature for that.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们获取一条记录，这是一个很好的开始。但是对于真正功能齐全的填充器，您可能希望循环使用某种随机生成器并多次运行`insert()`，对吧？Laravel
    就有这样的功能。
- en: Model Factories
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型工厂
- en: Model factories define one (or more) patterns for creating fake entries for
    your database tables. By default, each factory is named after an Eloquent class.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 模型工厂定义了创建数据库表中虚假条目的模式之一（或更多）。默认情况下，每个工厂的命名都是根据 Eloquent 类命名的。
- en: Theoretically you can name these factories anything you like, but naming the
    factory after your Eloquent class is the most idiomatic approach. If you follow
    a different convention to name your factories, you can set the factory class name
    in the related model.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，您可以随意命名这些工厂，但将工厂命名为您的 Eloquent 类的方式是最习惯的方法。如果您遵循不同的约定来命名您的工厂，您可以在相关模型中设置工厂类名。
- en: Creating a model factory
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个模型工厂
- en: Model factories are located in *database/factories*. Each factory is defined
    in its own class, with a definition method. In this method you define the attributes
    and their values to be used when creating a model with the factory.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 模型工厂位于 *database/factories*。每个工厂都在自己的类中定义，具有一个定义方法。在此方法中，您定义要在工厂创建模型时使用的属性及其值。
- en: 'To generate a new factory class, use the Artisan `make:factory` command; again,
    it’s most common to name factory classes after the Eloquent models they’re meant
    to generate instances of:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个新的工厂类，使用Artisan的`make:factory`命令；通常将工厂类命名为它们要生成实例的Eloquent模型：
- en: '[PRE28]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will generate a new file within the *database/factories* directory called
    *ContactFactory.php*. The simplest factory we could define for a contact might
    look something like [Example 5-7](#EX880):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在*database/factories*目录中生成一个名为*ContactFactory.php*的新文件。我们为联系人定义的最简单的工厂可能看起来像[Example 5-7](#EX880)：
- en: Example 5-7\. The simplest possible factory definition
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-7\. 最简单的工厂定义
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You now need to use the `Illuminate\Database\Eloquent\Factories\HasFactory`
    trait in your model.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要在你的模型中使用`Illuminate\Database\Eloquent\Factories\HasFactory`特性。
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `HasFactory` trait provides a `factory()` static method, which uses Laravel
    conventions to determine the proper factory for the model. It will look for a
    factory in `Database\Factories` namespace that has a class name matching the model
    name and is suffixed with `Factory`. If you don’t follow these conventions, you
    can override the `newFactory()` method in your model to specify the factory class
    that should be used:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`HasFactory`特性提供了一个静态的`factory()`方法，它使用Laravel的约定来确定模型的适当工厂。它将在`Database\Factories`命名空间中寻找一个类名与模型名匹配且以`Factory`结尾的工厂。如果你不遵循这些约定，你可以在你的模型中覆盖`newFactory()`方法来指定应该使用的工厂类：'
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we can call the static `factory()` method on the model, to create an instance
    of `Contact` in our seeding and testing:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在模型上调用静态的`factory()`方法，在我们的种子和测试中创建一个`Contact`的实例：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: However, if we used that factory to create 20 contacts, all 20 would have the
    same information. That’s less useful.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用该工厂创建了20个联系人，那么所有20个联系人将具有相同的信息。这就没那么有用了。
- en: We will get even more benefit from model factories when we take advantage of
    [Faker](https://oreil.ly/gxnrI), which is globally available in Laravel via the
    `fake()` helper; Faker makes it easy to randomize the creation of structured fake
    data. The previous example now turns into [Example 5-8](#EX881).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们利用[Faker](https://oreil.ly/gxnrI)全球可用于Laravel的`fake()`助手时，我们将从模型工厂中获得更多好处；Faker使得随机生成结构化虚假数据变得轻而易举。之前的例子现在变成了[Example 5-8](#EX881)。
- en: Example 5-8\. A simple factory, modified to use Faker
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-8\. 一个简单的工厂，修改以使用Faker
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Now, every time we create a fake contact using this model factory, all of our
    properties will be randomly generated.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们使用这个模型工厂创建一个虚假联系人时，所有属性都将被随机生成。
- en: Model factories need, at minimum, to return the required database fields for
    this table.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 模型工厂至少需要返回此表所需的数据库字段。
- en: Guaranteeing the Uniqueness of Randomly Generated Data
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保随机生成的数据的唯一性
- en: 'If you want to guarantee that the randomly generated values of any given entry
    are unique compared to the other randomly generated values during that PHP process,
    you can use Faker’s `unique()` method:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望保证任何给定条目的随机生成值在PHP进程中与其他随机生成值不同，你可以使用Faker的`unique()`方法：
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Using a model factory
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模型工厂
- en: 'There are two primary contexts in which we’ll use model factories: testing,
    which we’ll cover in [Chapter 12](ch12.html#testing), and seeding, which we’ll
    cover here. Let’s write a seeder using a model factory; take a look at [Example 5-9](#EX803).'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种主要情境下我们会使用模型工厂：测试，我们将在[Chapter 12](ch12.html#testing)中介绍；以及种子，我们在这里介绍。让我们使用模型工厂编写一个种子程序；看一看[Example 5-9](#EX803)。
- en: Example 5-9\. Using model factories
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-9\. 使用模型工厂
- en: '[PRE35]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To create an object, we use the `factory()` method on the model. Then we can
    run one of two methods on it: `make()` or `create()`.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个对象，我们在模型上使用`factory()`方法。然后我们可以在它上面运行两种方法之一：`make()`或`create()`。
- en: Both methods generate an instance of this specified model, using the definition
    in the factory class. The difference is that `make()` creates the instance but
    doesn’t (yet) save it to the database, whereas `create()` saves it to the database
    instantly.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都会使用工厂类中的定义生成指定模型的实例。区别在于，`make()`创建实例但不立即保存到数据库，而`create()`则立即保存到数据库。
- en: Overriding properties when calling a model factory
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在调用模型工厂时覆盖属性
- en: If you pass an array to either `make()` or `create()`, you can override specific
    keys from the factory, like we did in [Example 5-9](#EX803) to manually set the
    `title` on the post.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将数组传递给`make()`或`create()`，你可以像我们在[Example 5-9](#EX803)中所做的那样，手动设置帖子上的`title`来覆盖特定的键。
- en: Generating more than one instance with a model factory
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用模型工厂生成多个实例
- en: 'If you call the `count()` method after the `factory()` method, you can specify
    that you’re creating more than one instance. Instead of returning a single instance,
    it’ll return a collection of instances. This means you can treat the result like
    an array, iterating over them or passing them to any method that takes more than
    one object:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在调用`factory()`方法后调用`count()`方法，可以指定要创建多个实例。它不会返回单个实例，而是返回一组实例。这意味着您可以像处理数组一样处理结果，迭代它们或将它们传递给接受多个对象的任何方法：
- en: '[PRE36]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You can also, optionally, define a “sequence” of how to override each:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以选择定义每个覆盖的“序列”：
- en: '[PRE37]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Pro-level model factories
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专业级模型工厂
- en: Now that we’ve covered the most common uses for and arrangements of model factories,
    let’s dive into some of the more complicated ways we can use them.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了模型工厂的最常见用途和排列方式，让我们深入一些更复杂的使用方法。
- en: Attaching relationships when defining model factories
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在定义模型工厂时附加关系
- en: Sometimes you need to create a related item along with the item you’re creating.
    You can call the factory method on the related model to pull its ID, as shown
    in [Example 5-10](#EX5a).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您需要创建一个与您正在创建的项目相关的项目。您可以调用相关模型上的工厂方法以获取其ID，如示例[5-10](#EX5a)所示。
- en: Example 5-10\. Creating a related item in a factory
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-10\. 在工厂中创建相关项
- en: '[PRE38]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can also pass a closure where a single parameter is passed, which contains
    the array form of the generated item up until that point. This can be used in
    other ways, as demonstrated in [Example 5-11](#EX5b).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以传递一个闭包，闭包将传递一个参数，其中包含到目前为止生成项目的数组形式。这可以在其他地方使用，如示例[5-11](#EX5b)所示。
- en: Example 5-11\. Using values from other parameters in a factory
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-11\. 在工厂中使用其他参数的值
- en: '[PRE39]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Attaching related items when generating model factory instances
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在生成模型工厂实例时附加相关项
- en: While we’ve already covered how to define a relationship in a factory definition,
    it’s much more common that we’ll be defining our instance’s related items right
    when we create it.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经讨论了如何在工厂定义中定义关系，但更常见的情况是我们在创建实例时定义实例的相关项。
- en: 'There are two main methods we’ll use for this: `has()` and `for()`. `has()`
    allows us to define that the instance we’re creating “has” children or other items
    in a “hasMany” type relationship, whereas `for()` allows us to define that the
    instance we’re creating “belongsTo” another item. Let’s look at a few examples
    to get a better sense of how they work.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这方面，我们将使用两种主要方法：`has()`和`for()`。`has()`允许我们定义我们正在创建的实例“有”子项或其他项目的“hasMany”类型关系，而`for()`允许我们定义我们正在创建的实例“belongsTo”另一个项目。让我们看几个示例，以更好地了解它们的工作方式。
- en: In [Example 5-12](#EX5g), let’s assume a `Contact` has many `Addresses`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例5-12](#EX5g)中，让我们假设`Contact`有许多`Addresses`。
- en: Example 5-12\. Using `has()` when generating related models
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-12\. 在生成相关模型时使用`has()`
- en: '[PRE40]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now let’s imagine we’re creating the child instance instead of the parent instance.
    Let’s generate an address.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们假设我们正在创建子实例而不是父实例。让我们生成一个地址。
- en: In these sorts of circumstances, you usually can assume the child’s factory
    definition would take care of generating the parent instance. So, what’s the use
    of `for()` at all? It’s most helpful if you want to specifically define something
    about the parent, usually either one or more of its properties, or pass in a specific
    model instance. Take a look at [Example 5-13](#EX5h) to see how it’s most commonly
    used.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，您通常可以假设子工厂定义将负责生成父实例。那么，`for()`的用途是什么？如果您想要特别定义父实例的某些内容，通常是其一个或多个属性，或者传递特定的模型实例，这将非常有帮助。看看[示例5-13](#EX5h)，看看它是如何最常用的。
- en: Example 5-13\. Using `for()` when generating related models
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-13\. 在生成相关模型时使用`for()`
- en: '[PRE41]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Defining and accessing multiple model factory states
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义和访问多个模型工厂状态
- en: 'Let’s go back to *ContactFactory.php* (from Examples [5-7](#EX880) and [5-8](#EX881))
    for a second. We have a base `Contact` factory defined:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下*ContactFactory.php*（来自示例[5-7](#EX880)和[5-8](#EX881)）。我们定义了一个基础的`Contact`工厂：
- en: '[PRE42]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: But sometimes you need more than one factory for a class of object. What if
    we need to be able to add some contacts who are very important people (VIPs)?
    We can use the `state()` method to define a second factory state for this, as
    seen in [Example 5-14](#EX804). The `state()` method receives an array of any
    attributes you want to specifically set for this state.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要为某个类的对象创建多个工厂。如果我们需要添加一些非常重要的联系人（VIP），我们可以使用`state()`方法为此定义第二个工厂状态，正如在[示例
    5-14](https://example.org/EX804)中所见。`state()`方法接收一个属性数组，你可以为这个状态专门设置任何属性。
- en: Example 5-14\. Defining multiple factory states for the same model
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-14\. 为同一模型定义多个工厂状态
- en: '[PRE43]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, let’s make an instance of a specific state:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个特定状态的实例：
- en: '[PRE44]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Using the same model as the relationship in complex factory Setups
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在复杂工厂设置中使用相同模型作为关系
- en: Sometimes you have a factory that creates related items through their factories,
    and two or more of those have the same relationship. Maybe generating a `Trip`
    with your factory automatically creates a `Reservation` and a `Receipt`, and all
    three should be attached to the same `User`. When you go to create the `Trip`,
    the factories will each create their own user manually, unless you tell them to
    do otherwise.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你有一个工厂通过它们的工厂创建相关项，其中两个或更多有相同的关系。也许通过你的工厂生成`Trip`会自动创建`Reservation`和`Receipt`，并且所有三者都应该附属于同一个`User`。当你去创建`Trip`时，除非告诉它们要做其他事情，否则工厂将每个手动创建它们自己的用户。
- en: With the `recycle()` method, you can instruct that every factory called up the
    chain uses the same instance of a given object. As you can see in [Example 5-15](#EX5i),
    this gives a simple syntax for ensuring the same model is used in every place
    throughout a factory chain.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`recycle()`方法，你可以指示每个调用链中的工厂使用给定对象的同一个实例。正如你在[示例 5-15](https://example.org/EX5i)中看到的，这为确保整个工厂链中使用同一模型提供了简单的语法。
- en: Example 5-15\. Using `recycle()` to use the same instance for every relationship
    in a factory chain
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-15\. 使用`recycle()`在工厂链中的每个关系中使用相同的实例
- en: '[PRE45]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Whew. That was a lot. Don’t worry if that was tough to follow—​the last bit
    was definitely higher-level stuff. Let’s get back down to the basics and talk
    about the core of Laravel’s database tooling: the query builder.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，这真是太多了。如果你觉得理解起来有些困难，不要担心——最后一部分确实是更高级的内容。让我们回到基础，谈谈Laravel数据库工具的核心：查询构建器。
- en: Query Builder
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查询构建器
- en: Now that you’re connected and you’ve migrated and seeded your tables, let’s
    get started with how to use the database tools. At the core of every piece of
    Laravel’s database functionality is the *query builder*, a fluent interface for
    interacting with several different types of databases with a single clear API.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经连接并且迁移和填充了你的表，让我们开始学习如何使用数据库工具。在每一个Laravel数据库功能的核心是*查询构建器*，它是一个流畅的接口，用于与多种不同类型的数据库进行交互，具有清晰的单一API。
- en: Laravel’s database architecture can connect to MySQL, PostgreSQL, SQLite, and
    SQL Server through a single interface, with just the change of a few configuration
    settings.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的数据库架构可以通过单一接口连接到MySQL、PostgreSQL、SQLite和SQL Server，只需改变几个配置设置。
- en: If you’ve ever used a PHP framework, you’ve likely used a tool that allows you
    to run “raw” SQL queries with basic escaping for security. The query builder is
    that, with a lot of convenience layers and helpers on top. So, let’s start with
    some simple calls.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过PHP框架，你可能使用过一个工具，允许你运行带有基本转义的“原始”SQL查询，以确保安全性。查询构建器就是这样一个工具，在其上还有许多便利层和帮助程序。因此，让我们从一些简单的调用开始。
- en: Basic Usage of the DB Facade
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`DB`门面的基本用法'
- en: Before we get into building complex queries with fluent method chaining, let’s
    take a look at a few sample query builder commands. The `DB` facade is used both
    for query builder chaining and for simpler raw queries, as illustrated in [Example 5-16](#EX806).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用流畅方法链构建复杂查询之前，让我们看一些查询构建器命令的示例。`DB`门面用于查询构建器链式调用和更简单的原始查询，如[示例 5-16](https://example.org/EX806)所示。
- en: Example 5-16\. Sample raw SQL and query builder usage
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-16\. 示例原始SQL和查询构建器的使用
- en: '[PRE46]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Raw SQL
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始SQL
- en: 'As you saw in [Example 5-16](#EX806), it’s possible to make any raw call to
    the database using the `DB` facade and the `statement()` method: `DB::statement(''*SQL
    statement here*'')`.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[示例 5-16](https://example.org/EX806)中看到的，可以使用`DB`门面和`statement()`方法对数据库进行任何原始调用：`DB::statement('*SQL
    statement here*')`。
- en: 'But there are also specific methods for various common actions: `select()`,
    `insert()`, `update()`, and `delete()`. These are still raw calls, but there are
    differences. First, using `update()` and `delete()` will return the number of
    rows affected, whereas `statement()` won’t; second, with these methods it’s clearer
    to future developers exactly what sort of statement you’re making.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有特定于各种常见操作的方法：`select()`、`insert()`、`update()`和`delete()`。这些仍然是原始调用，但有所不同。首先，使用`update()`和`delete()`将返回受影响的行数，而`statement()`则不会；其次，使用这些方法可以让未来的开发人员更清楚地了解您正在进行的语句类型。
- en: Raw selects
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始选择
- en: 'The simplest of the specific `DB` methods is `select()`. You can run it without
    any additional parameters:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 具体的`DB`方法中最简单的是`select()`。您可以在不添加任何额外参数的情况下运行它：
- en: '[PRE47]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will return an array of `stdClass` objects.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个`stdClass`对象的数组。
- en: Parameter bindings and named bindings
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数绑定和命名绑定
- en: 'Laravel’s database architecture allows for the use of PDO (PHP data object,
    PHP’s native database access layer) parameter binding, which protects your queries
    from potential SQL attacks. Passing a parameter to a statement is as simple as
    replacing the value in your statement with a `?`, then adding the value to the
    second parameter of your call:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的数据库架构允许使用PDO（PHP数据对象，PHP的本地数据库访问层）参数绑定，这可以保护您的查询免受潜在的SQL攻击。将参数传递给语句就像在语句中用`?`替换值，然后将值添加到调用的第二个参数中：
- en: '[PRE48]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'You can also name those parameters for clarity:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为了清晰起见为这些参数命名：
- en: '[PRE49]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Raw inserts
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始插入
- en: 'From here, the raw commands all look pretty much the same. Raw inserts look
    like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，原始命令基本上都是相同的。原始插入如下所示：
- en: '[PRE50]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Raw updates
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始更新
- en: 'Updates look like this:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 更新操作如下：
- en: '[PRE51]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Raw deletes
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始删除
- en: 'And deletes look like this:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作如下所示：
- en: '[PRE52]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Chaining with the Query Builder
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用查询构建器进行链式调用
- en: Up until now, we haven’t actually used the query builder, per se. We’ve just
    used simple method calls on the `DB` facade. Let’s actually build some queries.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上还没有使用查询构建器。我们只是在`DB`门面上使用了简单的方法调用。让我们实际构建一些查询。
- en: The query builder makes it possible to chain methods together to, you guessed
    it, *build a query*. At the end of your chain you’ll use some method—likely `get()`—to
    trigger the actual execution of the query you’ve just built.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 查询构建器使得可以将方法链接在一起，以构建查询。在链的末尾，您将使用某些方法——很可能是`get()`——触发刚刚构建的查询的实际执行。
- en: 'Let’s take a look at a quick example:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个快速的示例：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we built our query—`users` table, `$type` type—​and then we executed the
    query and got our result. Note that, unlike the previous calls, this will return
    a *collection* of `stdClass` objects instead of an array.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们构建了我们的查询——`users`表，`$type`类型——然后执行了查询并得到了结果。请注意，与之前的调用不同，这将返回*collection*类型的`stdClass`对象，而不是数组。
- en: Let’s take a look at what methods the query builder allows you to chain. The
    methods can be split up into what I’ll call constraining methods, modifying methods,
    conditional methods, and ending/returning methods.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看查询构建器允许您链式调用哪些方法。这些方法可以分为我称之为约束方法、修改方法、条件方法和结束/返回方法。
- en: Constraining methods
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 约束方法
- en: 'These methods take the query as it is and constrain it to return a smaller
    subset of possible data:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法以当前查询为基础，将其约束为返回可能数据的更小子集：
- en: '`select()`'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`select()`'
- en: 'Allows you to choose which columns you’re selecting:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您选择要选择的列：
- en: '[PRE54]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`where()`'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`where()`'
- en: 'Allows you to limit the scope of what’s being returned using `WHERE`. By default,
    the signature of the `where()` method takes three parameters—the column, the comparison
    operator, and the value:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`WHERE`可以限制返回内容的范围。默认情况下，`where()`方法的签名需要三个参数——列名、比较运算符和数值：
- en: '[PRE55]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'However, if your comparison is `=`, which is the most common comparison, you
    can drop the second operator:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您的比较是`=`, 这是最常见的比较，您可以省略第二个操作符：
- en: '[PRE56]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you want to combine `where()` statements, you can either chain them after
    each other, or pass an array of arrays:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要组合`where()`语句，可以将它们依次链接在一起，或者传递一个数组的数组：
- en: '[PRE57]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`orWhere()`'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`orWhere()`'
- en: 'Creates simple `OR WHERE` statements:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 创建简单的`OR WHERE`语句：
- en: '[PRE58]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'To create a more complex `OR WHERE` statement with multiple conditions, pass
    `orWhere()` a closure:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建具有多个条件的更复杂的`OR WHERE`语句，请将`orWhere()`传递给闭包：
- en: '[PRE59]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '`whereBetween(*colName*, [*low*, *high*])`'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`whereBetween(*colName*, [*low*, *high*])`'
- en: 'Allows you to scope a query to return only rows where a column is between two
    values (inclusive of the two values):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 允许您将查询范围限定为只返回某一列在两个值之间的行（包括两个值）：
- en: '[PRE60]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The same works for `whereNotBetween()`, but it will select the inverse.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `whereNotBetween()` 同样有效，但会选择其反向操作。
- en: '`whereIn(*colName*, [*1*, *2*, *3*])`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`whereIn(*colName*, [*1*, *2*, *3*])`'
- en: 'Allows you to scope a query to return only rows where a column value is in
    an explicitly provided list of options:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你将查询范围限定为仅返回列值在显式提供的选项列表中的行：
- en: '[PRE61]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The same works for `whereNotIn()`, but it will select the inverse.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `whereNotIn()` 同样有效，但会选择其反向操作。
- en: '`whereNull(*colName*)`, `whereNotNull(*colName*)`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`whereNull(*colName*)`, `whereNotNull(*colName*)`'
- en: Allows you to select only rows where a given column is `NULL` or is `NOT NULL`,
    respectively.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你仅选择给定列为 `NULL` 或 `NOT NULL` 的行。
- en: '`whereRaw()`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`whereRaw()`'
- en: 'Allows you to pass in a raw, unescaped string to be added after the `WHERE`
    statement:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你传递一个原始、未转义的字符串，添加到 `WHERE` 语句之后：
- en: '[PRE62]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Beware of SQL Injection!
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 警惕 SQL 注入！
- en: Any SQL queries passed to `whereRaw()` will not be escaped. Use this method
    carefully and infrequently; this is a prime opportunity for SQL injection attacks
    in your app.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `whereRaw()` 的任何 SQL 查询都不会被转义。请谨慎使用这个方法，并且使用频率不高；这是你的应用中 SQL 注入攻击的一个主要机会。
- en: '`whereExists()`'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '`whereExists()`'
- en: 'Allows you to select only rows that, when passed into a provided subquery,
    return at least one row. Imagine you only want to get those users who have left
    at least one comment:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 允许你仅选择那些在提供的子查询中至少返回一行的行。想象一下，你只想获取那些至少留下一条评论的用户：
- en: '[PRE63]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '`distinct()`'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '`distinct()`'
- en: 'Selects only rows where the selected data is unique when compared to the other
    rows in the returned data. Usually this is paired with `select()`, because if
    you use a primary key, there will be no duplicated rows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 仅选择与返回数据中其他行相比具有唯一选择数据的行。通常与 `select()` 配对使用，因为如果使用主键，就不会有重复行：
- en: '[PRE64]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Modifying methods
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改方法
- en: 'These methods change the way the query’s results will be output, rather than
    just limiting its results:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法改变了查询结果输出的方式，而不仅仅限制其结果：
- en: '`orderBy(*colName*, *direction*)`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`orderBy(*colName*, *direction*)`'
- en: 'Orders the results. The second parameter may be either `asc` (the default,
    ascending order) or `desc` (descending order):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 对结果进行排序。第二个参数可以是 `asc`（默认，升序）或 `desc`（降序）：
- en: '[PRE65]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '`groupBy()`, `having()`, `havingRaw()`'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy()`, `having()`, `havingRaw()`'
- en: 'Groups your results by a column. Optionally, `having()` and `havingRaw()` allow
    you to filter your results based on properties of the groups. For example, you
    could look for only cities with at least 30 people in them:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的结果按列分组。可选地，`having()` 和 `havingRaw()` 允许你根据组的属性过滤结果。例如，你可以只查找至少有 30 个人口的城市：
- en: '[PRE66]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '`skip()`, `take()`'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip()`, `take()`'
- en: 'Most often used for pagination, these allow you to define how many rows to
    return and how many to skip before starting the return—​like a page number and
    a page size in a pagination system:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用于分页，允许你定义要返回的行数以及在开始返回之前要跳过的行数 —— 就像分页系统中的页码和页面大小：
- en: '[PRE67]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`latest(*colName*)`, `oldest(*colName*)`'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`latest(*colName*)`, `oldest(*colName*)`'
- en: Sorts by the passed column (or `created_at` if no column name is passed) in
    descending (`latest()`) or ascending (`oldest()`) order.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 按传递的列排序（如果没有传递列名，则按 `created_at`），支持降序（`latest()`）或升序（`oldest()`）：
- en: '`inRandomOrder()`'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`inRandomOrder()`'
- en: Sorts the result randomly.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 随机排序结果。
- en: Conditional methods
  id: totrans-397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 条件方法
- en: 'There are two methods that allow you to conditionally apply their “contents”
    (a closure you pass to them) based on the Boolean state of a value you pass in:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法允许你根据传入值的布尔状态有条件地应用它们的“内容”（你传递给它们的闭包）：
- en: '`when()`'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`when()`'
- en: 'Given a truthy first parameter, applies the query modification contained in
    the closure; given a falsy first parameter, it does nothing. Note that the first
    parameter could be a Boolean (e.g., `$ignoreDrafts`, set to `true` or `false`),
    an optional value (`$status`, pulled from user input and defaulting to `null`),
    or a closure that returns either; what matters is that it evaluates to truthy
    or falsy. For example:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个真值的第一个参数，应用包含在闭包中的查询修改；给定一个假值的第一个参数，它什么也不做。注意，第一个参数可以是布尔值（例如，设置为 `true`
    或 `false` 的 `$ignoreDrafts`）、可选值（从用户输入中提取的 `$status`，默认为 `null`）或返回布尔值的闭包；重要的是它评估为真或假。例如：
- en: '[PRE68]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You can also pass a third parameter, another closure, which will be applied
    only if the first parameter is falsy.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以传递第三个参数，另一个闭包，只有在第一个参数为假时才会应用。
- en: '`unless()`'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`unless()`'
- en: The exact inverse of `when()`. If the first parameter is falsy, it will run
    the second closure.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '`when()` 的确切反向操作。如果第一个参数为假，它将运行第二个闭包。'
- en: Ending/returning methods
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结束/返回方法
- en: 'These methods stop the query chain and trigger the execution of the SQL query.
    Without one of these at the end of the query chain, your return will always just
    be an instance of the query builder; chain one of these onto a query builder,
    and you’ll actually get a result:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法停止查询链并触发 SQL 查询的执行。如果在查询链的末尾没有这些方法之一，则返回值始终只是查询构建器的实例；将其中一个链到查询构建器上，你将获得一个实际的结果：
- en: '`get()`'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()`'
- en: 'Gets all results for the built query:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 获取构建查询的所有结果：
- en: '[PRE69]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`first()`, `firstOrFail()`'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`first()`，`firstOrFail()`'
- en: 'Gets only the first result—​like `get()`, but with a `LIMIT 1` added:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 仅获取第一个结果——类似于 `get()`，但添加了 `LIMIT 1`：
- en: '[PRE70]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '`first()` fails silently if there are no results, whereas `firstOrFail()` will
    throw an exception.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有结果，`first()` 会静默失败，而 `firstOrFail()` 将抛出异常。
- en: If you pass an array of column names to either method, it will return the data
    for just those columns instead of all columns.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向任一方法传递一个列名数组，它将返回仅这些列的数据，而不是所有列。
- en: '`find(*id*)`, `findOrFail(*id*)`'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`find(*id*)`，`findOrFail(*id*)`'
- en: 'Like `first()`, but you pass in an ID value that corresponds to the primary
    key to look up. `find()` fails silently if a row with that ID doesn’t exist, while
    `findOrFail()` throws an exception:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 `first()`，但你传递一个与主键对应的 ID 值来查找。如果不存在具有该 ID 的行，则 `find()` 会静默失败，而 `findOrFail()`
    将抛出异常：
- en: '[PRE71]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '`value()`'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '`value()`'
- en: 'Plucks just the value from a single field from the first row. Like `first()`,
    but if you only want a single column:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一行中的单个字段中提取值。类似于 `first()`，但如果你只想要单个列：
- en: '[PRE72]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`count()`'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`count()`'
- en: 'Returns an integer count of all of the matching results:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 返回所有匹配结果的整数计数：
- en: '[PRE73]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '`min()`, `max()`'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()`，`max()`'
- en: 'Returns the minimum or maximum value of a particular column:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 返回特定列中的最小或最大值：
- en: '[PRE74]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '`sum()`, `avg()`'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum()`，`avg()`'
- en: 'Returns the sum or average of all of the values in a particular column:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 返回特定列中所有值的总和或平均值：
- en: '[PRE75]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '`dd()`, `dump()`'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd()`，`dump()`'
- en: Dumps the underlying SQL query and the bindings, and, if using `dd()`, ends
    the script.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 显示底层的 SQL 查询和绑定，并且如果使用 `dd()`，则结束脚本。
- en: '[PRE76]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Explain Method
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释方法
- en: 'The `explain()` method returns an explanation of how SQL will execute the query.
    You can use it alongside the `dd()` or `dump()` methods to debug your query:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`explain()` 方法返回 SQL 将如何执行查询的解释。你可以将其与 `dd()` 或 `dump()` 方法一起使用来调试查询：'
- en: '[PRE77]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Writing raw queries inside query builder methods with DB::raw
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 DB::raw 在查询构建器方法中编写原始查询
- en: You’ve already seen a few custom methods for raw statements—for example, `select()`
    has a `selectRaw()` counterpart that allows you to pass in a string for the query
    builder to place after the `WHERE` statement.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了一些用于原始语句的自定义方法，例如 `select()` 有一个 `selectRaw()` 对应方法，允许你传递一个字符串给查询构建器，放置在
    `WHERE` 语句之后。
- en: 'You can also, however, pass in the result of a `DB::raw()` call to almost any
    method in the query builder to achieve the same result:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 `DB::raw()` 调用的结果传递给查询构建器中的几乎任何方法来实现相同的结果：
- en: '[PRE78]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Joins
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Joins can sometimes be a pain to define, and there’s only so much a framework
    can do to make them simpler, but the query builder does its best. Let’s look at
    a sample:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 连接有时可能很难定义，框架可以尽力简化它们，但查询构建器会尽最大努力。让我们看一个示例：
- en: '[PRE79]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The `join()` method creates an inner join. You can also chain together multiple
    joins one after another, or use `leftJoin()` to get a left join.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`join()` 方法创建内连接。你还可以依次链接多个连接，或使用 `leftJoin()` 获取左连接。'
- en: 'Finally, you can create more complex joins by passing a closure into the `join()`
    method:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过将闭包传递给 `join()` 方法，可以创建更复杂的连接：
- en: '[PRE80]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Unions
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联合
- en: 'You can union two queries (join their results together into one result set)
    by creating them first and then using the `union()` or `unionAll()` method:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过首先创建它们，然后使用 `union()` 或 `unionAll()` 方法将两个查询联合起来（将它们的结果合并为一个结果集）：
- en: '[PRE81]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Inserts
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入
- en: 'The `insert()` method is pretty simple. Pass it as an array to insert a single
    row or as an array of arrays to insert multiple rows, and use `insertGetId()`
    instead of `insert()` to get the autoincrementing primary key ID back as a return:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 方法非常简单。将其作为数组传递以插入单行，或者作为数组的数组插入多行，并使用 `insertGetId()` 而不是 `insert()`
    来获取自增的主键 ID 作为返回：'
- en: '[PRE82]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Updates
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: 'Updates are also simple. Create your update query and, instead of `get()` or
    `first()`, just use `update()` and pass it an array of parameters:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 更新也很简单。创建更新查询，而不是使用 `get()` 或 `first()`，只需使用 `update()` 并传递参数数组：
- en: '[PRE83]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'You can also quickly increment and decrement columns using the `increment()`
    and `decrement()` methods. The first parameter of each is the column name, and
    the second (optional) parameter is the number to increment/decrement by:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `increment()` 和 `decrement()` 方法快速增加和减少列。每个方法的第一个参数是列名，第二个（可选）参数是增加/减少的数字：
- en: '[PRE84]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Deletes
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除操作
- en: 'Deletes are even simpler. Build your query and then end it with `delete()`:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 删除操作更加简单。构建你的查询，然后以 `delete()` 结束：
- en: '[PRE85]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You can also truncate the table, which deletes every row and also resets the
    autoincrementing ID:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以截断表，这会删除每一行，并且重置自增 ID：
- en: '[PRE86]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: JSON operations
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JSON 操作
- en: 'If you have JSON columns, you can update or select rows based on aspects of
    the JSON structure by using the arrow syntax to traverse children:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有 JSON 列，可以使用箭头语法遍历子元素的方面来更新或选择行：
- en: '[PRE87]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Transactions
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务
- en: '*Database transactions* are tools that enable you to wrap up a series of database
    queries to be performed in a batch, which you can choose to roll back, undoing
    the entire series of queries. Transactions are often used to ensure that *all*
    or *none*, but not *some*, of a series of related queries are performed—if one
    fails, the ORM will roll back the entire series of queries.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '*数据库事务* 是一种工具，允许你将一系列数据库查询封装成批处理，你可以选择回滚，撤销整个查询系列。事务通常用于确保一系列相关查询的*全部*或*无*操作完成——如果其中一个失败，ORM
    将回滚整个查询系列。'
- en: With the Laravel query builder’s transaction feature, if any exceptions are
    thrown at any point within the transaction closure, all the queries in the transaction
    will be rolled back. If the transaction closure finishes successfully, all the
    queries will be committed and not rolled back.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Laravel 查询构建器的事务功能，如果事务闭包内的任何异常被抛出，事务中的所有查询将会回滚。如果事务闭包成功完成，所有查询将会提交而不会回滚。
- en: Let’s take a look at the sample transaction in [Example 5-17](#EX807).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 [示例 5-17](#EX807) 中的样本事务。
- en: Example 5-17\. A simple database transaction
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-17\. 一个简单的数据库事务
- en: '[PRE88]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In this example, we can assume we had some previous process that summarized
    the number of votes from the `votes` table for a given user. We want to cache
    that number in the `users` table and then wipe those votes from the `votes` table.
    But, of course, we don’t want to wipe the votes *until* the update to the `users`
    table has run successfully. And we don’t want to keep the updated number of votes
    in the `users` table if the `votes` table deletion fails.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以假设之前的某个过程总结了 `votes` 表中给定用户的投票数。我们想把这个数字缓存到 `users` 表中，然后从 `votes`
    表中清除这些投票。但是，当然，在成功运行到 `users` 表的更新之前，我们不想清除投票。如果 `votes` 表的删除操作失败，我们也不想在 `users`
    表中保留更新后的投票数。
- en: If anything goes wrong with either query, the other won’t be applied. That’s
    the magic of database transactions.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何一个查询出现问题，另一个都不会被应用。这就是数据库事务的魔力。
- en: 'Note that you can also manually begin and end transactions—and this applies
    for both query builder queries and Eloquent queries. Start with `DB::beginTransaction()`,
    end with `DB::commit()`, and abort with `DB::rollBack()`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你也可以手动开始和结束事务——这对于查询构建器和 Eloquent 查询都适用。以 `DB::beginTransaction()` 开始，以 `DB::commit()`
    结束，以 `DB::rollBack()` 中止：
- en: '[PRE89]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Introduction to Eloquent
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eloquent 简介
- en: Now that we’ve covered the query builder, let’s talk about Eloquent, Laravel’s
    flagship database tool that’s built on the query builder.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了查询构建器，让我们来谈谈 Eloquent，Laravel 的旗舰数据库工具，它是建立在查询构建器基础上的。
- en: Eloquent is an *ActiveRecord ORM*, which means it’s a database abstraction layer
    that provides a single interface to interact with multiple database types. “ActiveRecord”
    means that a single Eloquent class is responsible for not only providing the ability
    to interact with the table as a whole (e.g., `User::all()` gets all users), but
    also representing an individual table row (e.g., `$sharon = new User`). Additionally,
    each instance is capable of managing its own persistence; you can call `$sharon->save()`
    or `$sharon``->``delete()`.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 是一个 *ActiveRecord ORM*，这意味着它是一个数据库抽象层，提供了与多种数据库类型交互的单一接口。“ActiveRecord”意味着单个
    Eloquent 类不仅负责提供与整个表交互的能力（例如 `User::all()` 获取所有用户），还代表一个单独的表行（例如 `$sharon = new
    User`）。此外，每个实例都能够管理自己的持久性；你可以调用 `$sharon->save()` 或 `$sharon->delete()`。
- en: Eloquent has a primary focus on simplicity, and like the rest of the framework,
    it relies on “convention over configuration” to allow you to build powerful models
    with minimal code.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent主要关注简单性，并且像框架的其余部分一样，它依赖于“约定优于配置”，以允许您用最少的代码构建强大的模型。
- en: For example, you can perform all of the operations in [Example 5-19](#EX809)
    with the model defined in [Example 5-18](#EX808).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用在[示例5-18](#EX808)中定义的模型执行[示例5-19](#EX809)中的所有操作。
- en: Example 5-18\. The simplest Eloquent model
  id: totrans-480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-18。最简单的Eloquent模型
- en: '[PRE90]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Example 5-19\. Operations achievable with the simplest Eloquent model
  id: totrans-482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-19。使用最简单的Eloquent模型可以实现的操作
- en: '[PRE91]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: How? Convention. Eloquent assumes the table name (`Contact` becomes `contacts`),
    and with that, you have a fully functional Eloquent model.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 怎么做？约定。Eloquent假设表名（`Contact`变成`contacts`），然后你就有了一个完全功能的Eloquent模型。
- en: Let’s cover how we work with Eloquent models.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们介绍如何使用Eloquent模型。
- en: Creating and Defining Eloquent Models
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和定义Eloquent模型
- en: 'First, let’s create a model. There’s an Artisan command for that:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个模型。有一个Artisan命令可以做到这一点：
- en: '[PRE92]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'This is what we’ll get, in *app/Models/Contact.php*:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将得到的，在*app/Models/Contact.php*中：
- en: '[PRE93]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Creating a Migration Along with Your Model
  id: totrans-491
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建迁移及其模型
- en: 'If you want to automatically create a migration when you create your model,
    pass the `-m` or `--migration` flag:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在创建模型时自动创建一个迁移，请传递`-m`或`--migration`标志：
- en: '[PRE94]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Table name
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表名
- en: 'The default behavior for table names is that Laravel “snake cases” and pluralizes
    your class name, so `SecondaryContact` would access a table named `secondary_contacts`.
    If you’d like to customize the name, set the `$table` property explicitly on the
    model:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 表名的默认行为是，Laravel会将你的类名“蛇形命名”并将其复数化，因此`SecondaryContact`将访问名为`secondary_contacts`的表。如果你想自定义名称，请在模型上显式设置`$table`属性：
- en: '[PRE95]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Primary key
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主键
- en: Laravel assumes, by default, that each table will have an autoincrementing integer
    primary key, and it will be named `id`.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Laravel假定每个表都将具有自动递增的整数主键，并将其命名为`id`。
- en: 'If you want to change the name of your primary key, change the `$primaryKey`
    property:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更改主键的名称，请更改`$primaryKey`属性：
- en: '[PRE96]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'And if you want to set it to be nonincrementing, use:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将其设置为非自增，使用：
- en: '[PRE97]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Timestamps
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间戳
- en: 'Eloquent expects every table to have `created_at` and `updated_at` timestamp
    columns. If your table won’t have them, disable the `$timestamps` functionality:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent期望每个表都有`created_at`和`updated_at`时间戳列。如果你的表不需要它们，可以禁用`$timestamps`功能：
- en: '[PRE98]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'You can customize the format Eloquent uses to store your timestamps to the
    database by setting the `$dateFormat` class property to a custom string. The string
    will be parsed using PHP’s `date()` syntax, so the following example will store
    the date as seconds since the Unix epoch:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将`$dateFormat`类属性设置为自定义字符串来自定义Eloquent用于将时间戳存储到数据库中的格式。该字符串将使用PHP的`date()`语法进行解析，因此以下示例将日期存储为自Unix纪元以来的秒数：
- en: '[PRE99]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Retrieving Data with Eloquent
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Eloquent检索数据
- en: Most of the time when you pull data from your database with Eloquent, you’ll
    use static calls on your Eloquent model.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Eloquent从数据库中提取数据时，大多数时候会在你的Eloquent模型上使用静态调用。
- en: 'Let’s start by getting everything:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从获取所有内容开始：
- en: '[PRE100]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'That was easy. Let’s filter it a bit:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 那很容易。让我们稍微过滤一下：
- en: '[PRE101]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We can see that the `Eloquent` facade gives us the ability to chain constraints,
    and from there the constraints get very familiar:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`Eloquent`Facade使我们能够链式约束，从而使约束变得非常熟悉：
- en: '[PRE102]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: It turns out that once you move past the initial facade name, you’re just working
    with Laravel’s query builder. You can do a lot more—we’ll cover that soon—but
    everything you can do with the query builder on the `DB` facade, you also can
    do on your Eloquent objects.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，一旦你超越了最初的Facade名称，你只是在使用Laravel的查询构建器。你可以做更多的事情——我们很快会涵盖这一点——但是你可以在`DB`Facade上使用查询构建器的一切操作，同样也可以在你的Eloquent对象上使用。
- en: Get one
  id: totrans-517
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取一个
- en: Like we covered earlier in the chapter, you can use `first()` to return only
    the first record from a query, or use `find()` to pull just the record with the
    provided ID. For either, if you append “OrFail” to the method name, it will throw
    an exception if there are no matching results. This makes `findOrFail()` a common
    tool for looking up an entity by a URL segment (or throwing an exception if a
    matching entity doesn’t exist), like you can see in [Example 5-20](#EX810).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章早些时候介绍的，你可以使用 `first()` 只返回查询的第一条记录，或者使用 `find()` 仅检索提供的 ID 对应的记录。对于任何一个方法，如果在方法名称后添加“OrFail”，则如果没有匹配结果，它将抛出异常。这使得
    `findOrFail()` 成为通过 URL 段查找实体（或者如果找不到匹配的实体则抛出异常）的常用工具，正如你可以在 [示例 5-20](#EX810)
    中看到的。
- en: Example 5-20\. Using an Eloquent `OrFail()` method in a controller method
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-20\. 在控制器方法中使用 Eloquent 的 `OrFail()` 方法
- en: '[PRE103]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Any method intended to return a single record (`first()`, `firstOrFail()`, `find()`,
    or `findOrFail()`) will return an instance of the Eloquent class. So, `Contact::first()`
    will return an instance of the class `Contact` with the data from the first row
    in the table filling it out.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 任何意图返回单个记录的方法（`first()`、`firstOrFail()`、`find()` 或 `findOrFail()`）将返回 Eloquent
    类的实例。因此，`Contact::first()` 将返回填充了表中第一行数据的 `Contact` 类的实例。
- en: 'You can also use the `firstWhere()` method, which is a shortcut combining `where()`
    and `first()`:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `firstWhere()` 方法，它是 `where()` 和 `first()` 结合的快捷方式：
- en: '[PRE104]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Exceptions
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常
- en: As you can see in [Example 5-20](#EX810), we don’t need to catch Eloquent’s
    model not found exception (`Illuminate\Database\Eloquent``\ModelNotFoundException)`
    in our controllers; Laravel’s routing system will catch it and throw a 404 for
    us.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以在 [示例 5-20](#EX810) 中看到的，我们不需要在我们的控制器中捕获 Eloquent 的模型未找到异常（`Illuminate\Database\Eloquent\ModelNotFoundException`）；Laravel
    的路由系统将捕获它并为我们抛出 404。
- en: You could, of course, catch that particular exception and handle it, if you’d
    like.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以捕获特定的异常并处理它，如果你愿意的话。
- en: Get many
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取多个
- en: '`get()` works with Eloquent just like it does in normal query builder calls—build
    a query and call `get()` at the end to get the results:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`get()` 在 Eloquent 中的工作方式与普通查询构建器调用中的工作方式相同——构建一个查询，并在末尾调用 `get()` 来获取结果：'
- en: '[PRE105]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'However, there is an Eloquent-only method, `all()`, which you’ll often see
    people use when they want to get an unfiltered list of all data in the table:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个仅限于 Eloquent 的方法 `all()`，当人们希望获取表中所有数据的未过滤列表时，经常会看到它：
- en: '[PRE106]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Using get() Instead of all()
  id: totrans-532
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `get()` 替代 `all()`
- en: Any time you can use `all()`, you could use `get()`. `Contact::get()` has the
    same response as `Contact::all()`. However, the moment you start modifying your
    query—​adding a `where()` filter, for example—`all()` will no longer work, but
    `get()` will continue working.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 任何时候你可以使用 `all()`，你也可以使用 `get()`。`Contact::get()` 的响应与 `Contact::all()` 相同。然而，一旦你开始修改你的查询——例如添加一个
    `where()` 过滤器，`all()` 将不再工作，但 `get()` 仍将继续工作。
- en: So, even though `all()` is very common, I’d recommend using `get()` for everything
    and ignoring the fact that `all()` even exists.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，尽管 `all()` 非常常见，我建议一切都使用 `get()`，并忽略 `all()` 的存在。
- en: Chunking responses with chunk()
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `chunk()` 分块响应
- en: If you’ve ever needed to process a large amount (thousands or more) of records
    at a time, you may have run into memory or locking issues. Laravel makes it possible
    to break your requests into smaller pieces (chunks) and process them in batches,
    keeping the memory load of your large request smaller. [Example 5-21](#EX811)
    illustrates the use of `chunk()` to split a query into “chunks” of 100 records
    each.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经需要一次处理大量（数千或更多）的记录，可能会遇到内存或锁定问题。Laravel 允许你将请求分成较小的片段（块）并批量处理它们，从而减少大请求的内存负载。[示例 5-21](#EX811)
    演示了如何使用 `chunk()` 将查询分成每个包含 100 条记录的“块”。
- en: Example 5-21\. Chunking an Eloquent query to limit memory usage
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-21\. 将 Eloquent 查询分块以限制内存使用
- en: '[PRE107]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Aggregates
  id: totrans-539
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 聚合
- en: 'The aggregates that are available on the query builder are available on Eloquent
    queries as well. For example:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 查询构建器上可用的聚合函数也可以在 Eloquent 查询上使用。例如：
- en: '[PRE108]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Inserts and Updates with Eloquent
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Eloquent 进行插入和更新
- en: Inserting and updating values is one of the places where Eloquent starts to
    diverge from normal query builder syntax.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 插入和更新值是 Eloquent 开始与普通查询构建器语法分离的地方之一。
- en: Inserts
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插入
- en: There are two primary ways to insert a new record using Eloquent.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Eloquent 插入新记录有两种主要方式。
- en: First, you can create a new instance of your Eloquent class, set your properties
    manually, and call `save()` on that instance, like in [Example 5-22](#EX812).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以创建你的Eloquent类的新实例，手动设置属性，然后在该实例上调用`save()`，就像在[示例 5-22](#EX812)中一样。
- en: Example 5-22\. Inserting an Eloquent record by creating a new instance
  id: totrans-547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-22\. 通过创建新实例插入Eloquent记录
- en: '[PRE109]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Until you `save()`, this instance of `Contact` represents the contact fully—​except
    it has never been saved to the database. That means it doesn’t have an `id`, it
    won’t persist if the application quits, and it doesn’t have its `created_at` and
    `updated_at` values set.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 直到你调用`save()`之前，这个`Contact`实例完全代表了这个联系人，但它尚未保存到数据库中。这意味着它没有`id`，如果应用程序退出，它将不会持久存在，并且它的`created_at`和`updated_at`值也没有设置。
- en: You can also pass an array to `Model::create()`, as shown in [Example 5-23](#EX813).
    Unlike `make()`, `create()` saves the instance to the database as soon as it’s
    called.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像在[示例 5-23](#EX813)中展示的那样，将数组传递给`Model::create()`。与`make()`不同，`create()`在调用时会将实例保存到数据库中。
- en: Example 5-23\. Inserting an Eloquent record by passing an array to `create()`
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-23\. 通过将数组传递给`create()`插入Eloquent记录
- en: '[PRE110]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Also be aware that in any context where you are passing an array (to `new Model()`,
    `Model::make()`, `Model::create()`, or `Model::update()`), every property you
    set via `Model::create()` has to be approved for “mass assignment,” which we’ll
    cover shortly. This is not necessary with the first example in [Example 5-22](#EX812),
    where you assign each property individually.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在任何传递数组的上下文中（例如`new Model()`，`Model::make()`，`Model::create()`或`Model::update()`），你通过`Model::create()`设置的每个属性都必须经过“批量赋值”批准，我们稍后会介绍。在[示例
    5-22](#EX812)中的第一个示例中，这是不必要的，因为你可以单独分配每个属性。
- en: Note that if you’re using `Model::create()`, you don’t need to `save()` the
    instance—​that’s handled as a part of the model’s `create()` method.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你使用`Model::create()`，你不需要调用`save()`方法—​这是作为模型的`create()`方法的一部分处理的。
- en: Updates
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新
- en: Updating records looks very similar to inserting. You can get a specific instance,
    change its properties, and then save, or you can make a single call and pass an
    array of updated properties. [Example 5-24](#EX814) illustrates the first approach.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 更新记录看起来与插入非常相似。你可以获取一个特定实例，更改其属性，然后保存，或者你可以进行一次调用并传递一组更新后的属性。[示例 5-24](#EX814)说明了第一种方法。
- en: Example 5-24\. Updating an Eloquent record by updating an instance and saving
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-24\. 通过更新实例并保存来更新Eloquent记录
- en: '[PRE111]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Since this record already exists, it will already have a `created_at` timestamp
    and an `id`, which will stay the same, but the `updated_at` field will be changed
    to the current date and time. [Example 5-25](#EX815) illustrates the second approach.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此记录已经存在，它已经具有`created_at`时间戳和`id`，这些将保持不变，但`updated_at`字段将更改为当前日期和时间。[示例 5-25](#EX815)说明了第二种方法。
- en: Example 5-25\. Updating one or more Eloquent records by passing an array to
    the `update()` method
  id: totrans-560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-25\. 通过将数组传递给`update()`方法更新一个或多个Eloquent记录
- en: '[PRE112]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: This method expects an array where each key is the column name and each value
    is the column value.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法期望一个数组，其中每个键是列名，每个值是列值。
- en: Mass assignment
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批量赋值
- en: We’ve looked at a few examples of how to pass arrays of values into Eloquent
    class methods. However, none of these will actually work until you define which
    fields are “fillable” on the model.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过几个例子，演示了如何将值数组传递给Eloquent类方法。然而，在你定义模型上哪些字段是“fillable”之前，这些例子都不会真正起作用。
- en: The goal of this is to protect you from (possibly malicious) user input accidentally
    setting new values on fields you don’t want changed. Consider the common scenario
    in [Example 5-26](#EX816).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的目的是保护你免受（可能是恶意的）用户输入意外设置你不想更改的字段的新值。考虑在[示例 5-26](#EX816)中的常见场景。
- en: Example 5-26\. Updating an Eloquent model using the entirety of a request’s
    input
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-26\. 使用请求输入的全部内容更新Eloquent模型
- en: '[PRE113]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The Illuminate `Request` object in [Example 5-26](#EX816) will take every piece
    of user input and pass it to the `update()` method. That `all()` method includes
    things like URL parameters and form inputs, so a malicious user could easily add
    some things in there, like `id` and `owner_id`, that you likely don’t want updated.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: Illuminate的`Request`对象在[示例 5-26](#EX816)中将用户输入的每一部分传递给`update()`方法。该`all()`方法包括诸如URL参数和表单输入之类的内容，因此恶意用户可以轻松添加一些东西，例如`id`和`owner_id`，这些你可能不希望更新。
- en: Thankfully, that won’t actually work until you define your model’s fillable
    fields. You can either define the allowed “fillable fields or the disallowed *guarded*
    fields to determine which fields” can or cannot be edited via mass *assignment*—that
    is, by passing an array of values into either `create()` or `update()`. Note that
    nonfillable properties can still be changed by direct assignment (e.g., `$contact->password
    = '*abc*';`). [Example 5-27](#EX817) shows both approaches.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在定义模型的可填充字段之前，这实际上不起作用。您可以定义允许的“可填充字段或不允许的 *受保护* 字段，以确定哪些字段可以或不可以通过批量 *赋值*（即通过将值数组传递到
    `create()` 或 `update()`）进行编辑。请注意，非可填充属性仍然可以通过直接赋值进行更改（例如，`$contact->password =
    '*abc*';`）。[示例 5-27](#EX817) 展示了两种方法。
- en: Example 5-27\. Using Eloquent’s fillable or guarded properties to define mass-assignable
    fields
  id: totrans-570
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-27\. 使用 Eloquent 的可填充或受保护属性来定义可批量赋值的字段
- en: '[PRE114]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Using Request::only() with Eloquent Mass Assignment
  id: totrans-572
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Request::only() 与 Eloquent 批量赋值
- en: In [Example 5-26](#EX816), we needed Eloquent’s mass-assignment guard because
    we were using the `all()` method on the `Request` object to pass in the *entirety*
    of the user input.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [示例 5-26](#EX816) 中，我们需要使用 Eloquent 的批量赋值保护，因为我们正在使用 `Request` 对象上的 `all()`
    方法来传递用户输入的 *全部内容*。
- en: Eloquent’s mass-assignment protection is a great tool here, but there’s also
    a helpful trick to keep you from accepting any old input from the user.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 的批量赋值保护在这里是一个很好的工具，但还有一个有用的技巧可以防止您接受用户输入的任何旧数据。
- en: 'The `Request` class has an `only()` method that allows you to pluck only a
    few keys from the user input. So now you can do this:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request` 类具有 `only()` 方法，允许您从用户输入中仅提取几个键。现在您可以这样做：'
- en: '[PRE115]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: firstOrCreate() and firstOrNew()
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: firstOrCreate() 和 firstOrNew()
- en: Sometimes you want to tell your application, “Get me an instance with these
    properties, or if it doesn’t exist, create it.” This is where the `firstOr*()`
    methods come in.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您希望告诉应用程序，“使用这些属性获取一个实例，如果不存在，则创建它。”这就是 `firstOr*()` 方法发挥作用的地方。
- en: 'The `firstOrCreate()` and `firstOrNew()` methods take an array of keys and
    values as their first parameter:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`firstOrCreate()` 和 `firstOrNew()` 方法将一个键值对数组作为它们的第一个参数：'
- en: '[PRE116]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: They’ll both look for and retrieve the first record matching those parameters,
    and if there are no matching records, they’ll create an instance with those properties;
    `firstOrCreate()` will persist that instance to the database and then return it,
    while `firstOrNew()` will return it without saving it.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都会查找并检索与这些参数匹配的第一条记录，如果没有匹配的记录，则会创建一个具有这些属性的实例；`firstOrCreate()` 将将该实例持久化到数据库中然后返回它，而
    `firstOrNew()` 则会返回它而不保存它。
- en: If you pass an array of values as the second parameter, those values will be
    added to the created entry (if it’s created) but *won’t* be used to look up whether
    the entry exists.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将值数组作为第二个参数传递，这些值将被添加到创建的条目中（如果已创建），但 *不* 用于查找条目是否存在。
- en: Deleting with Eloquent
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Eloquent 进行删除
- en: Deleting with Eloquent is very similar to updating with Eloquent, but with (optional)
    soft deletes, you can archive your deleted items for later inspection or even
    recovery.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Eloquent 进行删除与使用 Eloquent 进行更新非常相似，但是通过（可选的）软删除，您可以将已删除的项目归档以供以后检查甚至恢复。
- en: Normal deletes
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 普通删除
- en: 'The simplest way to delete a model record is to call the `delete()` method
    on the instance itself:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 删除模型记录的最简单方法是在实例本身上调用 `delete()` 方法：
- en: '[PRE117]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'However, if you only have the ID, there’s no reason to look up an instance
    just to delete it; you can pass an ID or an array of IDs to the model’s `destroy()`
    method to delete them directly:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您只有 ID，则没有理由查找实例只是为了删除它；您可以将 ID 或 ID 数组传递给模型的 `destroy()` 方法，直接删除它们：
- en: '[PRE118]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Finally, you can delete all of the results of a query:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以删除查询的所有结果：
- en: '[PRE119]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Soft deletes
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软删除
- en: '*Soft deletes* mark database rows as deleted without actually deleting them
    from the database. This gives you the ability to inspect them later, to have records
    that show more than “no information, deleted” when displaying historic information,
    and to allow your users (or admins) to restore some or all data.'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '*软删除* 将数据库行标记为已删除，但实际上并未从数据库中删除它们。这使您可以以后检查它们，以便在显示历史信息时显示比“无信息，已删除”更多的记录，并允许用户（或管理员）恢复一些或所有数据。'
- en: The hard part about handcoding an application with soft deletes is that *every
    query* you ever write will need to exclude the soft-deleted data. Thankfully,
    if you use Eloquent’s soft deletes, every query you ever make will be scoped to
    ignore soft deletes by default, unless you explicitly ask to bring them back.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 手动编写启用软删除的应用程序的难点在于，*每个查询*你所写的都需要排除软删除的数据。幸运的是，如果你使用Eloquent的软删除，除非显式要求将它们重新引入，否则你所做的每个查询都会默认排除软删除的数据。
- en: Eloquent’s soft delete functionality requires a `deleted_at` column to be added
    to the table. Once you enable soft deletes on that Eloquent model, every query
    you ever write (unless you explicitly include soft-deleted records) will be scoped
    to ignore soft-deleted rows.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent的软删除功能要求在表中添加`deleted_at`列。一旦在Eloquent模型上启用了软删除，除非显式包含软删除的记录，否则你编写的每个查询都将被作用域限制以忽略软删除的行。
- en: Enabling soft deletes
  id: totrans-596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 启用软删除
- en: 'You enable soft deletes by doing two things: adding the `deleted_at` column
    in a migration and importing the `SoftDeletes` trait in the model. There’s a `softDeletes()`
    method available on the schema builder to add the `deleted_at` column to a table,
    as you can see in [Example 5-28](#EX818). [Example 5-29](#EX819) shows an Eloquent
    model with soft deletes enabled.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用软删除，需要做两件事情：在迁移中添加`deleted_at`列，并在模型中导入`SoftDeletes`特性。在模式生成器上有一个`softDeletes()`方法可以用来向表中添加`deleted_at`列，就像你在[示例
    5-28](#EX818)中看到的那样。[示例 5-29](#EX819)展示了启用软删除的Eloquent模型。
- en: Example 5-28\. Migration to add the soft delete column to a table
  id: totrans-598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-28\. 添加软删除列到表的迁移
- en: '[PRE120]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Example 5-29\. An Eloquent model with soft deletes enabled
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-29\. 启用软删除的Eloquent模型
- en: '[PRE121]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Once you make these changes, every `delete()` and `destroy()` call will now
    set the `deleted_at` column on your row to be the current date and time instead
    of deleting that row. And all future queries will exclude that row as a result.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你进行这些更改，每次调用`delete()`和`destroy()`将会将你的行的`deleted_at`列设置为当前日期和时间，而不是删除该行。随后的所有查询将会因此排除该行。
- en: Querying with soft deletes
  id: totrans-603
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用软删除进行查询
- en: So, how do we get soft-deleted items?
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何获取软删除的条目呢？
- en: 'First, you can add soft-deleted items to a query:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可以将软删除的条目添加到查询中：
- en: '[PRE122]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Next, you can use the `trashed()` method to see if a particular instance has
    been soft-deleted:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以使用`trashed()`方法来查看特定实例是否已被软删除：
- en: '[PRE123]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Finally, you can get *only* soft-deleted items:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以*仅仅*获取软删除的条目：
- en: '[PRE124]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Restoring soft-deleted entities
  id: totrans-611
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 恢复软删除的实体
- en: 'If you want to restore a soft-deleted item, you can run `restore()` on an instance
    or a query:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要恢复一个软删除的条目，可以在实例或查询上运行`restore()`：
- en: '[PRE125]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Force-deleting soft-deleted entities
  id: totrans-614
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 强制删除软删除的实体
- en: 'You can delete a soft-deleted entity by calling `forceDelete()` on an entity
    or query:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在实体或查询上调用`forceDelete()`来删除软删除的实体：
- en: '[PRE126]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Scopes
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作用域
- en: We’ve covered “filtered” queries, meaning any query where we’re not just returning
    every result for a table. But every time we’ve written them so far in this chapter,
    it’s been a manual process using the query builder.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了“过滤”查询，意味着任何不仅仅返回表中每个结果的查询。但到目前为止，在本章中编写它们时，使用的都是手动的查询构建器过程。
- en: Local and global scopes in Eloquent allow you to define prebuilt *scopes* (filters)
    that you can use either every time a model is queried (global) or every time you
    query it with a particular method chain (local).
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent中的局部和全局作用域允许你定义预定义的*作用域*（过滤器），你可以在每次查询模型时使用（全局），或者在使用特定方法链查询时使用（局部）。
- en: Local scopes
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部作用域
- en: 'Local scopes are the simplest to understand. Let’s take this example:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 局部作用域是最容易理解的。让我们来看这个例子：
- en: '[PRE127]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: First of all, if we write this combination of query methods over and over, it
    will get tedious. But additionally, the *knowledge* of how to define someone being
    an “active VIP” is now spread around our application. We want to centralize that
    knowledge. What if we could just write this?
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果我们一遍又一遍地编写这些查询方法的组合，将会变得很烦琐。而且，定义“活跃VIP”的知识现在散布在我们的整个应用程序中。我们希望将这些知识集中化。如果我们可以只写这样一段代码呢？
- en: '[PRE128]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: We can—it’s called a local scope. And it’s easy to define on the `Contact` class,
    as you can see in [Example 5-30](#EX5d).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做——称之为局部作用域。并且在`Contact`类上定义起来很容易，就像你在[示例 5-30](#EX5d)中看到的那样。
- en: Example 5-30\. Defining a local scope on a model
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-30\. 在模型上定义局部作用域
- en: '[PRE129]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: To define a local scope, we add a method to the Eloquent class that begins with
    “scope” and then contains the Pascal case version of the scope name. This method
    is passed a query builder and needs to return a query builder, but of course you
    can modify the query before returning—​that’s the whole point.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个本地作用域，我们在Eloquent类中添加一个以“scope”开头并包含作用域名称的Pascal case版本的方法。该方法传递一个查询构建器，并需要返回一个查询构建器，当然你可以在返回之前修改查询——这就是整个意义所在。
- en: You can also define scopes that accept parameters, as shown in [Example 5-31](#EX5e).
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以定义接受参数的作用域，示例见[示例 5-31](#EX5e)。
- en: Example 5-31\. Passing parameters to scopes
  id: totrans-630
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-31\. 向作用域传递参数
- en: '[PRE130]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'And you use them in the same way, just passing the parameter to the scope:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以以相同的方式使用它们，只需将参数传递给作用域即可：
- en: '[PRE131]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: You can also chain `orWhere()` between two local scopes.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在两个本地作用域之间链式使用`orWhere()`。
- en: '[PRE132]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Global scopes
  id: totrans-636
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局作用域
- en: Remember how we talked about soft deletes only working if you scope *every query*
    on the model to ignore the soft-deleted items? That’s a global scope. And we can
    define our own global scopes, which will be applied on every query made from a
    given model.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们之前谈到的软删除只在将每个模型上的每个查询范围限制为忽略软删除项时才起作用？这就是一个全局作用域。我们可以定义自己的全局作用域，将其应用于来自给定模型的每个查询。
- en: 'There are two ways to define a global scope: using a closure or using an entire
    class. In each, you’ll register the defined scope in the model’s `booted()` method.
    Let’s start with the closure method, illustrated in [Example 5-32](#EX820).'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 定义全局作用域有两种方法：使用闭包或使用整个类。在每种情况下，你都将在模型的`booted()`方法中注册定义的作用域。让我们从闭包方法开始，示例见[示例 5-32](#EX820)。
- en: Example 5-32\. Adding a global scope using a closure
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-32\. 使用闭包添加全局作用域
- en: '[PRE133]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: That’s it. We just added a global scope named `active`, and now every query
    on this model will be scoped to only rows with `active` set to `true`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。我们刚刚添加了一个名为`active`的全局作用域，现在这个模型上的每个查询都将仅限于`active`设置为`true`的行。
- en: Next, let’s try the longer way, as shown in [Example 5-33](#EX21). Run the following
    command to create a class called ActiveScope.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试更长的方法，如[示例 5-33](#EX21)所示。运行以下命令来创建一个名为ActiveScope的类。
- en: '[PRE134]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: It will have an `apply()` method that takes an instance of a query builder and
    an instance of the model.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 它将具有一个`apply()`方法，该方法接受一个查询构建器的实例和模型的实例。
- en: Example 5-33\. Creating a global scope class
  id: totrans-645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-33\. 创建一个全局作用域类
- en: '[PRE135]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: To apply this scope to a model, once again override the parent’s `booted()`
    method and call `addGlobalScope()` on the class using `static`, as shown in [Example 5-34](#EX22).
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 要将此作用域应用于模型，再次重写父类的`booted()`方法，并在类上使用`static`调用`addGlobalScope()`，示例见[示例 5-34](#EX22)。
- en: Example 5-34\. Applying a class-based global scope
  id: totrans-648
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-34\. 应用基于类的全局作用域
- en: '[PRE136]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Contact with No Namespace
  id: totrans-650
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 没有命名空间的联系人
- en: You may have noticed that several of these examples have used the class `Contact`,
    with no namespace. This is abnormal, and I’ve only done this to save space in
    the book. Normally, even your top-level models would live at something like `App\Models\Contact`.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，几个示例中都使用了没有命名空间的`Contact`类。这是不正常的，我之所以这样做是为了节省书中的空间。通常，即使是你顶层的模型也应该位于像`App\Models\Contact`这样的命名空间下。
- en: Removing global scopes
  id: totrans-652
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除全局作用域
- en: 'There are three ways to remove a global scope, and all three use either the
    `withoutGlobalScope()` or `withoutGlobalScopes()` method. If you’re removing a
    closure-based scope, the first parameter of that scope’s `addGlobalScope()` registration
    will be the key you used to enable it:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法可以移除全局作用域，所有方法都使用`withoutGlobalScope()`或`withoutGlobalScopes()`。如果你要移除基于闭包的作用域，那么该作用域的`addGlobalScope()`注册的第一个参数将是你用来启用它的键：
- en: '[PRE137]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'If you’re removing a single class-based global scope, you can pass the class
    name to `withoutGlobalScope()` or `withoutGlobalScopes()`:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你要移除单个基于类的全局作用域，你可以将类名传递给`withoutGlobalScope()`或`withoutGlobalScopes()`：
- en: '[PRE138]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Or, you can just disable all global scopes for a query:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以仅在查询中禁用所有全局作用域：
- en: '[PRE139]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Customizing Field Interactions with Accessors, Mutators, and Attribute Casting
  id: totrans-659
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用访问器、修改器和属性类型转换自定义字段交互
- en: Now that we’ve covered how to get records into and out of the database with
    Eloquent, let’s talk about decorating and manipulating the individual attributes
    on your Eloquent models.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何使用Eloquent将记录存入和从数据库中取出，接下来让我们来讨论如何装饰和操作你的Eloquent模型的各个属性。
- en: Accessors, mutators, and attribute casting all allow you to customize the way
    individual attributes of Eloquent instances are input or output. Without using
    any of these, each attribute of your Eloquent instance is treated like a string,
    and you can’t have any attributes on your models that don’t exist on the database.
    But we can change that.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 访问器、变动器和属性转换都允许你自定义 Eloquent 实例的各个属性的输入或输出方式。如果不使用这些功能，你的每个 Eloquent 实例的属性都将被视为字符串，且不能在模型上有任何数据库中不存在的属性。但我们可以改变这一点。
- en: Accessors
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问器
- en: '*Accessors* allow you to define custom attributes on your Eloquent models for
    when you are *reading* data from the model instance. This may be because you want
    to change how a particular column is output, or because you want to create a custom
    attribute that doesn’t exist in the database table at all.'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '*访问器* 允许你为从模型实例 *读取* 数据时在你的 Eloquent 模型上定义自定义属性。这可能是因为你想改变特定列的输出方式，或者因为你想创建一个数据库表中根本不存在的自定义属性。'
- en: You define an accessor by creating a method on your model with the name that
    is your property name, but camelCased. So, if your property name is `first_name`,
    the accessor method would be named `firstName`. Then, this method needs to have
    its return type show that it returns an instance of `Illuminate\Database\Eloquent\Casts\Attribute`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在模型上创建一个方法来定义访问器，方法名与属性名相同，但采用驼峰命名。因此，如果你的属性名是 `first_name`，访问器方法将命名为 `firstName`。然后，该方法需要有返回类型，表明它返回
    `Illuminate\Database\Eloquent\Casts\Attribute` 的实例。
- en: Let’s try it out. First, we’ll decorate a preexisting column ([Example 5-35](#EX823)).
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。首先，我们将装饰一个预先存在的列（[Example 5-35](https://example.org/#EX823)）。
- en: Example 5-35\. Decorating a preexisting column using Eloquent accessors
  id: totrans-666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-35\. 使用 Eloquent 访问器装饰预先存在的列
- en: '[PRE140]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: But we can also use accessors to define attributes that never existed in the
    database, as seen in [Example 5-36](#EX824).
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以使用访问器定义从未在数据库中存在的属性，正如在 [Example 5-36](https://example.org/#EX824) 中所见。
- en: Example 5-36\. Defining an attribute with no backing column using Eloquent accessors
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-36\. 使用 Eloquent 访问器定义没有后备列的属性
- en: '[PRE141]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Mutators
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变动器
- en: '*Mutators* work the same way as accessors, except they’re for determining how
    to process *setting* the data instead of *getting* it. Just like with accessors,
    you can use them to modify the process of writing data to existing columns, or
    to allow for setting columns that don’t exist in the database.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '*变动器* 与访问器的工作方式相同，不同之处在于它们用于确定如何处理 *设置* 数据，而不是 *获取* 数据。与访问器一样，你可以使用它们修改写入现有列数据的过程，或者允许设置数据库中不存在的列。'
- en: Mutators are defined the same way as accessors, but instead of the `get` parameter,
    we’ll be setting the `set` parameter.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 变动器的定义方式与访问器相同，但不使用 `get` 参数，而是使用 `set` 参数。
- en: Let’s try it out. First, we’ll add a constraint to updating a preexisting column
    ([Example 5-37](#EX825)).
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。首先，我们将添加对更新预先存在列的约束（[Example 5-37](https://example.org/#EX825)）。
- en: Example 5-37\. Modifying setting the value of an attribute using Eloquent mutators
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-37\. 修改使用 Eloquent 变动器设置属性的值
- en: '[PRE142]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Now let’s add a proxy column for setting, as shown in [Example 5-38](#EX826).
    If we’re setting values on more than one column at the same time, or if we’re
    customizing the name of the column we’re setting, we can return an array from
    the `set()` method.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加一个代理列用于设置，如 [Example 5-38](https://example.org/#EX826) 所示。如果我们一次设置多个列的值，或者我们自定义要设置的列的名称，我们可以从
    `set()` 方法返回一个数组。
- en: Example 5-38\. Allowing for setting the value of a nonexistent attribute using
    Eloquent mutators
  id: totrans-678
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-38\. 使用 Eloquent 变动器允许设置不存在属性的值
- en: '[PRE143]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: As you can probably guess, it’s relatively uncommon to create a mutator for
    a nonexistent column, because it can be confusing to set one property and have
    it change a different column—​but it is possible.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，为不存在的列创建变动器相对较少见，因为设置一个属性并改变另一列可能会令人困惑，但这是可能的。
- en: Attribute casting
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性转换
- en: You can probably imagine writing accessors to cast all of your integer-type
    fields as integers, encode and decode JSON to store in a `TEXT` column, or convert
    `TINYINT` `0` and `1` to and from Boolean values.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象编写访问器以将所有整数类型字段强制转换为整数，将 JSON 编码和解码以存储在 `TEXT` 列中，或者将 `TINYINT` `0` 和 `1`
    转换为布尔值。
- en: Thankfully, there’s a system for that in Eloquent already. It’s called *attribute
    casting*, and it allows you to define that any of your columns should always be
    treated, both on read and on write, as if they are of a particular data type.
    The options are listed in [Table 5-1](#poss-att-tabl).
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Eloquent 已经为此设计了一个系统。它被称为 *属性转换*，它允许您定义任何列始终被视为特定数据类型，无论读取还是写入时都如此。选项列在
    [表 5-1](#poss-att-tabl) 中。
- en: Table 5-1\. Possible attribute casting column types
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-1\. 可能的属性转换列类型
- en: '| Type | Description |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `int&#124;integer` | Casts with PHP (`int`) |'
  id: totrans-687
  prefs: []
  type: TYPE_TB
  zh: '| `int&#124;integer` | 使用 PHP (`int`) 进行转换 |'
- en: '| `real&#124;float&#124;double` | Casts with PHP (`float`) |'
  id: totrans-688
  prefs: []
  type: TYPE_TB
  zh: '| `real&#124;float&#124;double` | 使用 PHP (`float`) 进行转换 |'
- en: '| `decimal:<digits>` | Casts with PHP `number_format()` with the number of
    decimals specified. |'
  id: totrans-689
  prefs: []
  type: TYPE_TB
  zh: '| `decimal:<digits>` | 使用 PHP 的 `number_format()`，并指定小数位数进行转换。 |'
- en: '| `string` | Casts with PHP (`string`) |'
  id: totrans-690
  prefs: []
  type: TYPE_TB
  zh: '| `string` | 使用 PHP (`string`) 进行转换 |'
- en: '| `bool&#124;boolean` | Casts with PHP (`bool`) |'
  id: totrans-691
  prefs: []
  type: TYPE_TB
  zh: '| `bool&#124;boolean` | 使用 PHP (`bool`) 进行转换 |'
- en: '| `object&#124;json` | Parses to/from JSON, as a `stdClass` object |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| `object&#124;json` | 解析为 JSON，并作为 `stdClass` 对象 |'
- en: '| `array` | Parses to/from JSON, as an array |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| `array` | 解析为 JSON，并作为数组 |'
- en: '| `collection` | Parses to/from JSON, as a collection |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| `collection` | 解析为 JSON，并作为集合 |'
- en: '| `date&#124;datetime` | Parses from database `DATETIME` to Carbon, and back
    |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
  zh: '| `date&#124;datetime` | 在数据库 `DATETIME` 和 Carbon 之间进行解析 |'
- en: '| `timestamp` | Parses from database `TIMESTAMP` to Carbon, and back |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
  zh: '| `timestamp` | 在数据库 `TIMESTAMP` 和 Carbon 之间进行解析 |'
- en: '| `encrypted` | Handles the encryption and decryption of a string |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| `encrypted` | 处理字符串的加密和解密 |'
- en: '| `enum` | Casts to an enum |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| `enum` | 转换为枚举类型 |'
- en: '| `hashed` | Handles the hashing of a string |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| `hashed` | 处理字符串的哈希值 |'
- en: '[Example 5-39](#EX827) shows how you use attribute casting in your model.'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 5-39](#EX827) 展示了如何在您的模型中使用属性转换。'
- en: Example 5-39\. Using attribute casting on an Eloquent model
  id: totrans-701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-39\. 在 Eloquent 模型上使用属性转换
- en: '[PRE144]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Custom attribute casting
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义属性转换
- en: If the built-in attribute types aren’t enough, we can build custom cast types
    and use them in the `$casts` array.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 如果内置的属性类型不够用，我们可以构建自定义转换类型，并在 `$casts` 数组中使用它们。
- en: A *custom cast type* can be defined as a regular PHP class with a `get` and
    `set` method. The `get` method will be called when retrieving the given attribute
    from an eloquent model. The `set` method will be called before saving the attribute
    in the database, as you can see in [Example 5-40](#ex-05).
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 *自定义转换类型* 定义为一个常规的 PHP 类，具有 `get` 和 `set` 方法。当从 Eloquent 模型检索给定属性时，将调用 `get`
    方法。在将属性保存到数据库之前，将调用 `set` 方法，如您可以在 [示例 5-40](#ex-05) 中看到的。
- en: Example 5-40\. A sample custom cast type
  id: totrans-706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-40\. 一个样例自定义转换类型
- en: '[PRE145]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'You can use custom casts in the `$casts` property on your Eloquent model:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在您的 Eloquent 模型的 `$casts` 属性中使用自定义转换：
- en: '[PRE146]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Eloquent Collections
  id: totrans-710
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eloquent 集合
- en: When you make any query call in Eloquent that has the potential to return multiple
    rows, instead of an array they’ll come packaged in an Eloquent collection, which
    is a specialized type of collection. Let’s take a look at collections and Eloquent
    collections, and what makes them better than plain arrays.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在 Eloquent 中进行任何可能返回多行结果的查询调用时，它们将以 Eloquent 集合的形式返回，这是一种专门的集合类型。让我们来看看集合和
    Eloquent 集合，以及它们比纯数组更好的地方。
- en: Introducing the base collection
  id: totrans-712
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入基础集合
- en: Laravel’s `Collection` objects (`Illuminate\Support\Collection`) are a little
    bit like arrays on steroids. The methods they expose on array-like objects are
    so helpful that, once you’ve been using them for a while, you’ll likely want to
    pull them into non-Laravel projects—which you can, with the [Illuminate/Collections
    package](https://oreil.ly/YWnbl).
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的 `Collection` 对象 (`Illuminate\Support\Collection`) 类似于增强型数组。它们在类似数组的对象上公开的方法非常有用，使用一段时间后，您可能会希望将它们引入非
    Laravel 项目中 —— 您可以通过 [Illuminate/Collections package](https://oreil.ly/YWnbl)
    来实现这一点。
- en: 'The simplest way to create a collection is to use the `collect()` helper. Either
    pass an array in, or use it without arguments, to create an empty collection and
    then push items into it later. Let’s try it:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 创建集合的最简单方法是使用 `collect()` 辅助函数。可以传入一个数组，也可以不带参数使用它，后续再将项目推送到其中。让我们试试：
- en: '[PRE147]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Now let’s say we want to filter out any even numbers:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设我们想要过滤掉任何偶数：
- en: '[PRE148]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'Or, what if we want to get a version of the collection where each item is multiplied
    by 10? We can do that as follows:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想要得到每个项目乘以 10 的版本，可以这样做：
- en: '[PRE149]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'We can even get only the even numbers, multiply them all by 10, and reduce
    them to a single number by `sum()`:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以仅获取偶数，将它们全部乘以`10`，并通过`sum()`将它们缩减为一个单一的数字：
- en: '[PRE150]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: As you can see, collections provide a series of methods, which can optionally
    be chained to perform functional operations on your arrays. They provide the same
    functionality as native PHP methods like `array_map()` and `array_reduce()`, but
    you don’t have to memorize PHP’s unpredictable parameter order, and the method
    chaining syntax is infinitely more readable.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，集合提供了一系列方法，可以选择链式调用以在数组上执行功能操作。它们提供了与本地 PHP 方法（如 `array_map()` 和 `array_reduce()`）相同的功能，但你无需记忆
    PHP 不可预测的参数顺序，而且方法链语法更加可读。
- en: There are more than 60 methods available in the `Collection` class, including
    the methods `max()`, `whereIn()`, `flatten()`, and `flip()`—there’s not enough
    space to cover them all here. We’ll talk about more of them in [Chapter 17](ch17.html#helpers_and_collections),
    or you can check out the [Laravel collections docs](https://oreil.ly/i83f4) to
    see all of the methods.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '`Collection` 类中提供了超过 `60` 个方法，包括 `max()`、`whereIn()`、`flatten()` 和 `flip()`
    等方法——这里没有足够的空间来覆盖它们所有。我们将在[第17章](ch17.html#helpers_and_collections)讨论更多方法，或者你可以查看[Laravel
    集合文档](https://oreil.ly/i83f4)以查看所有方法。'
- en: Collections in the Place of Arrays
  id: totrans-724
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合取代数组
- en: Collections can also be used in any context (except typehinting) where you can
    use arrays. They allow for iteration, so you can pass them to `foreach`; and they
    allow for array access, so if they’re keyed you can try `$a = $collection['a']`.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 集合还可以在任何你可以使用数组的地方（除了类型提示）使用。它们允许迭代，所以你可以将它们传递给 `foreach`；它们还允许数组访问，所以如果它们有键，你可以尝试
    `$a = $collection['a']`。
- en: Lazy collections
  id: totrans-726
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟集合
- en: '[Lazy collections](https://oreil.ly/uyoGf) leverage the power of PHP generators
    to process very large datasets while keeping the memory usage of your app very
    low.'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '[延迟集合](https://oreil.ly/uyoGf)利用 PHP 生成器的强大功能来处理非常大的数据集，同时保持你的应用程序内存使用量非常低。'
- en: 'Imagine needing to iterate over 100,000 contacts in your database. If you were
    using Laravel’s normal `Collections`, you’d probably run into memory issues very
    quickly; all 100,000 records would be loaded into memory, and that’s a lot to
    ask of your machine:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下需要遍历数据库中的 100,000 个联系人。如果你使用 Laravel 的普通 `Collections`，很快就会遇到内存问题；所有 100,000
    条记录将加载到内存中，这对你的机器来说是一个很大的负担：
- en: '[PRE151]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Eloquent makes it simple to use lazy collections with your Eloquent models.
    If you use the `cursor` method, Eloquent models will return an instance of `LazyCollection`
    instead of the default `Collection` class. By using lazy collections, your app
    will only load one record at a time into memory:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent 可以轻松地使用延迟集合来处理你的 Eloquent 模型。如果你使用 `cursor` 方法，Eloquent 模型将返回一个 `LazyCollection`
    实例，而不是默认的 `Collection` 类。通过使用延迟集合，你的应用程序每次只会将一条记录加载到内存中：
- en: '[PRE152]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: What eloquent collections add
  id: totrans-732
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Eloquent 集合增加了什么
- en: Each Eloquent collection is a normal collection, but extended for the particular
    needs of a collection of Eloquent results.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Eloquent 集合都是一个普通集合，但扩展了对 Eloquent 结果集合特定需求的支持。
- en: Once again, there’s not enough room here to cover all of the additions, but
    they’re centered around the unique aspects of interacting with a collection not
    just of generic objects, but objects meant to represent database rows.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 再次说明，这里没有足够的空间来覆盖所有新增功能，但它们的核心是与集合交互的独特方面，不仅仅是一般对象的集合，而是用于表示数据库行的对象。
- en: For example, every Eloquent collection has a method called `modelKeys()` that
    returns an array of the primary keys of every instance in the collection. `find($id)`
    looks for an instance that has the primary key of `$id`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，每个 Eloquent 集合都有一个名为 `modelKeys()` 的方法，返回集合中每个实例的主键数组。`find($id)` 查找具有主键
    `$id` 的实例。
- en: One additional feature available here is the ability to define that any given
    model should return its results wrapped in a specific class of collection. So,
    if you want to add specific methods to any collection of objects of your `Order`
    model—possibly related to summarizing the financial details of your orders—​you
    could create a custom `OrderCollection` that extends `Illuminate\Database\Eloquent\Collection`,
    and then register it in your model, as shown in [Example 5-41](#EX29).
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个额外的功能，就是定义任何给定模型应该返回其结果的特定集合类。因此，如果你想向你的 `Order` 模型的任何对象集合中添加特定方法——可能与汇总订单财务详情相关——你可以创建一个自定义的
    `OrderCollection`，扩展 `Illuminate\Database\Eloquent\Collection`，然后在你的模型中注册它，如[示例 5-41](#EX29)所示。
- en: Example 5-41\. Custom `Collection` classes for Eloquent models
  id: totrans-737
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-41\. 用于Eloquent模型的自定义`Collection`类
- en: '[PRE153]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'Now, any time you get back a collection of `Order`s (e.g., from `Order::all()`),
    it’ll actually be an instance of the `OrderCollection` class:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每当你获取`Order`集合（例如，从`Order::all()`获取）时，它实际上是`OrderCollection`类的一个实例：
- en: '[PRE154]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Eloquent Serialization
  id: totrans-741
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eloquent序列化
- en: '*Serialization* is what happens when you take something complex—an array or
    an object—and convert it to a string. In a web-based context, that string is often
    JSON, but it could take other forms as well.'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列化*是指当你拿到一个复杂的东西——比如一个数组或对象——然后将其转换成字符串的过程。在基于Web的情境中，这个字符串通常是JSON，但也可能采用其他形式。'
- en: 'Serializing complex database records can be, well, complex, and this is one
    of the places many ORMs fall short. Thankfully, you get two powerful methods for
    free with Eloquent: `toArray()` and `toJson()`. Collections also have `toArray()`
    and `toJson()`, so all of these are valid:'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化复杂的数据库记录可能会很复杂，这是许多ORM在某些地方不足的地方之一。幸运的是，你可以免费使用Eloquent提供的两种强大方法：`toArray()`和`toJson()`。集合也有`toArray()`和`toJson()`，因此所有这些都是有效的：
- en: '[PRE155]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: You can also cast an Eloquent instance or collection to a string (`$string =
    (string) $contact;`), but both models and collections will just run `toJson()`
    and return the result.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将一个Eloquent实例或集合转换为字符串（`$string = (string) $contact;`），但是模型和集合都只会运行`toJson()`并返回结果。
- en: Returning models directly from route methods
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从路由方法直接返回模型
- en: Laravel’s router eventually converts everything that route methods return to
    a string, so there’s a clever trick you can use. If you return the result of an
    Eloquent call in a controller, it will be automatically cast to a string, and
    therefore returned as JSON. That means a JSON-returning route can be as simple
    as either of the ones in [Example 5-42](#EX830).
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的路由最终将路由方法返回的所有内容转换为字符串，因此你可以使用一个巧妙的技巧。如果在控制器中返回Eloquent调用的结果，它将自动转换为字符串，因此以JSON返回的路由可以简单地像[示例 5-42](#EX830)中的任意一个那样简单。
- en: Example 5-42\. Returning JSON from routes directly
  id: totrans-748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-42\. 直接从路由返回JSON
- en: '[PRE156]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Hiding attributes from JSON
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从JSON中隐藏属性
- en: It’s very common to use JSON returns in APIs, and it’s very common to want to
    hide certain attributes in these contexts, so Eloquent makes it easy to hide any
    attributes every time you cast to JSON.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 在API中使用JSON返回是非常常见的，而在这些上下文中隐藏某些属性也很常见，因此Eloquent使得每次转换为JSON时隐藏任何属性变得非常容易。
- en: 'You can either disallow specific attributes, hiding the ones you list:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以禁止特定的属性，隐藏你列出的那些：
- en: '[PRE157]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'or allow specific attributes, showing only the ones you list:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 或者允许指定的属性，仅显示你列出的那些：
- en: '[PRE158]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'This also works for relationships:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于关系：
- en: '[PRE159]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Loading the Contents of a Relationship
  id: totrans-758
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载关系的内容
- en: By default, the contents of a relationship are not loaded when you get a database
    record, so it doesn’t matter whether you hide them or not. But, as you’ll learn
    shortly, it’s possible to get a record *with* its related items, and in this context,
    those items will not be included in a serialized copy of that record if you choose
    to hide that relationship.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当你获取数据库记录时，关系的内容是不会被加载的，因此无论你是否隐藏它们都无所谓。但是，就像你很快就会了解到的那样，可以获取带有其相关项的记录，并且在这种情况下，如果选择隐藏该关系，则这些项目将不会包含在记录的序列化副本中。
- en: 'In case you’re curious now, you can get a `User` with all contacts—​assuming
    you’ve set up the relationship correctly—​with the following call:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在好奇的话，你可以获取一个带有所有联系人的`User`——假设你已经正确设置了关系——使用以下调用：
- en: '[PRE160]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'There might be times when you want to make an attribute visible just for a
    single call. That’s possible with the Eloquent method `makeVisible()`:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有时候，你想要使一个属性仅在单个调用中可见。这是可能的，使用Eloquent方法`makeVisible()`：
- en: '[PRE161]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Adding a Generated Column to Array and JSON Output
  id: totrans-764
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将生成的列添加到数组和JSON输出中
- en: 'If you have created an accessor for a column that doesn’t exist—​for example,
    our `full_name` column from [Example 5-36](#EX824)—you can add it to the `$appends`
    array on the model, which will add it to the array and JSON output:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为不存在的列创建了一个访问器——例如，我们的`full_name`列来自[示例 5-36](#EX824)——你可以将其添加到模型的`$appends`数组中，这样会将其添加到数组和JSON输出中：
- en: '[PRE162]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Eloquent Relationships
  id: totrans-767
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eloquent关系
- en: In a relational database model, it’s expected that you will have tables that
    are *related* to each other—​hence the name. Eloquent provides simple and powerful
    tools to make the process of relating your database tables easier than ever before.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 在关系数据库模型中，预计会有表彼此*相关*——因此得名。Eloquent提供了简单而强大的工具，使得关联数据库表的过程比以往更容易。
- en: Many of our examples in this chapter have been centered around a *user* who
    has many *contacts*, a relatively common situation.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中许多示例都围绕一个 *用户* 拥有多个 *联系人*，这是一个相对常见的情况。
- en: 'In an ORM like Eloquent, you would call this a *one-to-many* relationship:
    the one user *has many* contacts.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Eloquent这样的ORM中，您会将其称为 *一对多* 关系：一个用户 *拥有多个* 联系人。
- en: 'If it was a CRM where a contact could be assigned to many users, then this
    would be a *many-to-many* relationship: many users can be related to one contact,
    and each user can be related to many contacts. A user *has and belongs to many*
    contacts.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个客户关系管理系统（CRM），其中一个联系人可以分配给多个用户，那么这将是一个*多对多*关系：多个用户可以关联到一个联系人，每个用户可以与多个联系人相关联。一个用户
    *拥有并且属于多个* 联系人。
- en: If each contact can have many phone numbers and a user wanted a database of
    every phone number for their CRM, you would say the user *has many* phone numbers
    *through* contacts—​that is, a user *has many* contacts, and the contact *has
    many* phone numbers, so the contact is sort of an intermediary.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个联系人可以有多个电话号码，用户想要一个他们CRM中每个电话号码的数据库，您可以说用户 *通过* 联系人 *拥有多个* 电话号码——也就是说，一个用户
    *拥有多个* 联系人，每个联系人 *拥有多个* 电话号码，因此联系人是一种中间介质。
- en: And what if each contact has an address, but you’re only interested in tracking
    one address? You could have all the address fields on the `Contact`, but you might
    also create an `Address` model—​meaning the contact *has one* address.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个联系人都有一个地址，但您只想追踪一个地址怎么办？您可以在`Contact`上拥有所有地址字段，但您也可以创建一个`Address`模型——这意味着联系人
    *拥有一个* 地址。
- en: Finally, what if you want to be able to star (favorite) contacts, but also events?
    This would be a *polymorphic* relationship, where a user *has many* stars, but
    some may be contacts and some may be events.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您想要能够收藏联系人，还有事件怎么办？这将是一个*多态*关系，其中一个用户 *拥有多个* 星标，但有些可能是联系人，有些可能是事件。
- en: So, let’s dig into how to define and access these relationships.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解如何定义和访问这些关系。
- en: One to one
  id: totrans-776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对一
- en: 'Let’s start simple: a `Contact` *has one* `PhoneNumber`. This relationship
    is defined in [Example 5-43](#EX831).'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的开始：一个`Contact` *拥有一个* `PhoneNumber`。这个关系在[示例 5-43](#EX831)中定义。
- en: Example 5-43\. Defining a one-to-one relationship
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-43\. 定义一对一关系
- en: '[PRE163]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: As you can tell, the methods defining relationships are on the Eloquent model
    itself (`$this->hasOne()`) and take, at least in this instance, the fully qualified
    class name of the class that you’re relating them to.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，定义关系的方法在Eloquent模型本身上（`$this->hasOne()`）并且在这种情况下至少需要将与之相关的类的完全限定类名传递进去。
- en: 'How should this be defined in your database? Since we’ve defined that the `Contact`
    has one `PhoneNumber`, Eloquent expects that the table supporting the `PhoneNumber`
    class (likely `phone_numbers`) has a `contact_id` column on it. If you named it
    something different (for instance, `owner_id`), you’ll need to change your definition:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中如何定义这一点？由于我们已经定义`Contact`拥有一个`PhoneNumber`，Eloquent期望支持`PhoneNumber`类的表（可能是`phone_numbers`）有一个`contact_id`列。如果您使用不同的名称（例如`owner_id`），您需要更改您的定义：
- en: '[PRE164]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Here’s how we access the `PhoneNumber` of a `Contact`:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何访问`Contact`的`PhoneNumber`：
- en: '[PRE165]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Notice that we define the method in [Example 5-43](#EX831) with `phoneNumber()`,
    but we access it with `->phoneNumber`. That’s the magic. You could also access
    it with `->phone_number`. This will return a full Eloquent instance of the related
    `PhoneNumber` record.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在[示例 5-43](#EX831)中定义了`phoneNumber()`方法，但我们使用`->phoneNumber`访问它。这就是魔力所在。您还可以使用`->phone_number`访问它。这将返回与相关`PhoneNumber`记录的完整Eloquent实例。
- en: But what if we want to access the `Contact` from the `PhoneNumber`? There’s
    a method for that, too (see [Example 5-44](#EX832)).
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们想要从`PhoneNumber`访问`Contact`怎么办？也有一个方法（参见[示例 5-44](#EX832)）。
- en: Example 5-44\. Defining a one-to-one relationship’s inverse
  id: totrans-787
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-44\. 定义一对一关系的逆向
- en: '[PRE166]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Then we access it the same way:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们以同样的方式访问它：
- en: '[PRE167]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: One to many
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对多
- en: The one-to-many relationship is by far the most common. Let’s take a look at
    how to define that our `User` *has many* `Contact`s ([Example 5-45](#EX833)).
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是一对多关系。让我们看看如何定义我们的`User` *拥有多个* `Contact`s ([示例 5-45](#EX833))。
- en: Example 5-45\. Defining a one-to-many relationship
  id: totrans-793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-45\. 定义一对多关系
- en: '[PRE168]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Once again, this expects that the `Contact` model’s backing table (likely `contacts`)
    has a `user_id` column on it. If it doesn’t, override it by passing the correct
    column name as the second parameter of `hasMany()`.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这期望`Contact`模型的后台表（可能是`contacts`）有一个`user_id`列。如果没有，请通过将正确的列名作为`hasMany()`的第二个参数来覆盖它。
- en: 'We can get a `User`’s `Contact`s as follows:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以获取`User`的`Contact`如下：
- en: '[PRE169]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Just like with one to one, we use the name of the relationship method and call
    it as if it were a property instead of a method. However, this method returns
    a collection instead of a model instance. And this is a normal Eloquent collection,
    so we can have all sorts of fun with it:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一对一关系一样，我们使用关系方法的名称，并将其调用为属性而不是方法。但是，这个方法返回的是一个集合而不是一个模型实例。这是一个普通的Eloquent集合，所以我们可以做各种有趣的事情：
- en: '[PRE170]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Just like with one to one, we can also define the inverse ([Example 5-46](#EX834)).
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一对一关系一样，我们也可以定义反向关系（[Example 5-46](#EX834)）。
- en: Example 5-46\. Defining a one-to-many relationship’s inverse
  id: totrans-801
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-46\. 定义一对多关系的反向关系
- en: '[PRE171]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'And just like with one to one, we can access the `User` from the `Contact`:'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一对一关系一样，我们可以从`Contact`中访问`User`：
- en: '[PRE172]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Attaching and Detaching Related Items from the Attached Item
  id: totrans-805
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加和分离附加项目
- en: 'Most of the time we attach an item by running `save()` on the parent and passing
    in the related item, as in `$⁠u⁠s⁠e⁠r⁠-⁠>​c⁠o⁠n⁠t⁠a⁠c⁠t⁠s⁠(⁠)​-⁠>⁠s⁠a⁠v⁠e⁠($contact)`.
    But if you want to perform these behaviors on the attached (“child”) item, you
    can use `associate()` and `dissociate()` on the method that returns the `belongsTo`
    relationship:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们通过在父级上运行`save()`并传入相关项来附加项目，例如`$⁠u⁠s⁠e⁠r⁠-⁠>​c⁠o⁠n⁠t⁠a⁠c⁠t⁠s⁠(⁠)​-⁠>⁠s⁠a⁠v⁠e⁠($contact)`。但是，如果你想在已附加的（“子”）项目上执行这些行为，可以在返回`belongsTo`关系的方法上使用`associate()`和`dissociate()`：
- en: '[PRE173]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Using relationships as query builders
  id: totrans-808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用关系作为查询构建器
- en: Until now, we’ve taken the method name (e.g., `contacts()`) and called it as
    if were a property (e.g., `$user->contacts`). What happens if we call it as a
    method? Instead of processing the relationship, it will return a prescoped query
    builder.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将方法名（例如`contacts()`）作为属性调用（例如`$user->contacts`）。如果我们将其作为方法调用会发生什么？它不会处理关系，而是返回一个预设的查询构建器。
- en: 'So if you have `User 1`, and you call its `contacts()` method, you will now
    have a query builder prescoped to “all contacts that have a field `user_id` with
    the value of `1`.” You can then build out a functional query from there:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你有`User 1`，并调用其`contacts()`方法，你现在将得到一个查询构建器，预设为“所有`user_id`字段值为`1`的联系人”。然后你可以从这里构建出一个功能性的查询：
- en: '[PRE174]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Selecting only records that have a related item
  id: totrans-812
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅选择具有相关项的记录
- en: 'You can choose to select only records that meet particular criteria with regard
    to their related items using `has()`:'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择只选择符合特定条件的与相关项目的记录，使用`has()`：
- en: '[PRE175]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'You can also adjust the criteria further:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以进一步调整条件：
- en: '[PRE176]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'You can nest the criteria:'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以嵌套条件：
- en: '[PRE177]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'And finally, you can write custom queries on the related items:'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以在相关项目上编写自定义查询：
- en: '[PRE178]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Has one of many
  id: totrans-821
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对多关系的has one of many
- en: 'One common scenario when retrieving records from a one-to-many relationship
    is that you want to retrieve just one item from that relationship, often the newest
    or the oldest. Laravel provides a convenience tool for just these situations:
    has one of many.'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 从一对多关系中检索记录的常见情况是，你只想从该关系中检索一个项目，通常是最新的或最旧的。Laravel为这些情况提供了一个方便的工具：has one of
    many。
- en: Has-one-of-many relationships allow you to define that a given method should
    retrieve the newest item in a related collection, or the oldest item, or the item
    with the minimum or maximum value of any particular column, as you can see in
    [Example 5-47](#EX853).
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 一对多关系允许你定义一个给定方法应该检索相关集合中的最新项目，或者最旧项目，或者具有任何特定列的最小或最大值的项目，如[Example 5-47](#EX853)所示。
- en: Example 5-47\. Defining has-one-of-many relationships
  id: totrans-824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-47\. 定义一对多关系的has-one-of-many关系
- en: '[PRE179]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Has many through
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多关系
- en: '`hasManyThrough()` is really a convenience method for pulling in relationships
    of a relationship. Think of the example I gave earlier, where a `User` has many
    `Contact`s and each `Contact` has many `PhoneNumber`s. What if you want to get
    a user’s list of contact phone numbers? That’s a has-many-through relation.'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasManyThrough()`实际上是一个方便的方法，用于获取关系的关系。想象一下我之前给出的例子，一个`User`有许多`Contact`，每个`Contact`有许多`PhoneNumber`。如果你想获取用户的联系电话列表怎么办？这就是一个多对多的关系。'
- en: This structure assumes that your `contacts` table has a `user_id` to relate
    the contacts to the users and the `phone_numbers` table has a `contact_id` to
    relate it to the contacts. Then, we define the relationship on the `User` as in
    [Example 5-48](#EX835).
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构假设你的`contacts`表有一个`user_id`来将联系人与用户关联起来，而`phone_numbers`表有一个`contact_id`将其与联系人关联起来。然后，我们在`User`上定义关系，如[Example 5-48](#EX835)所示。
- en: Example 5-48\. Defining a has-many-through relationship
  id: totrans-829
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-48\. 定义一个多对多关系
- en: '[PRE180]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: You’d access this relationship using `$user->phone_numbers`. If you need to
    customize the relationship key on the intermediate or distant models, use the
    traditional syntax; you can define the key on the intermediate model (with the
    third parameter of `h⁠a⁠s​M⁠a⁠n⁠y⁠Through()`) and the relationship key on the
    distant model (with the fourth parameter).
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`$user->phone_numbers`访问此关系。如果需要在中间或远程模型上自定义关系键，请使用传统语法；您可以在中间模型上定义关键字（使用`h⁠a⁠s​M⁠a⁠n⁠y⁠Through()`的第三个参数）和在远程模型上定义关系键（使用第四个参数）。
- en: Has one through
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对一通过
- en: '`hasOneThrough()` is just like `hasManyThrough()`, but instead of accessing
    many related items through intermediate items, you’re only accessing a single
    related item through a single intermediate item.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`hasOneThrough()`与`hasManyThrough()`类似，但不是通过中间项目访问许多相关项目，而是仅通过单个中间项目访问单个相关项目。'
- en: What if each user belonged to a company, and that company had a single phone
    number, and you wanted to be able to get a user’s phone number by pulling their
    company’s phone number? That’s a has-one-through relation, as shown in [Example 5-49](#EX5-48).
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个用户属于一个公司，而公司有一个单独的电话号码，并且您希望能够通过获取用户公司的电话号码来获取用户的电话号码，那就是一对一通过关系，如[Example 5-49](#EX5-48)所示。
- en: Example 5-49\. Defining a has-one-through relationship
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-49\. 定义一对一通过关系
- en: '[PRE181]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Many to many
  id: totrans-837
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多
- en: This is where things start to get complex. Let’s take our example of a CRM that
    allows a `User` to have many `Contact`s, and each `Contact` to be related to multiple
    `User`s.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 这是事情开始变得复杂的地方。让我们以允许`User`拥有多个`Contact`的CRM示例为例，每个`Contact`又与多个`User`相关联。
- en: First, we define the relationship on the `User` as in [Example 5-50](#EX836).
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们像在[Example 5-50](#EX836)中一样在`User`上定义关系。
- en: Example 5-50\. Defining a many-to-many relationship
  id: totrans-840
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-50\. 定义多对多关系
- en: '[PRE182]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: And since this is many to many, the inverse looks exactly the same ([Example 5-51](#EX837)).
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是多对多关系，逆关系看起来完全相同（[Example 5-51](#EX837)）。
- en: Example 5-51\. Defining a many-to-many relationship’s inverse
  id: totrans-843
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-51\. 定义多对多关系的逆
- en: '[PRE183]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Since a single `Contact` can’t have a `user_id` column and a single `User` can’t
    have a `contact_id` column, many-to-many relationships rely on a pivot table that
    connects the two. The conventional naming of this table is done by placing the
    two singular table names together, ordered alphabetically, and separating them
    by an underscore.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 由于单个`Contact`不能有`user_id`列，单个`User`也不能有`contact_id`列，多对多关系依赖于连接这两者的中间表。这种表的常规命名是将两个单数表名按字母顺序排列在一起，并用下划线分隔。
- en: 'So, since we’re linking `users` and `contacts`, our pivot table should be named
    `contact_user` (if you’d like to customize the table name, pass it as the second
    parameter to the `belongsToMany()` method). It needs two columns: `contact_id`
    and `user_id`.'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于我们正在连接`users`和`contacts`，我们的中间表应该命名为`contact_user`（如果你想自定义表名，请将其作为第二个参数传递给`belongsToMany()`方法）。它需要两列：`contact_id`和`user_id`。
- en: Just like with `hasMany()`, we get access to a collection of the related items,
    but this time it’s from both sides ([Example 5-52](#EX838)).
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用`hasMany()`一样，我们可以从两个方向访问相关项的集合，这一次是从双方面（[Example 5-52](#EX838)）。
- en: Example 5-52\. Accessing the related items from both sides of a many-to-many
    relationship
  id: totrans-848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-52\. 访问多对多关系的双方相关项
- en: '[PRE184]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Getting data from the pivot table
  id: totrans-850
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从中间表获取数据
- en: One thing that’s unique about many to many is that it’s our first relationship
    that has a pivot table. The less data you have in a pivot table, the better, but
    there are some cases where it’s valuable to store information in your pivot table—​for
    example, you might want to store a `created_at` field to see when this relationship
    was created.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系的一个独特之处在于它是我们第一个具有中间表的关系。在中间表中数据越少越好，但也有一些情况下在中间表中存储信息很有价值，比如，你可能想要存储一个`created_at`字段，以查看这个关系是何时创建的。
- en: In order to store these fields, you have to add them to the relationship definition,
    like in [Example 5-53](#EX839). You can define specific fields using `withPivot()`
    or add `created_at` and `updated_at` timestamps using `withTimestamps()`.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储这些字段，您必须将它们添加到关系定义中，就像在[Example 5-53](#EX839)中一样。您可以使用`withPivot()`定义特定字段，或者使用`withTimestamps()`添加`created_at`和`updated_at`时间戳。
- en: Example 5-53\. Adding fields to a pivot record
  id: totrans-853
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-53\. 向中间记录添加字段
- en: '[PRE185]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: When you get a model instance through a relationship, it will have a `pivot`
    property on it, which will represent its place in the pivot table you just pulled
    it from. So, you can do something like [Example 5-54](#EX840).
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过关系获取模型实例时，它将在其上有一个 `pivot` 属性，该属性将表示它在刚刚提取的枢纽表中的位置。因此，您可以执行类似于 [示例 5-54](#EX840)
    的操作。
- en: Example 5-54\. Getting data from a related item’s pivot entry
  id: totrans-856
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-54\. 从相关项目的枢纽条目获取数据
- en: '[PRE186]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: If you’d like, you can customize the `pivot` key to have a different name using
    the `as()` method, as shown in [Example 5-55](#EX5f).
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，您可以使用 `as()` 方法自定义 `pivot` 键的名称，如 [示例 5-55](#EX5f) 中所示。
- en: Example 5-55\. Customizing the pivot attribute name
  id: totrans-859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-55\. 自定义 pivot 属性名称
- en: '[PRE187]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Polymorphic
  id: totrans-862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态
- en: 'Remember, our polymorphic relationship is where we have multiple Eloquent classes
    corresponding to the same relationship. We’re going to use `Star`s (like favorites)
    right now. A user can star both `Contact`s and `Event`s, and that’s where the
    name *polymorphic* comes from: there’s a single interface to objects of multiple
    types.'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们的多态关系是指我们有多个对应于相同关系的 Eloquent 类。我们现在要使用的是 `Star`（例如收藏夹）。用户可以同时收藏 `Contact`
    和 `Event`，这就是 *多态* 名称的由来：有多种类型的对象使用单一接口。
- en: So, we’ll need three tables (`stars`, `contacts`, `events`) and three models
    (`Star`, `Contact`, and `Event`). Actually, you’ll need four of each because we’ll
    also need `users` and `User`, but we’ll get there in a second. The `contacts`
    and `events` tables will just be as they normally are, and the `stars` table will
    contain `id`, `starrable_id`, and `starrable_type` fields. For each `Star`, we’ll
    be defining which “type” (e.g., `Contact` or `Event`) and which ID of that type
    (e.g., `1`) it is.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要三个表（`stars`、`contacts`、`events`）和三个模型（`Star`、`Contact` 和 `Event`）。实际上，您需要四个，因为我们还需要
    `users` 和 `User`，但我们马上会解决这个问题。`contacts` 和 `events` 表将保持正常，而 `stars` 表将包含 `id`、`starrable_id`
    和 `starrable_type` 字段。对于每个 `Star`，我们将定义它是哪种“类型”（例如 `Contact` 或 `Event`）以及该类型的哪个
    ID（例如 `1`）。
- en: Let’s create our models, as seen in [Example 5-56](#EX841).
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的模型，如 [示例 5-56](#EX841) 中所示。
- en: Example 5-56\. Creating the models for a polymorphic starring system
  id: totrans-866
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-56\. 创建多态星标系统的模型
- en: '[PRE189]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: So, how do we create a `Star`?
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何创建一个 `Star` 呢？
- en: '[PRE190]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: It’s that easy. The `Contact` is now starred.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这么简单。现在 `Contact` 已经被加星了。
- en: In order to find all of the `Star`s on a given `Contact`, we call the `stars()`
    method like in [Example 5-57](#EX842).
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到给定 `Contact` 上的所有 `Star`，我们像 [示例 5-57](#EX842) 中那样调用 `stars()` 方法。
- en: Example 5-57\. Retrieving the instances of a polymorphic relationship
  id: totrans-872
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-57\. 检索多态关系的实例
- en: '[PRE191]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: If we have an instance of `Star`, we can get its target by calling the method
    we used to define its `morphTo` relationship, which in this context is `starrable()`.
    Take a look at [Example 5-58](#EX843).
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个 `Star` 实例，我们可以通过调用用于定义其 `morphTo` 关系的方法来获取其目标，在这种情况下是 `starrable()`。请查看
    [示例 5-58](#EX843)。
- en: Example 5-58\. Retrieving the target of a polymorphic instance
  id: totrans-875
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-58\. 检索多态实例的目标
- en: '[PRE192]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Finally, you might be wondering, “What if I want to know who starred this contact?”
    That’s a great question. It’s as simple as adding `user_id` to your `stars` table,
    and then setting up that a `User` *has many* `Star`s and a `Star` *belongs to*
    one `User`—a one-to-many relationship ([Example 5-59](#EX844)). The `stars` table
    becomes almost a pivot table between your `User` and your `Contact`s and `Event`s.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可能会问：“如果我想知道谁收藏了这个联系人怎么办？”这是一个很好的问题。只需将 `user_id` 添加到您的 `stars` 表中，然后设置
    `User` *有多个* `Star` 和 `Star` *属于* 一个 `User`——一个一对多的关系（[示例 5-59](#EX844)）。`stars`
    表几乎成为您的 `User` 和您的 `Contact` 和 `Event` 之间的枢纽表。
- en: Example 5-59\. Extending a polymorphic system to differentiate by user
  id: totrans-878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-59\. 扩展多态系统以区分用户
- en: '[PRE193]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'That’s it! You can now run `$star->user` or `$user->stars` to find a list of
    a `User`’s `Star`s or to find the starring `User` from a `Star`. Also, when you
    create a new `Star`, you’ll now want to pass the `User`:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！您现在可以运行 `$star->user` 或 `$user->stars` 来查找 `User` 的 `Star` 列表，或者从 `Star`
    中查找星标的 `User`。此外，当您创建一个新的 `Star` 时，现在您需要传递 `User`：
- en: '[PRE194]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Many-to-many polymorphic
  id: totrans-882
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多多态
- en: The most complex and least common of the relationship types, many-to-many polymorphic
    relationships are like polymorphic relationships, except instead of being one
    to many, they’re many to many.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 关系类型中最复杂且最不常见的多对多多态关系就像多态关系一样，但不是一对多，而是多对多。
- en: 'The most common example for this relationship type is the tag, so I’ll keep
    it safe and use that as our example. Let’s imagine you want to be able to tag
    `Contact`s and `Event`s. The uniqueness of many-to-many polymorphism is that it’s
    many to many: each tag may be applied to multiple items, and each tagged item
    might have multiple tags. And to add to that, it’s polymorphic: tags can be related
    to items of several different types. For the database, we’ll start with the normal
    structure of the polymorphic relationship but also add a pivot table.'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系类型的最常见示例是标签，所以我将保持它的安全性并将其用作我们的示例。假设您希望能够为`Contact`和`Event`打标签。多对多多态关系的独特之处在于它是多对多的：每个标签可以应用于多个项目，并且每个标记的项目可能有多个标签。而且，它是多态的：标签可以与多种不同类型的项目相关联。对于数据库，我们将从多态关系的正常结构开始，但还将添加一个透视表。
- en: This means we’ll need a `contacts` table, an `events` table, and a `tags` table,
    all shaped like normal with an ID and whatever properties you want, *and* a new
    `taggables` table, which will have `tag_id`, `taggable_id`, and `taggable_type`
    fields. Each entry into the `taggables` table will relate a tag with one of the
    taggable content types.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要一个`contacts`表，一个`events`表和一个`tags`表，都像正常的表一样具有ID和您想要的任何属性，*还有*一个新的`taggables`表，它将具有`tag_id`、`taggable_id`和`taggable_type`字段。`taggables`表中的每个条目将关联一个标签与一个可标记的内容类型。
- en: Now let’s define this relationship on our models, as seen in [Example 5-60](#EX845).
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们像[示例 5-60](#EX845)中所示，在我们的模型上定义这个关系。
- en: Example 5-60\. Defining a polymorphic many-to-many relationship
  id: totrans-887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-60\. 定义多态多对多关系
- en: '[PRE195]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Here’s how to create your first tag:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何创建您的第一个标签：
- en: '[PRE196]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: We get the results of this relationship like normal, as seen in [Example 5-61](#EX846).
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 我们像正常情况下获取这个关系的结果，就像[示例 5-61](#EX846)中所示。
- en: Example 5-61\. Accessing the related items from both sides of a many-to-many
    polymorphic relationship
  id: totrans-892
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-61\. 从多对多多态关系的双方访问相关项目
- en: '[PRE197]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: Child records updating parent record timestamps
  id: totrans-894
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子记录更新父记录时间戳
- en: Remember, any Eloquent models by default will have `created_at` and `updated_at`
    timestamps. Eloquent will set the `updated_at` timestamp automatically any time
    you make any changes to a record.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，默认情况下，任何Eloquent模型都将具有`created_at`和`updated_at`时间戳。每当对记录进行更改时，Eloquent都会自动设置`updated_at`时间戳。
- en: When a related item has a `belongsTo` or `belongsToMany` relationship with another
    item, it might be valuable to mark the other item as updated any time the related
    item is updated. For example, if a `PhoneNumber` is updated, maybe the `Contact`
    it’s connected to should be marked as having been updated as well.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 当相关项目与另一个项目具有`belongsTo`或`belongsToMany`关系时，每当更新相关项目时标记另一个项目可能非常有价值。例如，如果更新了`PhoneNumber`，也许应该标记其连接的`Contact`已更新。
- en: We can accomplish this by adding the method name for that relationship to a
    `$touches` array property on the child class, as in [Example 5-62](#EX847).
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将该关系的方法名添加到子类的`$touches`数组属性中来实现这一点，就像[示例 5-62](#EX847)中所示。
- en: Example 5-62\. Updating a parent record any time the child record is updated
  id: totrans-898
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-62\. 每当更新子记录时更新父记录
- en: '[PRE198]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Eager Loading
  id: totrans-900
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 急加载
- en: By default, Eloquent loads relationships using *lazy loading*. This means when
    you first load a model instance, its related models will not be loaded along with
    it. Rather, they’ll only be loaded once you access them on the model; they’re
    “lazy” and don’t do any work until called upon.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Eloquent使用*lazy loading*加载关系。这意味着当您首次加载模型实例时，它的相关模型不会随之加载。相反，只有在您访问它们时才会加载它们；它们是“懒惰的”，直到被调用时才做任何工作。
- en: This can become a problem if you’re iterating over a list of model instances
    and each has a related item (or items) that you’re working on. The problem with
    lazy loading is that it can introduce significant database load (often the *N*+1
    problem, if you’re familiar with the term; if not, just ignore this parenthetical
    remark). For instance, every time the loop in [Example 5-63](#EX848) runs, it
    executes a new database query to look up the phone numbers for that `Contact`.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在迭代一系列模型实例，并且每个实例都有一个您正在处理的相关项目（或项目），这可能会成为问题。懒加载的问题在于它可能引入显著的数据库负载（通常是*N*+1问题，如果您熟悉这个术语的话；如果不熟悉，可以忽略这个括号内的备注）。例如，每次运行[示例
    5-63](#EX848)中的循环时，它都会执行一个新的数据库查询来查找`Contact`的电话号码。
- en: Example 5-63\. Retrieving one related item for each item in a list (N+1)
  id: totrans-903
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 5-63\. 检索列表中每个项目的一个相关项目（N+1）
- en: '[PRE199]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'If you are loading a model instance and you know you’ll be working with its
    relationships, you can instead choose to *eager load* one or many of its sets
    of related items:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你加载一个模型实例并且你知道你将使用它的关系，你可以选择*急加载*一个或多个相关项目集：
- en: '[PRE200]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Using the `with()` method with a retrieval gets all of the items related to
    the pulled item(s); as you can see in this example, you pass it the name of the
    method the relationship is defined by.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with()`方法和检索一起获取所有与已拉取项目相关的项目；正如你在这个例子中看到的，你传递给它的是关系定义的方法名称。
- en: When we use eager loading, instead of pulling the related items one at a time
    when they’re requested (e.g., selecting one contact’s phone numbers each time
    a `foreach` loop runs), we have a single query to pull the initial items (selecting
    all contacts) and a second query to pull all their related items (selecting all
    phone numbers owned by the contacts we just pulled).
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用急加载时，而不是在请求时逐个拉取相关项目（例如，每次`foreach`循环运行时选择一个联系人的电话号码），我们只有一个查询来拉取初始项目（选择所有联系人），并且第二个查询来拉取所有他们的相关项目（选择刚刚拉取的联系人拥有的所有电话号码）。
- en: 'You can eager load multiple relationships by passing an array of the relationships
    to eager load to the `with()` call:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将要急加载的多个关系作为数组传递给`with()`调用，你可以急加载多个关系：
- en: '[PRE201]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'And you can nest eager loading to eager load the relationships of relationships:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以嵌套急加载以急加载关系的关系：
- en: '[PRE202]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Constraining eager loads
  id: totrans-913
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 限制急加载
- en: 'If you want to eager load a relationship but not all of the items, you can
    pass a closure to `with()` to define exactly which related items to eager load:'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要急加载一个关系，但不是所有项目，你可以传递一个闭包给`with()`来定义确切要急加载的相关项目：
- en: '[PRE203]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Lazy eager loading
  id: totrans-916
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 惰性急加载
- en: 'I know it sounds crazy, because we just defined eager loading as sort of the
    opposite of lazy loading, but sometimes you don’t know you want to perform an
    eager load query until after the initial instances have been pulled. In this context,
    you’re still able to make a single query to look up all of the related items,
    avoiding *N*+1 cost. We call this *lazy eager loading*:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这听起来很疯狂，因为我们刚刚定义了急加载，就好像是惰加载的反义词，但有时在初始实例被拉取后你才意识到你想要执行急加载查询。在这种情况下，你仍然能够做一次查询来查找所有相关项目，避免*N*+1的成本。我们称之为*惰性急加载*：
- en: '[PRE204]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'To load a relationship only when it has not already been loaded, use the `loadMissing()`
    method:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 当关系尚未被加载时才加载它，请使用`loadMissing()`方法：
- en: '[PRE205]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: Preventing lazy loading
  id: totrans-921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 防止惰性加载
- en: 'Because lazy loading can often be an undesirable pattern, you can disable lazy
    loading for your entire app at once. It’s recommended that you take this action
    in the `boot()` method of your `AppServiceProvider`:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 因为惰性加载通常是一种不良模式，你可以一次为整个应用程序禁用惰性加载。建议你在`AppServiceProvider`的`boot()`方法中执行此操作：
- en: '[PRE206]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: Eager loading only the count
  id: totrans-924
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 仅急加载计数
- en: 'If you want to eager load relationships, but only so you can have access to
    the count of items in each relationship, you can try `withCount()`:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要急加载关系，但只是为了访问每个关系中项目的计数，你可以尝试使用`withCount()`：
- en: '[PRE207]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Eloquent Events
  id: totrans-927
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eloquent事件
- en: Eloquent models fire events out into the void of your application every time
    certain actions happen, regardless of whether you’re listening. If you’re familiar
    with pub/sub, it’s this same model (you’ll learn more about Laravel’s entire event
    system in [Chapter 16](ch16.html#queues_jobs_events)).
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent模型在发生某些操作时向应用程序的虚空中发出事件，无论你是否在监听。如果你熟悉发布/订阅，它是相同的模型（你将在[第16章](ch16.html#queues_jobs_events)中学到更多关于Laravel整个事件系统的内容）。
- en: Here’s a quick rundown of binding a listener to when a new `Contact` is created.
    We’re going to bind it in the `boot()` method of `AppServiceProvider`, and let’s
    imagine we’re notifying a third-party service every time we create a new `Contact`
    ([Example 5-64](#EX5-63b)).
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是绑定在创建新的`Contact`时触发时的监听器的快速概述。我们将在`AppServiceProvider`的`boot()`方法中绑定它，假设我们在每次创建新的`Contact`时通知第三方服务（[示例5-64](#EX5-63b)）。
- en: Example 5-64\. Binding a listener to an Eloquent event
  id: totrans-930
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例5-64。将监听器绑定到Eloquent事件
- en: '[PRE208]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: We can see a few things in [Example 5-64](#EX5-63b). First, we use ``*Modelname*`::`*eventName()*``
    as the method and pass it a closure. The closure gets access to the model instance
    that is being operated on. Second, we’re going to need to define this listener
    in a service provider somewhere. And third, if we return `false`, the operation
    will cancel and the `save()` or `update()` will be canceled.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 [Example 5-64](#EX5-63b) 中看到几个东西。首先，我们使用 ``*Modelname*`::`*eventName()*``
    作为方法，并传递一个闭包。闭包可以访问正在操作的模型实例。其次，我们需要在某个服务提供者中定义此监听器。第三，如果返回 `false`，操作将被取消，`save()`
    或 `update()` 将被取消。
- en: 'Here are the events that every Eloquent model fires:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是每个Eloquent模型触发的事件：
- en: '`creating`'
  id: totrans-934
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`creating`'
- en: '`created`'
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`'
- en: '`updating`'
  id: totrans-936
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updating`'
- en: '`updated`'
  id: totrans-937
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated`'
- en: '`saving`'
  id: totrans-938
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saving`'
- en: '`saved`'
  id: totrans-939
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saved`'
- en: '`deleting`'
  id: totrans-940
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleting`'
- en: '`deleted`'
  id: totrans-941
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deleted`'
- en: '`restoring`'
  id: totrans-942
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restoring`'
- en: '`restored`'
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restored`'
- en: '`retrieved`'
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`retrieved`'
- en: Most of these should be pretty clear, except possibly `restoring` and `restored`,
    which fire when you’re restoring a soft-deleted row. Also, `saving` is fired for
    both `creating` and `updating` and `saved` is fired for both `created` and `updated`.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数这些应该很明确，除了可能 `restoring` 和 `restored`，它们在恢复软删除的行时触发。此外，`saving` 会在 `creating`
    和 `updating` 时触发，`saved` 在 `created` 和 `updated` 时触发。
- en: The `retrieved` event is fired when an existing model is retrieved from the
    database.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieved` 事件在从数据库中检索到现有模型时触发。'
- en: Testing
  id: totrans-947
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Laravel’s entire application testing framework makes it easy to test your database—​not
    by writing unit tests against Eloquent, but by just being willing to test your
    entire application.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel的整个应用测试框架使得测试数据库变得非常简单——不是通过编写针对Eloquent的单元测试，而是通过愿意测试整个应用程序。
- en: Take this scenario. You want to test to ensure that a particular page shows
    one contact but not another. Some of that logic has to do with the interplay between
    the URL and the controller and the database, so the best way to test it is an
    application test. You might be thinking about mocking Eloquent calls and trying
    to avoid the system hitting the database. *Don’t do it.* Try [Example 5-65](#EX50)
    instead.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 想象这种情况。您想测试确保特定页面显示一个联系人但不显示另一个联系人。其中一些逻辑涉及URL、控制器和数据库之间的相互作用，因此最佳的测试方法是应用测试。您可能正在考虑模拟Eloquent调用并尝试避免系统访问数据库。*不要这样做。*
    请尝试使用 [Example 5-65](#EX50)。
- en: Example 5-65\. Testing database interactions with simple application tests
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-65\. 使用简单的应用测试测试数据库交互
- en: '[PRE209]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: As you can see, model factories and Laravel’s application testing features are
    great for testing database calls.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，模型工厂和Laravel的应用测试功能非常适合测试数据库调用。
- en: Alternatively, you can look for that record directly in the database, as in
    [Example 5-66](#EX51).
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以直接在数据库中查找该记录，就像在 [Example 5-66](#EX51) 中一样。
- en: Example 5-66\. Using `assertDatabaseHas()` to check for certain records in the
    database
  id: totrans-954
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-66\. 使用 `assertDatabaseHas()` 来检查数据库中的特定记录
- en: '[PRE210]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Eloquent and Laravel’s database framework are tested extensively. *You don’t
    need to test them.* You don’t need to mock them. If you really want to avoid hitting
    the database, you can use a repository and then return unsaved instances of your
    Eloquent models. But the most important message is this: test the way your application
    uses your database logic.'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent和Laravel的数据库框架经过了广泛测试。*您无需测试它们。* 您不需要模拟它们。如果您确实想避免访问数据库，可以使用存储库，然后返回未保存的Eloquent模型实例。但最重要的消息是：测试您的应用程序如何使用您的数据库逻辑。
- en: If you have custom accessors, mutators, scopes, or whatever else, you can also
    test them directly, as in [Example 5-67](#EX852).
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有自定义的访问器、修改器、作用域或其他内容，也可以直接测试它们，就像在 [Example 5-67](#EX852) 中一样。
- en: Example 5-67\. Testing accessors, mutators, and scopes
  id: totrans-958
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 5-67\. 测试访问器、修改器和作用域
- en: '[PRE211]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: Just avoid writing tests that leave you creating complex “Demeter chains” to
    assert that a particular fluent stack was called on some database mock. If your
    testing starts to get overwhelming and complex around the database layer, it’s
    because you’re allowing preconceived notions to force you into unnecessarily complex
    systems. Keep it simple.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: Just avoid writing tests that leave you creating complex “Demeter chains” to
    assert that a particular fluent stack was called on some database mock. If your
    testing starts to get overwhelming and complex around the database layer, it’s
    because you’re allowing preconceived notions to force you into unnecessarily complex
    systems. Keep it simple.
- en: TL;DR
  id: totrans-961
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TL;DR
- en: Laravel comes with a suite of powerful database tools, including migrations,
    seeding, an elegant query builder, and Eloquent, a powerful ActiveRecord ORM.
    Laravel’s database tools don’t require you to use Eloquent at all—​you can access
    and manipulate the database with a thin layer of convenience without having to
    write SQL directly. But adding an ORM, whether it’s Eloquent or Doctrine or whatever
    else, is easy and can work neatly with Laravel’s core database tools.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel自带一套强大的数据库工具，包括迁移（migrations）、填充（seeding）、优雅的查询构建器以及Eloquent，一个功能强大的ActiveRecord
    ORM。Laravel的数据库工具并不要求您完全使用Eloquent —— 您可以通过一个薄层的便利操作访问和操作数据库，而无需直接编写SQL。但是，添加ORM（无论是Eloquent还是Doctrine或其他）都很容易，并且可以与Laravel的核心数据库工具很好地配合。
- en: Eloquent follows the ActiveRecord pattern, which makes it simple to define a
    class of database-backed objects, including which table they’re stored in and
    the shape of their columns, accessors, and mutators. Eloquent can handle every
    sort of normal SQL action and also complex relationships, up to and including
    polymorphic many-to-many relationships.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: Eloquent遵循ActiveRecord模式，这使得定义支持数据库的对象类变得简单，包括它们存储在哪个表中以及列的形状、访问器和修改器。Eloquent可以处理各种常规的SQL操作，也可以处理复杂的关系，包括多态多对多关系。
- en: Laravel also has a robust system for testing databases, including model factories.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel还为数据库测试提供了强大的系统，包括模型工厂。
