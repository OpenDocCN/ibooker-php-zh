- en: Chapter 16\. Queues, Jobs, Events, Broadcasting, and the Scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far we’ve covered some of the most common structures that power web applications:
    databases, mail, filesystems, and more. All of these are common across a majority
    of applications and frameworks.'
  prefs: []
  type: TYPE_NORMAL
- en: Laravel also provides facilities for some less common architecture patterns
    and application structures. In this chapter we’ll cover Laravel’s tools for implementing
    queues, queued jobs, events, and WebSocket event publishing. We’ll also cover
    Laravel’s scheduler, which makes manually edited cron schedules a thing of the
    past.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand what a queue is, just think about the idea of “queueing up” in
    a line at the bank. Even if there are multiple lines—​queues—​only one person
    is being served at a time from each queue, and each person will eventually reach
    the front and be served. In some banks, it’s a strict first-in-first-out sort
    of policy, but in other banks, there’s not an exact guarantee that someone won’t
    cut ahead of you in line at some point. Essentially, someone can get added to
    the queue, be removed from the queue prematurely, or be successfully “processed”
    and then removed. Someone might even hit the front of the queue, not be able to
    be served correctly, return to the queue for a time, and then be processed again.
  prefs: []
  type: TYPE_NORMAL
- en: Queues in programming are very similar. Your application adds a “job” to a queue,
    which is a chunk of code that tells the application how to perform a particular
    behavior. Then some other separate application structure, usually a “queue worker,”
    takes the responsibility for pulling jobs off of the queue one at a time and performing
    the appropriate behavior. Queue workers can delete the jobs, return them to the
    queue with a delay, or mark them as successfully processed.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel makes it easy to serve your queues using Redis, *beanstalkd*, Amazon
    Simple Queue Service (SQS), or a database table. You can also choose the `sync`
    driver to have the jobs run right in your application without actually being queued,
    or the `null` driver for jobs to just be discarded; these two are usually used
    in local development or testing environments.
  prefs: []
  type: TYPE_NORMAL
- en: Why Queues?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Queues make it easy to remove a costly or slow process from any synchronous
    call. The most common example is sending mail—​doing so can be slow, and you don’t
    want your users to have to wait for mail to send in response to their actions.
    Instead, you can trigger a “send mail” queued job and let the users get on with
    their day. And sometimes you may not be worried about saving your users time,
    but you might have a process like a cron job or a webhook that has a lot of work
    to get through; rather than letting it all run at once (and potentially time out),
    you may choose to queue its individual pieces and let the queue worker process
    them one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if you have some heavy processing that’s more than your server
    can handle, you can spin up more than one queue worker to work through your queue
    faster than your normal application server could on its own.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Queue Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like many other Laravel features that abstract multiple providers, queues have
    their own dedicated config file (*config/queue.php*) that allows you to set up
    multiple drivers and define which will be the default. This is also where you’ll
    store your SQS, Redis, or *beanstalkd* authentication information.
  prefs: []
  type: TYPE_NORMAL
- en: Simple Redis Queues on Laravel Forge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Laravel Forge](http://forge.laravel.com) is a hosting management service provided
    by Taylor Otwell, the creator of Laravel, which makes serving queues with Redis
    a breeze. Every server you create has Redis configured automatically, so if you
    visit any site’s Forge console, you can just go to the Queue tab and hit Start
    Worker and you’re ready to use Redis as your queue driver; you can leave all the
    default settings, and no other work is necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: Queued Jobs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember our bank analogy? Each person in the bank’s *queue* (line) is, in programming
    terms, a *job*. Queued jobs can, depending on the environment, take many shapes,
    like arrays of data or simple strings. In Laravel, each job is a collection of
    information containing the job name, the data payload, the number of attempts
    that have been made so far to process this job, and some other simple metadata.
  prefs: []
  type: TYPE_NORMAL
- en: But you don’t need to worry about any of that in your interactions with Laravel.
    Laravel provides a structure called `Job`, which is intended to encapsulate a
    single task—​a behavior that your application can be commanded to do—​and allow
    it to be added to and pulled from a queue. There are also simple helpers to make
    it easy to queue Artisan commands and mail.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with an example in which every time a user changes their plan with
    your SaaS app, you want to rerun some calculations about your overall profit.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a job
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As always, there’s an Artisan command for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at [Example 16-1](#EX1502) to see what you’ll get.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-1\. The default template for jobs in Laravel
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this template imports the `Dispatchable`, `InteractsWithQueue`,
    `Queueable`, and `SerializesModels` traits, and implements the `ShouldQueue` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also get two methods from this template: the constructor, which you’ll use
    to attach data to the job, and the `handle()` method, which is where the job’s
    logic should reside (and is also the method signature you’ll use to inject dependencies).'
  prefs: []
  type: TYPE_NORMAL
- en: The traits and interface provide the class with the ability to be added to,
    and interact with, the queue. `Dispatchable` gives it methods to dispatch itself;
    `InteractsWithQueue` allows each job, while being handled, to control its relationship
    with the queue, including deleting or requeueing itself; `Queueable` allows you
    to specify how Laravel should push this job to the queue; and `SerializesModels`
    gives the job the ability to serialize and deserialize Eloquent models.
  prefs: []
  type: TYPE_NORMAL
- en: Serializing Models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SerializesModels` trait gives jobs the ability to *serialize* (convert
    to a flatter format that can be stored in a data store like a database or queue
    system) injected models so that your job’s `handle()` method will have access
    to them. However, because it’s too difficult to reliably serialize an entire Eloquent
    object, the trait ensures that just the primary keys of any attached Eloquent
    objects are serialized when the job is pushed onto the queue. When the job is
    deserialized and handled, the trait pulls those Eloquent models fresh from the
    database by their primary key. This means that when your job runs, it will be
    pulling a fresh instance of this model, not whatever state it was in when you
    queued the job.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s fill out the methods for our sample class, as in [Example 16-2](#example_job).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-2\. An example job
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We’re expecting the `User` instance to be injected when we create the job, and
    then when it’s handled, we’re typehinting a `ReportGenerator` class (which we
    presumably wrote). Laravel will read the typehint and inject that dependency automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing a job onto a queue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are multiple methods by which you can dispatch a job, including some methods
    available to every controller and a global `dispatch()` helper. But the simpler
    and preferred method is calling the `dispatch()` method on the job itself, so
    that’s what we’ll do for the rest of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To dispatch your job, you can just create an instance of it and then call its
    `dispatch()` method, passing any necessary data directly into that method. Take
    a look at [Example 16-3](#dispatching_jobs) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-3\. Dispatching jobs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three settings you can control to customize exactly how you dispatch
    a job: the connection, the queue, and the delay.'
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the connection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you ever have multiple queue connections in place at once, you can customize
    the connection by chaining `onConnection()` after the `dispatch()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Customizing the queue
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Within queue servers, you can specify which named queue you’re pushing a job
    onto. For example, you may differentiate your queues based on their importance,
    naming one `low` and one `high`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can customize which queue you’re pushing a job onto with the `onQueue()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Customizing the delay
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'You can customize the amount of time your queue workers should wait before
    processing a job with the `delay()` method, which accepts either an integer representing
    the number of seconds to delay a job or a `*DateTime*`/`*Carbon*` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that Amazon SQS doesn’t allow delays longer than 15 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Job chaining
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you need a series of jobs to run in order one after the other, you can “chain”
    them together. Each job will wait to run until the previous job completes, and
    if one job fails, the rest after it won’t run.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When one of the chained jobs fails, you can execute with the `catch()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Job batching
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Job batching makes it possible to push a group of jobs onto the queue at the
    same time, inspect the status of the batch, and take an action after the batch
    is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature requires a database table to keep track of the jobs; as you might
    expect, there’s an Artisan command to create it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: To mark a job as batchable, include the `Illuminate\Bus\Batchable` trait. This
    trait adds a `batch()` method to your job, which will allow you to retrieve information
    about the current batch your job is running in.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Example 16-4](#EX1605) to see how this works. In this example,
    you can see that one of the most important steps to take on a batchable job is
    to make sure it doesn’t take any action if its batch was canceled.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-4\. Batchable job in Laravel
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Dispatching batchable jobs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Bus` facade offers a method `batch()`, which allows you to dispatch a batch
    of jobs. You can also define actions to take after the batch succeeds or fails,
    using the `then()` (succeeds), `catch()` (fails), or `finally()` (succeeds or
    fails) methods.
  prefs: []
  type: TYPE_NORMAL
- en: You can see how these can be called in [Example 16-5](#EX1606).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-5\. Dispatching batchable jobs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Adding jobs to batches from a job
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If the jobs in your batch have a responsibility of adding jobs to a batch—for
    example, if you initially dispatch a few job-dispatcher type jobs—they can use
    the `add()` method on the `Batch` object returned by `batch()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Cancelling a batch
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If a job has a reason to cancel its batch, it can:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Batch failures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, if a single job in a batch fails, the batch will be marked as “canceled.”
    If you want to define a different behavior, you can chain `allowFailures()` when
    you dispatch the batch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Cleaning up the batches table
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The batches table isn’t self-pruning, so you’ll want to schedule your app to
    “prune” that table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Running a Queue Worker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So what is a queue worker, and how does it work? In Laravel, it’s an Artisan
    command that runs forever (until it’s stopped manually) and takes the responsibility
    for pulling down jobs from your queue and running them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command starts a daemon “listening” to your queue; every time there are
    jobs on the queue, it will pull down the first job, handle it, delete it, and
    move on to the next. If at any point there are no jobs, it “sleeps” for a configurable
    amount of time before checking again to see if there are any more jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define how many seconds a job should be allowed to run before the queue
    listener stops it (`--timeout`), how many seconds the listener should “sleep”
    when there are no jobs left (`--sleep`), how many tries each job should be allowed
    before being deleted (`--tries`), which connection the worker should listen to
    (the first parameter after `queue:work`), and which queues it should listen to
    (`--queue=`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can also process just a single job with `php artisan queue:work`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, what happens when something goes wrong with a job that’s in the middle of
    processing?
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions in handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If an exception is thrown, the queue listener will release that job back onto
    the queue. The job will be rereleased to be processed again and again until it
    is able to finish successfully or until it has reached the maximum number of attempts
    allowed by your queue listener.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the number of tries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The maximum number of tries is defined by the `--tries` switch passed to the
    `queue:listen` or `queue:work` Artisan command.
  prefs: []
  type: TYPE_NORMAL
- en: The Danger of Infinite Retries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don’t set `--tries`, or if you set it to `0`, the queue listener will
    allow infinite retries. That means if there are any circumstances in which a job
    can just *never* be completed—​for example, if it relies on a tweet that has since
    been deleted—​your app will slowly crawl to a halt as it retries forever.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [documentation](https://oreil.ly/7BIW-) and Laravel Forge both show `3`
    as the recommended starting point for the maximum number of retries. So, in case
    of confusion, start there and adjust:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If at any point you’d like to check how many times a job has been attempted
    already, use the `attempts()` method on the job itself, as in [Example 16-6](#times_a_job_been_tried).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-6\. Checking how many times a job has already been tried
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify the maximum number of times a given job can be retried
    on the job class itself by defining a `$tries` property. When specified, this
    value will take precedence over the value set with the `--tries` switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can set the `$maxExceptions` property in a job class to specify how many
    times the job can throw an exception (and therefore be retried) before it should
    be considered failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify when a job should time out, instructing the framework
    to attempt the job any number of times within a specified timeframe. You can specify
    a `retryUntil()` method on a job and from that return a `DateTime/Carbon` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Job-based retry delay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can specify how long to wait before retrying a failed job by setting a `$retryAfter`
    property on the job, equivalent to the minutes to wait. For more complex calculations,
    we can instead define a `retryAfter` method, which should also return the minutes
    to wait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Job middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can run jobs through middleware, just like we run our HTTP requests through
    middleware. This is a great opportunity to extract logic that guards or validates
    your jobs or the conditions they’ll run in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To assign a middleware to a job, specify a `middleware()` method in the job
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify a middleware when dispatching jobs using the `through`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Rate limiting middleware for jobs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Laravel comes out of the box with a rate limiting job middleware. To use it,
    define a rate limiter using `RateLimiter::for()` in the `boot()` method of a service
    provider, as shown in [Example 16-7](#EX1607).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-7\. A sample job rate limiting middleware
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The syntax of the job rate limiting middleware is the same as the route rate
    limiting middleware ([“Rate Limiting”](ch10.html#route_rate_limiting)).
  prefs: []
  type: TYPE_NORMAL
- en: Handling failed jobs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once a job has exceeded its allowable number of retries, it’s considered a “failed”
    job. Before you do anything else—​even if all you want to do is limit the number
    of times a job can be tried—​you’ll need to create a “failed jobs” database table.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an Artisan command to create the migration (and you’ll then want to
    migrate):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Any job that has surpassed its maximum number of allowed attempts will be dumped
    there. But there are quite a few things you can do with your failed jobs.
  prefs: []
  type: TYPE_NORMAL
- en: First, you can define a `failed()` method on the job itself, which will run
    when that job fails (see [Example 16-8](#method_when_a_job_fails)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-8\. Defining a method to run when a job fails
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Next, you can register a global handler for failed jobs. Somewhere in the application’s
    bootstrap—​if you don’t know where to put it, just put it in the `boot()` method
    of `AppServiceProvider`—place the code in [Example 16-9](#global_handler_to_handle_failed_jobs)
    to define a listener.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-9\. Registering a global handler to handle failed jobs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There is also a suite of Artisan tools for interacting with the failed jobs
    table.
  prefs: []
  type: TYPE_NORMAL
- en: '`queue:failed` shows you a list of your failed jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The list will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, you can grab the ID of any individual failed job and retry it with
    `queue:retry`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’d rather retry all of the jobs, pass `all` instead of an ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can delete an individual failed job with `queue:forget`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can delete all of your failed jobs over a certain age (by default, it’s
    24 hours, but you can also pass a custom number of hours using `--hours=48`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can delete all of your failed jobs with `queue:flush`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Controlling the Queue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, from within the handling of a job, you’ll want to add conditions
    that will potentially either release the job to be restarted later or delete the
    job forever.
  prefs: []
  type: TYPE_NORMAL
- en: To release a job back onto the queue, use the `release()` method, as in [Example 16-10](#releasing_back_onto_queue).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-10\. Releasing a job back onto the queue
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you want to delete a job during its handling, you can just `return` at any
    point, as seen in [Example 16-11](#deleting_a_job); that’s the signal to the queue
    that the job was handled appropriately and should not be returned to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-11\. Deleting a job
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Queues Supporting Other Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary use for queues is to push jobs onto them, but you can also queue
    mail using the `Mail::queue` functionality. You can learn more about this in [“Queues”](ch15.html#queued_mail).
    You can also queue Artisan commands, which we covered in [Chapter 8](ch08.html#artisan_and_tinker).
  prefs: []
  type: TYPE_NORMAL
- en: Laravel Horizon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel Horizon, like some of the other tools we’ve covered (Scout, Passport,
    etc.), is a tool provided by Laravel that doesn’t come bundled with the core.
  prefs: []
  type: TYPE_NORMAL
- en: Horizon provides insight into the status of your Redis queued jobs. You can
    see which jobs have failed, how many are queued, and how fast they’re working,
    and you can even get notifications when any of your queues are overloaded or failing.
    The Horizon dashboard is shown in [Figure 16-1](#horizon-dashboard).
  prefs: []
  type: TYPE_NORMAL
- en: Installing and running Horizon is relatively straightforward, and the documentation
    is thorough, so if you’re interested, take a look at the [Horizon docs](https://oreil.ly/6tpkn)
    to learn how to install, configure, and deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that you will need to have your queue connection set to `redis`,
    in your *.env* or the *config/queue.php* config file, in order to run Horizon.
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the Horizon dashboard](assets/lur3_1601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-1\. The Horizon dashboard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With jobs, the calling code informs the application that it should *do something*:
    `CrunchReports` or `NotifyAdminOfNewSignup`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With an event, the calling code instead informs the application that *something
    happened*: `UserSubscribed`, `UserSignedUp`, or `ContactWasAdded`. *Events* are
    notifications that something has taken place.'
  prefs: []
  type: TYPE_NORMAL
- en: Some of these events may be “fired” by the framework itself. For example, Eloquent
    models fire events when they are saved, created, or deleted. But some events can
    also be manually triggered by the application’s code.
  prefs: []
  type: TYPE_NORMAL
- en: An event being fired doesn’t do anything on its own. However, you can bind *event
    listeners*, whose sole purpose is to listen for the broadcasting of specific events
    and to act in response. Any event can have anywhere from zero to many event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel’s events are structured like the observer, or “pub/sub,” pattern. Many
    events are fired out into the application; some may never be listened for, and
    others may have a dozen listeners. The events don’t know or care.
  prefs: []
  type: TYPE_NORMAL
- en: Firing an Event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are three ways to fire an event. You can use the `Event` facade, inject
    the `Dispatcher`, or use the `event()` global helper, as illustrated in [Example 16-12](#fire-an-event).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-12\. Three ways to fire an event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: If in doubt, I’d recommend using the global helper function.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an event to fire, use the `make:event` Artisan command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That’ll make a file that looks something like [Example 16-13](#EX1503).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-13\. The default template for a Laravel event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Let’s take a look at what we get here. `SerializesModels` works just like with
    jobs; it allows you to accept Eloquent models as parameters. `InteractsWithSockets`,
    `ShouldBroadcast`, and the `broadcastOn()` method provide the backing functionality
    for broadcasting events using WebSockets, which we’ll cover in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: It might seem strange that there’s no `handle()` or `fire()` method here. But
    remember, this object exists not to determine a particular action, but just to
    encapsulate some data. The first piece of data is its name; `UserSubscribed` tells
    us that a particular event happened (a user subscribed). The rest of the data
    is any data we pass into the constructor and associate with this entity.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 16-14](#injecting_data_into_event) shows what we might want to do
    with our `UserSubscribed` event.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-14\. Injecting data into an event
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have an object that appropriately represents the event that happened:
    `$event->user` subscribed to the `$event->plan` plan. Remember, firing this event
    is as simple as `event(new UserSubscribed($user, $plan))`.'
  prefs: []
  type: TYPE_NORMAL
- en: Listening for an Event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have an event and the ability to fire it. Now let’s look at how to listen
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we’ll create an event listener. Let’s say we want to email the app’s
    owner every time a new user subscribes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: That gives us the file in [Example 16-15](#EX1504).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-15\. The default template for a Laravel event listener
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is where the action happens—​where the `handle()` method lives. This method
    expects to be passed an event of type `UserSubscribed` and act in response to
    it.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s make it send an email ([Example 16-16](#sample_event_listener)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-16\. A sample event listener
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, one last task: we need to set this listener to listen to the `UserSubscribed`
    event. We’ll do that in the `$listen` property of the `EventServiceProvider` class
    (see [Example 16-17](#binding_listeners_to_events)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-17\. Binding listeners to events in `EventServiceProvider`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the key of each array entry is the class name of the event,
    and the value is an array of listener class names. We can add as many class names
    as we want under the `UserSubscribed` key, and they will all listen and respond
    to each `UserSubscribed` event.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic event discovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also instruct Laravel to automatically connect events and their matching
    listeners, without having to manually bind them in `EventServiceProvider`. This
    feature, called *automatic event discovery*, is disabled by default, but can be
    enabled by setting the `shouldDiscoverEvents()` method to return `true` in the
    `EventS⁠e⁠r⁠v⁠i⁠c⁠e​P⁠r⁠o⁠v⁠i⁠d⁠e⁠r`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If this feature is enabled, Laravel will map events to their matching listeners
    based on the typehints in the listeners. It’ll have to match them on every request,
    which will introduce a small lag to your app, but like many slow features, you
    can cache these lookups using `php artisan event:cache` and clear the cache with
    `php artisan event:clear`.
  prefs: []
  type: TYPE_NORMAL
- en: Event subscribers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There’s one more structure you can use to define the relationship between your
    events and their listeners. Laravel has a concept called an *event subscriber*,
    which is a class that contains a collection of methods that act as separate listeners
    to unique events, and also contains the mapping of which method should handle
    which event. In this case it’s easier to show than to tell, so take a look at
    [Example 16-18](#EX1501). Note that event subscribers are not a particularly commonly
    used tool.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-18\. A sample event subscriber
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Subscribers need to define a `subscribe()` method, which is passed an instance
    of the event dispatcher. We’ll use that to pair events with their listeners, but
    in this case, those are methods on this class, instead of entire classes.
  prefs: []
  type: TYPE_NORMAL
- en: As a refresher, any time you see an `@` inline like this, it means the class
    name is to the left of the `@` and the method name is to the right. So, in [Example 16-18](#EX1501),
    we’re defining that the `onUserSubscription()` method of this subscriber will
    listen to any `U⁠s⁠e⁠r​S⁠u⁠b⁠s⁠c⁠r⁠i⁠b⁠e⁠d` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s one last thing we need to do: in `App\Providers\EventServiceProvider`,
    we need to add our subscriber’s class name to the `$subscribe` property, as seen
    in [Example 16-19](#registering_an_event_subscriber).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-19\. Registering an event subscriber
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Broadcasting Events Over WebSockets, and Laravel Echo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: WebSocket (often called WebSockets) is a protocol, popularized by Pusher (a
    hosted WebSocket SaaS), that makes it simple to provide near real-time communication
    between web devices. Rather than relying on information passing via HTTP requests,
    WebSockets libraries open a direct connection between the client and the server.
    WebSockets are behind tools like the chat boxes in Gmail and Facebook, where you
    don’t have to wait for the page to reload or for Ajax requests to receive or send
    data; instead, data is both sent and received in real time.
  prefs: []
  type: TYPE_NORMAL
- en: WebSockets work best with small pieces of data passed in a pub/sub structure—​just
    like Laravel’s events. Laravel has a built-in set of tools that makes it easy
    to define that one or more of your events should be broadcast to a WebSocket server;
    it’s straightforward, for example, to have a `MessageWasReceived` event that is
    published to the notifications box of a certain user or set of users the instant
    a message arrives at your application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration and Setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Take a look at *config/broadcasting.php* to find the configuration settings
    for your event broadcasting. Laravel supports three drivers for broadcasting:
    Pusher, a paid SaaS offering; Redis, for locally running WebSocket servers; and
    `log`, for local development and debugging.'
  prefs: []
  type: TYPE_NORMAL
- en: Queue Listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order for event broadcasting to move quickly, Laravel pushes the instruction
    to broadcast events onto a queue. That means you’ll need to have a queue worker
    running (or use the `sync` queue driver for local development). See [“Running
    a Queue Worker”](#queue_workers) to learn how to run a queue worker.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel suggests a default delay of three seconds before the queue worker looks
    for new jobs. However, with event broadcasting, you may notice some events take
    a second or two to broadcast. To speed this up, update your queue settings to
    wait only one second before looking for new jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting an Event
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To broadcast an event, you need to mark that event as a broadcast event by having
    it implement the `Illuminate\Contracts\Broadcasting\ShouldBroadcast` interface.
    This interface requires you to add the `broadcastOn()` method, which will return
    an array of either strings or `Channel` objects, each representing a WebSocket
    channel.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 16-20](#broadcasting_on_multiple_channels) shows our `UserSubscribed`
    event, modified to broadcast on two channels: one for the user (to confirm the
    user’s subscription) and one for admins (to notify them of a new subscription).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-20\. An event broadcasting on multiple channels
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: By default, any public properties of your event will be serialized as JSON and
    sent along as the data of your broadcast event. That means the data of one of
    our broadcast `UserSubscribed` events might look like [Example 16-21](#sample_broadcast_event_data).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-21\. Sample broadcast event data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You can override this by returning an array of data from the `broadcastWith()`
    method on your event, as in [Example 16-22](#customizing_broadcast_event_data).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-22\. Customizing the broadcast event data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can customize which queue your event is pushed onto by setting the `$broadcastQueue`
    property on the event class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: You may choose to do this so you can keep other queue items from slowing down
    your event broadcast; real-time WebSockets aren’t much fun if a long-running job
    that’s higher in the queue keeps the events from going out in time.
  prefs: []
  type: TYPE_NORMAL
- en: You can also force a given event to skip the queue entirely (using the “sync”
    queue driver, which is processed by the current PHP thread), by having it implement
    the `ShouldBroadcastNow` contract ([Example 16-23](#skip-the-broadcast-queue)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-23\. Forcing an event to skip the broadcast queue
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, you can choose to customize whether a given event should be broadcast
    at all by giving it a `broadcastWhen()` methods as in [Example 16-24](#determining-when-to-broadcast):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-24\. Conditionally determining whether an event should be broadcast
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Receiving the Message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of this book’s publication, the most common solution Laravel developers use
    is [Pusher](https://pusher.com). Plans over a certain size cost money, but there’s
    a generous free plan. Pusher makes it incredibly easy to set up a simple WebSocket
    server, and its JavaScript SDK handles all of the authentication and channel management
    with almost no work on your part. SDKs are available for iOS, Android, and many
    more platforms, languages, and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d like to host your own Pusher-compatible WebSockets server, there are
    two great options. First, you can try a Laravel-based tool called [Laravel WebSockets](https://oreil.ly/p8fyJ).
    You can install the package into your current Laravel app (the same app you’re
    broadcasting from) or into a separate microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Second, if you’re using Docker (including Sail) you can install [Soketi](https://soketi.app),
    a free Pusher replacement developed in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose to work with a server other than Pusher, you’ll follow all of
    the directions in this book as if you were working with Pusher, but your configuration
    settings will be a bit different.
  prefs: []
  type: TYPE_NORMAL
- en: It’s helpful to understand how to listen to Laravel’s broadcast events without
    Echo even if you choose to use Echo in the end. But because much of the code here
    is not necessary if you use Echo, I’d recommend reading this section, and then
    reading [“Laravel Echo (the JavaScript Side)”](#echo) before you start implementing
    any of it; you can decide which way you prefer and then write your code from there.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, pull in Pusher’s library, get an API key from your Pusher account,
    and subscribe to any events on any channels with code like that in [Example 16-25](#basic_usage_of_pusher_JS).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-25\. Basic usage of Pusher
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Escaping Backslashes in JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since `\` is a control character in JavaScript, you need to write `\\` to represent
    a backslash in your strings, which is why there are two backslashes between each
    namespace segment in [Example 16-25](#basic_usage_of_pusher_JS).
  prefs: []
  type: TYPE_NORMAL
- en: To publish to Pusher from Laravel, get your Pusher key, secret, cluster, and
    app ID from your Pusher account dashboard, and then set them in your *.env* file
    under the keys `PUSHER_KEY`, `PUSHER_SECRET`, `PUSHER_APP_CLUSTER`, and `PUSHER_APP_ID`,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If you serve your app, visit a page with the JavaScript from [Example 16-25](#basic_usage_of_pusher_JS)
    embedded in it in one window, push a broadcast event in another window or from
    your terminal, have a queue listener running or are using the `sync` driver, and
    all of your authentication information is set up correctly, you should see event
    logs popping up in your JavaScript window’s console in near real time.
  prefs: []
  type: TYPE_NORMAL
- en: With this power, it’s now easy for you to keep your users up to date with what’s
    happening with their data any time they’re in your app. You can notify users of
    the actions of other users, of long-running processes that have just finished,
    or of your application’s responses to external actions like incoming emails or
    webhooks. The possibilities are endless.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to broadcast with Pusher or Redis, you’ll need to bring in these
    dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pusher: `pusher/pusher-php-server "~3.0"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Redis: `predis/predis`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Broadcasting Tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel has a few more tools to make it possible to perform more complex interactions
    in event broadcasting. These tools, a combination of framework features and a
    JavaScript library, are called *Laravel Echo*.
  prefs: []
  type: TYPE_NORMAL
- en: These framework features work best when you use Laravel Echo in your JavaScript
    frontend (which we’ll cover in [“Laravel Echo (the JavaScript Side)”](#echo)),
    but you can still enjoy some of the benefits of Echo without using the JavaScript
    components. Echo will work with both Pusher and Redis, but I’m going to use Pusher
    for any examples.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding the current user from broadcast events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every connection to Pusher is assigned a unique “socket ID” identifying that
    socket connection. And it’s easy to define that any given socket (user) should
    be excluded from receiving a specified broadcast event.
  prefs: []
  type: TYPE_NORMAL
- en: This feature makes it possible to define that certain events should not be broadcast
    to the user who fired them. Let’s say every user in a team gets notified when
    other users create a task; would you want to be notified of a task you just created?
    No, and that’s why we have the `toOthers()` method.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this, there are two steps to follow. First, you need to set up
    your JavaScript to send a certain `POST` to `/broadcasting/socket` when your WebSocket
    connection is initialized. This attaches your `socket_id` to your Laravel session.
    Echo does this for you, but you can also do it manually—take a look at the [Echo
    source](https://oreil.ly/3Ww0U) to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you’ll want to update every request that your JavaScript makes to have
    an `X-Socket-ID` header that contains that `socket_id`. [Example 16-26](#sending_the_socket_id)
    shows how to do that with Axios or in jQuery. Note that your event must use the
    `Illuminate\Broadcasting\InteractsWithSockets` trait in order to call the `toOthers()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-26\. Sending the socket ID along with each Ajax request with Axios
    or in jQuery
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve handled this, you can exclude any event from being broadcast to
    the user who triggered it by using the `broadcast()` global helper, instead of
    the `event()` global helper, and then chaining `toOthers()` after it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The broadcast service provider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the other features that Echo provides require your JavaScript to authenticate
    with the server. Take a look at `App\Providers\BroadcastServiceProvider`, where
    you’ll define how to authorize users’ access to your private and presence channels.
  prefs: []
  type: TYPE_NORMAL
- en: The two primary actions you can take are to define the middleware that will
    be used on your broadcasting auth routes, and to define the authorization settings
    for your channels.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re going to use these features, you’ll need to uncomment the `App\Providers\BroadcastServiceProvider::class`
    line in *config/app.php*.
  prefs: []
  type: TYPE_NORMAL
- en: And if you’ll be using these features *without* Laravel Echo, you’ll either
    need to manually handle sending CSRF tokens along with your authentication requests,
    or exclude `/broadcasting/auth` and `/broadcasting/socket` from CSRF protection
    by adding them to the `$except` property of the `VerifyCsrfToken` middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Binding authorization definitions for WebSocket channels
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Private and presence WebSocket channels need to be able to ping your application
    to learn whether the current user is authorized for that channel. You’ll use the
    `Broadcast::channel()` method to define the rules for this authorization in your
    *routes/channels.php* file.
  prefs: []
  type: TYPE_NORMAL
- en: Public, Private, and Presence Channels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are three types of channels in WebSockets: public, private, and presence:'
  prefs: []
  type: TYPE_NORMAL
- en: Public channels
  prefs: []
  type: TYPE_NORMAL
- en: Can be subscribed to by any user, authenticated or not.
  prefs: []
  type: TYPE_NORMAL
- en: Private channels
  prefs: []
  type: TYPE_NORMAL
- en: Require the end user’s JavaScript to authenticate against the application to
    prove that the user is both authenticated and authorized to join this channel.
  prefs: []
  type: TYPE_NORMAL
- en: Presence channels
  prefs: []
  type: TYPE_NORMAL
- en: A type of private channel, but instead of allowing for message passing, they
    simply keep track of which users join and leave the channel, and make this information
    available to the application’s frontend.
  prefs: []
  type: TYPE_NORMAL
- en: '`Broadcast::channel()` takes two parameters: first, a string representing the
    channel(s) you want it to match, and second, a closure that defines how to authorize
    users for any channel matching that string. The closure will be passed an Eloquent
    model of the current user as its first parameter, and any matched *`variableNameHere`*
    segments as additional parameters. For example, a channel authorization definition
    with a string of `teams.*teamId*`, when matched against the channel `teams.5`,
    will pass its closure `$user` as the first parameter and `5` as the second parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re defining the rules for a private channel, your `Broadcast::channel()`
    closure will need to return a Boolean: is this user authorized for this channel
    or not? If you’re defining the rules for a presence channel, your closure should
    return an array of data you want available to the presence channel for any users
    that you want to show up in the channel. [Example 16-27](#defining_authorization_rules)
    illustrates defining rules for both kinds of channel.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-27\. Defining authorization rules for private and presence WebSocket
    channels
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be wondering how this information gets from your Laravel application
    to your JavaScript frontend. Pusher’s JavaScript library sends a `POST` to your
    application; by default it will hit `/pusher/auth`, but you can customize that
    (and Echo customizes it for you) to hit Laravel’s authentication route, `/broadcasting/auth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 16-28](#pusher_JS_for_private_and_presence_channels) shows how we
    can tweak [Example 16-25](#basic_usage_of_pusher_JS) for private and presence
    channels, *without* Echo’s frontend components.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-28\. Basic use of Pusher for private and presence channels
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: We now have the ability to send WebSocket messages to users depending on whether
    they pass a given channel’s authorization rules. We can also keep track of which
    users are active in a particular group or section of the site and display relevant
    information to each user about other users in the same group.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel Echo (the JavaScript Side)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Laravel Echo compromises two pieces: the advanced framework features we just
    covered and a JavaScript package that takes advantage of those features and drastically
    reduces the amount of boilerplate code you need to write powerful WebSocket-based
    frontends. The Echo JavaScript package makes it easy to handle authentication,
    authorization, and subscribing to private and presence channels. Echo can be used
    with the SDKs for either Pusher (for Pusher or a custom Pusher-compatible server)
    or `socket.io` (for Redis).'
  prefs: []
  type: TYPE_NORMAL
- en: Bringing Echo into your project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To use Echo in your project’s JavaScript, add it to *package.json* using `npm
    install` `--save` (be sure to bring in the appropriate Pusher or `socket.io` SDK
    as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Let’s assume you have a basic Vite file compiling your *app.js*, like in Laravel’s
    default installation setup.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel’s default *resources/js/app.js* structure has a great example of how
    best to initialize your Echo install. Take a look at [Example 16-29](#initializing_echo_in_appjs)
    to see how that works between that file and *resources/js/bootstrap.js*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-29\. Initializing Echo in app.js and bootstrap.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'For CSRF protection, you’ll also need to add a `csrf-token <meta>` tag to your
    HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, remember to link to your compiled *app.js* in your HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Now we’re ready to get started.
  prefs: []
  type: TYPE_NORMAL
- en: Changes to the Configuration When Using the Laravel WebSockets Server Package
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re working with a Laravel WebSockets server (using the package discussed
    earlier in [“Receiving the Message”](#websockets_servers)), the configuration
    details in [Example 16-29](#initializing_echo_in_appjs) will be a little bit different.
    See the [Laravel WebSockets package docs](https://oreil.ly/iL6Yl) for more info.
  prefs: []
  type: TYPE_NORMAL
- en: Using Echo for basic event broadcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is nothing different from what we’ve already used Pusher for, but [Example 16-30](#listening_to_a_public_channel_with_Echo)
    is a simple code sample to show how to use Echo to listen to public channels for
    basic event information.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-30\. Listening to a public channel with Echo
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Echo provides a few methods for subscribing to various types of channels; `channel()`
    will subscribe you to a public channel. Note that when you listen to an event
    with Echo, you can ignore the full event namespace and just listen for the unique
    class name of this event.
  prefs: []
  type: TYPE_NORMAL
- en: We now have access to the public data that’s passed along with our event, represented
    in the `data` object. We can also chain `listen()` handlers, as in [Example 16-31](#chaining_event_listeners_in_echo).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-31\. Chaining event listeners in Echo
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Remember to Compile and Include!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Did you try these code samples and not see anything change in your browser?
    Make sure to run `npm run dev` (if you’re running it locally) or `npm run build`
    (to build it once) to compile your code. And, if you haven’t yet, be sure to actually
    include *app.js* in your template somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Private channels and basic authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Echo also has a method for subscribing to private channels: `private()`. It
    works the same as `channel()`, but requires you to have set up channel authorization
    definitions in *routes/channel.php*, like we covered earlier. Additionally, unlike
    with the SDKs, you don’t need to put `private-` in front of your channel name.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 16-32](#listening_to_private_channel_with_echo) shows what it looks
    like to listen to a private channel named `private-teams.5`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-32\. Listening to a private channel with Echo
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Presence channels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Echo makes it much simpler to join and listen to events in presence channels.
    This time you’ll want to use the `join()` method to bind to the channel, as in
    [Example 16-33](#listening_to_presence_channel_with_echo).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-33\. Joining a presence channel
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '`join()` subscribes to the presence channel, and `here()` allows you to define
    the behavior when the user joins and also when any other users join or leave the
    presence channel.'
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a presence channel like a “who’s online” sidebar in a chat
    room. When you first join a presence channel, your `here()` callback will be called
    and provided a list of all the members at that time. And any time any members
    join or leave, that callback will be called again with the updated list. There’s
    no messaging happening here, but you can play sounds, update the on-page list
    of members, or do whatever else you want in response to these actions.
  prefs: []
  type: TYPE_NORMAL
- en: There are also specific methods for individual events, which you can use individually
    or chained (see [Example 16-34](#listening_for_specific_presence_events)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-34\. Listening for specific presence events
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Excluding the current user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We covered this previously in the chapter, but if you want to exclude the current
    user, you can use the `broadcast()` global helper instead of the `event()` global
    helper and then chain the `toOthers()` method after your broadcast call. But with
    Echo, the JavaScript side of this is already handled for you. It’ll just work.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Echo JavaScript library doesn’t do anything you couldn’t
    do on your own—​but it makes a lot of common tasks much simpler and provides a
    cleaner, more expressive syntax for common WebSocket tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing to notifications with Echo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Laravel’s notifications come with a broadcast driver out of the box that pushes
    notifications out as broadcast events. You can subscribe to these notifications
    with Echo using `Echo.notification()`, as in [Example 16-35](#subscribing_to_notification_with_Echo).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-35\. Subscribing to a notification with Echo
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Client events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’d like to send quick, performant messages between your users without
    the messages even hitting your Laravel application—​for example, to send “typing…​”
    notifications—​you can use Echo’s `whisper()` method, as shown in [Example 16-36](#bypassing-laravel-with-echo).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-36\. Bypassing the Laravel server using Echo’s `whisper()` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: And then use `listenForWhisper()` to listen, as in [Example 16-37](#whisper-events-with-echo).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-37\. Listening for whisper events with Echo
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Scheduler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve ever written a cron job before, you likely already wish for a better
    tool. Not only is the syntax onerous and frustratingly difficult to remember,
    but it’s one significant aspect of your application that can’t be stored in version
    control.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel’s scheduler makes handling scheduled tasks simple. You’ll write your
    scheduled tasks in code, and then point one cron job at your app: once per minute,
    run `php artisan schedule:run`. Every time this Artisan command is run, Laravel
    checks your schedule definitions to find out if any scheduled tasks should run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the cron job to define that command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: There are many task types you can schedule and many time frames you can use
    to schedule them.
  prefs: []
  type: TYPE_NORMAL
- en: '*app/Console/Kernel.php* has a method named `schedule()`, which is where you’ll
    define any tasks you’d like to schedule.'
  prefs: []
  type: TYPE_NORMAL
- en: Available Task Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s take a look at the simplest option: a closure, run every minute
    ([Example 16-38](#scheduling_closure_to_run_every_minute)). Every time the cron
    job hits the `schedule:run` command, it will call this closure.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-38\. Scheduling a closure to run once every minute
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two other types of tasks you can schedule: Artisan and shell commands.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can schedule Artisan commands by passing their syntax exactly as you would
    call them from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can run any shell commands that you can run with PHP’s `exec()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Available Time Frames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The beauty of the scheduler isn’t just that you can define your tasks in code;
    it’s that you can schedule them in code, too. Laravel keeps track of time passing
    and evaluates whether it’s time for any given task to run. That’s easy with `everyMinute()`
    because the answer is always simple: run the task. But Laravel keeps the rest
    simple for you, too, even for the most complex of requests.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at your options by starting with a monstrous definition that’s
    simple in Laravel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we can chain times together: we can define frequency and specify
    the day of the week and the time, and of course we can do much more.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 16-1](#modifiers_for_scheduler) shows a list of potential date/time
    modifiers for use when scheduling a job.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 16-1\. Date/time modifiers for use with the scheduler
  prefs: []
  type: TYPE_NORMAL
- en: '| Command | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `->timezone(''America/Detroit'')` | Set the time zone for schedules |'
  prefs: []
  type: TYPE_TB
- en: '| `->cron(''* * * * * *'')` | Define the schedule using the traditional cron
    notation |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyMinute()` | Run every minute |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyTwoMinutes()` | Run every 2 minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyThreeMinutes()` | Run every 3 minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyFourMinutes()` | Run every 4 minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyFiveMinutes()` | Run every 5 minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyTenMinutes()` | Run every 10 minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyFifteenMinutes()` | Run every 15 minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyThirtyMinutes()` | Run every 30 minutes |'
  prefs: []
  type: TYPE_TB
- en: '| `->hourly()` | Run every hour |'
  prefs: []
  type: TYPE_TB
- en: '| `->hourlyAt(14)` | Run every hour at 14 minutes past |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyTwoHours()` | Run every 2 hours |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyThreeHours()` | Run every 3 hours |'
  prefs: []
  type: TYPE_TB
- en: '| `->everyFourHours()` | Run every 4 hours |'
  prefs: []
  type: TYPE_TB
- en: '| `->everySixHours()` | Run every 6 hours |'
  prefs: []
  type: TYPE_TB
- en: '| `->daily()` | Run every day at midnight |'
  prefs: []
  type: TYPE_TB
- en: '| `->dailyAt(''14:00'')` | Run every day at 14:00 |'
  prefs: []
  type: TYPE_TB
- en: '| `->twiceDaily(1, 14)` | Run every day at 1:00 and 14:00 |'
  prefs: []
  type: TYPE_TB
- en: '| `->twiceDailyAt(1, 14, 6)` | Run every day at 1:06 and 14:06 (the third argument
    is the minutes to start) |'
  prefs: []
  type: TYPE_TB
- en: '| `->weekly()` | Run every week (midnight on Sunday) |'
  prefs: []
  type: TYPE_TB
- en: '| `->weeklyOn(5, ''10:00'')` | Run every week on Friday at 10:00 |'
  prefs: []
  type: TYPE_TB
- en: '| `->monthly()` | Run every month (midnight on the 1st) |'
  prefs: []
  type: TYPE_TB
- en: '| `->monthlyOn(15, ''23:00'')` | Run every month on the 15th at 23:00 |'
  prefs: []
  type: TYPE_TB
- en: '| `->quarterly()` | Run every quarter (midnight on the 1st of January, April,
    July, and October) |'
  prefs: []
  type: TYPE_TB
- en: '| `->yearly()` | Run every year (midnight on the 1st of January) |'
  prefs: []
  type: TYPE_TB
- en: '| `->yearlyOn(6)` | Run every year (midnight on the 1st of June) |'
  prefs: []
  type: TYPE_TB
- en: '| `->when(closure)` | Limit the task to when the closure returns `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `->skip(closure)` | Limit the task to when the closure returns `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `->between(''8:00'', ''12:00'')` | Limit the task to between the given times
    |'
  prefs: []
  type: TYPE_TB
- en: '| `->unlessBetween(''8:00'', ''12:00'')` | Limit the task to any time except
    between the given times |'
  prefs: []
  type: TYPE_TB
- en: '| `->weekdays()` | Limit to weekdays |'
  prefs: []
  type: TYPE_TB
- en: '| `->sundays()` | Limit to Sundays |'
  prefs: []
  type: TYPE_TB
- en: '| `->mondays()` | Limit to Mondays |'
  prefs: []
  type: TYPE_TB
- en: '| `->tuesdays()` | Limit to Tuesdays |'
  prefs: []
  type: TYPE_TB
- en: '| `->wednesdays()` | Limit to Wednesdays |'
  prefs: []
  type: TYPE_TB
- en: '| `->thursdays()` | Limit to Thursdays |'
  prefs: []
  type: TYPE_TB
- en: '| `->fridays()` | Limit to Fridays |'
  prefs: []
  type: TYPE_TB
- en: '| `->saturdays()` | Limit to Saturdays |'
  prefs: []
  type: TYPE_TB
- en: '| `->days([1,2])` | Limit to Sundays and Mondays |'
  prefs: []
  type: TYPE_TB
- en: '| `->environments(*staging*)` | Limit to only the staging environment |'
  prefs: []
  type: TYPE_TB
- en: Most of these can be chained one after another, but of course, any combinations
    that don’t make sense chained can’t be chained.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 16-39](#sample_scheduled_events) shows a few combinations you could
    consider.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-39\. Some sample scheduled events
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Defining Time Zones for Scheduled Commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can define the time zone on a specific scheduled command using the `timezone()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also set a default time zone (separate from the application time zone)
    that all of your scheduled times will be defined in, by defining the `scheduleTimezone()`
    method in `App\Console\Kernel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Blocking and Overlap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to avoid having your tasks overlap each other—​for example, if
    you have a task running every minute that may sometimes take longer than a minute
    to run—​end the schedule chain with the `withoutOverlapping()` method. This method
    skips a task if the previous instance of that task is still running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Handling Task Output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes the output from your scheduled task is important, whether for logging,
    notifications, or just ensuring that the task ran.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to write the returned output of a task to a file (potentially overwriting
    what is already in the file), use `sendOutputTo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to append it to a file instead, use `appendOutputTo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And if you want to email the output to a designated recipient, write it to
    a file first and then add `emailOutputTo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that your email settings are configured correctly in Laravel’s basic
    email configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Closure Scheduled Events Can’t Send Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sendOutputTo()`, `appendOutputTo()`, and `emailOutputTo()` methods only
    work for `command()-` scheduled tasks. You can’t use them for closures, unfortunately.
  prefs: []
  type: TYPE_NORMAL
- en: You may also want to send some output to a webhook to verify that your tasks
    ran correctly. There are a few services that provide this sort of uptime monitoring,
    most significantly [Laravel Envoyer](https://envoyer.io), a zero-downtime deployment
    service that also provides cron uptime monitoring, and [Dead Man’s Snitch](https://deadmanssnitch.com),
    a tool designed purely for monitoring cron job uptime.
  prefs: []
  type: TYPE_NORMAL
- en: 'These services don’t expect something to be emailed to them, but rather expect
    an HTTP “ping,” so Laravel makes that easy with `pingBefore()` and `thenPing()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to use the ping features, you’ll need to pull in Guzzle using Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '`composer require guzzlehttp/guzzle`'
  prefs: []
  type: TYPE_NORMAL
- en: Task Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Speaking of running something *before* and *after* your task, there are hooks
    for that, with `before()` and `after()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Running the Scheduler in Local Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since the scheduler depends on cron, it’s simpler to set up on a server than
    on your local machine. If you’d like to have the scheduler running locally, run
    the `schedule:work` Artisan command, which will invoke the scheduler every minute,
    just like a cron job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing queued jobs (or anything else in the queue) is easy. In *phpunit.xml*,
    which is the configuration file for your tests, the `QUEUE_DRIVER` environment
    variable is set to `sync` by default. That means your tests will run your jobs
    or other queued tasks synchronously, directly in your code, without relying on
    a queue system of any sort. You can test them just like any other code.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can assert against the specific job itself, as in [Example 16-40](#verify_job_meets_criteria).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-40\. Using a closure to verify that a dispatched job meets given
    criteria
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: There are also the `assertPushedWithChain()` and `assertPushedWithoutChain()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: To test that an event fired, you have two options. First, you can just test
    that the behavior you expected happened, without concerning yourself with the
    event itself.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you can run a test against the event that was fired, as in [Example 16-41](#verify_fired_event_meets_criteria).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-41\. Using a closure to verify that a fired event meets given criteria
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Another common scenario is that you’re testing code that incidentally fires
    events, and you want to disable the event listeners during that test. You can
    disable the event system with the `withoutEvents()` method, as in [Example 16-42](#disabling_event_listeners).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-42\. Disabling event listeners during a test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: TL;DR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queues allow you to separate chunks of your application’s code from the synchronous
    flow of user interactions out to a list of commands to be processed by a “queue
    worker.” This allows your users to resume interactions with your application while
    slower processes are handled asynchronously in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs are classes that are structured with the intention of encapsulating a chunk
    of application behavior so that it can be pushed onto a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel’s event system follows the pub/sub or observer pattern, allowing you
    to send out notifications of an event from one part of your application, and elsewhere
    bind listeners to those notifications to define what behavior should happen in
    response to them. Using WebSockets, events can also be broadcast to frontend clients.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel’s scheduler simplifies scheduling tasks. Point an every-minute cron
    job to `php artisan` `schedule:run` and then schedule your tasks with even the
    most complex of time requirements using the scheduler, and Laravel will handle
    all the timings for you.
  prefs: []
  type: TYPE_NORMAL
