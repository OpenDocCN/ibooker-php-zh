- en: Chapter 3\. Routing and Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The essential function of any web application framework is to take requests
    from a user and deliver responses, usually via HTTP(S). This means defining an
    application’s routes is the first and most important project to tackle when learning
    a web framework; without routes, you have little to no ability to interact with
    the end user.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter we will examine routes in Laravel; you’ll see how to define
    them, how to point them to the code they should execute, and how to use Laravel’s
    routing tools to handle a diverse array of routing needs.
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Introduction to MVC, the HTTP Verbs, and REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of what we’ll talk about in this chapter references how Model–View–Controller
    (MVC) applications are structured, and many of the examples we’ll be looking at
    use REST-ish route names and verbs, so let’s take a quick look at both.
  prefs: []
  type: TYPE_NORMAL
- en: What Is MVC?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In MVC, you have three primary concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: model
  prefs: []
  type: TYPE_NORMAL
- en: Represents an individual database table (or a record from that table)—think
    “Company” or “Dog.”
  prefs: []
  type: TYPE_NORMAL
- en: view
  prefs: []
  type: TYPE_NORMAL
- en: Represents the template that outputs your data to the end user—​think “the login
    page template with this given set of HTML and CSS and JavaScript.”
  prefs: []
  type: TYPE_NORMAL
- en: controller
  prefs: []
  type: TYPE_NORMAL
- en: Like a traffic cop, takes HTTP requests from the browser, gets the right data
    out of the database and other storage mechanisms, validates user input, and eventually
    sends a response back to the user.
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 3-1](#FIG301), you can see that the end user will first interact
    with the controller by sending an HTTP request using their browser. The controller,
    in response to that request, may write data to and/or pull data from the model
    (database). The controller will then likely send data to a view, and then the
    view will be returned to the end user to display in their browser.
  prefs: []
  type: TYPE_NORMAL
- en: '![A diagram of a Model, a View, and a Controller, together with the User, all
    with arrows pointing to each other](assets/lur3_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. A basic illustration of MVC
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll cover some use cases for Laravel that don’t fit this relatively simplistic
    way of looking at application architecture, so don’t get hung up on MVC, but this
    will at least get you ready to approach the rest of this chapter as we talk about
    views and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: The HTTP Verbs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: the most common HTTP verbs are `GET` and `POST`, followed by `PUT` and `DELETE`.
    There are also `HEAD`, `OPTIONS`, and `PATCH`, and two others that are pretty
    much never used in normal web development, `TRACE` and `CONNECT`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick rundown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`'
  prefs: []
  type: TYPE_NORMAL
- en: Request a resource (or a list of resources).
  prefs: []
  type: TYPE_NORMAL
- en: '`HEAD`'
  prefs: []
  type: TYPE_NORMAL
- en: Ask for a headers-only version of the `GET` response.
  prefs: []
  type: TYPE_NORMAL
- en: '`POST`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a resource.
  prefs: []
  type: TYPE_NORMAL
- en: '`PUT`'
  prefs: []
  type: TYPE_NORMAL
- en: Overwrite a resource.
  prefs: []
  type: TYPE_NORMAL
- en: '`PATCH`'
  prefs: []
  type: TYPE_NORMAL
- en: Modify a resource.
  prefs: []
  type: TYPE_NORMAL
- en: '`DELETE`'
  prefs: []
  type: TYPE_NORMAL
- en: Delete a resource.
  prefs: []
  type: TYPE_NORMAL
- en: '`OPTIONS`'
  prefs: []
  type: TYPE_NORMAL
- en: Ask the server which verbs are allowed at this URL.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 3-1](#table0301) shows the actions available on a resource controller
    (more on these in [“Resource Controllers”](#resource_controllers)). Each action
    expects you to call a specific URL pattern using a specific verb, so you can get
    a sense of what each verb is used for.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. The methods of Laravel’s resource controllers
  prefs: []
  type: TYPE_NORMAL
- en: '| Verb | URL | Controller method | Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `tasks` | `index()` | `tasks.index` | Show all tasks |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `tasks/create` | `create()` | `tasks.create` | Show the create task
    form |'
  prefs: []
  type: TYPE_TB
- en: '| `POST` | `tasks` | `store()` | `tasks.store` | Accept form submission from
    the create task form |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `tasks/{task}` | `show()` | `tasks.show` | Show one task |'
  prefs: []
  type: TYPE_TB
- en: '| `GET` | `tasks/{task}/edit` | `edit()` | `tasks.edit` | Edit one task |'
  prefs: []
  type: TYPE_TB
- en: '| `PUT/PATCH` | `tasks/{task}` | `update()` | `tasks.update` | Accept form
    submission from the edit task form |'
  prefs: []
  type: TYPE_TB
- en: '| `DELETE` | `tasks/{task}` | `destroy()` | `tasks.destroy` | Delete one task
    |'
  prefs: []
  type: TYPE_TB
- en: What Is REST?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll cover REST in greater detail in [“The Basics of REST-Like JSON APIs”](ch13.html#intro_to_rest),
    but as a brief introduction, it’s an architectural style for building APIs. When
    we talk about REST in this book, we’ll mainly be referencing a few characteristics,
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Being structured around one primary resource at a time (e.g., `tasks`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consisting of interactions with predictable URL structures using HTTP verbs
    (as seen in [Table 3-1](#table0301))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning JSON and often being requested with JSON
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s more to it, but usually “RESTful” as it’ll be used in this book will
    mean “patterned after these URL-based structures so we can make predictable calls
    like `GET /tasks/14/edit` for the edit page.” This is relevant (even when not
    building APIs) because Laravel’s routing structures are based around a REST-like
    structure, as you can see in [Table 3-1](#table0301).
  prefs: []
  type: TYPE_NORMAL
- en: REST-based APIs follow mainly this same structure, except they don’t have a
    *create* route or an *edit* route, since APIs just represent actions, not pages
    that prep for the actions.
  prefs: []
  type: TYPE_NORMAL
- en: Route Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a Laravel application, you will define your web routes in *routes/web.php*
    and your API routes in *routes/api.php*. *Web routes* are those that will be visited
    by your end users; *API routes* are those for your API, if you have one. For now,
    we’ll primarily focus on the routes in *routes/web.php*.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest way to define a route is to match a path (e.g., `/`) with a closure,
    as seen in [Example 3-1](#EX1X).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-1\. Basic route definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You’ve now defined that if anyone visits `/` (the root of your domain), Laravel’s
    router should run the closure defined there and return the result. Note that we
    `return` our content and don’t `echo` or `print` it.
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Introduction to Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be wondering, “Why am I returning ‘Hello, World!’ instead of echoing
    it?”
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few answers, but the simplest is that there are a lot of wrappers
    around Laravel’s request and response cycle, including something called *middleware*.
    When your route closure or controller method is done, it’s not time to send the
    output to the browser yet; returning the content allows it to continue flowing
    through the response stack and the middleware before it is returned to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Many simple websites could be defined entirely within the web routes file. With
    a few simple `GET` routes combined with some templates, as illustrated in [Example 3-2](#EX30),
    you can serve a classic website easily.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-2\. Sample website
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Static Calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have much experience developing with PHP, you might be surprised to see
    static calls on the `Route` class. This is not actually a static method per se,
    but rather a service location using Laravel’s facades, which we’ll cover in [Chapter 11](ch11.html#the_container).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to avoid facades, you can accomplish these same definitions like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Route Verbs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might’ve noticed that we’ve been using `Route::get()` in our route definitions.
    This means we’re telling Laravel to only match for these routes when the HTTP
    request uses the `GET` action. But what if it’s a form `POST`, or maybe some JavaScript
    sending `PUT` or `DELETE` requests? There are a few other options for methods
    to call on a route definition, as illustrated in [Example 3-3](#EX31).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-3\. Route verbs
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Route Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve probably guessed, passing a closure to the route definition is not
    the only way to teach it how to resolve a route. Closures are quick and simple,
    but the larger your application gets, the clumsier it becomes to put all of your
    routing logic in one file. Additionally, applications using route closures can’t
    take advantage of Laravel’s route caching (more on that later), which can shave
    up to hundreds of milliseconds off of each request.
  prefs: []
  type: TYPE_NORMAL
- en: The other common option is to pass a controller name and method as a string
    in place of the closure, as in [Example 3-4](#EX32).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-4\. Routes calling controller methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is telling Laravel to pass requests to that path to the `index()` method
    of the `App\Http\Controllers\WelcomeController` controller. This method will be
    passed the same parameters and treated the same way as a closure you might’ve
    alternatively put in its place.
  prefs: []
  type: TYPE_NORMAL
- en: Route Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the route you’re defining has parameters—​segments in the URL structure that
    are variable—​it’s simple to define them in your route and pass them to your closure
    (see [Example 3-5](#EX34)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-5\. Route parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You can also make your route parameters optional by including a question mark
    (`?`) after the parameter name, as illustrated in [Example 3-6](#EX35). In this
    case, you should also provide a default value for the route’s corresponding variable.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-6\. Optional route parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: And you can use regular expressions (regexes) to define that a route should
    only match if a parameter meets particular requirements, as in [Example 3-7](#EX36).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-7\. Regular expression route constraints
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you’ve probably guessed, if you visit a path that matches a route string
    but the regex doesn’t match the parameter, it won’t be matched. Since routes are
    matched top to bottom, `users/abc` would skip the first closure in [Example 3-7](#EX36),
    but it would be matched by the second closure, so it would get routed there. On
    the other hand, `posts/abc/123` wouldn’t match any of the closures, so it would
    return a 404 (Not Found) error.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel also offers convenience methods for common regular expression matching
    patterns, as you can see in [Example 3-8](#EX36.5).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-8\. Regular expression route constraint helpers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Route Names
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to refer to these routes elsewhere in your application is just
    by their path. There’s a `url()` global helper to simplify that linking in your
    views, if you need it; see [Example 3-9](#EX37) for an example. The helper will
    prefix your route with the full domain of your site.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-9\. The `url()` helper
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, Laravel also allows you to name each route, which enables you to refer
    to it without explicitly referencing the URL. This is helpful because it means
    you can give simple nicknames to complex routes, and also because linking them
    by name means you don’t have to rewrite your frontend links if the paths change
    (see [Example 3-10](#EX38)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-10\. Defining route names
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This example illustrates a few new concepts. First, we’re using fluent route
    definition to add the name, by chaining the `name()` method after the `get()`
    method. This method allows us to name the route, giving it a short alias to make
    it easier to reference elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we’ve named this route `members.show`; `*resourcePlural*.*action*`
    is a common convention within Laravel for route and view names.
  prefs: []
  type: TYPE_NORMAL
- en: This example also introduced the `route()` helper. Just like `url()`, it’s intended
    to be used in views to simplify linking to a named route. If the route has no
    parameters, you can simply pass the route name (`route('members.index')`) and
    receive a route string (`"http://myapp.com/members"`). If it has parameters, pass
    them as an array in the second parameter like we did in [Example 3-10](#EX38).
  prefs: []
  type: TYPE_NORMAL
- en: In general, I recommend using route names instead of paths to refer to your
    routes, and therefore using the `route()` helper instead of the `url()` helper.
    Sometimes it can get a bit clumsy—​for example, if you’re working with multiple
    subdomains—​but it provides an incredible level of flexibility to later change
    the application’s routing structure without major penalty.
  prefs: []
  type: TYPE_NORMAL
- en: Route Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Often a group of routes shares a particular characteristic—a certain authentication
    requirement, a path prefix, or perhaps a controller namespace. Defining these
    shared characteristics again and again on each route not only seems tedious but
    also can muddy up the shape of your routes file and obscure some of the structures
    of your application.
  prefs: []
  type: TYPE_NORMAL
- en: '*Route groups* allow you to reduce this duplication by grouping several routes
    together and applying any shared configuration settings once to the entire group.
    Additionally, route groups are visual cues to future developers (and to your own
    brain) that these routes are grouped together.'
  prefs: []
  type: TYPE_NORMAL
- en: To group two or more routes together, you “surround” the route definitions with
    a route group, as shown in [Example 3-11](#EX40). In reality, you’re actually
    passing a closure to the group definition and defining the grouped routes within
    that closure.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-11\. Defining a route group
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By default, a route group doesn’t actually do anything. There’s no difference
    between using the group in [Example 3-11](#EX40) and separating a segment of your
    routes with code comments.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the most common use for route groups is to apply middleware to a group
    of routes. You’ll learn more about middleware in [Chapter 10](ch10.html#requests_and_responses),
    but, among other things, they’re what Laravel uses for authenticating users and
    restricting guest users from using certain parts of a site.
  prefs: []
  type: TYPE_NORMAL
- en: In [Example 3-12](#EX41), we’re creating a route group around the `dashboard`
    and `account` views and applying the `auth` middleware to both. In this example,
    this means users have to be logged in to the application to view the dashboard
    or the account page.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-12\. Restricting a group of routes to logged-in users only
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, it’s clearer and more direct to attach middleware to your routes in
    the controller instead of at the route definition. You can do this by calling
    the `middleware()` method in the constructor of your controller. The string you
    pass to the `middleware()` method is the name of the middleware, and you can optionally
    chain modifier methods (`only()` and `except()`) to define which methods will
    receive that middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you’re doing a lot of “only” and “except” customizations, that’s
    often a sign that you should break out a new controller for the exceptional routes.
  prefs: []
  type: TYPE_NORMAL
- en: Path Prefixes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you have a group of routes that share a segment of their path—​for example,
    if your site’s dashboard is prefixed with `/dashboard`—you can use route groups
    to simplify this structure (see [Example 3-13](#EX42)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-13\. Prefixing a group of routes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note that each prefixed group also has a `/` route that represents the root
    of the prefix—​in [Example 3-13](#EX42) that’s `/dashboard`.
  prefs: []
  type: TYPE_NORMAL
- en: Subdomain Routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subdomain routing is the same as route prefixing, but it’s scoped by subdomain
    instead of route prefix. There are two primary uses for this. First, you may want
    to present different sections of the application (or entirely different applications)
    to different subdomains. [Example 3-14](#EX43) shows how you can achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-14\. Subdomain routing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Second, you might want to set part of the subdomain as a parameter, as illustrated
    in [Example 3-15](#EX44). This is most often done in cases of multitenancy (think
    Slack or Harvest, where each company gets its own subdomain, like *tighten.slack.co*).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-15\. Parameterized subdomain routing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note that any parameters for the group get passed into the grouped routes’ methods
    as the first parameter(s).
  prefs: []
  type: TYPE_NORMAL
- en: Name Prefixes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s common that route names will reflect the inheritance chain of path elements,
    so `users/comments/5` will be served by a route named `users.comments.show`. In
    this case, it’s common to use a route group around all of the routes that are
    beneath the `users.comments` resource.
  prefs: []
  type: TYPE_NORMAL
- en: Just like we can prefix URL segments, we can also prefix strings to the route
    name. With route group name prefixes, we can define that every route within this
    group should have a given string prefixed to its name. In this context, we’re
    prefixing `"users."` to each route name, then `"comments."` (see [Example 3-16](#EX46)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-16\. Route group name prefixes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Route Group Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re grouping routes that are served by the same controller, such as
    when we’re showing, editing, and deleting users, for example, we can use the route
    group `controller()` method, as shown in [Example 3-17](#EX45), to avoid having
    to define the full tuple for every route.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-17\. Route group controllers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Fallback Routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Laravel you can define a “fallback route” (which you need to define at the
    end of your routes file) to catch all unmatched requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Signed Routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many applications regularly send notifications about one-off actions (resetting
    a password, accepting an invitation, etc.) and provide simple links to take those
    actions. Let’s imagine sending an email confirming the recipient was willing to
    be added to a mailing list.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three ways to send that link:'
  prefs: []
  type: TYPE_NORMAL
- en: Make that URL public and hope no one else discovers the approval URL or modifies
    their own approval URL to approve someone else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the action behind authentication, link to the action, and require the user
    to log in if they’re not logged in yet (which, in this case, may be impossible,
    as many mailing list recipients likely won’t be users with accounts).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Sign” the link so that it uniquely proves that the user received the link from
    your email, without them having to log in—something like *http://myapp.com/invitations/5816/yes?signature=030ab0ef6a8237bd86a8b8*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One simple way to accomplish the last option is to use a feature called *signed
    URLs*, which makes it easy to build a signature authentication system for sending
    out authenticated links. These links are composed of the normal route link with
    a “signature” appended that proves that the URL has not been changed since it
    was sent (and therefore that no one has modified the URL to access someone else’s
    information).
  prefs: []
  type: TYPE_NORMAL
- en: Signing a Route
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To build a signed URL to access a given route, the route must have a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate a normal link to this route you would use the `route()` helper,
    as we’ve already covered, but you could also use the `URL` facade to do the same
    thing: `URL::route(''invitations'', [''invitation'' => 12345, ''answer'' => ''yes''])`.
    To generate a *signed* link to this route, simply use the `signedRoute()` method
    instead. And if you want to generate a signed route with an expiration, use `temporarySignedRoute()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Using the now() Helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel offers a `now()` helper that’s the equivalent of `Carbon::now()`; it
    returns a Carbon object representative of today, right at this second.
  prefs: []
  type: TYPE_NORMAL
- en: Carbon is a datetime library that’s included with Laravel.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Routes to Allow Signed Links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you’ve generated a link to your signed route, you need to protect
    against any unsigned access. The easiest option is to apply the `signed` middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’d prefer, you can manually validate using the `hasValidSignature()`
    method on the `Request` object instead of using the `signed` middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a few of the route closures we’ve looked at so far, we’ve seen something
    along the lines of `return view('account')`. What’s going on here?
  prefs: []
  type: TYPE_NORMAL
- en: In the MVC pattern ([Figure 3-1](#FIG301)), *views* (or templates) are files
    that describe what some particular output should look like. You might have views
    that output JSON or XML or email, but the most common views in a web framework
    output HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Laravel, there are two view formats you can use out of the box: plain PHP
    and Blade templates (see [Chapter 4](ch04.html#blade_templating)). The difference
    is in the filename: *about.php* will be rendered with the PHP engine, and *about.blade.php*
    will be rendered with the Blade engine.'
  prefs: []
  type: TYPE_NORMAL
- en: Three Ways to Load a View
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are three ways to return a view. For now, just concern yourself with `view()`,
    but if you ever see `View::make()`, it’s the same thing, or you could inject `Illuminate\View\ViewFactory`
    if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve “loaded” a view with the `view()` helper, you have the option to
    simply return it (as in [Example 3-18](#EX47)), which will work fine if the view
    doesn’t rely on any variables from the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-18\. Simple `view()` usage
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This code looks for a view in *resources/views/home.blade.php* or *resources/views/home.php*
    and loads its contents and parses any inline PHP or control structures until you
    have just the view’s output. Once you return it, it’s passed on to the rest of
    the response stack and eventually returned to the user.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you need to pass in variables? Take a look at [Example 3-19](#EX48).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-19\. Passing variables to views
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This closure loads the *resources/views/tasks/index.blade.php* or *resources/views/tasks/index.php*
    view and passes it a single variable named `tasks`, which contains the result
    of the `Task::all()` method. `Task::all()` is an Eloquent database query you’ll
    learn about in [Chapter 5](ch05.html#database_and_eloquent).
  prefs: []
  type: TYPE_NORMAL
- en: Returning Simple Routes Directly with Route::view()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because it’s so common for a route to just return a view with no custom data,
    Laravel allows you to define a route as a “view” route without even passing the
    route definition a closure or a controller/method reference, as you can see in
    [Example 3-20](#route_view).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-20\. `Route::view()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Using View Composers to Share Variables with Every View
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes it can become a hassle to pass the same variables over and over. There
    may be a variable that you want accessible to every view in the site or to a certain
    class of views or a certain included subview—​for example, all views related to
    tasks or the header partial.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to share certain variables with every template or just certain
    templates, like in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: To learn more, check out [“View Composers and Service Injection”](ch04.html#view-comp-serv).
  prefs: []
  type: TYPE_NORMAL
- en: Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve mentioned controllers a few times, but until now, most of the examples
    have shown route closures. In the MVC pattern, controllers are essentially classes
    that organize the logic of one or more routes together in one place. Controllers
    tend to group similar routes together, especially if your application is structured
    in a traditionally CRUD-like format; in this case, a controller might handle all
    the actions that can be performed on a particular resource.
  prefs: []
  type: TYPE_NORMAL
- en: What is CRUD?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CRUD stands for *create*, *read*, *update*, *delete*, which are the four primary
    operations that web applications most commonly provide on a resource. For example,
    you can create a new blog post, you can read that post, you can update it, or
    you can delete it.
  prefs: []
  type: TYPE_NORMAL
- en: It may be tempting to cram all of the application’s logic into the controllers,
    but it’s better to think of controllers as the traffic cops that route HTTP requests
    around your application. Since there are other ways requests can come into your
    application—cron jobs, Artisan command-line calls, queue jobs, etc.—it’s wise
    to not rely on controllers for much behavior. This means a controller’s primary
    job is to capture the intent of an HTTP request and pass it on to the rest of
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s create a controller. One easy way to do this is with an Artisan command,
    so from the command line, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Artisan and Artisan Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel comes bundled with a command-line tool called Artisan. Artisan can be
    used to run migrations, create users and other database records manually, and
    perform many other manual, one-time tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Under the `make` namespace, Artisan provides tools for generating skeleton files
    for a variety of system files. That’s what allows us to run `php artisan make:controller`.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about this and other Artisan features, see [Chapter 8](ch08.html#artisan_and_tinker).
  prefs: []
  type: TYPE_NORMAL
- en: This will create a new file named *TaskController.php* in *app/Http/Controllers*,
    with the contents shown in [Example 3-21](#EX52).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-21\. Default generated controller
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Modify this file as shown in [Example 3-22](#EX53), creating a new public method
    called `index()`. We’ll just return some text there.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-22\. Simple controller example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Then, like we learned before, we’ll hook up a route to it, as shown in [Example 3-23](#EX54).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-23\. Route for the simple controller
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: That’s it. Visit the `/` route and you’ll see the words “Hello, World!”
  prefs: []
  type: TYPE_NORMAL
- en: The most common use of a controller method, then, will be something like [Example 3-24](#EX55),
    which provides the same functionality as our route closure in [Example 3-19](#EX48).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-24\. Common controller method example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This controller method loads the *resources/views/tasks/index.blade.php* or
    *resources/views/tasks/index.php* view and passes it a single variable named `tasks`,
    which contains the result of the `Task::all()` Eloquent method.
  prefs: []
  type: TYPE_NORMAL
- en: Generating Resource Controllers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to create a resource controller with autogenerated methods for
    all the basic resource routes like `create()` and `update()`, you can pass the
    `--resource` flag when using `php artisan make:controller`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Getting User Input
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second most common action to perform in a controller method is to take input
    from the user and act on it. That introduces a few new concepts, so let’s take
    a look at a bit of sample code and walk through the new pieces.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s bind our route; see [Example 3-25](#EX56).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-25\. Binding basic form actions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we’re binding the `GET` action of `tasks/create` (which shows a
    form for creating a new task) and the `POST` action of `tasks` (which is where
    our form will `POST` to when we’re creating a new task). We can assume the `create()`
    method in our controller just shows a form, so let’s look at the `store()` method
    in [Example 3-26](#EX57).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-26\. Common form input controller method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This example makes use of Eloquent models and the `redirect()` functionality,
    and we’ll talk about them more later, but for now let’s talk quickly about how
    we’re getting our data here.
  prefs: []
  type: TYPE_NORMAL
- en: We’re using the `request()` helper to represent the HTTP request (more on that
    later) and using its `only()` method to pull just the `title` and `description`
    fields the user submitted.
  prefs: []
  type: TYPE_NORMAL
- en: We’re then passing that data into the `create()` method of our `Task` model,
    which creates a new instance of the `Task` with `title` set to the passed-in title
    and `description` set to the passed-in description. Finally, we redirect back
    to the page that shows all tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few layers of abstraction at work here, which we’ll cover in a
    second, but know that the data coming from the `only()` method comes from the
    same pool of data all common methods used on the `Request` object draw from, including
    `all()` and `get()`. The set of data each of these methods is pulling from represents
    all user-provided data, whether from query parameters or `POST` values. So, our
    user filled out two fields on the “add task” page: “title” and “description.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'To break down the abstraction a bit, `request()->only()` takes an associative
    array of input names and returns them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And `Task::create()` takes an associative array and creates a new task from
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Combining them together creates a task with just the user-provided “title” and
    “description” fields.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting Dependencies into Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel’s facades and global helpers present a simple interface to the most
    useful classes in Laravel’s codebase. You can get information about the current
    request and user input, the session, caches, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: But if you prefer to inject your dependencies, or if you want to use a service
    that doesn’t have a facade or a helper, you’ll need to find some way to bring
    instances of these classes into your controller.
  prefs: []
  type: TYPE_NORMAL
- en: This is our first exposure to Laravel’s service container. For now, if this
    is unfamiliar, you can think about it as a little bit of Laravel magic; or, if
    you want to know more about how it’s actually functioning, you can skip ahead
    to [Chapter 11](ch11.html#the_container).
  prefs: []
  type: TYPE_NORMAL
- en: All controller methods (including the constructors) are resolved out of Laravel’s
    container, which means anything you typehint that the container knows how to resolve
    will be automatically injected.
  prefs: []
  type: TYPE_NORMAL
- en: Typehints in PHP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Typehinting* in PHP means putting the name of a class or interface in front
    of a variable in a method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This typehint is telling PHP that whatever is passed into the method *must*
    be of type `Logger`, which could be either an interface or a class.
  prefs: []
  type: TYPE_NORMAL
- en: As a nice example, what if you’d prefer having an instance of the `Request`
    object instead of using the global helper? Just typehint `Illuminate\Http\Request`
    in your method parameters, like in [Example 3-27](#EX58).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-27\. Controller method injection via typehinting
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: So, you’ve defined a parameter that must be passed into the `store()` method.
    And since you typehinted it, and since Laravel knows how to resolve that class
    name, you’re going to have the `Request` object ready for you to use in your method
    with no work on your part. No explicit binding, no anything else—​it’s just there
    as the `$request` variable.
  prefs: []
  type: TYPE_NORMAL
- en: And, as you can tell from comparing Examples [3-26](#EX57) and [3-27](#EX58),
    the `request()` helper and the `Request` object behave exactly the same.
  prefs: []
  type: TYPE_NORMAL
- en: Resource Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes naming the methods in your controllers can be the hardest part of
    writing a controller. Thankfully, Laravel has some conventions for all of the
    routes of a traditional REST/CRUD controller (called a *resource controller* in
    Laravel); additionally, it comes with a generator out of the box and a convenience
    route definition that allows you to bind an entire resource controller at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the methods that Laravel expects for a resource controller, let’s generate
    a new controller from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now open *app/Http/Controllers/MySampleResourceController.php*. You’ll see it
    comes prefilled with quite a few methods. Let’s walk through what each represents.
    We’ll use a `Task` as an example.
  prefs: []
  type: TYPE_NORMAL
- en: The methods of Laravel’s resource controllers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember the table from earlier? [Table 3-1](#table0301) shows the HTTP verb,
    the URL, the controller method name, and the name for each of these default methods
    that are generated in Laravel’s resource controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Binding a resource controller
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, we’ve seen that these are the conventional route names to use in Laravel,
    and also that it’s easy to generate a resource controller with methods for each
    of these default routes. Thankfully, you don’t have to generate routes for each
    of these controller methods by hand, if you don’t want to. There’s a trick for
    that, called *resource controller binding*. Take a look at [Example 3-28](#EX59).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-28\. Resource controller binding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This will automatically bind all of the routes listed in [Table 3-1](#table0301)
    for this resource to the appropriate method names on the specified controller.
    It’ll also name these routes appropriately; for example, the `index()` method
    on the `tasks` resource controller will be named `tasks.index`.
  prefs: []
  type: TYPE_NORMAL
- en: artisan route:list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you ever find yourself in a situation where you’re wondering what routes
    your current application has available, there’s a tool for that: from the command
    line, run `php artisan route:list` and you’ll get a listing of all of the available
    routes. I prefer `php artisan route:list --exclude-vendor` so I don’t see all
    the weird routes my dependencies register in order for them to operate (see [Figure 3-2](#FIG301X)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![lur3 0302](assets/lur3_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. artisan route:list
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: API Resource Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re working with RESTful APIs, the list of potential actions on a resource
    is not the same as it is with an HTML resource controller. For example, you can
    send a `POST` request to an API to create a resource, but you can’t really “show
    a create form” in an API.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate an *API resource controller*, which is a controller that has the
    same structure as a resource controller except it excludes the *create* and *edit*
    actions, pass the `--api` flag when creating a controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To bind an API resource controller, use the `apiResource()` method instead of
    the `resource()` method, as shown in [Example 3-29](#EX60).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-29\. API resource controller binding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Single Action Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will be times in your applications when a controller should only service
    a single route. You may find yourself wondering how to name the controller method
    for that route. Thankfully, you can point a single route at a single controller
    without concerning yourself with naming the one method.
  prefs: []
  type: TYPE_NORMAL
- en: As you may already know, the `__invoke()` method is a PHP magic method that
    allows you to “invoke” an instance of a class, treating it like a function and
    calling it. This is the tool Laravel’s *single action controllers* use to allow
    you to point a route to a single controller, as you can see in [Example 3-30](#EX61).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-30\. Using the `__invoke()` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Route Model Binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common routing patterns is that the first line of any controller
    method tries to find the resource with the given ID, like in [Example 3-31](#EX62).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-31\. Getting a resource for each route
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Laravel provides a feature that simplifies this pattern called *route model
    binding*. This allows you to define that a particular parameter name (e.g., `{conference}`)
    will indicate to the route resolver that it should look up an Eloquent database
    record with that ID and then pass it in as the parameter *instead* of just passing
    the ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two kinds of route model binding: implicit and custom (or explicit).'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Route Model Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to use route model binding is to name your route parameter
    something unique to that model (e.g., name it `$conference` instead of `$id`),
    then typehint that parameter in the closure/controller method and use the same
    variable name there. It’s easier to show than to describe, so take a look at [Example 3-32](#EX75).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-32\. Using an implicit route model binding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Because the route parameter (`{conference}`) is the same as the method parameter
    (`$conference`), and the method parameter is typehinted with a `Conference` model
    (`Conference $conference`), Laravel sees this as a route model binding. Every
    time this route is visited, the application will assume that whatever is passed
    into the URL in place of `{conference}` is an ID that should be used to look up
    a `Conference`, and then that resulting model instance will be passed in to your
    closure or controller method.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Route Key for an Eloquent Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any time an Eloquent model is looked up via a URL segment (usually because of
    route model binding), the default column Eloquent will look it up by is its primary
    key (ID).
  prefs: []
  type: TYPE_NORMAL
- en: 'To change the column your Eloquent model uses for URL lookups in all your routes,
    add a method to your model named `getRouteKeyName()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, a URL like `conferences/{conference}` will expect to get an entry from
    the slug column instead of the ID and will perform its lookups accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Route Key in a Specific Route
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Laravel, you can also change the route key on a specific route instead of
    globally by appending a colon and the column name in the route definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have two dynamic segments in your URL (for example: `organizers/{organizer}/conferences/{conference:slug`),
    Laravel will automatically attempt to scope the second model’s queries to only
    those related to the first. So it’ll check the `Organizer` model for a `conferences`
    relationship, and if it exists, only return Conferences that are associated with
    the `Organizer` found by the first segment.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Custom Route Model Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manually configure route model bindings, add a line like the one in [Example 3-33](#EX63)
    to the `boot()` method in `App\Providers\RouteServiceProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-33\. Adding a route model binding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: You’ve now specified that whenever a route has a parameter in its definition
    named `{event}`, as demonstrated in [Example 3-34](#EX64), the route resolver
    will return an instance of the `Conference` class with the ID of that URL parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-34\. Using an explicit route model binding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Route Caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’re looking to squeeze every millisecond out of your load time, you may
    want to take a look at *route caching*. One of the pieces of Laravel’s bootstrap
    that can take anywhere from a few dozen to a few hundred milliseconds is parsing
    the *routes/** files, and route caching speeds up this process dramatically.
  prefs: []
  type: TYPE_NORMAL
- en: To cache your routes file, you need to be using all controller, redirect, view,
    and resource routes (no route closures). If your app isn’t using any route closures,
    you can run `php artisan route:cache` and Laravel will serialize the results of
    your *routes/** files. If you want to delete the cache, run `php artisan route:clear`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the drawback: Laravel will now match routes against that cached file
    instead of your actual *routes/** files. You can make endless changes to your
    routes files, and they won’t take effect until you run `route:cache` again. This
    means you’ll have to recache every time you make a change, which introduces a
    lot of potential for confusion.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what I would recommend instead: since Git ignores the route cache file
    by default anyway, consider only using route caching on your production server,
    and run the `php artisan route:cache` command every time you deploy new code (whether
    via a Git post-deploy hook, a Forge deploy command, or as a part of whatever other
    deployment system you use). This way, you won’t have confusing local development
    issues, but your remote environment will still benefit from route caching.'
  prefs: []
  type: TYPE_NORMAL
- en: Form Method Spoofing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes you need to manually define which HTTP verb a form should send as.
    HTML forms only allow for `GET` or `POST`, so if you want any other sort of verb,
    you’ll need to specify that yourself.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Verbs in Laravel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen already, you can define which verbs a route will match in the
    route definition using `Route::get()`, `Route::post()`, `Route::any()`, or `Route::match()`.
    You can also match with `Route::patch()`, `Route::put()`, and `Route::delete()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how does one send a request other than `GET` with a web browser? First,
    the `method` attribute in an HTML form determines its HTTP verb: if your form
    has a `method` of `"GET"`, it will submit via query parameters and a `GET` method;
    if the form has a `method` of `"POST"`, it will submit via the post body and a
    `POST` method.'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript frameworks make it easy to send other requests, like `DELETE` and
    `PATCH`. But if you find yourself needing to submit HTML forms in Laravel with
    verbs other than `GET` or `POST`, you’ll need to use *form method spoofing*, which
    means spoofing the HTTP method in an HTML form.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Method Spoofing in HTML Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To inform Laravel that the form you’re currently submitting should be treated
    as something other than a `POST`, add a hidden variable named `_method` with the
    value of `"PUT"`, `"PATCH"`, or `"DELETE"`, and Laravel will match and route that
    form submission as if it were actually a request with that verb.
  prefs: []
  type: TYPE_NORMAL
- en: The form in [Example 3-35](#EX65), since it’s passing Laravel the method of
    `"DELETE"`, will match routes defined with `Route::delete()`, but not those with
    `Route::post()`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-35\. Form method spoofing
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: CSRF Protection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve tried to submit a form in a Laravel application already, including
    the one in [Example 3-35](#EX65), you’ve likely run into the dreaded `TokenMismatchException`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all routes in Laravel except “read-only” routes (those using `GET`,
    `HEAD`, or `OPTIONS`) are protected against cross-site request forgery (CSRF)
    attacks by requiring a token, in the form of an input named `_token`, to be passed
    along with each request. This token is generated at the start of every session,
    and every non–read-only route compares the submitted `_token` against the session
    token.
  prefs: []
  type: TYPE_NORMAL
- en: What is CSRF?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *cross-site request forgery* is when one website pretends to be another. The
    goal is for someone to hijack your users’ access to your website by submitting
    forms from *their* website to *your* website via the logged-in user’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: The best way around CSRF attacks is to protect all inbound routes—`POST`, `DELETE`,
    etc.—with a token, which Laravel does out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: You have two options for getting around this CSRF error. The first, and preferred,
    method is to add the `_token` input to each of your submissions. In HTML forms,
    there’s a simple way to do it, as you can see in [Example 3-36](#EX66).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-36\. CSRF tokens
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript applications, it takes a bit more work, but not much. The most
    common solution for sites using JavaScript frameworks is to store the token on
    every page in a `<meta>` tag like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Storing the token in a `<meta>` tag makes it easy to bind it to the correct
    HTTP header, which you can do once globally for all requests from your JavaScript
    framework, like in [Example 3-37](#EX67).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-37\. Globally binding a header for CSRF
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Laravel will check the `X-CSRF-TOKEN` (and `X-XSRF-TOKEN`, which Axios and other
    JavaScript frameworks like Angular use) on every request, and valid tokens passed
    there will mark the CSRF protection as satisfied.
  prefs: []
  type: TYPE_NORMAL
- en: Binding CSRF Tokens with Vue Resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bootstrapping the CSRF token into Vue Resource looks a bit different than it
    does for Laravel; see the [Vue Resource docs](https://oreil.ly/YT0Nb) for examples.
  prefs: []
  type: TYPE_NORMAL
- en: Redirects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, the only things we’ve explicitly talked about returning from a controller
    method or route definition have been views. But there are a few other structures
    we can return to give the browser instructions on how to behave.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s cover the *redirect*. You’ve already seen a few of these in other
    examples. There are two common ways to generate a redirect; we’ll use the `redirect()`
    global helper here, but you may prefer the facade. Both create an instance of
    `Illuminate\Http\RedirectResponse`, perform some convenience methods on it, and
    then return it. You can also do this manually, but you’ll have to do a little
    more work yourself. Take a look at [Example 3-38](#EX68) to see a few ways you
    can return a redirect.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-38\. Different ways to return a redirect
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `redirect()` helper exposes the same methods as the `Redirect`
    facade, but it also has a shortcut; if you pass parameters directly to the helper
    instead of chaining methods after it, it’s a shortcut to the `to()` redirect method.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the (optional) third parameter for the `Route::redirect()` route
    helper can be the status code (e.g., 302) for your redirect.
  prefs: []
  type: TYPE_NORMAL
- en: redirect()->to()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The method signature for the `to()` method for redirects looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`$to` is a valid internal path, `$status` is the HTTP status (defaulting to
    `302`), `$headers` allows you to define which HTTP headers to send along with
    your redirect, and `$secure` allows you to override the default choice of `http`
    versus `https` (which is normally set based on your current request URL). [Example 3-39](#EX76)
    shows an example of its use.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-39\. `redirect()->to()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: redirect()->route()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `route()` method is the same as the `to()` method, but rather than pointing
    to a particular path, it points to a particular route name (see [Example 3-40](#EX69)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-40\. `redirect()->route()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that since some route names require parameters, its parameter order is
    a little different. `route()` has an optional second parameter for the route parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: So, using it might look a little like [Example 3-41](#EX70).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-41\. `redirect()->route()` with parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Redirect to_route() Helper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can use the `to_route()` helper as an alias for the `redirect()->route()`
    method. The signature for both is the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: redirect()->back()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Because of some of the built-in conveniences of Laravel’s session implementation,
    your application will always have knowledge of what the user’s previously visited
    page was. That opens up the opportunity for a `redirect()->back()` redirect, which
    simply redirects the user to whatever page they came from. There’s also a global
    shortcut for this: `back()`.'
  prefs: []
  type: TYPE_NORMAL
- en: Other Redirect Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The redirect service provides other methods that are less commonly used, but
    still available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`refresh()`'
  prefs: []
  type: TYPE_NORMAL
- en: Redirects to the same page the user is currently on.
  prefs: []
  type: TYPE_NORMAL
- en: '`away()`'
  prefs: []
  type: TYPE_NORMAL
- en: Allows for redirecting to an external URL without the default URL validation.
  prefs: []
  type: TYPE_NORMAL
- en: '`secure()`'
  prefs: []
  type: TYPE_NORMAL
- en: Like `to()` with the `secure` parameter set to `"true"`.
  prefs: []
  type: TYPE_NORMAL
- en: '`action()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allows you to link to a controller and method in one of two ways: as a string
    (`redirect()->action(''MyController@myMethod'')`) or as a tuple (`r⁠e⁠d⁠i⁠r⁠e⁠c⁠t⁠(⁠)​\-⁠>⁠a⁠c⁠t⁠i⁠o⁠n⁠([MyController::class,
    ''myMethod''])`).'
  prefs: []
  type: TYPE_NORMAL
- en: '`guest()`'
  prefs: []
  type: TYPE_NORMAL
- en: Used internally by the authentication system (discussed in [Chapter 9](ch09.html#user_authentication_and_authorization));
    when a user visits a route they’re not authenticated for, this captures the “intended”
    route and then redirects the user (usually to a login page).
  prefs: []
  type: TYPE_NORMAL
- en: '`intended()`'
  prefs: []
  type: TYPE_NORMAL
- en: Also used internally by the authentication system; after a successful authentication,
    this grabs the “intended” URL stored by the `guest()` method and redirects the
    user there.
  prefs: []
  type: TYPE_NORMAL
- en: redirect()->with()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While it is structured similarly to the other methods you can call on `redirect()`,
    `with()` is different in that it doesn’t define where you’re redirecting to, but
    what data you’re passing along with the redirect. When you’re redirecting users
    to different pages, you often want to pass certain data along with them. You could
    manually flash the data to the session, but Laravel has some convenience methods
    to help you with that.
  prefs: []
  type: TYPE_NORMAL
- en: Most commonly, you can pass along either an array of keys and values or a single
    key and value using `with()`, like in [Example 3-42](#EX71). This saves your `with()`
    data to the session just for the next page load.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-42\. Redirect with data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Chaining Methods on Redirects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with many other facades, most calls to the `Redirect` facade can accept fluent
    method chains, like the `with()` calls in [Example 3-42](#EX71). You’ll learn
    more about fluency in [“What Is a Fluent Interface?”](ch05.html#fluent).
  prefs: []
  type: TYPE_NORMAL
- en: You can also use `withInput()`, as in [Example 3-43](#EX72), to redirect with
    the user’s form input flashed; this is most common in the case of a validation
    error, where you want to send the user back to the form they just came from.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-43\. Redirect with form input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to get the flashed input that was passed with `withInput()`
    is using the `old()` helper, which can be used to get all old input (`old()`)
    or just the value for a particular key, as shown in the following example, with
    the second parameter as the default if there is no old value. You’ll commonly
    see this in views, which allows this HTML to be used both on the “create” and
    the “edit” view for this form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Speaking of validation, there is also a useful method for passing errors along
    with a redirect response: `withErrors()`. You can pass it any “provider” of errors,
    which may be an error string, an array of errors, or, most commonly, an instance
    of the Illuminate `Validator`, which we’ll cover in [Chapter 10](ch10.html#requests_and_responses).
    [Example 3-44](#EX73) shows an example of its use.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-44\. Redirect with errors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '`withErrors()` automatically shares an `$errors` variable with the views of
    the page it’s redirecting to, for you to handle however you’d like.'
  prefs: []
  type: TYPE_NORMAL
- en: The validate() Method on Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Don’t like how [Example 3-44](#EX73) looks? There’s a simple and powerful tool
    that will make it easy for you to clean up that code. Read more in [“validate()
    on the Request Object”](ch07.html#validation_on_request).
  prefs: []
  type: TYPE_NORMAL
- en: Aborting the Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aside from returning views and redirects, the most common way to exit a route
    is to abort. There are a few globally available methods (`abort()`, `abort_if()`,
    and `abort_unless()`), which optionally take HTTP status codes, a message, and
    a headers array as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: As [Example 3-45](#EX74) shows, `abort_if()` and `abort_unless()` take a first
    parameter that is evaluated for its truthiness and perform the abort depending
    on the result.
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-45\. 403 Forbidden aborts
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Custom Responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few other options available for us to return, so let’s go over the
    most common responses after views, redirects, and aborts. Just like with redirects,
    you can run these methods on either the `response()` helper or the `Response`
    facade.
  prefs: []
  type: TYPE_NORMAL
- en: response()->make()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to create an HTTP response manually, just pass your data into the
    first parameter of `response()->make()`: for example, `return response()->make(*Hello,
    World!*)`. Once again, the second parameter is the HTTP status code and the third
    is your headers.'
  prefs: []
  type: TYPE_NORMAL
- en: response()->json() and ->jsonp()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a JSON-encoded HTTP response manually, pass your JSON-able content
    (arrays, collections, or whatever else) to the `json()` method: for example `return
    response()->json(User::all())`. It’s just like `make()`, except it `json_encode`s
    your content and sets the appropriate headers.'
  prefs: []
  type: TYPE_NORMAL
- en: response()->download(), ->streamDownload(), and ->file()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To send a file for the end user to download, pass either an `SplFileInfo` instance
    or a string filename to `download()`, with an optional second parameter of the
    download filename: for example, `return response()->download(''file501751.pdf'',
    ''myFile.pdf'')`, which would send a file that’s at *file501751.pdf* and rename
    it, as it’s sent, to *myFile.pdf*.'
  prefs: []
  type: TYPE_NORMAL
- en: To display the same file in the browser (if it’s a PDF or an image or something
    else the browser can handle), use `response()->file()` instead, which takes the
    same parameters as `response->download()`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to make some content from an external service available as a download
    without having to write it directly to your server’s disk, you can stream the
    download using `response()->streamDownload()`. This method expects as parameters
    a closure that echoes a string, a filename, and optionally an array of headers;
    see [Example 3-46](#EX78).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-46\. Streaming downloads from external servers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some other communities the idea of unit-testing controller methods is common,
    but within Laravel (and most of the PHP community) it’s typical to rely on *application
    testing* to test the functionality of routes.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to verify that a `POST` route works correctly, we can write a test
    like [Example 3-47](#EX80).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-47\. Writing a simple `POST` route test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Did we directly call the controller methods? No. But we ensured that the goal
    of this route—to receive a `POST` and save its important information to the database—was
    met.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use similar syntax to visit a route and verify that certain text
    shows up on the page, or that clicking certain buttons does certain things (see
    [Example 3-48](#EX75X)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3-48\. Writing a simple `GET` route test
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: TL;DR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel’s routes are defined in *routes/web.php* and *routes/api.php*. You can
    define the expected path for each route, which segments are static and which are
    parameters, which HTTP verbs can access the route, and how to resolve it. You
    can also attach middleware to routes, group them, and give them names.
  prefs: []
  type: TYPE_NORMAL
- en: What is returned from the route closure or controller method dictates how Laravel
    responds to the user. If it’s a string or a view, it’s presented to the user;
    if it’s other sorts of data, it’s converted to JSON and presented to the user;
    and if it’s a redirect, it forces a redirect.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel provides a series of tools and conveniences to simplify common routing-related
    tasks and structures. These include resource controllers, route model binding,
    and form method spoofing.
  prefs: []
  type: TYPE_NORMAL
