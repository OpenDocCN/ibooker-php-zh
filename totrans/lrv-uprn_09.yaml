- en: Chapter 9\. User Authentication and Authorization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章 用户认证与授权
- en: Setting up a basic user authentication system—including registration, login,
    sessions, password resets, and access permissions—can often be one of the more
    time-consuming pieces of creating the foundation of an application. It’s a prime
    candidate for extracting functionality out to a library, and there are quite a
    few such libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 设置基本的用户认证系统，包括注册、登录、会话、密码重置和访问权限，通常是创建应用程序基础的更耗时的部分之一。这是将功能提取到库中的一个主要候选项，而且有许多这样的库可供选择。
- en: But because authentication needs can vary widely across projects, most authentication
    systems grow bulky and unusable quickly. Thankfully, Laravel has found a way to
    make a suite of authentication systems that are easy to use and understand, but
    flexible enough to fit in a variety of settings.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于项目的认证需求可能存在较大差异，大多数认证系统很快就会变得笨重且难以使用。幸运的是，Laravel 已经找到了一种方法，可以创建一套易于使用和理解的认证系统，同时灵活到可以适应各种设置。
- en: Every new installation of Laravel has a `create_users_table` migration and a
    `User` model built in. If you bring in Breeze (see [“Laravel Breeze”](ch06.html#breeze))
    or Jetstream (see [“Laravel Jetstream”](ch06.html#jetstream)), they’ll seed your
    app with a collection of authentication-related views, routes, controllers/actions,
    and other features. The APIs are clean and clear, and the conventions all work
    together to provide a simple—​and seamless—​authentication and authorization system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的每一个新安装都包含一个 `create_users_table` 迁移和一个内置的 `User` 模型。如果引入了 Breeze（参见
    [“Laravel Breeze”](ch06.html#breeze)）或 Jetstream（参见 [“Laravel Jetstream”](ch06.html#jetstream)），它们将为您的应用程序提供一系列与认证相关的视图、路由、控制器/动作和其他功能。API
    是清晰易懂的，所有约定都协同工作，提供了一个简单且无缝的认证和授权系统。
- en: The User Model and Migration
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户模型与迁移
- en: When you create a new Laravel application, the first migration and model you’ll
    see are the `create_users_table` migration and the `App\User` model. [Example 9-1](#EX901)
    shows, straight from the migration, the fields you’ll get in your `users` table.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建一个新的 Laravel 应用程序时，您将看到的第一个迁移和模型是 `create_users_table` 迁移和 `App\User` 模型。[示例 9-1](#EX901)
    直接展示了从迁移中获取的 `users` 表中的字段。
- en: Example 9-1\. Laravel’s default user migration
  id: totrans-6
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-1\. Laravel 的默认用户迁移
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We have an autoincrementing primary key ID, a name, a unique email, a password,
    a “remember me” token, and created and modified timestamps. This covers everything
    you need to handle basic user authentication in most apps.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个自增主键 ID，一个名称，一个唯一的电子邮件，一个密码，一个“记住我”令牌，以及创建和修改的时间戳。这涵盖了大多数应用程序中处理基本用户认证所需的一切内容。
- en: The Difference Between Authentication and Authorization
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证与授权的区别
- en: '*Authentication* means verifying who someone is and allowing them to act as
    that person in your system. This includes the login and logout processes as well
    as any tools that allow the users to identify themselves during their time using
    the application.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证* 意味着验证某人是谁，并允许他们在您的系统中以此身份行事。这包括登录和注销过程，以及任何允许用户在使用应用程序期间识别自己的工具。'
- en: '*Authorization* means determining whether the authenticated user is *allowed*
    (authorized) to perform a specific behavior. For example, an authorization system
    allows you to forbid any nonadministrators from viewing the site’s earnings.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*授权* 意味着确定经过身份验证的用户是否*被允许*（授权）执行特定行为。例如，授权系统允许您禁止非管理员查看站点的收入情况。'
- en: The `User` model is a bit more complex, as you can see in [Example 9-2](#EX902).
    The `App\User` class itself is simple, but it extends the `Illuminate\Foundation\Auth\User`
    class, which pulls in several traits.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 模型略微复杂，您可以在 [示例 9-2](#EX902) 中看到。`App\User` 类本身很简单，但它扩展了 `Illuminate\Foundation\Auth\User`
    类，后者引入了几个特性。'
- en: Example 9-2\. Laravel’s default `User` model
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-2\. Laravel 的默认 `User` 模型
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Eloquent Model Refresher
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Eloquent 模型刷新器
- en: If this is entirely unfamiliar, consider reading [Chapter 5](ch05.html#database_and_eloquent)
    before continuing to learn how Eloquent models work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些内容对您完全陌生，请考虑在继续学习如何使用 Eloquent 模型之前阅读[第 5 章](ch05.html#database_and_eloquent)。
- en: So, what can we learn from this model? First, users live in the `users` table;
    Laravel will infer this from the class name. We are able to fill out the `name`,
    `email`, and `password` properties when creating a new user, and the `password`
    and `remember_token` properties are excluded when outputting the user as JSON.
    Looking good so far.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们从这个模型中能学到什么？首先，用户存储在 `users` 表中；Laravel 将从类名推断出这一点。创建新用户时，我们可以填写 `name`、`email`
    和 `password` 属性，而在将用户输出为 JSON 时，则会排除 `password` 和 `remember_token` 属性。目前看起来一切都很好。
- en: We also can see from the contracts and the traits in the `Illuminate\Foundation\Auth`
    version of `User` that there are some features in the framework (the ability to
    authenticate, to authorize, and to reset passwords) that theoretically could be
    applied to other models, not just the `User` model, and that could be applied
    individually or together.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从 `Illuminate\Foundation\Auth` 版本的 `User` 中的合约和特性中看到，框架中有一些功能（例如身份验证、授权和密码重置的能力），理论上可以应用于其他模型，而不仅仅是
    `User` 模型，并且可以单独或集体应用。
- en: The `Authenticatable` contract requires methods (e.g., `getAuthIdentifier()`)
    that allow the framework to authenticate instances of this model to the auth system;
    the `Authenticatable` trait includes the methods necessary to satisfy that contract
    with an average Eloquent model.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authenticatable` 合约要求方法（例如 `getAuthIdentifier()`），允许框架对此模型的实例进行身份验证到身份验证系统；`Authenticatable`
    特性包含了满足普通 Eloquent 模型此合约所需的方法。'
- en: The `Authorizable` contract requires a method (`can()`) that allows the framework
    to authorize instances of this model for their access permissions in different
    contexts. Unsurprisingly, the `Authorizable` trait provides methods that will
    satisfy the `Authorizable` contract for an average Eloquent model.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Authorizable` 合约要求一个方法 (`can()`)，允许框架在不同上下文中授权此模型的实例以获取其访问权限。毫不奇怪，`Authorizable`
    特性提供了方法，这些方法将为普通的 Eloquent 模型满足 `Authorizable` 合约。'
- en: Finally, the `CanResetPassword` contract requires methods (`g⁠⁠e⁠t⁠E⁠m⁠a⁠i⁠l⁠F⁠o⁠r​P⁠a⁠s⁠s⁠w⁠o⁠r⁠d⁠R⁠e⁠s⁠e⁠t⁠(⁠)`,
    `sendPasswordResetNotification()`) that allow the framework to—you guessed it—reset
    the password of any entity that satisfies this contract. The `CanResetPassword`
    trait provides methods to satisfy that contract for an average Eloquent model.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`CanResetPassword` 合约要求方法 (`g⁠⁠e⁠t⁠E⁠m⁠a⁠i⁠l⁠F⁠o⁠r​P⁠a⁠s⁠s⁠w⁠o⁠r⁠d⁠R⁠e⁠s⁠e⁠t⁠(⁠)`、`sendPasswordResetNotification()`)，允许框架重置任何满足此合约的实体的密码。`CanResetPassword`
    特性提供了方法，以满足普通 Eloquent 模型的这一合约。
- en: At this point, we have the ability to easily represent an individual user in
    the database (with the migration), and to pull them out with a model instance
    that can be authenticated (logged in and out), authorized (checked for access
    permissions to a particular resource), and sent a password reset email.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们能够轻松地在数据库中表示个别用户（通过迁移），并使用可以进行身份验证（登录和注销）、授权（检查对特定资源的访问权限）和发送密码重置电子邮件的模型实例。
- en: Using the auth() Global Helper and the Auth Facade
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `auth()` 全局辅助函数和 Auth 门面
- en: The `auth()` global helper is the easiest way to interact with the status of
    the authenticated user throughout your app. You can also inject an instance of
    `Illuminate\Auth\AuthManager` and get the same functionality, or use the `Auth`
    facade.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth()` 全局辅助函数是在整个应用程序中与已验证用户的状态交互的最简单方法。您还可以注入一个 `Illuminate\Auth\AuthManager`
    实例并获得相同的功能，或者使用 `Auth` 门面。'
- en: The most common usages are to check whether a user is logged in—(`auth()->check()`
    returns `true` if the current user is logged in; `auth()->guest()` returns `true`
    if the user is not logged in)—and to get the currently logged-in user (use `auth()->user()`,
    or `auth()->id()` for just the ID; both return `null` if no user is logged in).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的用法是检查用户是否已登录（如果当前用户已登录，则 `auth()->check()` 返回 `true`；如果用户未登录，则 `auth()->guest()`
    返回 `true`）以及获取当前已登录用户（使用 `auth()->user()`，或仅获取 ID 使用 `auth()->id()`；如果没有用户登录，则两者都返回
    `null`）。
- en: Take a look at [Example 9-3](#EX903) for a sample usage of the global helper
    in a controller.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 查看示例 [Example 9-3](#EX903) 了解控制器中全局辅助函数的示例用法。
- en: Example 9-3\. Sample usage of the `auth()` global helper in a controller
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-3. 在控制器中使用 `auth()` 全局辅助函数的示例用法
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: routes/auth.php, Auth Controllers, and Auth Actions
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由 `routes/auth.php`，Auth 控制器和 Auth 操作
- en: If you’re working with one of Laravel’s starter kits, you’ll see that using
    the baked-in authentication routes, such as login, register, and password reset,
    requires routes, controllers, and views.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Laravel 的其中一个入门工具包，你会发现使用内置的身份验证路由（例如登录、注册和重置密码）需要路由、控制器和视图。
- en: 'Both Breeze and Jetstream define your routes using a custom routes file: *routes/auth.php*.
    They’re not exactly the same, but take a look at [Example 9-4](#EX927) to see
    a bit of Breeze’s auth routes file to show what they look like generally.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze 和 Jetstream 都使用自定义路由文件定义您的路由：*routes/auth.php*。它们并不完全相同，但可以查看 [示例 9-4](#EX927)
    以了解 Breeze 的认证路由文件的一部分，以便了解它们的一般情况。
- en: Example 9-4\. Part of Breeze’s routes/auth.php
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-4\. Breeze 的路由/auth.php 的一部分
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Breeze publishes controllers under the `Auth` namespace, which you can configure
    if you need to:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze 在 `Auth` 命名空间下发布控制器，您可以根据需要进行配置：
- en: '*AuthenticatedSessionController.php*'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*AuthenticatedSessionController.php*'
- en: '*ConfirmablePasswordController.php*'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ConfirmablePasswordController.php*'
- en: '*EmailVerificationNotificationController.php*'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EmailVerificationNotificationController.php*'
- en: '*EmailVerificationPromptController.php*'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*EmailVerificationPromptController.php*'
- en: '*NewPasswordController.php*'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NewPasswordController.php*'
- en: '*PasswordController.php*'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PasswordController.php*'
- en: '*PasswordResetLinkController.php*'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PasswordResetLinkController.php*'
- en: '*RegisteredUserController.php*'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*RegisteredUserController.php*'
- en: '*VerifyEmailController.php*'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*VerifyEmailController.php*'
- en: 'Instead of controllers, Jetstream (and Fortify, which it depends on) publishes
    “actions” that you can customize:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream（以及它依赖的 Fortify）不发布控制器，而是发布您可以自定义的“操作”：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Breeze and Jetstream’s Frontend Templates
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Breeze 和 Jetstream 的前端模板
- en: At this point you have a migration, a model, controllers/actions, and routes
    for your authentication system. But what about your views?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，您的认证系统已经有了迁移、模型、控制器/操作和路由。但是您的视图呢？
- en: You can learn more in [“Laravel Breeze”](ch06.html#breeze) and [“Laravel Jetstream”](ch06.html#jetstream),
    but each tool provides multiple different stacks, and each stack keeps its templates
    in different places.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [“Laravel Breeze”](ch06.html#breeze) 和 [“Laravel Jetstream”](ch06.html#jetstream)
    中了解更多信息，但每个工具都提供多种不同的堆栈，并且每个堆栈将其模板放置在不同的位置。
- en: In general, the JavaScript-based stacks put their templates in *resources/js*
    and the Blade-based stacks put them in *resources/views*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，基于 JavaScript 的堆栈将其模板放置在 *resources/js* 中，而基于 Blade 的堆栈将其放置在 *resources/views*
    中。
- en: There’s at least one view for each function (log in, register, reset password,
    etc.) and they’re all generated with a slick Tailwind-based design, ready to be
    used or customized.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 每个功能（登录、注册、重置密码等）至少有一个视图，并且它们都采用了流畅的基于 Tailwind 的设计生成，可以直接使用或自定义。
- en: “Remember Me”
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: “记住我”
- en: Breeze and Jetstream have this implemented out of the box, but it’s still worth
    learning how it works and how to use it on your own. If you want to implement
    a “remember me”–style long-lived access token, make sure you have a `remember_token`
    column on your `users` table (which you will if you used the default migration).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze 和 Jetstream 都已经默认实现了此功能，但是了解其工作原理以及如何在自己的项目中使用仍然是值得的。如果您想要实现“记住我”风格的长期访问令牌，请确保您的
    `users` 表中有一个 `remember_token` 列（如果您使用了默认迁移，那么这个列应该已经存在）。
- en: When you’re normally logging in a user (and this is how the `LoginController`
    does it, with the `AuthenticatesUsers` trait), you’ll “attempt” an authentication
    with the user-provided information, like in [Example 9-5](#EX905).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您正常登录用户时（这是 `LoginController` 使用 `AuthenticatesUsers` trait 所做的方式），您将“尝试”使用用户提供的信息进行认证，就像在
    [示例 9-5](#EX905) 中所示。
- en: Example 9-5\. Attempting a user authentication
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-5\. 尝试用户认证
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This provides you with a user login that lasts as long as the user’s session.
    If you want Laravel to extend the login indefinitely using cookies (as long as
    the user is on the same computer and doesn’t log out), you can pass a Boolean
    `true` as the second parameter of the `auth()->attempt()` method. Take a look
    at [Example 9-6](#EX906) to see what that request looks like.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了一个与用户会话同久的用户登录。如果您希望 Laravel 使用 Cookie 无限期延长登录时间（只要用户在同一台计算机上且不退出登录），您可以将布尔值
    `true` 作为 `auth()->attempt()` 方法的第二个参数传递。查看 [示例 9-6](#EX906) 以了解该请求的外观。
- en: Example 9-6\. Attempting a user authentication with a “remember me” checkbox
    check
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-6\. 使用“记住我”复选框进行用户认证尝试
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can see that we checked whether the input has a nonempty (“filled”) `remember`
    property, which will return a Boolean. This allows our users to decide if they
    want to be remembered with a checkbox in the login form.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我们检查了输入是否具有非空（“filled”）`remember` 属性，该属性将返回一个布尔值。这允许我们的用户通过登录表单中的复选框决定是否要记住登录状态。
- en: 'And later, if you need to manually check whether the current user was authenticated
    by a remember token, there’s a method for that: `auth()->viaRemember()` returns
    a Boolean, indicating whether or not the current user authenticated via a remember
    token. This allows you to prevent certain higher-sensitivity features from being
    accessible by remember token; instead, you can require users to reenter their
    passwords.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，如果你需要手动检查当前用户是否通过记住令牌进行了认证，有一个方法可以做到：`auth()->viaRemember()` 返回一个布尔值，指示当前用户是否通过记住令牌进行了认证。这使你可以防止通过记住令牌访问某些更高敏感度功能；而是，你可以要求用户重新输入他们的密码。
- en: Password Confirmation
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码确认
- en: It may be necessary for your users to reconfirm their passwords before accessing
    certain parts of your application. For example, if a user has been logged in for
    a while, and then attempts to visit the billing section of your site, you might
    want them to verify their password.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序的某些部分访问之前，用户可能需要重新确认他们的密码。例如，如果用户已经登录了一段时间，然后尝试访问你站点的账单部分，你可能希望他们验证他们的密码。
- en: You can attach a `password.confirm` middleware to your routes to force this
    behavior. Once their password is confirmed, the user will be sent to the route
    they tried to visit initially. After that point, the user won’t have to reconfirm
    their password for 3 hours; you can change this in the `auth.password_timeout`
    configuration setting.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在你的路由上附加 `password.confirm` 中间件来强制这种行为。一旦他们确认了密码，用户将被发送到他们最初尝试访问的路由。此后，用户在
    3 小时内不需要重新确认密码；你可以在 `auth.password_timeout` 配置设置中更改这个时间。
- en: Manually Authenticating Users
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动认证用户
- en: The most common case for user authentication is that you allow the user to provide
    their credentials, and then use `auth()->attempt()` to see whether the provided
    credentials match any real users. If so, you log them in.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 用户认证的最常见情况是，允许用户提供他们的凭证，然后使用 `auth()->attempt()` 来查看提供的凭证是否与任何真实用户匹配。如果匹配，则登录他们。
- en: But sometimes there are contexts where it’s valuable for you to be able to choose
    to log a user in on your own. For example, you may want to allow admin users to
    switch users.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时候，在某些情境下，你能够选择自己选择性地登录一个用户，这是非常有价值的。例如，你可能希望允许管理员用户切换用户。
- en: 'There are four methods that make this possible. First, you can just pass a
    user ID:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种方法可以实现这一点。首先，你可以只传递一个用户 ID：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Second, you can pass a `User` object (or any other object that implements the
    `Illuminate``\Contracts\Auth\Authenticatable` contract):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你可以传递一个 `User` 对象（或者任何实现 `Illuminate\Contracts\Auth\Authenticatable` 合约的对象）：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And third and fourth, you can choose to authenticate the given user for only
    the current request, which won’t impact your session or cookies at all, using
    `once()` or `onceUsingId()`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第三和第四，你可以选择仅为当前请求验证给定用户，这不会影响你的会话或者 cookie，可以使用 `once()` 或 `onceUsingId()`：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Note that the array you pass to the `once()` method can contain any key/value
    pairs to uniquely identify the user you’d like to authenticate as. You can even
    pass multiple keys and values, if it’s what is appropriate for your project. For
    example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你传递给 `once()` 方法的数组可以包含任何键值对来唯一标识你想要认证的用户。如果适合你的项目，你甚至可以传递多个键和值。例如：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Manually Logging Out a User
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动登出用户
- en: 'If you ever need to log out a user manually, just call `logout()`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要手动登出用户，只需调用 `logout()`：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Invalidating Sessions on Other Devices
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使其他设备上的会话失效
- en: If you’d like to log out a user’s current session on any other devices—​for
    example, after they’ve changed their password—​you’ll need to prompt the user
    for their password and pass it to the `logoutOtherDevices()` method. To do this,
    you’ll have to apply the `auth.session` middleware to any routes you want them
    logged out of (for most projects, that’s the entire app).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在任何其他设备上登出用户的当前会话 —— 例如，在他们更改密码后 —— 你需要提示用户输入他们的密码并将其传递给 `logoutOtherDevices()`
    方法。为此，你需要将 `auth.session` 中间件应用到你想让他们退出登录的所有路由上（对于大多数项目而言，这是整个应用程序）。
- en: 'Then you can use it inline anywhere you need:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你可以在任何需要的地方内联使用它：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you want to give your users a detailed look at what other sessions are active,
    Jetstream (see [“Laravel Jetstream”](ch06.html#jetstream)) comes out of the box
    with a page that lists all active sessions and provides a button to log out of
    all of them.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让用户详细查看其他活动会话，Jetstream（参见[“Laravel Jetstream”](ch06.html#jetstream)）默认提供了一个页面，列出所有活动会话，并提供一个按钮可以登出所有会话。
- en: Auth Middleware
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证中间件
- en: In [Example 9-3](#EX903), you saw how to check whether visitors are logged in
    and redirect them if not. You could perform these sorts of checks on every route
    in your application, but it would very quickly get tedious. It turns out that
    route middleware (see [Chapter 10](ch10.html#requests_and_responses) to learn
    more about how they work) are a perfect fit for restricting certain routes to
    guests or to authenticated users.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 9-3](#EX903)中，您看到如何检查访客是否已登录，并在未登录时重定向他们。您可以在应用程序的每个路由上执行这些检查，但很快会变得乏味。事实证明，路由中间件（详见[第 10 章](ch10.html#requests_and_responses)以了解其工作原理）非常适合将某些路由限制为仅限访客或经过身份验证的用户。
- en: 'Once again, Laravel comes with the middleware we need out of the box. You can
    see which route middleware you have defined in `App\Http\Kernel`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Laravel默认即可提供我们所需的中间件。您可以查看您在`App\Http\Kernel`中定义的路由中间件：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Six of the default route middleware are authentication-related:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 六种默认的路由中间件与身份验证相关：
- en: '`auth`'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth`'
- en: Restricts route access to authenticated users
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 限制路由访问权限仅限经过身份验证的用户
- en: '`auth.basic`'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth.basic`'
- en: Restricts access to authenticated users using HTTP Basic Authentication
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过HTTP基本身份验证限制仅限经过身份验证的用户访问
- en: '`auth.session`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth.session`'
- en: Makes routes viable to be disabled using `Auth::logoutOtherDevices`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使路由可供其他设备登出使用`Auth::logoutOtherDevices`
- en: '`can`'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`can`'
- en: Used for authorizing user access to given routes
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 用于授权用户访问指定路由
- en: '`guest`'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`guest`'
- en: Rstricts access to unauthenticated users
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 限制未经身份验证的用户访问
- en: '`password.confirm`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`password.confirm`'
- en: Requires users to have recently reconfirmed their password
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要求用户最近重新确认其密码
- en: It’s most common to use `auth` for your authenticated-user-only sections and
    `guest` for any routes you don’t want authenticated users to see (like the login
    form). `auth.basic` and `auth.session` are much less commonly used middleware
    for authenticating.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要仅限经过身份验证的用户访问的部分，最常见的做法是使用`auth`，而对于不希望经过身份验证的用户看到的任何路由（如登录表单），则使用`guest`。`auth.basic`和`auth.session`用于认证的中间件则较少使用。
- en: '[Example 9-7](#EX907) shows an example of a few routes protected by the `auth`
    middleware.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 9-7](#EX907)展示了几个由`auth`中间件保护的路由示例。'
- en: Example 9-7\. Sample routes protected by auth middleware
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-7\. 受`auth`中间件保护的示例路由
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Email Verification
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 电子邮件验证
- en: If you’d like to require a user to verify they have access to the email address
    they registered with, you can reach for Laravel’s email verification feature.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望要求用户验证他们注册时使用的电子邮件地址的访问权限，则可以使用Laravel的电子邮件验证功能。
- en: To enable email verification, update your `App\User` class and make it implement
    the `Illuminate\Contracts\Auth\MustVerifyEmail` contract, as shown in [Example 9-8](#EX9a).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用电子邮件验证，请更新您的`App\User`类，并使其实现`Illuminate\Contracts\Auth\MustVerifyEmail`合同，如[示例 9-8](#EX9a)所示。
- en: Example 9-8\. Adding the `MustVerifyEmail` trait to an `Authenticatable` model
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-8\. 将`MustVerifyEmail`特性添加到`Authenticatable`模型中
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `users` table must also contain a nullable timestamp column named `email_``verified_at`,
    which the default `CreateUsersTable` migration will have already provided for
    you.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`users`表还必须包含一个名为`email_verified_at`的可空时间戳列，这是默认的`CreateUsersTable`迁移已经为您提供的。'
- en: 'Finally, you’ll need to enable the email verification routes in your controller.
    The easiest method is to use `Auth::routes()` in your routes file with the `verify`
    parameter set to `true`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要在控制器中启用电子邮件验证路由。最简单的方法是在路由文件中使用`Auth::routes()`，并将`verify`参数设置为`true`：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, you can protect any routes you’d like from being accessed by any users
    who haven’t verified their email address:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以保护任何希望不被尚未验证其电子邮件地址的任何用户访问的路由：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can customize the route to which users are redirected after verifying in
    your `Verification``Controller`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以自定义在验证后重定向用户的路由`Verification``Controller`：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Blade Authentication Directives
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Blade身份验证指令
- en: If you want to check whether a user is authenticated, not at the route level
    but in your views, you can do so with `@auth` and `@guest` (see [Example 9-9](#EX9b)).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想检查用户是否经过身份验证，而不是在路由级别进行检查，而是在视图中进行检查，您可以使用`@auth`和`@guest`（参见[示例 9-9](#EX9b)）。
- en: Example 9-9\. Checking a user’s authentication status in templates
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-9\. 在模板中检查用户的身份验证状态
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can also specify which guard you’d like to use with both methods by passing
    the guard name as a parameter, as shown in [Example 9-10](#EX9c).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过将守卫名称作为参数传递给这两种方法来指定您想要使用的守卫，如[示例 9-10](#EX9c)所示。
- en: Example 9-10\. Checking a specific auth guard’s authentication in templates
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-10\. 在模板中检查特定认证保护的身份验证
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Guards
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 守卫
- en: 'Every aspect of Laravel’s authentication system is routed through something
    called a *guard*. Each guard is a combination of two pieces: a *driver* that defines
    how it persists and retrieves the authentication state (for example, `session`),
    and a *provider* that allows you to get a user by certain criteria (for example,
    `users`).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 认证系统的每个方面都通过称为*守卫*的东西路由。每个守卫由两个部分组成：定义它如何持久化和检索认证状态的*驱动程序*（例如 `session`），以及允许你按某些条件获取用户的*提供者*（例如
    `users`）。
- en: 'Out of the box, Laravel has two guards: `web` and `api`. `web` is the more
    traditional authentication style, using the `session` driver and the basic user
    provider. `api` uses the same user provider, but it uses the `token` driver instead
    of `session` to authenticate each request.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 开箱即用，Laravel 有两个守卫：`web` 和 `api`。`web` 是更传统的认证样式，使用 `session` 驱动程序和基本用户提供者。`api`
    使用相同的用户提供者，但它使用 `token` 驱动程序而不是 `session` 在每个请求中进行认证。
- en: You’d change drivers if you wanted to handle the identification and persistence
    of a user’s identity differently (for example, changing from a long-running session
    to a provided-every-page-load token), and you’d change providers if you wanted
    to change the storage type or retrieval methods for your users (for example, storing
    your users in Mongo instead of MySQL).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想以不同方式处理用户身份的识别和持久性（例如，从长时间运行的会话更改为每页加载提供的令牌），你会更改驱动程序；如果你想更改用户的存储类型或检索方法（例如，将用户存储在Mongo而不是MySQL中），你会更改提供者。
- en: Changing the Default Guard
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改默认守卫
- en: The guards are defined in *config/auth.php*, and you can change them, add new
    guards, and also define which guard will be the default there. For what it’s worth,
    this is a relatively uncommon configuration; most Laravel apps just use one guard.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 守卫在 *config/auth.php* 中定义，你可以在那里更改它们、添加新的守卫，并定义默认的守卫。就其价值而言，这是一种相对不常见的配置；大多数
    Laravel 应用程序只使用一个守卫。
- en: 'The “default” guard is the one that will be used any time you use any auth
    features without specifying a guard. For example, `auth()->user()` will pull the
    currently authenticated user using the default guard. You can change this guard
    by changing the `auth.defaults.guard` setting in *config/auth.php*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “默认”守卫是在没有指定守卫的情况下使用任何认证功能时将使用的守卫。例如，`auth()->user()` 将使用默认守卫拉取当前认证的用户。你可以通过更改
    *config/auth.php* 中的 `auth.defaults.guard` 设置来更改此守卫：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Configuration Conventions
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置约定
- en: You may have noticed that I refer to configuration sections with references
    like `auth.defaults.guard`. This means that in *config/auth.php*, in the array
    section keyed `defaults`, there should be a property keyed `guard`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我用 `auth.defaults.guard` 等引用来引用配置部分。这意味着在 *config/auth.php* 中，在以 `defaults`
    键为键的数组部分中，应该有一个以 `guard` 为键的属性。
- en: Using Other Guards Without Changing the Default
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不更改默认值的情况下使用其他守卫
- en: 'If you want to use another guard but *not* change the default, you can start
    your `auth()` calls with `guard()`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用另一个守卫但*不*更改默认值，你可以在 `auth()` 调用中以 `guard()` 开头：
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This will, just for this call, get the current user using the `api` guard.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在此调用中仅获取使用 `api` 守卫的当前用户。
- en: Adding a New Guard
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新的守卫
- en: 'You can add a new guard at any time in *config/auth.php*, in the `auth.guards`
    setting:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以随时在 *config/auth.php* 的 `auth.guards` 设置中添加新的守卫：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we’ve created a new guard (in addition to `web` and `api`) named `trainees`.
    Let’s imagine, for the rest of this section, that we’re building an app where
    our users are physical trainers, and they each have their *own* users—​trainees—​who
    can log in to their subdomains. So, we need a separate guard for them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的守卫（除了 `web` 和 `api`）名为 `trainees`。假设在接下来的这一节中，我们正在构建一个应用程序，其中我们的用户是体育教练，每个教练都有自己的*用户*——受训者——他们可以登录到他们的子域名。因此，我们需要一个单独的守卫来处理他们。
- en: The only two options for `driver` are `token` and `session`. Out of the box,
    the only option for `provider` is `users`, which supports authentication against
    your default `users` table, but you can create your own provider easily.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`driver` 的唯二选项是 `token` 和 `session`。开箱即用，`provider` 的唯一选项是 `users`，支持对默认的 `users`
    表进行认证，但你可以轻松创建自己的提供者。'
- en: Closure Request Guards
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 闭包请求守卫
- en: If you want to define a custom guard, and your guard conditions (how to look
    up a given user against the request) can be described simply enough in response
    to any given HTTP request, you might just want to throw the user lookup code into
    a closure and not deal with creating a new custom guard class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想定义一个自定义守卫，并且您的守卫条件（如何查找给定用户的请求）可以简单地在任何给定的 HTTP 请求中响应，您可能只想将用户查找代码放入一个闭包中，而不必创建一个新的自定义守卫类。
- en: The `viaRequest()` auth method makes it possible to define a guard (named in
    the first parameter) using just a closure (defined in the second parameter) that
    takes the HTTP request and returns the appropriate user. To register a closure
    request guard, call `viaRequest()` in the `boot()` method of your `AuthServiceProvider`,
    as shown in [Example 9-11](#EX9d).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`viaRequest()` 认证方法允许仅通过闭包（定义在第二个参数中）来定义一个守卫（第一个参数中命名的），该闭包接受 HTTP 请求并返回适当的用户。要在
    `AuthServiceProvider` 的 `boot()` 方法中注册一个闭包请求守卫，如 [示例 9-11](#EX9d) 所示。'
- en: Example 9-11\. Defining a closure request guard
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-11\. 定义闭包请求守卫
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Creating a Custom User Provider
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义用户提供程序
- en: 'Just below where guards are defined in *config/auth.php*, there’s an `auth.providers`
    section that defines the available providers. Let’s create a new provider named
    `trainees`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *config/auth.php* 中定义守卫的位置下方，有一个 `auth.providers` 部分，定义了可用的提供程序。让我们创建一个名为
    `trainees` 的新提供程序：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The two options for `driver` are `eloquent` and `database`. If you use `eloquent`,
    you’ll need a `model` property that contains an Eloquent class name (the model
    to use for your `User` class); and if you use `database`, you’ll need a `table`
    property to define which table it should authenticate against.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`driver` 的两个选项是 `eloquent` 和 `database`。如果使用 `eloquent`，您将需要一个包含 Eloquent 类名的
    `model` 属性（用于 `User` 类的模型）；如果使用 `database`，则需要一个 `table` 属性来定义应该对其进行身份验证的表。'
- en: In our example, you can see that this application has a `User` and a `Trainee`,
    and they need to be authenticated separately. This way, the code can differentiate
    between `auth()->guard('users')` and `auth()->guard('trainees')`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，您可以看到此应用程序有一个 `User` 和一个 `Trainee`，它们需要分别进行身份验证。这样，代码可以区分 `auth()->guard('users')`
    和 `auth()->guard('trainees')`。
- en: 'One last note: the `auth` route middleware can take a parameter that is the
    guard name. So, you can guard certain routes with a specific guard:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点：`auth` 路由中间件可以接受一个参数，即守卫名称。因此，您可以使用特定的守卫保护某些路由：
- en: '[PRE27]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Custom User Providers for Nonrelational Databases
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非关系数据库的自定义用户提供程序
- en: The user provider creation flow just described still relies on the same `UserProvider`
    class, which means it’s expecting to pull the identifying information out of a
    relational database. But if you’re using Mongo or Riak or something similar, you’ll
    actually need to create your own class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 刚才描述的用户提供程序创建流程仍然依赖于相同的 `UserProvider` 类，这意味着它期望从关系数据库中提取标识信息。但是，如果您使用的是 Mongo
    或 Riak 或类似的东西，实际上您需要创建自己的类。
- en: 'To do this, create a new class that implements the `Illuminate\Contracts\Auth\``UserProvider`
    interface, and then bind it in `AuthServiceProvider@boot`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请创建一个新的类，实现 `Illuminate\Contracts\Auth\UserProvider` 接口，然后在 `AuthServiceProvider@boot`
    中绑定它：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Auth Events
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证事件
- en: We’ll talk more about events in [Chapter 16](ch16.html#queues_jobs_events),
    but Laravel’s event system is a basic pub/sub framework. There are system- and
    user-generated events that are broadcast, and the user has the ability to create
    event listeners that do certain things in response to certain events.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 16 章](ch16.html#queues_jobs_events) 中更多地讨论事件，但 Laravel 的事件系统是一个基本的发布/订阅框架。有系统生成的事件和用户生成的事件进行广播，并且用户可以创建事件监听器以响应某些事件。
- en: So, what if you wanted to send a ping to a particular security service every
    time a user was locked out after too many failed login attempts? Maybe this service
    watches for a certain number of failed logins from certain geographic regions
    or something else. You could, of course, inject a call in the appropriate controller.
    But with events, you can just create an event listener that listens to the “user
    locked out” event, and register that.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果您想在用户因登录尝试失败次数过多而被锁定后，每次都向特定的安全服务发送一个 ping 呢？也许此服务监视某些地理区域的某个特定数量的登录失败或其他内容。当然，您可以在适当的控制器中注入一个调用。但是通过事件，您可以创建一个监听器来监听“用户被锁定”的事件，并注册它。
- en: Take a look at [Example 9-12](#EX908) to see all of the events that the authentication
    system emits.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [示例 9-12](#EX908) 以查看身份验证系统发出的所有事件。
- en: Example 9-12\. Authentication events generated by the framework
  id: totrans-163
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-12\. 框架生成的认证事件
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, there are listeners for “user registered,” “user attempting
    login,” “user validated but not logged in,” “user authenticated,” “successful
    login,” “failed login,” “logout,” “logout from another device,” “logout from current
    device,” “lockout,” “password reset,” and “user email verified.” To learn more
    about how to build event listeners for these events, check out [Chapter 16](ch16.html#queues_jobs_events).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有“用户注册”、“用户尝试登录”、“用户验证但未登录”、“用户已认证”、“成功登录”、“登录失败”、“登出”、“从其他设备登出”、“从当前设备登出”、“锁定”、“重置密码”和“用户邮箱验证”等监听器。要了解如何为这些事件构建事件监听器，请查看[第16章](ch16.html#queues_jobs_events)。
- en: Authorization and Roles
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权与角色
- en: 'Finally, let’s cover Laravel’s authorization system. It enables you to determine
    whether a user is *authorized* to do a particular thing, which you’ll check using
    a few primary verbs: `can`, `cannot`, `allows`, and `denies`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们介绍一下Laravel的授权系统。它使你能够确定用户是否*被授权*执行特定操作，你将使用几个主要动词进行检查：`can`、`cannot`、`allows`和`denies`。
- en: Most of this authorization control will be performed using the `Gate` facade,
    but there are also convenience helpers available in your controllers, on the `User`
    model, as middleware, and as Blade directives. Take a look at [Example 9-13](#EX9e)
    to get a taste of what we’ll be able to do.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分授权控制都将使用`Gate`外观进行，但在你的控制器、`User`模型、中间件和Blade指令中也有便捷的辅助功能可用。查看[示例 9-13](#EX9e)可以体验我们能做到什么。
- en: Example 9-13\. Basic usage of the `Gate` facade
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-13\. `Gate`外观的基本用法
- en: '[PRE30]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Defining Authorization Rules
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义授权规则
- en: The default location for defining authorization rules is in the `boot()` method
    of the `AuthServiceProvider`, where you’ll be calling methods on the `Auth` facade.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 定义授权规则的默认位置是在`AuthServiceProvider`的`boot()`方法中，在这里你将调用`Auth`外观的方法。
- en: 'An authorization rule is called an *ability* and comprises two things: a string
    key (e.g., `update-contact`) and a closure that returns a Boolean. [Example 9-14](#EX909)
    shows an ability for updating a contact.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 授权规则称为*ability*，由两部分组成：一个字符串键（例如，`update-contact`）和返回布尔值的闭包。[示例 9-14](#EX909)展示了更新联系人的ability。
- en: Example 9-14\. Sample ability for updating a contact
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-14\. 用于更新联系人的样例ability
- en: '[PRE31]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let’s walk through the steps for defining an ability.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看定义ability的步骤。
- en: 'First, you want to define a key. In naming this key, you should consider what
    string makes sense in your code’s flow to refer to the ability you’re providing
    to the user. You can see in [Example 9-14](#EX909) that the code uses the convention
    `{*verb*}-{*modelName*}`: `create-contact`, `update-contact`, etc.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要定义一个键。在命名这个键时，你应该考虑在你的代码流中哪个字符串对于引用你所提供给用户的ability是有意义的。你可以在[示例 9-14](#EX909)中看到代码使用了`{*verb*}-{*modelName*}`的约定：`create-contact`、`update-contact`等。
- en: Second, you define the closure. The first parameter will be the currently authenticated
    user, and all parameters after that will be the object(s) you’re checking for
    access to—​in this instance, the contact.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你要定义闭包。第一个参数将是当前已认证的用户，之后的所有参数将是你要检查访问权限的对象——在本例中是联系人。
- en: So, given those two objects, we can check whether the user is authorized to
    update this contact. You can write this logic however you want, but in the app
    we’re looking at in [Example 9-14](#EX909), authorization depends on being the
    creator of the contact row. The closure will return `true` (authorized) if the
    current user created the contact, and `false` (unauthorized) if not.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到这两个对象，我们可以检查用户是否有权限更新这个联系人。你可以按自己的逻辑编写这段代码，但在我们查看的应用中（在[示例 9-14](#EX909)中），授权取决于是否是联系人行的创建者。如果当前用户创建了联系人，闭包将返回`true`（授权），否则返回`false`（未授权）。
- en: 'Just like with route definitions, you could also use a class and method instead
    of a closure to resolve this definition:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 就像路由定义一样，你也可以使用类和方法而不是闭包来解析这个定义：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The Gate Facade (and Injecting Gate)
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`Gate`外观（和注入`Gate`）'
- en: Now that you’ve defined an ability, it’s time to test against it. The simplest
    way is to use the `Gate` facade, as in [Example 9-15](#EX910) (or you can inject
    an instance of `Illuminate\Contracts\Auth\Access\Gate`).
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经定义了一个ability，是时候测试它了。最简单的方法是使用`Gate`外观，就像在[示例 9-15](#EX910)中一样（或者你可以注入`Illuminate\Contracts\Auth\Access\Gate`的实例）。
- en: Example 9-15\. Basic `Gate` facade usage
  id: totrans-184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-15\. `Gate`外观的基本用法
- en: '[PRE33]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You might also define an ability with multiple parameters—​maybe contacts can
    be in groups, and you want to authorize whether the user has access to add a contact
    to a group. [Example 9-16](#EX911) shows how to do this.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还可以定义一个具有多个参数的能力 —— 也许联系人可以分组，并且您希望授权用户是否有权限将联系人添加到组中。[Example 9-16](#EX911)
    展示了如何做到这一点。
- en: Example 9-16\. Abilities with multiple parameters
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-16\. 具有多个参数的能力
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: And if you need to check authorization for a user other than the currently authenticated
    user, try `forUser()`, like in [Example 9-17](#EX912).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要检查不是当前认证用户的用户的授权，请尝试`forUser()`，就像 [Example 9-17](#EX912) 中那样。
- en: Example 9-17\. Specifying the user for `Gate`
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-17\. 指定`Gate`的用户
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Resource Gates
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资源门
- en: The most common use for access control lists is to define access to individual
    “resources” (think an Eloquent model, or something you’re allowing users to administer
    from their admin panel).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制列表最常见的用途是定义对单个“资源”的访问权限（想想一个Eloquent模型，或者您允许用户从其管理面板管理的东西）。
- en: 'The `resource()` method makes it possible to apply the four most common gates,
    `view`, `create`, `update`, and `delete`, to a single resource at once:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`resource()` 方法使得可以一次将四个最常见的门控（`view`、`create`、`update` 和 `delete`）应用于单个资源：'
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is equivalent to defining the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于定义以下内容：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The Authorize Middleware
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权中间件
- en: If you want to authorize entire routes, you can use the `Authorize` middleware
    (which has a shortcut of `can`), like in [Example 9-18](#EX913).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想授权整个路由，可以使用`Authorize`中间件（有一个`can`的快捷方式），就像在 [Example 9-18](#EX913) 中那样。
- en: Example 9-18\. Using the `Authorize` middleware
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-18\. 使用`Authorize`中间件
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, the `{person}` parameter (whether it’s defined as a string or as a bound
    route model) will be passed to the ability method as an additional parameter.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`{person}` 参数（无论它是作为字符串定义还是作为绑定路由模型）将作为附加参数传递给能力方法。
- en: The first check in [Example 9-18](#EX913) is a normal ability, but the second
    is a policy, which we’ll talk about in [“Policies”](#policies).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 9-18](#EX913) 中的第一个检查是一个普通的能力，但第二个是一个策略，我们将在[“策略”](#policies)中讨论它。'
- en: 'If you need to check for an action that doesn’t require a model instance (for
    example, `create`, unlike `edit`, doesn’t get passed an actual route model–bound
    instance), you can just pass the class name:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要检查不需要模型实例的操作（例如 `create`，与 `edit` 不同，不会传递实际的路由模型绑定实例），您可以只传递类名：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Controller Authorization
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器授权
- en: 'The parent `App\Http\Controllers\Controller` class in Laravel imports the `Authorizes``Requests`
    trait, which provides three methods for authorization: `authorize()`, `authorizeForUser()`,
    and `authorizeResource()`.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 中的父类 `App\Http\Controllers\Controller` 导入了 `AuthorizesRequests` 特性，提供了三种授权方法：`authorize()`、`authorizeForUser()`
    和 `authorizeResource()`。
- en: '`authorize()` takes an ability key and an object (or array of objects) as parameters,
    and if the authorization fails, it’ll quit the application with a 403 (Unauthorized)
    status code. That means this feature can turn three lines of authorization code
    into just one, as you can see in [Example 9-19](#EX914).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorize()` 接受一个能力键和一个对象（或对象数组）作为参数，如果授权失败，它将以403（未经授权）状态码退出应用程序。这意味着这个特性可以将三行授权代码转换为一行，正如您在
    [Example 9-19](#EX914) 中所看到的。'
- en: Example 9-19\. Simplifying controller authorization with `authorize()`
  id: totrans-209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-19\. 使用`authorize()`简化控制器授权
- en: '[PRE40]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`authorizeForUser()` is the same, but allows you to pass in a `User` object
    instead of defaulting to the currently authenticated user:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorizeForUser()` 是相同的，但允许您传递一个 `User` 对象，而不是默认为当前认证用户：'
- en: '[PRE41]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`authorizeResource()`, called once in the controller constructor, maps a predefined
    set of authorization rules to each of the RESTful controller methods in that controller—​something
    like [Example 9-20](#EX915).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorizeResource()` 在控制器构造函数中调用一次，将预定义的一组授权规则映射到该控制器中的每个RESTful控制器方法 —— 类似于
    [Example 9-20](#EX915)。'
- en: Example 9-20\. The authorization-to-method mappings of `authorizeResource()`
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 9-20\. `authorizeResource()` 方法的授权到方法映射
- en: '[PRE42]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Checking the User Instance
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查用户实例
- en: If you’re not in a controller, you’re more likely to be checking the capabilities
    of a specific user than the currently authenticated user. That’s already possible
    with the `Gate` facade using the `forUser()` method, but sometimes the syntax
    can feel a little off.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不在控制器中，更有可能检查特定用户的能力而不是当前认证的用户。使用`Gate`外观可以使用`forUser()`方法实现这一点，但有时语法可能有些奇怪。
- en: 'Thankfully, the `Authorizable` trait on the `User` class provides four methods
    to make a more readable authorization feature: `$user->can()`, `$user→canAny()`,
    `$user->cant()`, and `$user->cannot()`. As you can probably guess, `cant()` and
    `cannot()` do the same thing, and `can()` is their exact inverse. With `canAny()`,
    you pass an array of permissions, and this method checks if the user can do any
    of them.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 类上的 `Authorizable` 特性提供了四种方法来实现更可读的授权功能：`$user->can()`、`$user->canAny()`、`$user->cant()`
    和 `$user->cannot()`。你可以大概猜到，`cant()` 和 `cannot()` 是一样的，而 `can()` 则完全相反。使用 `canAny()`，你传递一个权限数组，该方法检查用户是否可以执行其中任何一个。'
- en: That means you can do something like [Example 9-21](#EX916).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以做像 [示例 9-21](#EX916) 这样的事情。
- en: Example 9-21\. Checking authorization on a `User` instance
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-21\. 检查 `User` 实例的授权
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Behind the scenes, these methods are just passing your parameters to `Gate`;
    in the preceding example, `Gate::forUser($user)->check('create-contact')`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，这些方法只是将参数传递给 `Gate`；在前面的示例中，`Gate::forUser($user)->check('create-contact')`。
- en: Blade Checks
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blade 检查
- en: 'Blade also has a little convenience helper: the `@can` directive. [Example 9-22](#EX917)
    illustrates its usage.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Blade 还有一个小方便的助手：`@can` 指令。[示例 9-22](#EX917) 展示了它的使用方式。
- en: Example 9-22\. Using Blade’s `@can` directive
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-22\. 使用 Blade 的 `@can` 指令
- en: '[PRE44]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You can also use `@else` in between `@can` and `@endcan`, and you can use `@cannot`
    and `@endcannot` as in [Example 9-23](#EX918).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 `@can` 和 `@endcan` 之间使用 `@else`，以及像 [示例 9-23](#EX918) 中使用 `@cannot` 和
    `@endcannot`。
- en: Example 9-23\. Using Blade’s `@cannot` directive
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-23\. 使用 Blade 的 `@cannot` 指令
- en: '[PRE45]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Intercepting Checks
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拦截检查
- en: If you’ve ever built an app with an admin user class, you’ve probably looked
    at all of the simple authorization closures so far in this chapter and thought
    about how you could add a superuser class that overrides these checks in every
    case. Thankfully, there’s already a tool for that.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经用过管理员用户类构建过应用程序，你可能已经看过本章节中所有简单授权闭包，并考虑过如何添加一个超级用户类，在任何情况下都覆盖这些检查。幸运的是，已经有一个工具可以做到这一点。
- en: In `AuthServiceProvider`, where you’re already defining your abilities, you
    can also add a `before()` check that runs before all the others and can optionally
    override them, like in [Example 9-24](#EX919).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `AuthServiceProvider` 中，你已经在定义你的能力，你还可以添加一个 `before()` 检查，该检查在所有其他检查之前运行，可以选择性地覆盖它们，就像
    [示例 9-24](#EX919) 中一样。
- en: Example 9-24\. Overriding `Gate` checks with `before()`
  id: totrans-233
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-24\. 使用 `before()` 覆盖 `Gate` 检查
- en: '[PRE46]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that the string name for the ability is also passed in, so you can differentiate
    your `before()` hooks based on your ability naming scheme.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，也会传递能力的字符串名称，因此你可以根据你的能力命名方案区分你的 `before()` 钩子。
- en: Policies
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 策略
- en: Up until this point, all of the access controls have required you to manually
    associate Eloquent models with the ability names. You could have created an ability
    named something like `visit-dashboard` that’s not related to a specific Eloquent
    model, but you’ll probably have noticed that most of our examples have had to
    do with *doing something to something*—and in most of these cases, the *something*
    that’s the recipient of the action is an Eloquent model.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的访问控制都要求你手动将 Eloquent 模型与能力名称关联起来。你可以创建一个名为 `visit-dashboard` 的能力，该能力与特定的
    Eloquent 模型无关，但你可能已经注意到，我们大多数示例都涉及*对某物做某事*，在大多数情况下，受到操作的*某物*是一个 Eloquent 模型。
- en: Authorization policies are organizational structures that help you group your
    authorization logic based on the resource you’re controlling access to. They make
    it easy to manage defining authorization rules for behavior toward a particular
    Eloquent model (or other PHP class) all together in a single location.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 授权策略是组织结构，帮助你根据你正在控制访问的资源将授权逻辑分组。它们使得能够轻松管理定义针对特定 Eloquent 模型（或其他 PHP 类）行为的授权规则，全部在一个地方。
- en: Generating policies
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成策略
- en: 'Policies are PHP classes, which can be generated with an Artisan command:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是 PHP 类，可以通过 Artisan 命令生成：
- en: '[PRE47]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Once they’re generated, they need to be registered. The `AuthServiceProvider`
    has a `$policies` property, which is an array. The key of each item is the class
    name of the protected resource (almost always an Eloquent class), and the value
    is the policy class name. [Example 9-25](#EX9f) shows what this will look like.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 生成后，需要注册它们。`AuthServiceProvider` 有一个 `$policies` 属性，它是一个数组。每个项目的键是受保护资源的类名（几乎总是一个
    Eloquent 类），值是策略类名。[示例 9-25](#EX9f) 显示了这将是什么样子。
- en: Example 9-25\. Registering policies in `AuthServiceProvider`
  id: totrans-243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-25\. 在`AuthServiceProvider`中注册策略
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: A policy class that’s generated by Artisan doesn’t have any special properties
    or methods. But every method that you add is now mapped as an ability key for
    this object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由Artisan生成的策略类没有任何特殊属性或方法。但是您添加的每个方法现在都映射为此对象的能力键。
- en: Policy Auto-discovery
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略自动发现
- en: Laravel tries to “guess” the links between your policies and their corresponding
    models. For example, it’ll apply the `PostPolicy` to your `Post` model automatically.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel尝试“猜测”您的策略及其相应模型之间的链接。例如，它将自动将`PostPolicy`应用于您的`Post`模型。
- en: If you need to customize the logic Laravel uses to guess this mapping, check
    out the [Policy docs](https://oreil.ly/P5gC2).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要自定义Laravel用于猜测此映射的逻辑，请查看[策略文档](https://oreil.ly/P5gC2)。
- en: Let’s define an `update()` method to take a look at how it works ([Example 9-26](#EX920)).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个`update()`方法来看看它的工作原理（参见[示例 9-26](#EX920)）。
- en: Example 9-26\. A sample `update()` policy method
  id: totrans-250
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-26\. 一个样本`update()`策略方法
- en: '[PRE49]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Notice that the contents of this method look exactly like they would in a `Gate`
    definition.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该方法的内容看起来与在`Gate`定义中的内容完全相同。
- en: Policy Methods That Don’t Take an Instance
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不需要使用实例的政策方法
- en: 'What if you want to define a policy method that relates to the class but not
    a specific instance—​for example, “can this user create contacts at all?” rather
    than just “can this user view this specific contact?” You can treat this just
    like a normal policy method:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要定义一个与类相关但不是特定实例的策略方法——例如，“此用户是否可以创建任何联系人？”而不仅仅是“此用户是否可以查看此特定联系人？”——您可以像处理普通策略方法一样处理它：
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Checking policies
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查政策
- en: If there’s a policy defined for a resource type, the `Gate` facade will use
    the first parameter to figure out which method to check on the policy. If you
    run `Gate``::allows``('update',` `$contact)`, it will check the `ContactPolicy@update`
    method for authorization.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为资源类型定义了策略，则`Gate`外观将使用第一个参数来确定要在策略上检查哪个方法。如果您运行`Gate::allows('update', $contact)`，它将检查`ContactPolicy@update`方法的授权情况。
- en: This also works for the `Authorize` middleware and for `User` model checking
    and Blade checking, as seen in [Example 9-27](#EX921).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于`Authorize`中间件和`User`模型检查以及Blade检查，如[示例 9-27](#EX921)所示。
- en: Example 9-27\. Checking authorization against a policy
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-27\. 对策略进行授权检查
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Additionally, there’s a `policy()` helper that allows you to retrieve a policy
    class and run its methods:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个`policy()`辅助程序，允许您检索策略类并运行其方法：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Overriding policies
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖政策
- en: Just like with normal ability definitions, policies can define a `before()`
    method that allows you to override any call before it’s even processed (see [Example 9-28](#EX922)).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通能力定义一样，政策可以定义一个`before()`方法，允许您在处理之前覆盖任何调用（参见[示例 9-28](#EX922)）。
- en: Example 9-28\. Overriding policies with the `before()` method
  id: totrans-265
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-28\. 使用`before()`方法覆盖策略
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Testing
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: Application tests often need to perform a particular behavior on behalf of a
    particular user. We therefore need to be able to authenticate as a user in application
    tests, and we need to test authorization rules and authentication routes.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序测试经常需要代表特定用户执行特定行为。因此，在应用程序测试中进行身份验证并测试授权规则和身份验证路由是必要的。
- en: Of course, it’s possible to write an application test that manually visits the
    login page and then fills out the form and submits it, but that’s not necessary.
    Instead, the simplest option is to use the `->be()` method to simulate being logged
    in as a user. Take a look at [Example 9-29](#EX923).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以编写一个应用程序测试，手动访问登录页面，然后填写表单并提交，但这并不是必需的。相反，最简单的选项是使用`->be()`方法模拟作为用户登录。请参阅[示例 9-29](#EX923)。
- en: Example 9-29\. Authenticating as a user in application tests
  id: totrans-270
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-29\. 在应用程序测试中作为用户进行身份验证
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'You can also use, and chain, the `actingAs()` method instead of `be()`, if
    you prefer how it reads:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用并链`actingAs()`方法，而不是`be()`，如果您更喜欢其阅读方式：
- en: '[PRE55]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We can also test authorization like in [Example 9-30](#EX924).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以像在[示例 9-30](#EX924)中那样测试授权。
- en: Example 9-30\. Testing authorization rules
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-30\. 测试授权规则
- en: '[PRE56]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Or we can test for a 403 response like in [Example 9-31](#EX925).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以像在[示例 9-31](#EX925)中那样测试403响应。
- en: Example 9-31\. Testing authorization rules by checking status code
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-31\. 通过检查状态代码测试授权规则
- en: '[PRE57]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We need to test that our authentication (signup and signin) routes work too,
    as illustrated in [Example 9-32](#EX926).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要测试我们的认证（注册和登录）路由是否正常工作，如[示例 9-32](#EX926)所示。
- en: Example 9-32\. Testing authentication routes
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 9-32\. 测试认证路由
- en: '[PRE58]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can also use the integration test features to direct the test to “click”
    our authentication fields and “submit” the fields to test the entire flow. We’ll
    talk about that more in [Chapter 12](ch12.html#testing).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用集成测试功能来直接测试“点击”认证字段并“提交”字段以测试整个流程。关于这一点，我们将在[第12章](ch12.html#testing)中详细讨论。
- en: TL;DR
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TL;DR
- en: Between the default `User` model, the `create_users_table` migration, and Jetstream
    and Breeze, Laravel provides options for a full user authentication system out
    of the box. Breeze handles the authentication functionality in controllers and
    Jetstream handles it in Actions, both of which can be customized for each app.
    Both tools also publish config files and templates for customization.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认的`User`模型、`create_users_table`迁移以及Jetstream和Breeze之间，Laravel提供了开箱即用的完整用户认证系统选项。Breeze在控制器中处理认证功能，Jetstream在操作中处理认证功能，两者都可以根据每个应用程序进行定制。这两个工具还发布了配置文件和模板以进行定制。
- en: The `Auth` facade and the `auth()` global helper provide access to the current
    user (`auth()->user()`) and make it easy to check whether a user is logged in
    (`auth()``->check()` and `auth()->guest()`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`Auth`门面和全局助手`auth()`提供了访问当前用户（`auth()->user()`）的途径，并且轻松检查用户是否已登录（`auth()->check()`和`auth()->guest()`）。'
- en: Laravel also has an authorization system built in that allows you to define
    specific abilities (`create-contact`, `visit-secret-page`) or define policies
    for user interaction with entire models.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel还内置了一个授权系统，允许您定义特定的权限（`create-contact`、`visit-secret-page`）或为用户与整个模型的交互定义策略。
- en: You can check for authorization with the `Gate` facade, the `can()` and `cannot()`
    methods on the `User` class, the `@can` and `@cannot` directives in Blade, the
    `authorize()` methods on the controller, or the `can` middleware.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Gate`门面、`User`类上的`can()`和`cannot()`方法、Blade模板中的`@can`和`@cannot`指令、控制器中的`authorize()`方法或`can`中间件来检查授权。
