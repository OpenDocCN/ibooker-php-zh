- en: Chapter 17\. JavaScript and PHP Validation and Error Handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With your solid foundation in both PHP and JavaScript, it’s time to bring these
    technologies together to create web forms that are as user-friendly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be using PHP to create the forms and JavaScript to perform client-side
    validation to ensure that the data is as complete and correct as it can be before
    it is submitted. Final validation of the input will then be done by PHP, which
    will, if necessary, present the form again to the user for further modification.
  prefs: []
  type: TYPE_NORMAL
- en: In the process, this chapter will cover validation and regular expressions in
    both JavaScript and PHP.
  prefs: []
  type: TYPE_NORMAL
- en: Validating User Input with JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript validation should be considered an assistance more to your users
    than to your websites because, as I have already stressed many times, you cannot
    trust any data submitted to your server, even if it has supposedly been validated
    with JavaScript. This is because hackers can quite easily simulate your web forms
    and submit any data of their choosing.
  prefs: []
  type: TYPE_NORMAL
- en: Another reason you cannot rely on JavaScript to perform all your input validation
    is that some users disable JavaScript, or use browsers that don’t support it.
  prefs: []
  type: TYPE_NORMAL
- en: So, the best types of validation to do in JavaScript are checking that fields
    have content if they are not to be left empty, ensuring that email addresses conform
    to the proper format, and ensuring that values entered are within expected bounds.
  prefs: []
  type: TYPE_NORMAL
- en: The validate.html Document (Part 1)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin with a general signup form, common on most sites that offer memberships
    or user registration. The inputs requested will be *forename*, *surname*, *username*,
    *password*, *age*, and *email address*. [Example 17-1](ch17_split_001.xhtml#form_with_javascript_validation_left_p)
    provides a good template for such a form.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-1\. A form with JavaScript validation (part 1)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As it stands, this form will display correctly but will not self-validate, because
    the main validation functions have not yet been added. Even so, save it as *validate.html*,
    and when you call it up in your browser, it will look like [Figure 17-1](ch17_split_001.xhtml#output_from_example_16-1).
  prefs: []
  type: TYPE_NORMAL
- en: '![The output from Example 16-1](Images/pmj6_1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. The output from [Example 17-1](ch17_split_001.xhtml#form_with_javascript_validation_left_p)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s look at how this document is made up. The first few lines set up the document
    and use a little CSS to make the form look a little less plain. The parts of the
    document related to JavaScript come next and are shown in bold.
  prefs: []
  type: TYPE_NORMAL
- en: Between the `<script>` and `</script>` tags lies a single function called `validate`
    that itself calls up six other functions to validate each of the form’s input
    fields. We’ll get to these functions shortly. For now I’ll just explain that they
    return either an empty string if a field validates or an error message if it fails.
    If there are any errors, the final line of the script pops up an alert box to
    display them.
  prefs: []
  type: TYPE_NORMAL
- en: Upon passing validation, the `validate` function returns a value of `true`;
    otherwise, it returns `false`. The return values from `validate` are important,
    because if it returns `false`, the form is prevented from being submitted. This
    allows the user to close the alert pop-up and make changes. If `true` is returned,
    no errors were encountered in the form’s fields, and so the form is submitted.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of this example features the HTML for the form, with each field
    and its name placed within its own row of a table. This is pretty straightforward
    HTML, with the exception of the `onSubmit="return validate(this)"` statement within
    the opening `<form>` tag. Using `onSubmit`, you can cause a function of your choice
    to be called when a form is submitted. That function can perform some checking
    and return a value of either `true` or `false` to signify whether the form should
    be allowed to be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: The `this` parameter is the current object (i.e., this form) and is passed to
    the `validate` function just discussed. The `validate` function receives this
    parameter as the object `form`.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the only JavaScript used within the form’s HTML is the call
    to `return` buried in the `onSubmit` attribute. Browsers with JavaScript disabled
    or not available will simply ignore the `onSubmit` attribute, and the HTML will
    display just fine.
  prefs: []
  type: TYPE_NORMAL
- en: The validate.html Document (Part 2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we come to [Example 17-2](ch17_split_002.xhtml#form_with_javascript_validation-id00101),
    a set of six functions that do the actual form-field validation. I suggest that
    you type all of this second part and save it in the `<script>...</script>` section
    of [Example 17-1](ch17_split_001.xhtml#form_with_javascript_validation_left_p),
    which you should already have saved as *validate.html*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-2\. A form with JavaScript validation (part 2)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We’ll go through each of these functions in turn, starting with `validateForename`,
    so you can see how validation works.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the forename
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`validateForename` is quite a short function that accepts the parameter `field`,
    which is the value of the forename passed to it by the `validate` function.'
  prefs: []
  type: TYPE_NORMAL
- en: If this value is the empty string, an error message is returned; otherwise,
    an empty string is returned to signify that no error was encountered.
  prefs: []
  type: TYPE_NORMAL
- en: If the user entered spaces in this field, it would be accepted by `validateForename`,
    even though it’s empty for all intents and purposes. You can fix this by adding
    an extra statement to trim whitespace from the field before checking whether it’s
    empty, use a regular expression to make sure there’s something besides whitespace
    in the field, or—as I do here—just let the user make the mistake and allow the
    PHP program to catch it on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the surname
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `validateSurname` function is almost identical to `validateForename` in
    that an error is returned only if the surname supplied was an empty string. I
    chose not to limit the characters allowed in either of the name fields to allow
    for possibilities such as non-English and accented characters.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the username
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `validateUsername` function is a little more interesting, because it has
    a more complicated job. It has to allow through only the characters `a-z`, `A-Z`,
    `0-9`, `_` and `-`, and ensure that usernames are at least five characters long.
  prefs: []
  type: TYPE_NORMAL
- en: The `if...else` statements commence by returning an error if `field` has not
    been filled in. If it’s not the empty string, but is fewer than five characters
    in length, another error message is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Then the JavaScript `test` function is called, passing a regular expression
    (which matches any character that is *not* one of those allowed) to be matched
    against `field` (see [“Regular Expressions”](ch17_split_002.xhtml#regular_expressions)).
    If even one character that isn’t one of the acceptable characters is encountered,
    the `test` function returns `true`, and so `validateUser` returns an error string.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the password
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar techniques are used in the `validatePassword` function. First the function
    checks whether `field` is empty, and if it is, it returns an error. Next, an error
    message is returned if the password is shorter than six characters.
  prefs: []
  type: TYPE_NORMAL
- en: One of the requirements we’re imposing on passwords is that they must have at
    least one each of a lowercase, uppercase, and numerical character, so the `test`
    function is called three times, once for each of these cases. If any one of these
    calls returns `false`, one of the requirements was not met, and so an error message
    is returned. Otherwise, the empty string is returned to signify that the password
    was OK.
  prefs: []
  type: TYPE_NORMAL
- en: Validating the age
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`validateAge` returns an error message if `field` is not a number (determined
    by a call to the `isNaN` function) or if the age entered is lower than 18 or greater
    than 110\. Your applications may well have different or no age requirements. Again,
    upon successful validation, the empty string is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: Validating the email
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the last and most complicated example, the email address is validated with
    `validateEmail`. After checking whether anything was actually entered, and returning
    an error message if it wasn’t, the function calls the JavaScript `indexOf` function
    twice. The first time a check is made to ensure there is a period (`.`) somewhere
    after the first character of the field, and the second checks that an `@` symbol
    appears somewhere after the first character.
  prefs: []
  type: TYPE_NORMAL
- en: If those two checks are satisfied, the `test` function is called to see whether
    any disallowed characters appear in the field. If any of these tests fail, an
    error message is returned. The allowed characters in an email address are uppercase
    and lowercase letters, numbers, and the `_`, `-`, period, and `@` characters,
    as detailed in the regular expression passed to the `test` method. If no errors
    are found, the empty string is returned to indicate successful validation. On
    the last line, the script and document are closed.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-2](ch17_split_002.xhtml#javascript_form_validation_in_action) shows
    the result of the user clicking the Signup button without having completed any
    fields.'
  prefs: []
  type: TYPE_NORMAL
- en: '![JavaScript form validation in action](Images/pmj6_1702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-2\. JavaScript form validation in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using a separate JavaScript file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Of course, because they are generic in construction and could apply to many
    types of validations you might require, these six functions make ideal candidates
    for moving out into a separate JavaScript file. You could name the file something
    like *validate_functions.js* and include it right after the initial script section
    in [Example 17-1](ch17_split_001.xhtml#form_with_javascript_validation_left_p),
    using the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Regular Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s look a little more closely at the pattern matching we have been doing.
    We’ve achieved it using *regular expressions*, which are supported by both JavaScript
    and PHP. They make it possible to construct the most powerful of pattern-matching
    algorithms within a single expression.
  prefs: []
  type: TYPE_NORMAL
- en: Matching Through Metacharacters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every regular expression must be enclosed in slashes. Within these slashes,
    certain characters have special meanings; they are called *metacharacters*. For
    instance, an asterisk (`*`) has a meaning similar to what you have seen if you’ve
    used a shell or Windows command prompt (but not quite the same). An asterisk means
    “The text you’re trying to match may have any number of the preceding characters—or
    none at all.”
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, let’s say you’re looking for the name *Le Guin* and know that
    someone might spell it with or without a space. Because the text is laid out strangely
    (for instance, someone may have inserted extra spaces to right-justify lines),
    you could have to search for a line such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So you need to match *LeGuin*, as well as *Le* and *Guin* separated by any
    number of spaces. The solution is to follow a space with an asterisk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot more than the name *Le Guin* in the line, but that’s OK. As long
    as the regular expression matches some part of the line, the `test` function returns
    a `true` value. What if it’s important to make sure the line contains nothing
    but *Le Guin*? I’ll show you how to ensure that later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you know there is always at least one space. In that case, you
    could use the plus sign (`+`), because it requires at least one of the preceding
    characters to be present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Fuzzy Character Matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dot (`.`) is particularly useful, because it can match anything except
    a newline. Suppose that you are looking for HTML tags, which start with `<` and
    end with `>`. A simple way to do so is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The dot matches any character, and the `*` expands it to match zero or more
    characters, so this is saying, “Match anything that lies between `<` and `>`,
    even if there’s nothing.” You will match `<>`, `<em>`, `<br>`, and so on. But
    if you don’t want to match the empty case, `<>`, you should use `+` instead of
    `*`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The plus sign expands the dot to match one or more characters, saying, “Match
    anything that lies between `<` and `>` as long as there’s at least one character
    between them.” You will match `<em>` and `</em>`, `<h1>` and `</h1>`, and tags
    with attributes, such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, the plus sign keeps on matching up to the last `>` on the line,
    so you might end up with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A lot more than one tag! I’ll show a better solution later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you use the dot on its own between the angle brackets, without following
    it with either a `+` or `*`, then it matches a single character; you will match
    `<b>` and `<i>` but *not* `<em>` or `<textarea>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to match the dot character itself (`.`), you have to escape it
    by placing a backslash (`\`) before it, because otherwise it’s a metacharacter
    and matches anything. As an example, suppose you want to match the floating-point
    number `5.0`. The regular expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The backslash can escape any metacharacter, including another backslash (in
    case you’re trying to match a backslash in text). However, to make things a bit
    confusing, you’ll see later how backslashes sometimes give the following character
    a special meaning.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just matched a floating-point number. But perhaps you want to match `5.`
    as well as `5.0`, because both mean the same thing as a floating-point number.
    You also want to match `5.00`, `5.000`, and so forth—any number of zeros is allowed.
    You can do this by adding an asterisk, as you’ve seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Grouping Through Parentheses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose you want to match powers of increments of units, such as kilo, mega,
    giga, and tera. In other words, you want all the following to match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The plus sign works here, too, but you need to group the string `,000` so the
    plus sign matches the whole thing. The regular expression is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The parentheses mean “Treat this as a group when you apply something such as
    a plus sign.” `1,00,000` and `1,000,00` won’t match because the text must have
    a 1 followed by one or more complete groups of a comma followed by three zeros.
  prefs: []
  type: TYPE_NORMAL
- en: The space after the `+` character indicates that the match must end when a space
    is encountered. Without it, `1,000,00` would incorrectly match because only the
    first `1,000` would be taken into account, and the remaining `,00` would be ignored.
    Requiring a space afterward ensures that matching will continue right through
    to the end of a number.
  prefs: []
  type: TYPE_NORMAL
- en: Character Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you want to match something fuzzy but not so broadly that you want
    to use a dot. Fuzziness is the great strength of regular expressions: they allow
    you to be as precise or vague as you want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the key features supporting fuzzy matching is the pair of square brackets,
    `[]`. It matches a single character, like a dot, but inside the brackets you put
    a list of things that can match. If any of those characters appears, the text
    matches. For instance, if you wanted to match both the American spelling *gray*
    and the British spelling *grey*, you could specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `gr` in the text you’re matching, there can be either an `a` or an
    `e`. But there must be only one of them: whatever you put inside the brackets
    matches exactly one character. The group of characters inside the brackets is
    called a *character class*.'
  prefs: []
  type: TYPE_NORMAL
- en: Indicating a Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inside the brackets, you can use a hyphen (`-`) to indicate a range. One very
    common task is matching a single digit, which you can do with a range as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Digits are such a common item in regular expressions that a single character
    is provided to represent them: `\d`. You can use it in place of the bracketed
    regular expression to match a digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Negation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One other important feature of the square brackets is *negation* of a character
    class. You can turn the whole character class on its head by placing a caret (`^`)
    after the opening bracket. Here it means “Match any characters *except* the following.”
    So let’s say you want to find instances of *Yahoo* that lack the following exclamation
    point. (The name of the company officially contains an exclamation point!) You
    could do it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The character class consists of a single character—an exclamation point—but
    it is inverted by the preceding `^`. This is actually not a great solution to
    the problem—for instance, it fails if *Yahoo* is at the end of the line, because
    then it’s not followed by *anything*, whereas the brackets must match a character.
    A better solution involves negative *lookahead* (matching something that is not
    followed by anything else), but that’s beyond the scope of this book, so please
    refer to the [online documentation](https://tinyurl.com/regexdocs).
  prefs: []
  type: TYPE_NORMAL
- en: Some More Complicated Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With an understanding of character classes and negation, you’re ready now to
    see a better solution to the problem of matching an HTML tag. This solution avoids
    going past the end of a single tag but still matches tags such as `<em>` and `</em>`
    as well as tags with attributes such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is one solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That regular expression may look like I just dropped my teacup on the keyboard,
    but it is perfectly valid and very useful. Let’s break it apart. [Figure 17-3](ch17_split_002.xhtml#breakdown_of_a_typical_regular_expressio)
    shows the various elements, which I’ll describe one by one.
  prefs: []
  type: TYPE_NORMAL
- en: '![Breakdown of a typical regular expression](Images/pmj6_1703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-3\. Breakdown of a typical regular expression
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The elements are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`/`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Opening slash that indicates this is a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`<`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Opening bracket of an HTML tag. This is matched exactly; it’s not a metacharacter.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`[^>]`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Character class. The embedded `^>` means “Match anything except a closing angle
    bracket.”
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`+`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Allows any number of characters to match the previous `[^>]`, as long as there
    is at least one of them.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`>`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Closing bracket of an HTML tag. This is matched exactly.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`/`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Closing slash that indicates the end of the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another solution to the problem of matching HTML tags is to use a nongreedy
    operation. By default, pattern matching is greedy, returning the longest match
    possible. Nongreedy (or lazy) matching finds the shortest possible match. Its
    use is beyond the scope of this book, but there are more details on the [JavaScript.info
    website](https://tinyurl.com/regexgreedy).
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look now at one of the expressions from [Example 17-1](ch17_split_001.xhtml#form_with_javascript_validation_left_p),
    where the `validateUsername` function is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 17-4](ch17_split_002.xhtml#val-usr-reg-exp) shows the various elements.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/pmj6_1704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-4\. Breakdown of the `validateUsername` regular expression
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s look at these elements in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`/`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Opening slash that indicates this is a regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`[`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Opening bracket that starts a character class.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`^`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: 'Negation character: inverts everything else between the brackets.'
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`a-z`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Represents any lowercase letter.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`A-Z`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Represents any uppercase letter.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`0-9`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Represents any digit.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`_`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: An underscore.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`-`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: A dash.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`]`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Closing bracket that ends a character class.
  prefs: []
  type: TYPE_NORMAL
- en: <dfn class="keep-together">`/`</dfn>
  prefs: []
  type: TYPE_NORMAL
- en: Closing slash that indicates the end of the regular expression.
  prefs: []
  type: TYPE_NORMAL
- en: There are two other important metacharacters. They “anchor” a regular expression
    by requiring that it appear in a particular place. If a caret (`^`) appears at
    the beginning of the regular expression, the expression has to appear at the beginning
    of a line of text; otherwise, it doesn’t match. Similarly, if a dollar sign (`$`)
    appears at the end of the regular expression, the expression has to appear at
    the end of a line of text.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It may be somewhat confusing that `^` can mean “negate the character class”
    inside square brackets and “match the beginning of the line” if it’s at the beginning
    of the regular expression. Unfortunately, the same character is used for two different
    things, so take care when using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll finish our exploration of regular expression basics by answering a question
    raised earlier: suppose you want to make sure there is nothing extra on a line
    besides the regular expression? What if you want a line that has “Le Guin” and
    nothing else? We can do that by amending the earlier regular expression to anchor
    the two ends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summary of Metacharacters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Table 17-1](ch17_split_002.xhtml#regular_expression_metacharacters) shows
    the metacharacters available in regular expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 17-1\. Regular expression metacharacters
  prefs: []
  type: TYPE_NORMAL
- en: '| Metacharacters | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `/` | Begins and ends the regular expression |'
  prefs: []
  type: TYPE_TB
- en: '| `.` | Matches any single character except the newline |'
  prefs: []
  type: TYPE_TB
- en: '| ``*`element`**`` | Matches *`element`* zero or more times |'
  prefs: []
  type: TYPE_TB
- en: '| ``*`element`*+`` | Matches *`element`* one or more times |'
  prefs: []
  type: TYPE_TB
- en: '| ``*`element`*?`` | Matches *`element`* zero or one times |'
  prefs: []
  type: TYPE_TB
- en: '| ``[*`characters`*]`` | Matches a character out of those contained within
    the brackets |'
  prefs: []
  type: TYPE_TB
- en: '| ``[^*`characters`*]`` | Matches a single character that is not contained
    within the brackets |'
  prefs: []
  type: TYPE_TB
- en: '| ``(*`regex`*)`` | Treats the *`regex`* as a group for counting or a following
    `*`, `+`, or `?` |'
  prefs: []
  type: TYPE_TB
- en: '| ``*`left`*&#124;*`right`*`` | Matches either *`left`* or *`right`* |'
  prefs: []
  type: TYPE_TB
- en: '| ``[*`l`*-*`r`*]`` | Matches a range of characters between *`l`* and *`r`*
    |'
  prefs: []
  type: TYPE_TB
- en: '| `^` | Requires match to be at the string’s start |'
  prefs: []
  type: TYPE_TB
- en: '| `$` | Requires match to be at the string’s end |'
  prefs: []
  type: TYPE_TB
- en: '| `\b` | Matches a word boundary |'
  prefs: []
  type: TYPE_TB
- en: '| `\B` | Matches where there is not a word boundary |'
  prefs: []
  type: TYPE_TB
- en: '| `\d` | Matches a single digit |'
  prefs: []
  type: TYPE_TB
- en: '| `\D` | Matches a single nondigit |'
  prefs: []
  type: TYPE_TB
- en: '| `\n` | Matches a newline character |'
  prefs: []
  type: TYPE_TB
- en: '| `\s` | Matches a whitespace character |'
  prefs: []
  type: TYPE_TB
- en: '| `\S` | Matches a nonwhitespace character |'
  prefs: []
  type: TYPE_TB
- en: '| `\t` | Matches a tab character |'
  prefs: []
  type: TYPE_TB
- en: '| `\w` | Matches a word character (`a-z`, `A-Z`, `0-9`, and `_`) |'
  prefs: []
  type: TYPE_TB
- en: '| `\W` | Matches a nonword character (anything but `a-z`, `A-Z`, `0-9`, and
    `_`) |'
  prefs: []
  type: TYPE_TB
- en: '| ``\*`x`*`` | Matches *`x`* (useful if *`x`* is a metacharacter, but you really
    want *`x`*) |'
  prefs: []
  type: TYPE_TB
- en: '| ``{*`n`*}`` | Matches exactly *`n`* times |'
  prefs: []
  type: TYPE_TB
- en: '| ``{*`n`*,}`` | Matches *`n`* times or more |'
  prefs: []
  type: TYPE_TB
- en: '| ``{*`min`*,*`max`*}`` | Matches at least *`min`* and at most *`max`* times
    |'
  prefs: []
  type: TYPE_TB
- en: Provided with this table, and looking again at the expression `/[^a-zA-Z0-9_]/`,
    you can see that it could easily be shortened to `/[^\w]/` because the single
    metacharacter `\w` (with a lowercase `w`) specifies the characters `a-z`, `A-Z`,
    `0-9`, and `_`.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we can be cleverer than that, because the metacharacter `\W` (with
    an uppercase `W`) specifies all characters *except* for `a-z`, `A-Z`, `0-9`, and
    `_`. Therefore, we could also drop the `^` metacharacter and simply use `/[\W]/`
    for the expression, or even go a step further and drop the square brackets, as
    in `/\W/`, because it’s a single character.
  prefs: []
  type: TYPE_NORMAL
- en: To give you more ideas of how this all works, [Table 17-2](ch17_split_002.xhtml#some_example_regular_expressions)
    shows a range of expressions and the patterns they match.
  prefs: []
  type: TYPE_NORMAL
- en: Table 17-2\. Some example regular expressions
  prefs: []
  type: TYPE_NORMAL
- en: '| Example | Matches |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `r` | The first *r* in *The quick brown* |'
  prefs: []
  type: TYPE_TB
- en: '| `rec[ei][ei]ve` | Either of *receive* or *recieve* (but also *receeve* or
    *reciive*) |'
  prefs: []
  type: TYPE_TB
- en: '| `rec[ei]{2}ve` | Either of *receive* or *recieve* (but also *receeve* or
    *reciive*) |'
  prefs: []
  type: TYPE_TB
- en: '| `rec(ei&#124;ie)ve` | Either of *receive* or *recieve* (but not *receeve*
    or *reciive*) |'
  prefs: []
  type: TYPE_TB
- en: '| `cat` | The word *cat* in *I like cats and dogs* |'
  prefs: []
  type: TYPE_TB
- en: '| `cat&#124;dog` | The word *cat* in *I like cats and dogs* (matches either
    *cat* or *dog*, whichever is encountered first) |'
  prefs: []
  type: TYPE_TB
- en: '| `\.` | `.` (the `\` is necessary because `.` is a metacharacter) |'
  prefs: []
  type: TYPE_TB
- en: '| `5\.0*` | *5.*, *5.0*, *5.00*, *5.000*, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| `[a-f]` | Any of the characters *a*, *b*, *c*, *d*, *e*, or *f* |'
  prefs: []
  type: TYPE_TB
- en: '| `cats$` | Only the final *cats* in *My cats are friendly cats* |'
  prefs: []
  type: TYPE_TB
- en: '| `^my` | Only the first *my* in *my cats are my pets* |'
  prefs: []
  type: TYPE_TB
- en: '| `\d{2,3}` | Any two- or three-digit number (*00* through *999*) |'
  prefs: []
  type: TYPE_TB
- en: '| `7(,000)+` | *7,000*; *7,000,000*; *7,000,000,000*; *7,000,000,000,000*;
    etc. |'
  prefs: []
  type: TYPE_TB
- en: '| `[\w]+` | Any word of one or more characters |'
  prefs: []
  type: TYPE_TB
- en: '| `[\w]{5}` | Any five-letter word |'
  prefs: []
  type: TYPE_TB
- en: General Modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some additional modifiers are available for regular expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/g` enables *global* matching. When using a replace function, specify this
    modifier to replace all matches, rather than only the first one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/i` makes the regular expression match case-insensitive. Thus, instead of
    `/[a-zA-Z]/`, you could specify `/[a-z]/i` or `/[A-Z]/i`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/m` enables multiline mode, in which the caret (`^`) and dollar sign (`$`)
    match before and after any newlines in the subject string. Normally, in a multiline
    string, `^` matches only at the start of the string, and `$` matches only at the
    end of the string.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the expression `/cats/g` will match both occurrences of the word
    *cats* in the sentence “I like cats, and cats like me.” Similarly, `/dogs/gi`
    will match both occurrences of the word *dogs* (*Dogs* and *dogs*) in the sentence
    “Dogs like other dogs,” because you can use these specifiers together.
  prefs: []
  type: TYPE_NORMAL
- en: Using Regular Expressions in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, you will use regular expressions mostly in two methods: `test`
    (which you have already seen) and `replace`. Whereas `test` just tells you whether
    its argument matches the regular expression, `replace` takes a second parameter:
    the string to replace the text that matches. Like most functions, `replace` generates
    a new string as a return value; it does not change the input.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To compare the two methods, the following statement just returns `true` to
    let us know that the word *cats* appears at least once somewhere within the string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'But the following statement replaces both occurrences of the word *cats* with
    the word *dogs*, printing the result. The search has to be global (`/g`) to find
    all occurrences, and case-insensitive (`/i`) to find the capitalized *Cats*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try out the statement, you’ll see a limitation of `replace`: because
    it replaces text with exactly the string you tell it to use, the first word *Cats*
    is replaced by *dogs* instead of *Dogs*.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Regular Expressions in PHP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common regular expression functions that you are likely to use in PHP
    are `preg_match`, `preg_match_all`, and `preg_replace`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether the word *cats* appears anywhere within a string, in any combination
    of upper- and lowercase, you could use `preg_match` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Because PHP uses `1` for `TRUE` and `0` for `FALSE`, the preceding statement
    sets `$n` to `1`. The first argument is the regular expression, and the second
    is the text to match. But `preg_match` is actually a good deal more powerful and
    complicated, because it takes a third argument that shows what text matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The third argument is an array (here, given the name `$match`). The function
    puts the matching text into the first element, so if the match is successful,
    you can find the text that matched in `$match[0]`. In this example, the output
    lets us know that the matched text was capitalized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to locate all matches, you use the `preg_match_all` function, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As before, `$match` is passed to the function, and the element `$match[0]` is
    assigned the matches made but this time as a subarray. To display the subarray,
    this example iterates through it with a `for` loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to replace part of a string, you can use `preg_replace`, as shown
    here. This example replaces all occurrences of the word *cats* with the word *dogs*,
    regardless of case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The subject of regular expressions is a large one, and entire books have been
    written about it. If you would like further information, I suggest the [Wikipedia
    entry](http://bit.ly/regex-wiki) or *[Regular-Expressions.info](https://www.regular-expressions.info)*.
  prefs: []
  type: TYPE_NORMAL
- en: Redisplaying a Form After PHP Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: OK, back to form validation. So far we’ve created the HTML document *validate.html*,
    which will post through to the PHP program *adduser.php*, but only if JavaScript
    validates the fields or if JavaScript is disabled or unavailable.
  prefs: []
  type: TYPE_NORMAL
- en: So now it’s time to create *adduser.php* to receive the posted form, perform
    its own validation, and then present the form again to the visitor if the validation
    fails. [Example 17-3](ch17_split_002.xhtml#adduserdotphp_program) contains the
    code that you should type and save (or download from the companion website).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-3\. The adduser.php program
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, all input is sanitized prior to use—even passwords, which,
    since they may contain characters used to format HTML, will be changed into HTML
    entities. For example, `&` will become `&amp;`, `<` will become `&lt;`, and so
    on. If you will be using a hash function to store encrypted passwords, this will
    not be an issue as long as when you later check the password entered it is sanitized
    in the same way so that the same inputs will be compared.
  prefs: []
  type: TYPE_NORMAL
- en: The result of submitting the form with JavaScript disabled (and two fields incorrectly
    completed) is shown in [Figure 17-5](ch17_split_002.xhtml#form_as_represented_after_php_valida).
  prefs: []
  type: TYPE_NORMAL
- en: '![The form as represented after PHP validation fails](Images/pmj6_1705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-5\. The form as represented after PHP validation fails
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I have put the PHP section of this code (and changes to the HTML section) in
    a bold typeface so that you can more clearly see the difference between this and
    Examples [17-1](ch17_split_001.xhtml#form_with_javascript_validation_left_p) and
    [17-2](ch17_split_002.xhtml#form_with_javascript_validation-id00101).
  prefs: []
  type: TYPE_NORMAL
- en: If you browsed through this example, or typed it in or downloaded it from the
    [book’s example repository](https://github.com/RobinNixon/lpmj6), you’ll have
    seen that the PHP code is almost a clone of the JavaScript code; the same regular
    expressions are used to validate each field in very similar functions.
  prefs: []
  type: TYPE_NORMAL
- en: But there are a couple of things to note. First, the `fix_string` function (right
    at the end) is used to sanitize each field and prevent any attempts at code injection
    from succeeding.
  prefs: []
  type: TYPE_NORMAL
- en: Also, you will see that the HTML from [Example 17-1](ch17_split_001.xhtml#form_with_javascript_validation_left_p)
    has been repeated in the PHP code within an `<<<_END..._END;` structure, displaying
    the form with the values that the visitor entered the previous time. You do this
    by simply adding an extra `value` parameter to each `<input>` tag (such as `value="$forename"`).
    This courtesy is highly recommended so that the user only has to edit the previously
    entered values and doesn’t have to type the values in the fields all over again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the real world, you probably wouldn’t start with an HTML form such as the
    one in [Example 17-1](ch17_split_001.xhtml#form_with_javascript_validation_left_p).
    Instead, you’d be more likely to go straight ahead and write the PHP program in
    [Example 17-3](ch17_split_002.xhtml#adduserdotphp_program), which incorporates
    all the HTML. And, of course, you’d also need to make a minor tweak for the case
    when it’s the first time the program is called up, to prevent it from displaying
    errors when all the fields are empty. You also might drop the six JavaScript functions
    into their own *.js* file for separate inclusion, as mentioned in [“Using a separate
    JavaScript file”](ch17_split_002.xhtml#using_a_separate_javascript_file).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen how to bring PHP, HTML, and JavaScript together, the next
    chapter will introduce *Ajax* (Asynchronous JavaScript and XML), which uses JavaScript
    calls to the server in the background to seamlessly update portions of a web page,
    without having to resubmit the entire page to the web server.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What JavaScript method can you use to send a form for validation prior to submitting
    it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What JavaScript method is used to match a string against a regular expression?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a regular expression to match any characters that are *not* in a word,
    as defined by regular expression syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a regular expression to match either of the words *fox* or *fix*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a regular expression to match any single word followed by any nonword
    character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using regular expressions, write a JavaScript function to test whether the word
    *fox* exists in the string `The quick brown fox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using regular expressions, write a PHP function to replace all occurrences of
    the word *the* in `The cow jumps over the moon` with the word *my*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What HTML attribute is used to precomplete form fields with a value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See [“Chapter 17 Answers”](app01_split_016.xhtml#chapter_17_answers) in the
    [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions) for the
    answers to these questions.
  prefs: []
  type: TYPE_NORMAL
