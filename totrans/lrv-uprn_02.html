<html><head></head><body><section data-pdf-bookmark="Chapter 2. Setting Up a Laravel Development Environment" data-type="chapter" epub:type="chapter"><div class="chapter" id="setting_up_development_environment">&#13;
<h1><span class="label">Chapter 2. </span>Setting Up a Laravel <span class="keep-together">Development Environment</span></h1>&#13;
&#13;
&#13;
<p>Part of PHP’s success has been because it’s hard to find a web server that <em>can’t</em> serve PHP. However, modern PHP tools have stricter requirements than those of the past. The best way to develop for Laravel is to ensure a consistent local and remote server environment for your code, and, thankfully, the Laravel ecosystem has a few tools <span class="keep-together">for this.</span></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="System Requirements" data-type="sect1"><div class="sect1" id="id373">&#13;
<h1>System Requirements</h1>&#13;
&#13;
<p>Everything<a data-primary="development environment" data-secondary="system requirements" data-type="indexterm" id="id756"/> we’ll cover in this chapter is possible with Windows machines, but you’ll need dozens of pages of custom instructions and caveats. I’ll leave those instructions and caveats to actual Windows users, so the examples here and in the rest of the book will focus on Unix/Linux/macOS developers.</p>&#13;
&#13;
<p>Whether you choose to serve your website by installing PHP and other tools on your local machine, serve your development environment from a virtual machine via Vagrant or Docker, or rely on a tool like MAMP/WAMP/XAMPP, your development environment will need to have all of the following installed in order to serve Laravel sites:</p>&#13;
&#13;
<ul class="two-col">&#13;
<li>&#13;
<p>PHP &gt;= 8.1</p>&#13;
</li>&#13;
<li>&#13;
<p>OpenSSL PHP extension</p>&#13;
</li>&#13;
<li>&#13;
<p>PDO PHP extension</p>&#13;
</li>&#13;
<li>&#13;
<p>Mbstring PHP extension</p>&#13;
</li>&#13;
<li>&#13;
<p>Tokenizer PHP extension</p>&#13;
</li>&#13;
<li>&#13;
<p>XML PHP extension</p>&#13;
</li>&#13;
<li>&#13;
<p>Ctype PHP extension</p>&#13;
</li>&#13;
<li>&#13;
<p>JSON PHP extension</p>&#13;
</li>&#13;
<li>&#13;
<p>BCMath PHP extension</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Composer" data-type="sect1"><div class="sect1" id="id374">&#13;
<h1>Composer</h1>&#13;
&#13;
<p>Whatever<a data-primary="development environment" data-secondary="Composer" data-type="indexterm" id="id757"/><a data-primary="Composer" data-secondary="uses for" data-type="indexterm" id="id758"/> machine you’re developing on will need to have <a href="https://getcomposer.org">Composer</a> installed globally. <em>Composer</em> is a tool that’s at the foundation of most modern PHP development. It’s a dependency manager for PHP, much like NPM (Node Package Manager) for Node or RubyGems for Ruby. But like NPM, Composer is also the foundation of much of our testing, local script loading, installation scripts, and much more. You’ll need Composer to install Laravel, update Laravel, and bring in external dependencies.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Local Development Environments" data-type="sect1"><div class="sect1" id="id8">&#13;
<h1>Local Development Environments</h1>&#13;
&#13;
<p>For<a data-primary="development environment" data-secondary="local development environments" data-type="indexterm" id="id759"/><a data-primary="local development environments" data-type="indexterm" id="id760"/> many projects, hosting your development environment using a simpler toolset will be enough. If you already have MAMP or WAMP or XAMPP installed on your system, that will likely be fine to run Laravel.</p>&#13;
&#13;
<p>You can also just run Laravel with PHP’s built-in web server. Run <code>php -S localhost:8000 -t public</code> from your Laravel site’s root folder, and PHP’s built-in web server will serve your site at <em>http://localhost:8000/</em>.</p>&#13;
&#13;
<p>However, if you want a little more power in your development environment (different local domains for each project, management of dependencies like MySQL, etc.), you’ll want to reach for a more powerful tool than just PHP’s built-in server.</p>&#13;
&#13;
<p>Laravel offers five tools for local development: <code>Artisan serve</code>, Sail, Valet, Herd, and Homestead. We’ll cover each briefly. If you’re unsure of which to use, I’m personally a fan of Valet for Mac users and Sail for everyone else.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Artisan Serve" data-type="sect2"><div class="sect2" id="id375">&#13;
<h2>Artisan Serve</h2>&#13;
&#13;
<p>If<a data-primary="Artisan" data-secondary="serving" data-type="indexterm" id="id761"/> you run <code>php artisan serve</code> after setting up your Laravel application, it’ll serve it at <a class="bare" href="http://localhost:8000"><em class="hyperlink">http://localhost:8000</em></a>, just like we set it up earlier using PHP’s built-in web server. You’re not getting anything else for free here, so its only meaningful benefit is that it’s easier to remember.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel Sail" data-type="sect2"><div class="sect2" id="sail">&#13;
<h2>Laravel Sail</h2>&#13;
&#13;
<p>Sail<a data-primary="Laravel Sail" data-type="indexterm" id="id762"/><a data-primary="Sail" data-secondary="benefits of" data-type="indexterm" id="id763"/> is the simplest way to get started with local Laravel development in a way that’s the same regardless of your operating system. It comes with a PHP web server, databases, and a host of other niceties that make it very easy to run a single Laravel installation that’s consistent for every developer on your project regardless of the project’s dependencies or your developers’ work environments.</p>&#13;
&#13;
<p>Why don’t I use Sail? It uses Docker to accomplish the above, and Docker on macOS is just slow enough that I prefer Valet. But if you’re new to Laravel, especially if you don’t use a Mac, Sail is intentionally created as the simplest way to get started building your Laravel apps.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel Valet" data-type="sect2"><div class="sect2" id="valet">&#13;
<h2>Laravel Valet</h2>&#13;
&#13;
<p>If<a data-primary="Laravel Valet" data-type="indexterm" id="id764"/><a data-primary="Valet" data-type="indexterm" id="id765"/> you’re a macOS user (there are also unofficial forks for Windows and Linux), Laravel Valet makes it easy to serve every one of your local Laravel apps (and most other static and PHP-based apps) on different local domains.</p>&#13;
&#13;
<p>You’ll need to install a few tools using Homebrew, which the documentation will walk you through, but there are very few steps from initial installation to serving your apps.</p>&#13;
&#13;
<p>Install Valet—see the <a href="https://laravel.com/docs/valet">Valet docs</a> for the latest installation instructions—and point it at one or more directories where your sites will live. I ran <code>valet park</code> from my <span class="keep-together"><em>~/Sites</em></span> directory, which is where I put all of my under-development apps. Now, you can just add <em>.test</em> to the end of the directory name and visit it in your browser.</p>&#13;
&#13;
<p>Valet makes it easy to serve Laravel apps; we can use <code>valet park</code> to serve all subfolders in a given folder as <em>{foldername}.test</em>, <code>valet link</code> to serve just a single folder, <code>valet open</code> to open a browser to show the Valet-served domain for a folder, <code>valet secure</code> to serve the Valet site with HTTPS, and <code>valet share</code> to open an ngrok or Expose tunnel so you can share your site with others.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel Herd" data-type="sect2"><div class="sect2" id="herd">&#13;
<h2>Laravel Herd</h2>&#13;
&#13;
<p>Herd<a data-primary="Laravel Herd" data-type="indexterm" id="id766"/><a data-primary="Herd" data-type="indexterm" id="id767"/> is a native macOS app that bundles Valet and all its dependencies as a single installer. While Herd is not quite as customizable as Valet CLI is, it removes the need to work with Homebrew, Docker, or any other dependency managers, and it allows you to interact with Valet’s core features through a nice graphical interface.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel Homestead" data-type="sect2"><div class="sect2" id="homestead">&#13;
<h2>Laravel Homestead</h2>&#13;
&#13;
<p>Homestead<a data-primary="Laravel Homestead" data-type="indexterm" id="id768"/><a data-primary="Homestead" data-secondary="uses for" data-type="indexterm" id="id769"/> is another tool you might want to use to set up your local development environment. It’s a configuration tool that sits on top of Vagrant (which is a tool for managing virtual machines) and provides a preconfigured virtual machine image that is perfectly set up for Laravel development <em>and</em> mirrors the most common production environment that many Laravel sites run on.</p>&#13;
&#13;
<p>The <a href="https://laravel.com/docs/homestead">Homestead docs</a> are robust and kept constantly up to date, so I’ll just refer you to them if you want to learn how it works and how to get it set up.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a New Laravel Project" data-type="sect1"><div class="sect1" id="id13">&#13;
<h1>Creating a New Laravel Project</h1>&#13;
&#13;
<p>There<a data-primary="development environment" data-secondary="creating new Laravel projects" data-type="indexterm" id="id770"/><a data-primary="projects, creating new" data-type="indexterm" id="id771"/> are two ways to create a new Laravel project, both of which are run from the command line. The first option is to globally install the Laravel installer tool (using Composer); the second is to use Composer’s <code>create-project</code> feature.</p>&#13;
&#13;
<p>You can learn about both options in greater detail on the <a href="https://laravel.com/docs/installation">Installation documentation page</a>, but I’d recommend the Laravel installer tool.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing Laravel with the Laravel Installer Tool" data-type="sect2"><div class="sect2" id="laravel_installer">&#13;
<h2>Installing Laravel with the Laravel Installer Tool</h2>&#13;
&#13;
<p>If<a data-primary="installation" data-type="indexterm" id="id772"/><a data-primary="Laravel installer tool" data-type="indexterm" id="id773"/> you have Composer installed globally, installing the Laravel installer tool is as simple as running the following command:</p>&#13;
&#13;
<pre data-type="programlisting">composer global require "laravel/installer"</pre>&#13;
&#13;
<p>Once you have the Laravel installer tool installed, spinning up a new Laravel project is simple. Just run this command from your command line:</p>&#13;
&#13;
<pre data-type="programlisting">laravel new projectName</pre>&#13;
&#13;
<p>This will create a new subdirectory of your current directory named <em>{projectName}</em> and install a bare Laravel project in it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing Laravel with Composer’s create-project Feature" data-type="sect2"><div class="sect2" id="id376">&#13;
<h2>Installing Laravel with Composer’s create-project Feature</h2>&#13;
&#13;
<p>Composer<a data-primary="Composer" data-secondary="create-project feature" data-type="indexterm" id="id774"/> also offers a feature called <code>create-project</code> for creating new projects with a particular skeleton. To use this tool to create a new Laravel project, issue the following command:</p>&#13;
&#13;
<pre data-type="programlisting">composer create-project laravel/laravel projectName</pre>&#13;
&#13;
<p>Just like the installer tool, this will create a subdirectory of your current directory named <em>{projectName}</em> that contains a skeleton Laravel install, ready for you to develop.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Installing Laravel with Sail" data-type="sect2"><div class="sect2" id="id377">&#13;
<h2>Installing Laravel with Sail</h2>&#13;
&#13;
<p>If<a data-primary="Sail" data-secondary="installing Laravel with" data-type="indexterm" id="id775"/> you plan to work with Laravel Sail, you can install a Laravel app and begin its Sail installation process at the same time. Ensure you have Docker installed on your computer, and then issue the following command, replacing <code><em>example-app</em></code> with the name of your app:</p>&#13;
&#13;
<pre data-type="programlisting">curl -s "https://laravel.build/example-app" | bash</pre>&#13;
&#13;
<p>This will install Laravel into the <code><em>example-app</em></code> folder underneath your current folder and then begin the Sail installation process.</p>&#13;
&#13;
<p>Once that installation process is complete, change to your new directory and spin up Sail:</p>&#13;
&#13;
<pre data-type="programlisting">cd example-app&#13;
./vendor/bin/sail up</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The first time you run <code>sail up</code>, it’ll take quite a bit longer than other installation processes, as it needs to build up the initial Docker image.</p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel’s Directory Structure" data-type="sect1"><div class="sect1" id="id15">&#13;
<h1>Laravel’s Directory Structure</h1>&#13;
&#13;
<p>When you open up a directory that contains a skeleton Laravel application, you’ll see the following files and<a data-primary="development environment" data-secondary="Laravel's directory structure" data-type="indexterm" id="DEdirectory01"/><a data-primary="directory structure" data-type="indexterm" id="directstruct01"/> directories:</p>&#13;
<pre><strong>app/</strong>&#13;
<strong>bootstrap/</strong>&#13;
<strong>config/</strong>&#13;
<strong>database/</strong>&#13;
<strong>public/</strong>&#13;
<strong>resources/</strong>&#13;
<strong>routes/</strong>&#13;
<strong>storage/</strong>&#13;
<strong>tests/</strong>&#13;
<strong>vendor/</strong>&#13;
.editorconfig&#13;
.env&#13;
.env.example&#13;
.gitattributes&#13;
.gitignore&#13;
artisan&#13;
composer.json&#13;
composer.lock&#13;
package.json&#13;
phpunit.xml&#13;
readme.md&#13;
vite.config.js</pre>&#13;
&#13;
<p>Let’s walk through them one by one to get familiar.</p>&#13;
<section data-pdf-bookmark="The Folders" data-type="sect2"><div class="sect2" id="the-folders-k0sYuGT0">&#13;
<h2 class="less_space">The Folders</h2>&#13;
&#13;
<p>The root directory contains the following folders by default:</p>&#13;
<dl>&#13;
<dt>app</dt>&#13;
<dd>&#13;
<p>Where the bulk of your actual application will go. Models, controllers, commands, and your PHP domain code all go in here.</p>&#13;
</dd>&#13;
<dt>bootstrap</dt>&#13;
<dd>&#13;
<p>Contains the files that the Laravel framework uses to boot every time <span class="keep-together">it runs.</span></p>&#13;
</dd>&#13;
<dt>config</dt>&#13;
<dd>&#13;
<p>Where all the configuration files live.</p>&#13;
</dd>&#13;
<dt>database</dt>&#13;
<dd>&#13;
<p>Where database migrations, seeds, and factories live.</p>&#13;
</dd>&#13;
<dt>public</dt>&#13;
<dd>&#13;
<p>The directory the server points to when it’s serving the website. This contains <em>index.php</em>, which is the front controller that kicks off the bootstrapping process and routes all requests appropriately. It’s also where any public-facing files like images, stylesheets, scripts, or downloads go.</p>&#13;
</dd>&#13;
<dt>resources</dt>&#13;
<dd>&#13;
<p>Where files that are needed for other scripts live. Views, and (optionally) source CSS and source JavaScript files live here.</p>&#13;
</dd>&#13;
<dt>routes</dt>&#13;
<dd>&#13;
<p>Where all of the route definitions live, both for HTTP routes and “console routes,” or Artisan commands.</p>&#13;
</dd>&#13;
<dt>storage</dt>&#13;
<dd>&#13;
<p>Where caches, logs, and compiled system files live.</p>&#13;
</dd>&#13;
<dt>tests</dt>&#13;
<dd>&#13;
<p>Where unit and integration tests live.</p>&#13;
</dd>&#13;
<dt>vendor</dt>&#13;
<dd>&#13;
<p>Where Composer installs its dependencies. It’s Git-ignored (marked to be excluded from your version control system) because Composer is expected to run as a part of your deploy me process on any remote servers.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
<section data-pdf-bookmark="The Loose Files" data-type="sect2"><div class="sect2" id="the-loose-files-avszTbTm">&#13;
<h2 class="less_space">The Loose Files</h2>&#13;
&#13;
<p>The root directory also contains the following files:</p>&#13;
<dl>&#13;
<dt>.editorconfig</dt>&#13;
<dd>&#13;
<p>Gives your IDE/text editor instructions about Laravel’s coding standards (e.g., the size of indents, the charset, and whether to trim trailing whitespace).</p>&#13;
</dd>&#13;
<dt>.env and .env.example</dt>&#13;
<dd>&#13;
<p>Dictate the environment variables (variables that are expected to be different in each environment and are therefore not committed to version control). <em>.env.example</em> is a template that each environment should duplicate to create its own <em>.env</em> file, which is Git-ignored.</p>&#13;
</dd>&#13;
<dt>.gitignore and .gitattributes</dt>&#13;
<dd>&#13;
<p>Git configuration files.</p>&#13;
</dd>&#13;
<dt>artisan</dt>&#13;
<dd>&#13;
<p>Allows you to run Artisan commands (see <a data-type="xref" href="ch08.html#artisan_and_tinker">Chapter 8</a>) from the command line.</p>&#13;
</dd>&#13;
<dt>composer.json and composer.lock</dt>&#13;
<dd>&#13;
<p>Configuration files for Composer; <em>composer.json</em> is user-editable and <em>composer.lock</em> is not. These files share some basic information about the project and also define its PHP dependencies.</p>&#13;
</dd>&#13;
<dt>package.json</dt>&#13;
<dd>&#13;
<p>Like <em>composer.json</em>, but for frontend assets and dependencies of the build system; it instructs NPM about which JavaScript-based dependencies to pull in.</p>&#13;
</dd>&#13;
<dt>phpunit.xml</dt>&#13;
<dd>&#13;
<p>A configuration file for PHPUnit, the tool Laravel uses for testing out of the box.</p>&#13;
</dd>&#13;
<dt>readme.md</dt>&#13;
<dd>&#13;
<p>A Markdown file giving a basic introduction to Laravel. You won’t see this file if you use the Laravel installer.</p>&#13;
</dd>&#13;
<dt>vite.config.js</dt>&#13;
<dd>&#13;
<p>The (optional) configuration file for Vite. This file instructs your build system about how to compile and process your frontend assets.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuration" data-type="sect1"><div class="sect1" id="id16">&#13;
<h1>Configuration</h1>&#13;
&#13;
<p>The<a data-primary="development environment" data-secondary="configuration" data-type="indexterm" id="DEconfig01"/><a data-primary="configuration" data-type="indexterm" id="configur01"/><a data-primary="" data-startref="DEdirectory01" data-type="indexterm" id="id776"/><a data-primary="" data-startref="directstruct01" data-type="indexterm" id="id777"/> core settings of your Laravel application—​database connection settings, queue and mail settings, etc.—live in files in the <em>config</em> folder. Each of these files returns a PHP array, and each value in the array is accessible by a config key that is comprised of the filename and all descendant keys, separated by dots (<code>.</code>).</p>&#13;
&#13;
<p>So, if you create a file at <em>config/services.php</em> that looks like this:</p>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// config/services.php</code>&#13;
<code class="o">&lt;?</code><code class="nx">php</code>&#13;
<code class="k">return</code> <code class="p">[</code>&#13;
    <code class="s1">'sparkpost'</code> <code class="o">=&gt;</code> <code class="p">[</code>&#13;
        <code class="s1">'secret'</code> <code class="o">=&gt;</code> <code class="s1">'abcdefg'</code><code class="p">,</code>&#13;
    <code class="p">],</code>&#13;
<code class="p">];</code></pre>&#13;
&#13;
<p>You can access that config variable using <code>config('services.sparkpost.secret')</code>.</p>&#13;
&#13;
<p>Any configuration variables that should be distinct for each environment (and therefore not committed to source control) will instead live in your <em>.env</em> files. Let’s say you want to use a different Bugsnag API key for each environment. You’d set the config file to pull it from <em>.env</em>:</p>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// config/services.php</code>&#13;
<code class="o">&lt;?</code><code class="nx">php</code>&#13;
<code class="k">return</code> <code class="p">[</code>&#13;
    <code class="s1">'bugsnag'</code> <code class="o">=&gt;</code> <code class="p">[</code>&#13;
        <code class="s1">'api_key'</code> <code class="o">=&gt;</code> <code class="nx">env</code><code class="p">(</code><code class="s1">'BUGSNAG_API_KEY'</code><code class="p">),</code>&#13;
    <code class="p">],</code>&#13;
<code class="p">];</code></pre>&#13;
&#13;
<p>This <code>env()</code> helper function pulls a value from your <em>.env</em> file with that same key. So now, add that key to your <em>.env</em> (settings for this environment) and <em>.env.example</em> (template for all environments) files:</p>&#13;
&#13;
<pre data-code-language="ini" data-type="programlisting"><code class="c1"># In .env</code>&#13;
<code class="na">BUGSNAG_API_KEY</code><code class="o">=</code><code class="s">oinfp9813410942</code></pre>&#13;
&#13;
<pre data-code-language="ini" data-type="programlisting"><code class="c1"># In .env.example</code>&#13;
<code class="na">BUGSNAG_API_KEY</code><code class="o">=</code></pre>&#13;
&#13;
<p>Your <em>.env</em> file will already contain quite a few environment-specific variables needed by the framework, like which mail driver you’ll be using and what your basic database settings are.</p>&#13;
<div data-type="tip"><h1>Using env() Outside of Config Files</h1>&#13;
<p>Certain features in Laravel, including some caching and optimization features, aren’t available if you use <code>env()</code> calls anywhere outside of config files.</p>&#13;
&#13;
<p>The best way to pull in environment variables is to set up config items for anything you want to be environment-specific. Have those config items read the environment variables, and then reference the config variables anywhere within your app:</p>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// config/services.php</code>&#13;
<code class="k">return</code> <code class="p">[</code>&#13;
    <code class="s1">'bugsnag'</code> <code class="o">=&gt;</code> <code class="p">[</code>&#13;
        <code class="s1">'key'</code> <code class="o">=&gt;</code> <code class="nx">env</code><code class="p">(</code><code class="s1">'BUGSNAG_API_KEY'</code><code class="p">),</code>&#13;
    <code class="p">],</code>&#13;
<code class="p">];</code>&#13;
&#13;
<code class="c1">// In controller, or whatever</code>&#13;
<code class="nv">$bugsnag</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Bugsnag</code><code class="p">(</code><code class="nx">config</code><code class="p">(</code><code class="s1">'services.bugsnag.key'</code><code class="p">));</code></pre>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The .env File" data-type="sect2"><div class="sect2" id="id17">&#13;
<h2>The .env File</h2>&#13;
&#13;
<p>Let’s<a data-primary=".env File" data-primary-sortas="env File" data-type="indexterm" id="id778"/> take a quick look at the default contents of the <em>.env</em> file. The exact keys will vary depending on which version of Laravel you’re using, but take a look at <a data-type="xref" href="#default_env_vars">Example 2-1</a> to see what they look like.</p>&#13;
<div data-type="example" id="default_env_vars">&#13;
<h5><span class="label">Example 2-1. </span>The default environment variables in Laravel</h5>&#13;
&#13;
<pre data-code-language="ini" data-type="programlisting"><code class="na">APP_NAME</code><code class="o">=</code><code class="s">Laravel</code>&#13;
<code class="na">APP_ENV</code><code class="o">=</code><code class="s">local</code>&#13;
<code class="na">APP_KEY</code><code class="o">=</code>&#13;
<code class="na">APP_DEBUG</code><code class="o">=</code><code class="s">true</code>&#13;
<code class="na">APP_URL</code><code class="o">=</code><code class="s">http://localhost</code>&#13;
&#13;
<code class="na">LOG_CHANNEL</code><code class="o">=</code><code class="s">stack</code>&#13;
<code class="na">LOG_DEPRECATIONS_CHANNEL</code><code class="o">=</code><code class="s">null</code>&#13;
<code class="na">LOG_LEVEL</code><code class="o">=</code><code class="s">debug</code>&#13;
&#13;
<code class="na">DB_CONNECTION</code><code class="o">=</code><code class="s">mysql</code>&#13;
<code class="na">DB_HOST</code><code class="o">=</code><code class="s">127.0.0.1</code>&#13;
<code class="na">DB_PORT</code><code class="o">=</code><code class="s">3306</code>&#13;
<code class="na">DB_DATABASE</code><code class="o">=</code><code class="s">laravel</code>&#13;
<code class="na">DB_USERNAME</code><code class="o">=</code><code class="s">root</code>&#13;
<code class="na">DB_PASSWORD</code><code class="o">=</code>&#13;
&#13;
<code class="na">BROADCAST_DRIVER</code><code class="o">=</code><code class="s">log</code>&#13;
<code class="na">CACHE_DRIVER</code><code class="o">=</code><code class="s">file</code>&#13;
<code class="na">FILESYSTEM_DISK</code><code class="o">=</code><code class="s">local</code>&#13;
<code class="na">QUEUE_CONNECTION</code><code class="o">=</code><code class="s">sync</code>&#13;
<code class="na">SESSION_DRIVER</code><code class="o">=</code><code class="s">file</code>&#13;
<code class="na">SESSION_LIFETIME</code><code class="o">=</code><code class="s">120</code>&#13;
&#13;
<code class="na">MEMCACHED_HOST</code><code class="o">=</code><code class="s">127.0.0.1</code>&#13;
&#13;
<code class="na">REDIS_HOST</code><code class="o">=</code><code class="s">127.0.0.1</code>&#13;
<code class="na">REDIS_PASSWORD</code><code class="o">=</code><code class="s">null</code>&#13;
<code class="na">REDIS_PORT</code><code class="o">=</code><code class="s">6379</code>&#13;
&#13;
<code class="na">MAIL_MAILER</code><code class="o">=</code><code class="s">smtp</code>&#13;
<code class="na">MAIL_HOST</code><code class="o">=</code><code class="s">mailpit</code>&#13;
<code class="na">MAIL_PORT</code><code class="o">=</code><code class="s">1025</code>&#13;
<code class="na">MAIL_USERNAME</code><code class="o">=</code><code class="s">null</code>&#13;
<code class="na">MAIL_PASSWORD</code><code class="o">=</code><code class="s">null</code>&#13;
<code class="na">MAIL_ENCRYPTION</code><code class="o">=</code><code class="s">null</code>&#13;
<code class="na">MAIL_FROM_ADDRESS</code><code class="o">=</code><code class="s">"hello@example.com"</code>&#13;
<code class="na">MAIL_FROM_NAME</code><code class="o">=</code><code class="s">"${APP_NAME}"</code>&#13;
&#13;
<code class="na">AWS_ACCESS_KEY_ID</code><code class="o">=</code>&#13;
<code class="na">AWS_SECRET_ACCESS_KEY</code><code class="o">=</code>&#13;
<code class="na">AWS_DEFAULT_REGION</code><code class="o">=</code><code class="s">us-east-1</code>&#13;
<code class="na">AWS_BUCKET</code><code class="o">=</code>&#13;
<code class="na">AWS_USE_PATH_STYLE_ENDPOINT</code><code class="o">=</code><code class="s">false</code>&#13;
&#13;
<code class="na">PUSHER_APP_ID</code><code class="o">=</code>&#13;
<code class="na">PUSHER_APP_KEY</code><code class="o">=</code>&#13;
<code class="na">PUSHER_APP_SECRET</code><code class="o">=</code>&#13;
<code class="na">PUSHER_HOST</code><code class="o">=</code>&#13;
<code class="na">PUSHER_PORT</code><code class="o">=</code><code class="s">443</code>&#13;
<code class="na">PUSHER_SCHEME</code><code class="o">=</code><code class="s">https</code>&#13;
<code class="na">PUSHER_APP_CLUSTER</code><code class="o">=</code><code class="s">mt1</code>&#13;
&#13;
<code class="na">VITE_PUSHER_APP_KEY</code><code class="o">=</code><code class="s">"${PUSHER_APP_KEY}"</code>&#13;
<code class="na">VITE_PUSHER_HOST</code><code class="o">=</code><code class="s">"${PUSHER_HOST}"</code>&#13;
<code class="na">VITE_PUSHER_PORT</code><code class="o">=</code><code class="s">"${PUSHER_PORT}"</code>&#13;
<code class="na">VITE_PUSHER_SCHEME</code><code class="o">=</code><code class="s">"${PUSHER_SCHEME}"</code>&#13;
<code class="na">VITE_PUSHER_APP_CLUSTER</code><code class="o">=</code><code class="s">"${PUSHER_APP_CLUSTER}"</code></pre></div>&#13;
&#13;
<p>I won’t go into all of them, because quite a few are just groups of authentication information for various services (Pusher, Redis, DB, Mail). Here are two important environment variables you should know about, though:</p>&#13;
<dl>&#13;
<dt><code>APP_KEY</code></dt>&#13;
<dd>&#13;
<p>A randomly generated string that’s used to encrypt data. If this is ever empty, you may run into the error “No application encryption key has been specified.” In that case, just run <code>php artisan key:generate</code>, and Laravel will generate one for you.</p>&#13;
</dd>&#13;
<dt><code>APP_DEBUG</code></dt>&#13;
<dd>&#13;
<p>A Boolean determining whether the users of this instance of your application should see debug errors—great for local and staging environments, terrible for production.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The rest of the nonauthentication settings (<code>BROADCAST_DRIVER</code>, <code>QUEUE_CONNECTION</code>, etc.) are given default values that work with as little reliance on external services as possible, which is perfect for when you’re getting started.</p>&#13;
&#13;
<p>When you start your first Laravel app, the only change you’ll likely want to make for most projects is to the database configuration settings. I use Laravel Valet, so I change <code>DB_DATABASE</code> to the name of my project, <code>DB_USERNAME</code> to <code>root</code>, and <code>DB_PASSWORD</code> to an empty string:</p>&#13;
&#13;
<pre data-type="programlisting">DB_DATABASE=myProject&#13;
DB_USERNAME=root&#13;
DB_PASSWORD=</pre>&#13;
&#13;
<p>Then, I create a database with the same name as my project in my favorite MySQL client, and I’m ready to go.<a data-primary="" data-startref="DEconfig01" data-type="indexterm" id="id779"/><a data-primary="" data-startref="configur01" data-type="indexterm" id="id780"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Up and Running" data-type="sect1"><div class="sect1" id="id378">&#13;
<h1>Up and Running</h1>&#13;
&#13;
<p>You’re<a data-primary="development environment" data-secondary="bare Laravel installation" data-type="indexterm" id="id781"/> now up and running with a bare Laravel install. Run <code>git init</code>, commit the bare files with <code>git add .</code> and <code>git commit</code>, and you’re ready to start coding. That’s it! And if you’re using Valet, you can run the following commands and instantly see your site live in your browser:</p>&#13;
&#13;
<pre data-type="programlisting">laravel new myProject &amp;&amp; cd myProject &amp;&amp; valet open</pre>&#13;
&#13;
<p>Every time I start a new project, these are the steps I take:</p>&#13;
&#13;
<pre data-type="programlisting">laravel new myProject&#13;
cd myProject&#13;
git init&#13;
git add .&#13;
git commit -m "Initial commit"</pre>&#13;
&#13;
<p>I keep all of my sites in a <em>~/Sites</em> folder, which I have set up as my primary Valet directory, so in this case I’d instantly have <em>myProject.test</em> accessible in my browser with no added work. I can edit <em>.env</em> and point it to a particular database, add that database in my MySQL app, and I’m ready to start coding.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing" data-type="sect1"><div class="sect1" id="id379">&#13;
<h1>Testing</h1>&#13;
&#13;
<p>In<a data-primary="testing" data-secondary="basics of" data-type="indexterm" id="id782"/> every chapter after this, the “Testing” section at the end of the chapter will show you how to write tests for the feature or features that were covered. Since this chapter doesn’t cover a testable feature, let’s talk tests quickly. (To learn more about writing and running tests in Laravel, head over to <a data-type="xref" href="ch12.html#testing">Chapter 12</a>.)</p>&#13;
&#13;
<p>Out of the box, Laravel brings in PHPUnit as a dependency and is configured to run the tests in any file in the <em>tests</em> directory whose name ends with <em>Test.php</em> (for example, <em>tests/UserTest.php</em>).</p>&#13;
&#13;
<p>So, the simplest way to write tests is to create a file in the <em>tests</em> directory with a name that ends with <em>Test.php</em>. And the easiest way to run them is to run <code>./vendor/bin/phpunit</code> from the command line (in the project root).</p>&#13;
&#13;
<p>If any tests require database access, be sure to run your tests from the machine where your database is hosted—​so if you’re hosting your database in Vagrant, make sure to <code>ssh</code> into your Vagrant box to run your tests from there. Again, you can learn about this and much more in <a data-type="xref" href="ch12.html#testing">Chapter 12</a>.</p>&#13;
&#13;
<p>Also, some of the testing sections will use testing syntax and features that you will not be familiar with yet if you’re reading the book for the first time. If code in any of the testing sections is confusing, just skip it and come back to it after you’ve had a chance to read the testing chapter.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="TL;DR" data-type="sect1"><div class="sect1" id="id380">&#13;
<h1>TL;DR</h1>&#13;
&#13;
<p>Since<a data-primary="development environment" data-secondary="overview of" data-type="indexterm" id="id783"/> Laravel is a PHP framework, it’s very simple to serve it locally. Laravel also provides three tools for managing your local development: Sail, a Docker setup; Valet, a simpler macOS-based tool; and Homestead, a preconfigured Vagrant setup. Laravel relies on and can be installed by Composer and comes out of the box with a series of folders and files that reflect both its conventions and its relationship with other open source tools.</p>&#13;
</div></section>&#13;
</div></section></body></html>