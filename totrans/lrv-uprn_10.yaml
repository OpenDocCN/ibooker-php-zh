- en: Chapter 10\. Requests, Responses, and Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve already talked a bit about the Illuminate `Request` object. In [Chapter 3](ch03.html#routing),
    for example, you saw how you can typehint it in constructors to get an instance
    or use the `request()` helper to retrieve it, and in [Chapter 7](ch07.html#collecting_and_handling_user_data)
    we looked at how you can use it to get information about the user’s input.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn more about what the `Request` object is, how it’s
    generated, what it represents, and what part it plays in your application’s lifecycle.
    We’ll also talk about the `Response` object and Laravel’s implementation of the
    middleware pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel’s Request Lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every request coming into a Laravel application, whether generated by an HTTP
    request or a command-line interaction, is immediately converted into an Illuminate
    `Request` object, which then crosses many layers and ends up being parsed by the
    application itself. The application then generates an Illuminate `Response` object,
    which is sent back out across those layers and finally returned to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: This request/response lifecycle is illustrated in [Figure 10-1](#FIG1001). Let’s
    take a look at what it takes to make each of these steps happen, from the first
    line of code to the last.
  prefs: []
  type: TYPE_NORMAL
- en: '![lur3 1001](assets/lur3_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Request/response lifecycle
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Bootstrapping the Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every Laravel application has some form of configuration set up at the web server
    level, in an Apache *.htaccess* file or an Nginx configuration setting or something
    similar, that captures every web request regardless of URL and routes it to *public/index.php*
    in the Laravel application directory.
  prefs: []
  type: TYPE_NORMAL
- en: '*index.php* doesn’t actually have that much code in it. It has three primary
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: First, it loads Composer’s autoload file, which registers all of the Composer-loaded
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Next, it kicks off Laravel’s bootstrap, creating the application container (you’ll
    learn more about the container in [Chapter 11](ch11.html#the_container)) and registering
    a few core services (including the kernel, which we’ll talk about in just a bit).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it creates an instance of the kernel, creates a request representing
    the current user’s web request, and passes the request to the kernel to handle.
    The kernel responds with an Illuminate `Response` object, which *index.php* returns
    to the end user. Then, the kernel terminates the page request.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel is the core router of every Laravel application, responsible for
    taking in a user request, processing it through middleware, handling exceptions
    and passing it to the page router, and then returning the final response. Actually,
    there are two kernels, but only one is used for each page request. One of the
    routers handles web requests (the HTTP kernel), and the other handles console,
    cron, and Artisan requests (the console kernel). Each has a `handle()` method
    that’s responsible for taking in an Illuminate `Request` object and returning
    an Illuminate `Response` object.
  prefs: []
  type: TYPE_NORMAL
- en: The kernel runs all of the bootstraps that need to run before every request,
    including determining which environment the current request is running in (staging,
    local, production, etc.) and running all of the service providers. The HTTP kernel
    additionally defines the list of middleware that will wrap each request, including
    the core middleware responsible for sessions and CSRF protection.
  prefs: []
  type: TYPE_NORMAL
- en: Service Providers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although there’s a bit of procedural code in these bootstraps, almost all of
    Laravel’s bootstrap code is separated into something Laravel calls *service providers*.
    A service provider is a class that encapsulates logic that various parts of your
    application need to run to bootstrap their core functionality.
  prefs: []
  type: TYPE_NORMAL
- en: For example, there’s an `AuthServiceProvider` that bootstraps all of the registrations
    necessary for Laravel’s authentication system and a `RouteServiceProvider` that
    bootstraps the routing system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of service providers can be a little hard to understand at first,
    so think about it this way: many components of your application have bootstrap
    code that needs to run when the application initializes. Service providers are
    a tool for grouping that bootstrap code into related classes. If you have any
    code that needs to run *in preparation* for your application code to work, it’s
    a strong candidate for a service provider.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you ever find that the feature you’re working on requires some
    classes registered in the container (you’ll learn more about this in [Chapter 11](ch11.html#the_container)),
    you would create a service provider just for that piece of functionality. You
    might have a `GitHubServiceProvider` or a `MailerServiceProvider`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service providers have two important methods: `boot()` and `register()`. There’s
    also a `DeferrableProvider` interface that you might choose to use. Here’s how
    they work.'
  prefs: []
  type: TYPE_NORMAL
- en: First, all of the service providers’ `register()` methods are called. This is
    where you’ll want to bind classes and aliases to the container. You don’t want
    to do anything in `register()` that relies on the entire application being bootstrapped.
  prefs: []
  type: TYPE_NORMAL
- en: Second, all of the service providers’ `boot()` methods are called. You can now
    do any other bootstrapping here, like binding event listeners or defining routes—​anything
    that may rely on the entire Laravel application having been bootstrapped.
  prefs: []
  type: TYPE_NORMAL
- en: If your service provider is only going to register bindings in the container
    (i.e., teach the container how to resolve a given class or interface), but not
    perform any other bootstrapping, you can “defer” its registrations, which means
    they won’t run unless one of their bindings is explicitly requested from the container.
    This can speed up your application’s average time to bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to defer your service provider’s registrations, first implement
    the `Illuminate\Contracts\Support\DeferrableProvider` interface; then, give the
    service provider a `provides()` method that returns a list of bindings the provider
    provides, as shown in [Example 10-1](#EX1001).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-1\. Deferring the registration of a service provider
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: More Uses for Service Providers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service providers also have a suite of methods and configuration options that
    can provide advanced functionality to the end user when the provider is published
    as part of a Composer package. Take a look at the service provider definition
    in the [Laravel source](https://oreil.ly/uHhap) to learn more about how this can
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the application bootstrap, let’s take a look at the `Request`
    object, the most important output of the bootstrap.
  prefs: []
  type: TYPE_NORMAL
- en: The Request Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Illuminate\Http\Request` class is a Laravel-specific extension of Symfony’s
    `HttpFoundation``\Request` class.
  prefs: []
  type: TYPE_NORMAL
- en: Symfony HttpFoundation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Symfony’s `HttpFoundation` suite of classes powers almost every PHP framework
    in existence at this point; this is the most popular and powerful set of abstractions
    available in PHP for representing HTTP requests, responses, headers, cookies,
    and more.
  prefs: []
  type: TYPE_NORMAL
- en: The `Request` object is intended to represent every relevant piece of information
    you might care to know about a user’s HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: In native PHP code, you might find yourself looking to `$_SERVER`, `$_GET`,
    `$_POST`, and other combinations of globals and processing logic to get information
    about the current user’s request. What files has the user uploaded? What’s their
    IP address? What fields did they post? All of this is sprinkled around the language—​and
    your code—​in a way that’s hard to understand and harder to mock.
  prefs: []
  type: TYPE_NORMAL
- en: Symfony’s `Request` object instead collects all of the information necessary
    to represent a single HTTP request into a single object, and then tacks on convenience
    methods to make it easy to get useful information from it. The Illuminate `Request`
    object adds even more convenience methods to get information about the request
    it’s representing.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing a Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You’ll very likely never need to do this in a Laravel app, but if you ever
    need to capture your own Illuminate `Request` object directly from PHP’s globals,
    you can use the `capture()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Getting a Request Object in Laravel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel creates an internal `Request` object for each request, and there are
    a few ways you can get access to it.
  prefs: []
  type: TYPE_NORMAL
- en: First—and again, we’ll cover this more in [Chapter 11](ch11.html#the_container)—you
    can typehint the class in any constructor or method that’s resolved by the container.
    That means you can typehint it in a controller method or a service provider, as
    seen in [Example 10-2](#EX1002).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-2\. Typehinting in a container-resolved method to receive a `Request`
    object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `request()` global helper, which allows you
    to call methods on it (e.g., `request()->input()`) and also allows you to call
    it on its own to get an instance of `$request`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can use the `app()` global method to get an instance of `Request`.
    You can pass either the fully qualified class name or the shortcut `request`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Getting Basic Information About a Request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know how to get an instance of `Request`, what can you do with
    it? The primary purpose of the `Request` object is to represent the current HTTP
    request, so the primary functionality the `Request` class offers is to make it
    easy to get useful information about the current request.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve categorized the methods described here, but note that there’s certainly
    overlap between the categories, and the categories are a bit arbitrary—​for example,
    query parameters could just as easily be in “User and request state” as they are
    in “Basic user input.” Hopefully these categories will make it easy for you to
    learn what’s available, and then you can throw away the categories.
  prefs: []
  type: TYPE_NORMAL
- en: Also, be aware that there are many more methods available on the `Request` object;
    these are just the most commonly used methods.
  prefs: []
  type: TYPE_NORMAL
- en: Basic user input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The basic user input methods make it simple to get information that the users
    themselves explicitly provide—​likely through submitting a form or an Ajax component.
    When I reference “user-provided input” here, I’m talking about input from query
    strings (`GET`), form submissions (`POST`), or JSON. The basic user input methods
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`all()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all user-provided input.
  prefs: []
  type: TYPE_NORMAL
- en: '`input(*fieldName*)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the value of a single user-provided input field.
  prefs: []
  type: TYPE_NORMAL
- en: '`only(*fieldName*|[*array,of,field,names*])`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all user-provided input for the specified field name(s).
  prefs: []
  type: TYPE_NORMAL
- en: '`except(*fieldName*|[*array,of,field,names*])`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all user-provided input except for the specified field name(s).
  prefs: []
  type: TYPE_NORMAL
- en: '`exists(*fieldName*)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether the field exists in the input. `has()`
    is an alias. Executes the given callback when the field exists in the input.
  prefs: []
  type: TYPE_NORMAL
- en: '`filled(*fieldName*)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether the field exists in the input and is not
    empty (that is, has a value).
  prefs: []
  type: TYPE_NORMAL
- en: '`whenFilled()`'
  prefs: []
  type: TYPE_NORMAL
- en: Executes the given callback when the field exists in the input and is not empty
    (that is, has a value).
  prefs: []
  type: TYPE_NORMAL
- en: '`json()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a `ParameterBag` if the page had JSON sent to it.
  prefs: []
  type: TYPE_NORMAL
- en: '`boolean(*fieldName*)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns value from the input as a Boolean. Converts strings and integers to
    appropriate booleans (using `FILTER_VALIDATE_BOOLEAN`). If the key is not present
    in the request, returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '`json(*keyName*)`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the value of the given key from the JSON sent to the page.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 10-3](#EX1003) gives a few quick examples of how to use the user-provided
    information methods from a request.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-3\. Getting basic user-provided information from the request
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: User and request state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The user and request state methods include input that wasn’t explicitly provided
    by the user through a form:'
  prefs: []
  type: TYPE_NORMAL
- en: '`method()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the method (`GET`, `POST`, `PATCH`, etc.) used to access this route.
  prefs: []
  type: TYPE_NORMAL
- en: '`path()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the path (without the domain) used to access this page; for example,
    `'http://www.myapp.com/abc/def'` would return `'abc/def'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`url()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the URL (with the domain) used to access this page; for example, `'abc'`
    would return `'http://www.myapp.com/abc'`.
  prefs: []
  type: TYPE_NORMAL
- en: '`is()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether or not the current page request fuzzy-matches
    a provided string (e.g., `/a/b/c` would be matched by `$request->is('*b*')`, where
    `*` stands for any characters); uses a custom regex parser found in `Str::is()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`ip()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the user’s IP address.
  prefs: []
  type: TYPE_NORMAL
- en: '`header()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of headers (e.g., `['accept-language' => ['⁠e⁠n⁠-⁠U⁠S⁠,⁠e⁠n⁠;​q⁠=⁠0⁠.⁠8⁠']]`),
    or, if passed a header name as a parameter, returns just that header.
  prefs: []
  type: TYPE_NORMAL
- en: '`server()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of the variables traditionally stored in `$_SERVER` (e.g.,
    `REMOTE_ADDR`), or, if passed a `$_SERVER` variable name, returns just that value.
  prefs: []
  type: TYPE_NORMAL
- en: '`secure()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether this page was loaded using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: '`pjax()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether this page request was loaded using Pjax.
  prefs: []
  type: TYPE_NORMAL
- en: '`wantsJson()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether this request has any `/json` content types
    in its `Accept` headers.
  prefs: []
  type: TYPE_NORMAL
- en: '`isJson()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether this page request has any `/json` content
    types in its `Content-Type` header.
  prefs: []
  type: TYPE_NORMAL
- en: '`accepts()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether this page request accepts a given content
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, all of the input we’ve covered is either explicit (retrieved by methods
    like `all()`, `input()`, etc.) or defined by the browser or referring site (retrieved
    by methods like `pjax()`). File inputs are similar to explicit user input, but
    they’re handled much differently:'
  prefs: []
  type: TYPE_NORMAL
- en: '`file()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all uploaded files, or, if a key is passed (the file upload
    field name), returns just the one file.
  prefs: []
  type: TYPE_NORMAL
- en: '`allFiles()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all uploaded files; useful as opposed to `file()` because
    of clearer naming.
  prefs: []
  type: TYPE_NORMAL
- en: '`hasFile()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether a file was uploaded at the specified key.
  prefs: []
  type: TYPE_NORMAL
- en: Every file that’s uploaded will be an instance of `Symfony\Component\HttpFoundation\File\UploadedFile`,
    which provides a suite of tools for validating, processing, and storing uploaded
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Chapter 14](ch14.html#storage_and_retrieval) for more examples
    of how to handle uploaded files.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The request can also provide functionality for interacting with the session.
    Most session functionality lives elsewhere, but there are a few methods that are
    particularly relevant to the current page request:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flash()`'
  prefs: []
  type: TYPE_NORMAL
- en: Flashes the current request’s user input to the session to be retrieved later,
    which means it’s saved to the session but disappears after the next request.
  prefs: []
  type: TYPE_NORMAL
- en: '`flashOnly()`'
  prefs: []
  type: TYPE_NORMAL
- en: Flashes the current request’s user input for any keys in the provided array.
  prefs: []
  type: TYPE_NORMAL
- en: '`flashExcept()`'
  prefs: []
  type: TYPE_NORMAL
- en: Flashes the current request’s user input, except for any keys in the provided
    array.
  prefs: []
  type: TYPE_NORMAL
- en: '`old()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns an array of all previously flashed user input, or, if passed a key,
    returns the value for that key if it was previously flashed.
  prefs: []
  type: TYPE_NORMAL
- en: '`flush()`'
  prefs: []
  type: TYPE_NORMAL
- en: Wipes all previously flashed user input.
  prefs: []
  type: TYPE_NORMAL
- en: '`cookie()`'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieves all cookies from the request, or, if a key is provided, retrieves
    just that cookie.
  prefs: []
  type: TYPE_NORMAL
- en: '`hasCookie()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Boolean indicating whether the request has a cookie for the given
    key.
  prefs: []
  type: TYPE_NORMAL
- en: The `flash*()` and `old()` methods are used for storing user input and retrieving
    it later, often after the input is validated and rejected.
  prefs: []
  type: TYPE_NORMAL
- en: The Response Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to the `Request` object, there’s an Illuminate `Response` object that
    represents the response your application is sending to the end user, complete
    with headers, cookies, content, and anything else used for sending the end user’s
    browser instructions on rendering a page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like `Request`, the `Illuminate\Http\Response` class extends a Symfony
    class: `Symfony\Component\HttpFoundation\Response`. This is a base class with
    a series of properties and methods that makes it possible to represent and render
    a response; Illuminate’s `Response` class decorates it with a few helpful shortcuts.'
  prefs: []
  type: TYPE_NORMAL
- en: Using and Creating Response Objects in Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we talk about how you can customize your `Response` objects, let’s step
    back and see how we most commonly work with `Response` objects.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, any `Response` object returned from a route definition will be converted
    into an HTTP response. It may define specific headers or specific content, set
    cookies, or whatever else, but eventually it will be converted into a response
    your users’ browsers can parse.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at the simplest possible response, in [Example 10-4](#EX1004).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-4\. Simplest possible HTTP response
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We create a response, give it some core data, and then return it. We can also
    customize the HTTP status, headers, cookies, and more, like in [Example 10-5](#EX1005).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-5\. Simple HTTP response with customized status and headers
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Setting headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We define a header on a response by using the `header()` fluent method, like
    in [Example 10-5](#EX1005). The first parameter is the header name, and the second
    is the header value.
  prefs: []
  type: TYPE_NORMAL
- en: Adding cookies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also set cookies directly on the `Response` object if we’d like. We’ll
    cover Laravel’s cookie handling a bit more in [Chapter 14](ch14.html#storage_and_retrieval),
    but take a look at [Example 10-6](#EX1006) for a simple use case for attaching
    cookies to a response.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-6\. Attaching a cookie to a response
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Specialized Response Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are also a few special response types for views, downloads, files, and
    JSON. Each is a predefined macro that makes it easy to reuse particular templates
    for headers or content structure.
  prefs: []
  type: TYPE_NORMAL
- en: View responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html#routing), I used the global `view()` helper to show
    how to return a template—​for example, `view('*view.name.here*')` or something
    similar. But if you need to customize the headers, HTTP status, or anything else
    when returning a view, you can use the `view()` response type as shown in [Example 10-7](#EX1007).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-7\. Using the `view()` response type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Download responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes you want your application to force the user’s browser to download
    a file, whether you’re creating the file in Laravel or serving it from a database
    or a protected location. The `download()` response type makes this simple.
  prefs: []
  type: TYPE_NORMAL
- en: The required first parameter is the path for the file you want the browser to
    download. If it’s a generated file, you’ll need to save it somewhere temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: The optional second parameter is the filename for the downloaded file (e.g.,
    *export.csv*). If you don’t pass a string here, the name will be generated automatically.
    The optional third parameter allows you to pass an array of headers. [Example 10-8](#EX1008)
    illustrates the use of the `download()` response type.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-8\. Using the `download()` response type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to delete the original file from the disk after returning a download
    response, you can chain the `deleteFileAfterSend()` method after the `download()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: File responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file response is similar to the download response, except it allows the
    browser to display the file instead of forcing a download. This is most common
    with images and PDFs.
  prefs: []
  type: TYPE_NORMAL
- en: The required first parameter is the filename, and the optional second parameter
    can be an array of headers (see [Example 10-9](#EX1009)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-9\. Using the `file()` response type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: JSON responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JSON responses are so common that, even though they’re not really particularly
    complex to program, there’s a custom response for them as well.
  prefs: []
  type: TYPE_NORMAL
- en: JSON responses convert the passed data to JSON (with `json_encode()`) and set
    the `Content-Type` to `application/json`. You can also optionally use the `setCallback()`
    method to create a JSONP response instead of JSON, as seen in [Example 10-10](#EX1011).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-10\. Using the `json()` response type
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Redirect responses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redirects aren’t commonly called on the `response()` helper, so they’re a bit
    different from the other custom response types we’ve discussed already, but they’re
    still just another sort of response. Redirects, returned from a Laravel route,
    send the user a redirect (often a 301) to another page or back to the previous
    page.
  prefs: []
  type: TYPE_NORMAL
- en: You technically *can* call a redirect from `response()`, as in `return response()``->redirectTo('/')`.
    But, more commonly, you’ll use the redirect-specific global helpers.
  prefs: []
  type: TYPE_NORMAL
- en: There is a global `redirect()` function that can be used to create redirect
    responses and a global `back()` function that is a shortcut to `redirect()->back()`.
  prefs: []
  type: TYPE_NORMAL
- en: Just like most global helpers, the `redirect()` global function can either be
    passed parameters or be used to get an instance of its class that you then chain
    method calls onto. If you don’t chain, but just pass parameters, `redirect()`
    performs the same as `redirect()->to()`; it takes a string and redirects to that
    string URL. [Example 10-11](#EX10011) shows some examples of its use.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-11\. Examples of using the `redirect()` global helper
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can also redirect “back” to the previous page, which is especially useful
    when handling and validating user input. [Example 10-12](#EX1012) shows a common
    pattern in validation contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-12\. Redirect back with input
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you can redirect and flash data to the session at the same time. This
    is common with error and success messages, like in [Example 10-13](#EX1013).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-13\. Redirect with flashed data
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Custom response macros
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also create your own custom response types using *macros*. This allows
    you to define a series of modifications to make to the response and its provided
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s re-create the `json()` custom response type, just to see how it works.
    As always, you should probably create a custom service provider for these sorts
    of bindings, but for now we’ll just put it in `AppServiceProvider`, as seen in
    [Example 10-14](#EX1014).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-14\. Creating a custom response macro
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use it just like we would use the predefined `json()` macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This will return a response with the body of that array encoded for JSON, with
    the JSON-appropriate `Content-Type` header.
  prefs: []
  type: TYPE_NORMAL
- en: The responsable interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’d like to customize how you’re sending responses and a macro doesn’t
    offer enough space or enough organization, or if you want any of your objects
    to be capable of being returned as a “response” with their own logic of how to
    be displayed, the `Responsable` interface is for you.
  prefs: []
  type: TYPE_NORMAL
- en: The `Responsable` interface, `Illuminate\Contracts\Support\Responsable`, dictates
    that its implementors must have a `toResponse()` method. This needs to return
    an Illuminate `Response` object. [Example 10-15](#EX1022) illustrates how to create
    a `Responsable` object.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-15\. Creating a simple `Responsable` object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can use it just like our custom macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This probably looks like a lot of work relative to the response macros we covered
    earlier. But the `Responsable` interface really shines when you’re working with
    more complicated controller manipulations. One common example is to use it to
    create view models (or view objects), like in [Example 10-16](#EX1023).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-16\. Using `Responsable` to create a view object
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It starts to make a little bit more sense in this context—move your complex
    view preparation into a dedicated, *testable* object, and keep your controllers
    clean. Here’s a controller that uses that `Responsable` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Laravel and Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take a look back at [Figure 10-1](#FIG1001), at the start of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve covered the requests and responses, but we haven’t actually looked into
    what middleware are. You may already be familiar with middleware, which aren’t
    unique to Laravel, but rather a widely used architecture pattern.
  prefs: []
  type: TYPE_NORMAL
- en: An Introduction to Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The idea of middleware is that there is a series of layers wrapping around your
    application, like a multilayer cake or an onion.^([1](ch10.html#id1407)) Just
    as shown in [Figure 10-1](#FIG1001), every request passes through every middleware
    layer on its way into the application, and then the resulting response passes
    back through the middleware layers on its way out to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware are most often considered separate from your application logic, and
    usually are constructed in a way that should theoretically be applicable to any
    application, not just the one you’re working on at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'A middleware can inspect a request and decorate it or reject it, based on what
    it finds. That means middleware are great for something like rate limiting: they
    can inspect the IP address, check how many times it’s accessed this resource in
    the last minute, and send back a 429 (Too Many Requests) status if a threshold
    is passed.'
  prefs: []
  type: TYPE_NORMAL
- en: Because middleware also get access to the response on its way out of the application,
    it’s great for decorating responses. For example, Laravel uses a middleware to
    add all of the queued cookies from a given request/response cycle to the response
    right before it is sent to the end user.
  prefs: []
  type: TYPE_NORMAL
- en: But some of the most powerful uses of middleware come from the fact that they
    can be nearly the *first* and the *last* thing to interact with the request/response
    cycle. That makes middleware perfect for something like enabling sessions—​PHP
    needs you to open the session very early and close it very late, and middleware
    are also great for this.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Custom Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s imagine we want to have a middleware that rejects every request that uses
    the `DELETE` HTTP method and also sends a cookie back for every request.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s an Artisan command to create custom middleware. Let’s try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can now open up the file at *app/Http/Middleware/BanDeleteMethod.php*. The
    default contents are shown in [Example 10-17](#EX1015).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-17\. Default middleware contents
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: How this `handle()` method represents the processing of both the incoming request
    *and* the outgoing response is the most difficult thing to understand about middleware,
    so let’s walk through it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding middleware’s handle() method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, remember that middleware are layered, one on top of another, and then
    finally on top of the app. The first middleware that’s registered gets *first*
    access to a request when it comes in, then that request is passed to every other
    middleware in turn, then to the app. Then the resulting response is passed outward
    through the middleware, and finally the first middleware gets *last* access to
    the response when it goes out.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s imagine we’ve registered `BanDeleteMethod` as the first middleware to
    run. That means the `$request` coming into it is the raw request, unadulterated
    by any other middleware. Now what?
  prefs: []
  type: TYPE_NORMAL
- en: Passing that request to `$next()` means handing it off to the rest of the middleware.
    The `$next()` closure just takes that `$request` and passes it to the `handle()`
    method of the next middleware in the stack. It then gets passed on down the line
    until there are no more middleware to hand it to, and it finally ends up at the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Next, how does the response come out? This is where it might be hard to follow.
    The application returns a response, which is passed back up the chain of middleware—​because
    each middleware returns its response. So, within that same `handle()` method,
    the middleware can decorate a `$request` and pass it to the `$next()` closure,
    and can then choose to do something with the output it receives before finally
    returning that output to the end user. Let’s look at some pseudocode to make this
    clearer ([Example 10-18](#EX1016)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-18\. Pseudocode explaining the middleware call process
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let’s make the middleware do what we actually promised ([Example 10-19](#EX1017)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-19\. Sample middleware banning the `DELETE` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Binding Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’re not quite done yet. We need to register this middleware in one of two
    ways: globally or for specific routes.'
  prefs: []
  type: TYPE_NORMAL
- en: Global middleware are applied to every route; route middleware are applied on
    a route-by-route basis.
  prefs: []
  type: TYPE_NORMAL
- en: Binding global middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both bindings happen in *app/Http/Kernel.php*. To add a middleware as global,
    add its class name to the `$middleware` property, as in [Example 10-20](#EX1018).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-20\. Binding global middleware
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Binding route middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Middleware intended for specific routes can be added as route middleware or
    as part of a middleware group. Let’s start with the former.
  prefs: []
  type: TYPE_NORMAL
- en: Route middleware are added to the `$middlewareAliases` array in *app/Http/Kernel.php*.
    It’s similar to adding them to `$middleware`, except we have to give each one
    a key that will be used when applying this middleware to a particular route, as
    seen in [Example 10-21](#EX1019).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-21\. Binding route middleware
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We can now use this middleware in our route definitions, like in [Example 10-22](#EX1020).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-22\. Applying route middleware in route definitions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Using middleware groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Middleware groups are essentially prepackaged bundles of middleware that make
    sense to be together in specific contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware Groups in Routes Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every route in *routes/web.php* is in the `web` middleware group. This *routes/web.php*
    file is specific for web routes and the *routes/api.php* file for API routes.
    If you want to add routes in other groups, read on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the box, there are two groups: `web` and `api`. The `web` group has
    all the middleware that will be useful on almost every Laravel page request, including
    middleware for cookies, sessions, and CSRF protection. `api` has none of those—​it
    has a throttling middleware and a route model binding middleware, and that’s it.
    These are all defined in *app/Http/Kernel.php*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply middleware groups to routes just like you apply route middleware
    to routes, with the `middleware()` fluent method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: You can also create your own middleware groups and add and remove route middleware
    to and from preexisting middleware groups. It works just like adding route middleware
    normally, but you’re instead adding them to keyed groups in the `$middlewareGroups`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how these middleware groups match up with the two default
    route files. Unsurprisingly, the *routes/web.php* file is wrapped with the `web`
    middleware group, and the *routes/api.php* file is wrapped with the `api` middleware
    group.
  prefs: []
  type: TYPE_NORMAL
- en: The *routes/** files are loaded in the `RouteServiceProvider`. Take a look at
    the `map()` method there ([Example 10-23](#EX1021)) and you’ll find a `mapWebRoutes()`
    method and a `mapApiRoutes()` method, each of which loads its respective files
    already wrapped in the appropriate middleware group.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-23\. Default route service provider
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Example 10-23](#EX1021), we’re using the router to load a
    route group with the `web` middleware group, and another under the `api` middleware
    group.
  prefs: []
  type: TYPE_NORMAL
- en: Passing Parameters to Middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s not common, but there are times when you need to pass parameters to a
    route middleware. For example, you might have an authentication middleware that
    will act differently depending on whether you’re guarding for the `member` user
    type or the `owner` user type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To make this work, you’ll need to add one or more parameters to the middleware’s
    `handle()` method and update that method’s logic accordingly, as shown in [Example 10-24](#EX10a).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-24\. Defining a route middleware that accepts parameters
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you can also add more than one parameter to the `handle()` method
    and pass multiple parameters to the route definition by separating them with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Default Middleware
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel comes with quite a few middleware out of the box. Let’s take a look
    at each.
  prefs: []
  type: TYPE_NORMAL
- en: Maintenance Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often we need to take our applications offline temporarily to perform some form
    of maintenance. Laravel offers tooling for this feature, called “Maintenance Mode,”
    and there’s a middleware that checks every response to see if the app is in that
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable maintenance mode for your app with the `down` Artisan command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`refresh`'
  prefs: []
  type: TYPE_NORMAL
- en: Sends a header with the response to refresh the browser after the specified
    number of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '`retry`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the Retry-After header, with the specified number of seconds. Browsers
    usually ignore this header.
  prefs: []
  type: TYPE_NORMAL
- en: '`secret`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a password to allow some users to bypass the maintenance mode. To bypass
    the maintenance mode navigate to your app URL followed by the secret you set (e.g.,
    *app.url/long-password*). This will redirect you to the */* app URL, while setting
    a bypass cookie on your browser, allowing you to access the application normally
    even while it’s in maintenance mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable maintenance mode, use the `up` Artisan command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Rate Limiting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need to limit users such that they can access any given route(s) only
    a certain number of times in a given time frame (called *rate limiting*, and most
    common with APIs), there’s an out-of-the-box middleware for that: `throttle`.
    [Example 10-25](#EX41.5) demonstrates its use, using the “api” `RateLimiter` preset
    Laravel ships with.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-25\. Applying the rate limiting middleware to a route
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can define as many custom `RateLimiter` configurations as you need; look
    at the `configureRateLimiting()` method of the `RouteServiceProvider` for the
    default `api` configuration, and also to create your own.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in [Example 10-26](#EX1025), the default `api` configuration
    limits requests to 60 per minute, segmented by either the authenticated ID or,
    if the user is not logged in, the IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-26\. Default rate limiter definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can also customize the response that’s sent if the rate limit is hit, specify
    different rate limits based on user or application or request conditions, or even
    specify a stack of rate limiters that are applied in sequence. Take a look at
    [the rate limiting docs](https://oreil.ly/dEy4V) to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: Trusted Proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you use any Laravel tools to generate URLs within the app, you’ll notice
    that Laravel detects whether the current request was via HTTP or HTTPS and generates
    links using the appropriate protocol.
  prefs: []
  type: TYPE_NORMAL
- en: However, this doesn’t always work when you have a proxy (e.g., a load balancer
    or other web-based proxy) in front of your app. Many proxies send nonstandard
    headers like `X_FORWARDED_PORT` and `X_FORWARDED_PROTO` to your app, and expect
    your app to “trust” those, interpret them, and use them as a part of the process
    of interpreting the HTTP request. To make Laravel correctly treat proxied HTTPS
    calls like secure calls, and in order for Laravel to process other headers from
    proxied requests, you need to define how it should do so.
  prefs: []
  type: TYPE_NORMAL
- en: You likely don’t want to allow just *any* proxy to send traffic to your app;
    rather, you want to lock your app to only trust certain proxies, and even from
    those proxies you may only want to trust certain forwarded headers.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel includes the [TrustedProxy package](https://oreil.ly/wYcDc), which makes
    it possible for you to mark certain sources of traffic as “trusted,” and also
    mark which forwarded headers you want to trust from those sources and how to map
    them to normal headers.
  prefs: []
  type: TYPE_NORMAL
- en: To configure which proxies your app will trust, you can edit the `App\Http``\Middleware``\TrustProxies`
    middleware and add the IP address for your load balancer or proxy to the `$proxies`
    array, as shown in [Example 10-27](#EX10b).
  prefs: []
  type: TYPE_NORMAL
- en: Example 10-27\. Configuring the `TrustProxies` middleware
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `$headers` array defaults to trusting all forwarded headers
    from the trusted proxies; if you want to customize this list, take a look at the
    [Symfony docs on trusting proxies](https://oreil.ly/ur3bg).
  prefs: []
  type: TYPE_NORMAL
- en: CORS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hopefully you’ve never had a run in with CORS (cross-origin resource sharing).
    It’s one of those things that we hope always *just works*, and when it doesn’t,
    it’s painful.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel’s built-in CORS middleware runs by default and can be configured in
    *config/cors.php*. Its default configuration is reasonable for most apps, but
    in its config file you can exclude routes from CORS protection, modify the HTTP
    methods it operates on, and configure how it interacts with CORS headers.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Outside of the context of you as a developer using requests, responses, and
    middleware in your own testing, Laravel itself actually uses each quite a bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re doing application testing with calls like `$this->get(''/'')`,
    you’re instructing Laravel’s application testing framework to generate request
    objects that represent the interactions you’re describing. Then those request
    objects are passed to your application, as if they were actual visits. That’s
    why the application tests are so accurate: your application doesn’t actually “know”
    that it’s not a real user that’s interacting with it.'
  prefs: []
  type: TYPE_NORMAL
- en: In this context, many of the assertions you’re making—​say, `assertResponseOk()`—are
    assertions against the response object generated by the application testing framework.
    The `assertResponseOk()` method just looks at the response object and asserts
    that its `isOk()` method returns `true`—which is just checking that its status
    code is 200. In the end, *everything* in application testing is acting as if this
    were a real page request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Find yourself in a context where you need a request to work with in your tests?
    You can always pull one from the container with `$request = request()`. Or you
    could create your own—the constructor parameters for the `Request` class, all
    optional, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re really interested in an example, check out the method Symfony uses
    to create a new `Request` from the globals PHP provides: `Symfony\Component\HttpFoundation\Request@createFromGlobals()`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Response` objects are even simpler to create manually, if you need to. Here
    are the (optional) parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if you need to disable your middleware during an application test,
    import the `WithoutMiddleware` trait into that test. You can also use the `$this``->``withoutMiddleware()`
    method to disable middleware just for a single test method.
  prefs: []
  type: TYPE_NORMAL
- en: TL;DR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every request coming into a Laravel application is converted into an Illuminate
    `Request` object, which then passes through all the middleware and is processed
    by the application. The application generates a `Response` object, which is then
    passed back through all of the middleware (in reverse order) and returned to the
    end user.
  prefs: []
  type: TYPE_NORMAL
- en: '`Request` and `Response` objects are responsible for encapsulating and representing
    every relevant piece of information about the incoming user request and the outgoing
    server response.'
  prefs: []
  type: TYPE_NORMAL
- en: Service providers gather together related behavior for binding and registering
    classes for use by the application.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware wrap the application and can reject or decorate any request and response.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch10.html#id1407-marker)) Or an [ogre](https://oreil.ly/HQ1zL).
  prefs: []
  type: TYPE_NORMAL
