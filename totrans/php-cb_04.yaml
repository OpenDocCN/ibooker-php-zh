- en: Chapter 4\. Strings
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章. 字符串
- en: Strings are one of the fundamental building blocks of data in PHP. Each string
    represents an ordered sequence of bytes. Strings can range from human-readable
    sections of text (like `To be or not to be`) to sequences of raw bytes encoded
    as integers (such as `\110\145\154\154\157\40\127\157\162\154\144\41`).^([1](ch04.html#idm45875185433888))
    Every element of data read or written by a PHP application is represented as a
    string.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是PHP数据的基本构建块之一。每个字符串表示一个有序的字节序列。字符串可以是人类可读的文本部分（例如`To be or not to be`），也可以是编码为整数的原始字节序列（例如`\110\145\154\154\157\40\127\157\162\154\144\41`）。^([1](ch04.html#idm45875185433888))
    PHP应用程序读取或写入的每个数据元素都表示为字符串。
- en: In PHP, strings are typically encoded as [ASCII values](https://oreil.ly/Tjsyx),
    although you can convert between ASCII and other formats (like UTF-8) as necessary.
    Strings can contain `null` bytes when needed and are essentially limitless in
    terms of storage so long as the PHP process has adequate memory available.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，字符串通常编码为[ASCII值](https://oreil.ly/Tjsyx)，尽管您可以根据需要在ASCII和其他格式（如UTF-8）之间转换。字符串可以包含`null`字节，并且在PHP进程具有足够的内存可用的情况下，其存储几乎没有限制。
- en: The most basic way to create a string in PHP is with single quotes. Single-quoted
    strings are treated as literal statements—there are no special characters or any
    kind of *interpolation* of variables. To include a literal single quote within
    a single-quoted string, you must *escape* that quote by prefixing it with a backslash—for
    example, `\'`. In fact, the only two characters that need to be—or even can be—escaped
    are the single quote itself or the backslash. [Example 4-1](#single_quoted_strings)
    shows single-quoted strings along with their corresponding printed output.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中创建字符串的最基本方法是使用单引号。单引号字符串被视为字面状态——没有特殊字符或任何类型的*插值*变量。要在单引号字符串中包含字面单引号，必须通过在其前面加上反斜杠来*转义*该引号，例如，`\'`。实际上，唯一需要转义的两个字符是单引号本身或反斜杠。[例子 4-1](#single_quoted_strings)展示了单引号字符串及其相应的打印输出。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*Variable interpolation* is the practice of referencing a variable directly
    by name within a string and letting the interpreter replace the variable with
    its value at runtime. Interpolation allows for more flexible strings, as you can
    write a single string but dynamically replace some of its contents to fit the
    context of its location in code.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*变量插值*是直接按名称引用变量的实践，在字符串中让解释器在运行时将变量替换为其值。插值允许更灵活的字符串，因为您可以编写一个字符串，但动态替换其中一些内容以适应代码中的位置上下文。'
- en: Example 4-1\. Single-quoted strings
  id: totrans-6
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-1. 单引号字符串
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: More complicated strings might need to interpolate variables or reference special
    characters, like a newline or tab. For these more complicated use cases, PHP requires
    the use of double quotes instead and allows for various escape sequences, as shown
    in [Table 4-1](#string_escape_sequences).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的字符串可能需要插入变量或引用特殊字符，比如换行符或制表符。对于这些更复杂的用例，PHP需要使用双引号，并允许使用各种转义序列，如[表 4-1](#string_escape_sequences)所示。
- en: Table 4-1\. Double-quoted string escape sequences
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4-1. 双引号字符串转义序列
- en: '| Escape sequence | Character | Example |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 转义序列 | 字符 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `\n` | Newline | `"This string ends in a new line.\n"` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `\n` | 换行符 | `"这个字符串以换行符结尾。\n"` |'
- en: '| `\r` | Carriage return | `"This string ends with a carriage return.\r"` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `\r` | 回车符 | `"这个字符串以回车符结尾。\r"` |'
- en: '| `\t` | Tab | `"Lots\tof\tspace"` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `\t` | 制表符 | `"很多\t空格"` |'
- en: '| `\\` | Backslash | `"You must escape the \\ character."` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `\\` | 反斜杠 | `"必须转义\\字符。"` |'
- en: '| `\$` | Dollar sign | `A movie ticket is \$10.` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `\$` | 美元符号 | `电影票价为\$10。` |'
- en: '| `\"` | Double quote | `"Some quotes are \"scare quotes.\""` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `\"` | 双引号 | `"一些引号是 \"恐怖引号\"."` |'
- en: '| `\0` through `\777` | Octal character value | `"\120\110\120"` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `\0` 到 `\777` | 八进制字符值 | `"\120\110\120"` |'
- en: '| `\x0` through `\xFF` | Hex character value | `"\x50\x48\x50"` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `\x0` 到 `\xFF` | 十六进制字符值 | `"\x50\x48\x50"` |'
- en: Except for special characters that are explicitly escaped with leading backspaces,
    PHP will automatically substitute the value of any variable passed within a double-quoted
    string. Further, PHP will interpolate entire expressions within a double-quoted
    string if they’re wrapped in curly braces (`{}`) and treat them as a variable.
    [Example 4-2](#double_quoted_interpolation) shows how variables, complex or otherwise,
    are treated within double-quoted strings.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用前导反斜杠明确转义的特殊字符外，PHP 将自动替换任何传递到双引号字符串中的变量的值。此外，如果将整个表达式用大括号（`{}`）包裹起来并将其视为变量，PHP
    将在双引号字符串中插值整个表达式。[示例 4-2](#double_quoted_interpolation) 展示了如何处理双引号字符串中的变量，无论是复杂还是简单的。
- en: Example 4-2\. Variable interpolation within double-quoted strings
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-2\. 双引号字符串中的变量插值
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_strings_CO1-1)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_strings_CO1-1)'
- en: The first reference to `$var` is escaped, but the second will be replaced by
    its actual value. If `$var = 'apple'`, the string will print `The value of $var
    is apple`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`$var` 的第一个引用是转义的，但第二个将被其实际值替换。如果 `$var = ''apple''`，则该字符串将打印 `The value of
    $var is apple`。'
- en: '[![2](assets/2.png)](#co_strings_CO1-2)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_strings_CO1-2)'
- en: Using curly braces enables the direct reference of object properties within
    a double-quoted string as if these properties were locally defined variables.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在双引号字符串中，使用大括号可以直接引用对象属性，就好像这些属性是本地定义的变量一样。
- en: '[![3](assets/3.png)](#co_strings_CO1-3)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_strings_CO1-3)'
- en: Assuming `getVar()` returns the name of a defined variable, this line will both
    execute the function and print the value assigned to that variable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `getVar()` 返回一个已定义变量的名称，这行代码将执行该函数并打印分配给该变量的值。
- en: Both single- and double-quoted strings are represented as single lines. Often,
    though, a program will need to represent multiple lines of text (or multiple lines
    of encoded binary) as a string. In such a situation, the best tool at a developer’s
    disposal is a Heredoc.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单引号和双引号字符串都表示为单行。但通常，程序需要将多行文本（或多行编码的二进制）表示为一个字符串时，开发人员最好的工具是 Heredoc。
- en: A *Heredoc* is a literal block of text that’s started with three angle brackets
    (the `<<<` operator), followed by a named identifier, followed by a newline. Every
    subsequent line of text (including newlines) is part of the string, up to a completely
    independent line containing nothing but the Heredoc’s named identifier and a semicolon.
    [Example 4-3](#heredoc_example) illustrates how a Heredoc might look in code.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*Heredoc* 是一个以三个尖括号（`<<<` 运算符）开始的文本块，接着是一个命名标识符，然后是一个换行符。每个后续的文本行（包括换行符）都是字符串的一部分，直到一个仅包含
    Heredoc 命名标识符和一个分号的独立行。[示例 4-3](#heredoc_example) 展示了代码中 Heredoc 的外观。'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The identifier used for a Heredoc does not need to be capitalized. However,
    it is common convention in PHP to always capitalize these identifiers to help
    distinguish them from the text definition of the string.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 Heredoc 的标识符不需要大写。然而，在 PHP 中，通常习惯于始终将这些标识符大写，以帮助区分它们与字符串定义的文本。
- en: Example 4-3\. String definition using the Heredoc syntax
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-3\. 使用 Heredoc 语法定义字符串
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Heredocs function just like double-quoted strings and allow variable interpolation
    (or special characters like escaped hexadecimals) within them. This can be particularly
    powerful when encoding blocks of HTML within an application, as variables can
    be used to make the strings dynamic.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Heredoc 函数与双引号字符串完全相同，并允许在其中进行变量插值（或者类似转义十六进制的特殊字符）。在应用程序中编码 HTML 块时，这特别有用，因为可以使用变量使字符串变得动态。
- en: In some situations, though, you might want a string literal rather than something
    open to variable interpolation. In that case, PHP’s Nowdoc syntax provides a single-quoted
    style alternative to Heredoc’s double-quoted string analog. A Nowdoc looks almost
    exactly like a Heredoc, except the identifier itself is enclosed in single quotes,
    as in [Example 4-4](#nowdoc_example).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，您可能希望使用字符串字面量而不是开放变量插值的形式。在这种情况下，PHP 的 Nowdoc 语法提供了单引号风格的 Heredoc 双引号字符串的替代方案。Nowdoc
    看起来几乎与 Heredoc 相同，只是标识符本身用单引号括起来，如 [示例 4-4](#nowdoc_example) 所示。
- en: Example 4-4\. String definition using the Nowdoc syntax
  id: totrans-37
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-4\. 使用 Nowdoc 语法定义字符串
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Both single and double quotes can be used within Heredoc and Nowdoc blocks without
    additional escaping. Nowdocs, however, will not interpolate or dynamically replace
    any values, whether they are escaped or otherwise.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在Heredoc和Nowdoc块中可以使用单引号和双引号，而无需额外的转义。但是，Nowdocs不会插值或动态替换任何值，无论它们是否被转义或其他情况。
- en: The recipes that follow help further illustrate how strings can be used in PHP
    and the various problems they can solve.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的示例可以帮助进一步说明PHP中如何使用字符串及其解决的各种问题。
- en: 4.1 Accessing Substrings Within a Larger String
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 在更大的字符串中访问子字符串
- en: Problem
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to identify whether a string contains a specific substring. For example,
    you want to know if a URL contains the text `/secret/`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望确定一个字符串是否包含特定的子字符串。例如，您想知道一个URL是否包含文本 `/secret/`。
- en: Solution
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `strpos()`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `strpos()`：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Discussion
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP’s `strpos()` function will scan through a given string and identify the
    starting position of the first occurrence of a given substring. This function
    literally looks for a needle in a haystack, as the function’s arguments are named
    `$haystack` and `$needle`, respectively. If the substring (`$needle`) is not found,
    the function returns a Boolean `false`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的 `strpos()` 函数将扫描给定的字符串，并确定给定子字符串的第一次出现的起始位置。这个函数像是在干草堆中找针一样，因为函数的参数分别被命名为
    `$haystack` 和 `$needle`。如果未找到子字符串（`$needle`），则函数返回布尔值 `false`。
- en: It’s important in this case to use *strict equality comparison*, as `strpos()`
    will return `0` if the substring appears at the very beginning of the string being
    searched. Remember from [Recipe 2.3](ch02.html#equality_operators) that comparing
    values with only two equals signs will attempt to recast the types, converting
    an integer `0` into a Boolean `false`; always use strict comparison operators
    (either `===` for equality or `!==` for inequality) to avoid confusion.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用*严格的相等比较*很重要，因为 `strpos()` 如果子字符串出现在要搜索的字符串的开头，则返回 `0`。从 [Recipe 2.3](ch02.html#equality_operators)
    中可以了解到，使用只有两个等号的比较将尝试重新转换类型，将整数 `0` 转换为布尔值 `false`；始终使用严格比较运算符（`===` 表示相等或 `!==`
    表示不相等）以避免混淆。
- en: If the `$needle` appears multiple times within a string, `strpos()` only returns
    the position of the first occurrence. You can search for additional occurrences
    by adding an optional position offset as a third parameter to the function call,
    as in [Example 4-5](#identify_all_substring_occurrences). Defining an offset also
    allows you to search the latter part of a string for a substring that you know
    already appears earlier in the string.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `$needle` 在字符串中出现多次，`strpos()` 只会返回第一次出现的位置。您可以通过将第三个参数作为函数调用的可选位置偏移量来搜索其他出现，如在
    [示例 4-5](#identify_all_substring_occurrences) 中。定义偏移量还允许您搜索字符串的后半部分，以查找您已知已在字符串中较早出现的子字符串。
- en: Example 4-5\. Count all occurrences of a substring
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-5\. 计算子字符串的所有出现次数
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_strings_CO2-1)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_strings_CO2-1)'
- en: All of the variables are initially set to `0` so you can track new string occurrences.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量最初都设置为 `0`，以便跟踪新字符串的出现次数。
- en: '[![2](assets/2.png)](#co_strings_CO2-2)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_strings_CO2-2)'
- en: If and only if the string was found should an occurrence be counted.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在找到字符串时才应计算一个出现次数。
- en: '[![3](assets/3.png)](#co_strings_CO2-3)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_strings_CO2-3)'
- en: If the string was found, update the offset but also increment by `1` so you
    don’t repeatedly recount the occurrence you’ve already found.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到了字符串，则更新偏移量，但也要增加 `1`，以免重复计算已经找到的出现次数。
- en: '[![4](assets/4.png)](#co_strings_CO2-4)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_strings_CO2-4)'
- en: Once you’ve reached the last occurrence of the target substring, exit the loop
    and return the total count.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦达到目标子字符串的最后一个出现，退出循环并返回总计数。
- en: See Also
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`strpos()`](https://oreil.ly/w9Od4).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档中关于 [`strpos()`](https://oreil.ly/w9Od4) 的说明。
- en: 4.2 Extracting One String from Within Another
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 从另一个字符串中提取一个字符串
- en: Problem
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to extract a small string from a much larger string—for example, the
    domain name from an email address.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您想从一个更大的字符串中提取一个小字符串，例如从电子邮件地址中提取域名。
- en: Solution
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `substr()` to select the part of the string you want to extract:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `substr()` 来选择您想要提取的字符串的部分：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Discussion
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'PHP’s `substr()` function returns the portion of a given string, based on an
    initial offset (the second parameter) up to an optional length. The full function
    signature is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的 `substr()` 函数基于初始偏移量（第二个参数）返回给定字符串的部分，直到可选长度。完整的函数签名如下：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If the `$length` parameter is omitted, `substr()` will return the entire remainder
    of the string. If the `$offset` parameter is greater than the length of the input
    string, an empty string is returned.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了 `$length` 参数，`substr()` 将返回字符串的剩余部分。如果 `$offset` 参数大于输入字符串的长度，则返回一个空字符串。
- en: You can also specify a *negative* offset to return a subset starting from the
    end of the string instead of the beginning, as in [Example 4-6](#negative_substring_offset).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以指定一个 *负* 偏移量，从字符串末尾而不是开头开始返回子集，就像 [示例 4-6](#negative_substring_offset) 中展示的那样。
- en: Example 4-6\. Substring with a negative offset
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-6\. 带有负偏移量的子字符串
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_strings_CO3-1)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_strings_CO3-1)'
- en: Returns `ook` (the last three characters)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `ook`（最后三个字符）
- en: '[![2](assets/2.png)](#co_strings_CO3-2)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_strings_CO3-2)'
- en: Returns `ok` (the last two characters)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `ok`（最后两个字符）
- en: '[![3](assets/3.png)](#co_strings_CO3-3)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_strings_CO3-3)'
- en: Returns `cook` (the middle four characters)
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `cook`（中间四个字符）
- en: You should be aware of some other edge cases regarding offsets and string lengths
    with `substr()`. It is possible for the offset to legitimately start within the
    string, but for `$length` to run past the end of the string. PHP catches this
    discrepancy and merely returns the remainder of the original string, even if the
    final return is *less* than the specified length. [Example 4-7](#substring_lengths)
    details some potential outputs of `substr()` based on various specified lengths.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意一些关于 `substr()` 中偏移量和字符串长度的其他边界情况。偏移量可以合法地从字符串内部开始，但 `$length` 可能会超出字符串的末尾。PHP
    会捕捉到这种不一致，并且即使最终返回的字符串长度 *小于* 指定的长度，也仅返回原始字符串的剩余部分。[示例 4-7](#substring_lengths)
    细节化了基于不同指定长度的 `substr()` 可能的输出。
- en: Example 4-7\. Various substring lengths
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-7\. 不同的子字符串长度
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_strings_CO4-1)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_strings_CO4-1)'
- en: Returns `and`
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `and`
- en: '[![2](assets/2.png)](#co_strings_CO4-2)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_strings_CO4-2)'
- en: Returns an empty string
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个空字符串
- en: '[![3](assets/3.png)](#co_strings_CO4-3)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_strings_CO4-3)'
- en: Returns `y`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `y`
- en: Another edge case is a negative `$length` supplied to the function. When requesting
    a substring with a negative length, PHP will remove that many characters from
    the substring it returns, as illustrated in [Example 4-8](#negative_substring_length).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个边界情况是函数中提供的负 `$length`。当请求一个具有负长度的子字符串时，PHP 将从返回的子字符串中删除相应数量的字符，正如 [示例 4-8](#negative_substring_length)
    中所示。
- en: Example 4-8\. Substring with a negative length
  id: totrans-92
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-8\. 带有负长度的子字符串
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_strings_CO5-1)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_strings_CO5-1)'
- en: Returns `score and twenty`
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `score and twenty`
- en: '[![2](assets/2.png)](#co_strings_CO5-2)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_strings_CO5-2)'
- en: Returns `score`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `score`
- en: See Also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation for [`substr()`](https://oreil.ly/z_w10) and for [`strpos()`](https://oreil.ly/NWcWJ).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 文档中的 [`substr()`](https://oreil.ly/z_w10) 和 [`strpos()`](https://oreil.ly/NWcWJ)
    函数。
- en: 4.3 Replacing Part of a String
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 替换字符串的一部分
- en: Problem
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to replace just one part of a string with another string. For example,
    you want to obfuscate all but the last four digits of a phone number before printing
    it to the screen.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要仅用另一个字符串替换字符串的一部分。例如，在将电话号码打印到屏幕之前，你想要模糊显示除最后四位数字以外的所有内容。
- en: Solution
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `substr_replace()` to replace a component of an existing string based on
    its position:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `substr_replace()` 基于其位置替换现有字符串的组成部分：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Discussion
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP’s `substr_replace()` function operates on a part of a string, similar to
    `substr()`, defined by an integer offset up to a specific length. [Example 4-9](#substr_replace_signature)
    shows the full function signature.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的 `substr_replace()` 函数操作字符串的一部分，类似于 `substr()`，通过整数偏移量和特定长度定义。[示例 4-9](#substr_replace_signature)
    展示了完整的函数签名。
- en: Example 4-9\. Full function signature of `substr_replace()`
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-9\. `substr_replace()` 的完整函数签名
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Unlike its `substr()` analog, `substr_replace()` can operate either on individual
    strings or on collections of strings. If an array of strings is passed in with
    scalar values for `$replace` and `$offset`, the function will run the replacement
    on each string, as in [Example 4-10](#replace_multiple_substrings).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 不像它的 `substr()` 模拟函数，`substr_replace()` 可以操作单个字符串或字符串集合。如果将包含标量值的字符串数组传递给 `$replace`
    和 `$offset`，函数将对每个字符串执行替换，就像 [示例 4-10](#replace_multiple_substrings) 中展示的那样。
- en: Example 4-10\. Replacing multiple substrings at once
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-10\. 同时替换多个子字符串
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In general, developers have a lot of flexibility with the parameters in this
    function. Similar to `substr()`, the following are true:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，开发人员在这个函数的参数上有很大的灵活性。类似于`substr()`，以下内容是正确的：
- en: '`$offset` can be negative, in which case replacements begin that number of
    characters from the *end* of the string.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`$offset`为负数，则从字符串的末尾开始进行替换。
- en: '`$length` can be negative, representing the number of characters from the end
    of the string at which to stop replacing.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$length`可以为负数，表示从字符串末尾开始停止替换的字符数。'
- en: If `$length` is `null`, it will internally become the same as the length of
    the input string itself.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`$length`为`null`，它将内部变为输入字符串本身的长度。
- en: If `length` is `0`, `$replace` will be *inserted* into the string at the given
    `$offset`, and no replacement will take place at all.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`length`为`0`，`$replace`将被插入到给定的`$offset`处的字符串中，并且根本不会进行替换。
- en: Finally, if `$string` is provided as an array, all other parameters can be provided
    as arrays as well. Each element will represent a setting for the string in the
    same position in `$string`, as illustrated by [Example 4-11](#replace_with_array_parameters).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果`$string`被提供为数组，那么所有其他参数也可以作为数组提供。每个元素将代表在`$string`中相同位置的字符串的设置，如[示例 4-11](#replace_with_array_parameters)所示。
- en: Example 4-11\. Replacing multiple substrings with array parameters
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 4-11\. 使用数组参数替换多个子字符串
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It is not a hard requirement for arrays passed in for `$string`, `$replace`,
    `$offset`, and `$length` to be all of the same size. PHP will not throw an error
    or warning if you pass arrays with different dimensions. Doing so will, however,
    result in unexpected output during the replacement operation—for example, truncating
    a string rather than replacing its contents. It’s a good idea to validate that
    the dimensions of each of these four arrays all match.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 不要求传递给`$string`、`$replace`、`$offset`和`$length`的数组具有相同的大小。如果您传递具有不同维度的数组，PHP不会抛出错误或警告。但这将导致在替换操作期间产生意外的输出，例如截断字符串而不是替换其内容。验证这四个数组的每个维度是否匹配是个好主意。
- en: The `substr_replace()` function is convenient if you know exactly *where* you
    need to replace characters within a string. In some situations, you might not
    know the position of a substring that needs to be replaced, but you want to instead
    replace occurrences of a *specific* substring. In those circumstances, you would
    want to use either `str_replace()` or `str_ireplace()`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确切地知道在字符串中需要替换字符的位置，`substr_replace()`函数是很方便的。在某些情况下，您可能不知道需要替换的子字符串的位置，但您希望替换特定子字符串的出现。在这种情况下，您会希望使用`str_replace()`或`str_ireplace()`。
- en: These two functions will search a specified string to find an occurrence (or
    many occurrences) of a specified substring and replace it with something else.
    The functions are identical in their call pattern, but the extra `i` in `str_ireplace()`
    indicates that it searches for a pattern in a *case-insensitive* fashion. [Example 4-12](#string_search_and_replace)
    illustrates both functions in use.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数将搜索指定的字符串以查找指定子字符串的出现（或多个出现），并将其替换为其他内容。这两个函数在调用模式上是相同的，但`str_ireplace()`中的额外的`i`表示它以*不区分大小写*的方式搜索模式。[示例 4-12](#string_search_and_replace)展示了这两个函数的使用。
- en: Example 4-12\. Searching and replacing within a string
  id: totrans-125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-12\. 在字符串内搜索和替换
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[![1](assets/1.png)](#co_strings_CO6-1)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_strings_CO6-1)'
- en: '*How much wood could a Woodchuck chuck if a beaver could chuck wood?*'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果一只海狸可以扔木头，它能扔多少木头？*'
- en: '[![2](assets/2.png)](#co_strings_CO6-2)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_strings_CO6-2)'
- en: '*How much wood could a beaver chuck if a beaver could chuck wood?*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果一只海狸可以扔木头，它能扔多少木头？*'
- en: Both `str_replace()` and `str_ireplace()` accept an optional `$count` parameter
    that is passed by reference. If specified, this variable will be updated with
    the number of replacements the function performed. In [Example 4-12](#string_search_and_replace),
    this return value would have been `1` and `2`, respectively, because of the capitalization
    of `Woodchuck`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`str_replace()`和`str_ireplace()`都接受一个可选的`$count`参数，通过引用传递。如果指定了此变量，函数执行的替换次数将更新到此变量中。在[示例 4-12](#string_search_and_replace)中，由于`Woodchuck`的大写，返回值分别为`1`和`2`。'
- en: See Also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`substr_replace()`](https://oreil.ly/-BSkA), [`str_replace()`](https://oreil.ly/Vm7KH),
    and [`str_ireplace()`](https://oreil.ly/8P46w).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档：[`substr_replace()`](https://oreil.ly/-BSkA)、[`str_replace()`](https://oreil.ly/Vm7KH)和[`str_ireplace()`](https://oreil.ly/8P46w)。
- en: 4.4 Processing a String One Byte at a Time
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 逐字节处理字符串
- en: Problem
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to process a string of single-byte characters from beginning to end,
    one character at a time.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要从头到尾处理一个由单字节字符组成的字符串，逐个字符处理。
- en: Solution
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Loop through each character of the string as if it were an array. [Example 4-13](#count_capital_characters)
    will count the number of capital letters in a string.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 像循环遍历数组一样遍历字符串的每个字符。[示例 4-13](#count_capital_characters)将计算字符串中大写字母的数量。
- en: Example 4-13\. Count capital characters in a string
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-13\. 计算字符串中的大写字母数量
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Discussion
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Strings are not arrays in PHP, so you cannot loop over them directly. However,
    they do provide array-like access to individual characters within the string based
    on their position. You can reference individual characters by their integer offset
    (starting with 0), or even by a *negative* offset to start at the end of the string.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP中，字符串不是数组，因此不能直接对它们进行循环。但是，它们提供了类似数组的访问方式，可以根据它们在字符串中的位置访问单个字符。你可以通过它们的整数偏移量（从0开始）引用单个字符，甚至可以通过*负*偏移量从字符串的末尾开始。
- en: Array-like access isn’t read-only, though. You can just as easily *replace*
    a single character in a string based on its position, as demonstrated by [Example 4-14](#replace_single_character_in_string).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类似数组的访问并非只读。你也可以根据其位置轻松*替换*字符串中的单个字符，正如[示例 4-14](#replace_single_character_in_string)所示。
- en: Example 4-14\. Replacing a single character in a string
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-14\. 替换字符串中的单个字符
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It is also possible to convert a string *directly* to an array by using [`str_split()`](https://oreil.ly/eNxaF)
    and then iterate over all items in the resulting array. This will work as an update
    to the Solution example, as illustrated in [Example 4-15](#str_split_array).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过使用[`str_split()`](https://oreil.ly/eNxaF)将字符串*直接*转换为数组，然后迭代结果数组中的所有项目来实现。这将作为更新到解决方案示例，如[示例 4-15](#str_split_array)中所示。
- en: Example 4-15\. Converting a string into an array directly
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-15\. 将字符串直接转换为数组
- en: '[PRE18]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The downside of [Example 4-15](#str_split_array) is that PHP now has to maintain
    *two* copies of your data: the original string and the resultant array. This isn’t
    a problem when handling small strings as in the example; if your strings instead
    represent entire files on disk, you will rapidly exhaust the memory available
    to PHP.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 4-15](#str_split_array)的缺点在于PHP现在必须维护*两份*数据副本：原始字符串和结果数组。在处理像示例中那样的小字符串时，这不是问题；但如果你的字符串代表磁盘上的整个文件，你将迅速耗尽PHP可用的内存。'
- en: PHP makes accessing individual bytes (characters) within a string relatively
    easy without any changes in data type. Splitting a string into an array works
    but might be unnecessary unless you actually *need* an array of characters. [Example 4-16](#str_split_reduce)
    reimagines [Example 4-15](#str_split_array), using an array reduction technique
    rather than counting the capital letters in a string directly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: PHP使得在不改变数据类型的情况下相对容易地访问字符串中的单个字节（字符）。将字符串拆分为数组是可行的，但除非你确实*需要*一个字符数组，否则可能是不必要的。[示例 4-16](#str_split_reduce)重新构想了[示例 4-15](#str_split_array)，使用了数组缩减技术，而不是直接计算字符串中的大写字母数量。
- en: Example 4-16\. Counting capital letters in a string with array reduction
  id: totrans-151
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 4-16\. 使用数组缩减技术计算字符串中的大写字母数量
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While [Example 4-16](#str_split_reduce) is functionally equivalent to [Example 4-15](#str_split_array),
    it is more concise and, consequently, more difficult to understand. While it is
    tempting to reimagine complex logic as one-line functions, unnecessary refactoring
    of your code for the sake of conciseness can be dangerous. The code might appear
    elegant but over time becomes more difficult to maintain.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[示例 4-16](#str_split_reduce)在功能上等效于[示例 4-15](#str_split_array)，但它更为简洁，因此更难理解。虽然将复杂逻辑重新构想为单行函数很诱人，但为了简洁而不必要地重构代码可能是危险的。代码可能看起来优雅，但随着时间的推移，会变得更难维护。
- en: The simplified reduction introduced in [Example 4-16](#str_split_reduce) is
    functionally accurate but still requires splitting the string into an array. It
    saves on lines of code in your program but still results in creating a second
    copy of your data. As mentioned before, if the strings over which you’re iterating
    are large (e.g., massive binary files), this will rapidly consume the memory available
    to PHP.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 4-16](#str_split_reduce)中引入的简化缩减是功能上准确的，但仍然需要将字符串拆分为数组。它在程序中节省了代码行数，但仍然会导致创建数据的第二份副本。如前所述，如果你迭代的字符串很大（例如大型二进制文件），这将迅速消耗PHP可用的内存。
- en: See Also
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [string access and modification](https://oreil.ly/8MOWh),
    as well as documentation on [`ctype_upper()`](https://oreil.ly/bQctH).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: PHP关于[string访问和修改](https://oreil.ly/8MOWh)的文档，以及关于[`ctype_upper()`](https://oreil.ly/bQctH)的文档。
- en: 4.5 Generating Random Strings
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 生成随机字符串
- en: Problem
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to generate a string of random characters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望生成一串随机字符。
- en: Solution
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use PHP’s native `random_int()` function:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP的本地`random_int()`函数：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Discussion
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP has strong, *cryptographically secure* pseudorandom generator functions
    for both integers and bytes. It does not have a native function that generates
    random human-readable text, but the underlying functions can be used to create
    such a string of random text by leveraging lists of human-readable characters,
    as illustrated by the Solution example.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: PHP拥有强大的、*密码学安全*的伪随机生成函数，适用于整数和字节。它没有原生函数生成随机的可读文本，但可以通过利用人类可读字符列表来创建这样的随机文本串，示例见解决方案部分。
- en: Note
  id: totrans-166
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: A *cryptographically secure pseudorandom number generator* is a function that
    returns numbers with no distinguishable or predictable pattern. Even forensic
    analysis cannot distinguish between random noise and the output of a cryptographically
    secure generator.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '*密码学安全的伪随机数生成器*是一种函数，它返回没有可区分或可预测模式的数字。即使是法庭鉴定也无法区分随机噪声和密码学安全生成器的输出。'
- en: A valid and potentially simpler method for producing random strings is to leverage
    PHP’s `random_bytes()` function and encode the binary output as ASCII text. [Example 4-17](#random_byte_string)
    illustrates two possible methods of using random bytes as a string.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机字符串的一个有效且可能更简单的方法是利用PHP的`random_bytes()`函数，并将二进制输出编码为ASCII文本。[Example 4-17](#random_byte_string)展示了两种可能的使用随机字节作为字符串的方法。
- en: Example 4-17\. Creating a string of random bytes
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-17\. 创建一串随机字节
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](assets/1.png)](#co_strings_CO7-1)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_strings_CO7-1)'
- en: Because the string of binary bytes will be encoded in a different format, keep
    in mind that the number of bytes produced will *not* match the length of the final
    string.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因为二进制字节串将以不同的格式进行编码，所以产生的字节数量将*不会*与最终字符串的长度匹配。
- en: '[![2](assets/2.png)](#co_strings_CO7-2)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_strings_CO7-2)'
- en: Encode the random string in hexadecimal format. Note that this format will double
    the length of the string—16 bytes is equivalent to 32 hexadecimal characters.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 将随机字符串编码为十六进制格式。请注意，这种格式会使字符串长度加倍——16字节相当于32个十六进制字符。
- en: '[![3](assets/3.png)](#co_strings_CO7-3)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_strings_CO7-3)'
- en: Leverage [Base64](https://oreil.ly/NsyVs) encoding to convert the raw bytes
    on readable characters. Note that this format increases the length of the string
    by 33%–36%.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 利用[Base64编码](https://oreil.ly/NsyVs)将原始字节转换为可读字符。请注意，这种格式会使字符串长度增加33%至36%。
- en: See Also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`random_int()`](https://oreil.ly/g3gAR) and on [`random_bytes()`](https://oreil.ly/2Zbio).
    Also [Recipe 5.4](ch05.html#recipe_random_numbers) on generating random numbers.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: PHP关于[`random_int()`](https://oreil.ly/g3gAR)和[`random_bytes()`](https://oreil.ly/2Zbio)的文档。还有关于生成随机数的[Recipe
    5.4](ch05.html#recipe_random_numbers)。
- en: 4.6 Interpolating Variables Within a String
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.6 在字符串中插入变量
- en: Problem
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to include dynamic content in an otherwise static string.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在静态字符串中包含动态内容。
- en: Solution
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use double quotes to wrap the string and insert a variable, object property,
    or even function/method call directly in the string itself:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双引号包裹字符串并直接在字符串中插入变量、对象属性甚至函数/方法调用：
- en: '[PRE22]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Discussion
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Unlike single-quoted strings, double-quoted strings allow for complex, dynamic
    values as literals. Any word starting with a `$` character is interpreted as a
    variable name, unless that leading character is properly escaped.^([2](ch04.html#idm45875190506912))
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 与单引号字符串不同，双引号字符串允许作为字面量使用复杂的动态值。任何以`$`字符开头的单词都会被解释为变量名，除非该前导字符被正确转义。^([2](ch04.html#idm45875190506912))
- en: While the Solution example wraps dynamic content in curly braces, this is not
    a requirement in PHP. Simple variables can easily be written as is within a double-quoted
    string and will be interpolated properly. However, more complex sequences become
    difficult to read without the braces. It’s a highly recommended best practice
    to always enclose any value you want interpolated to make the string more readable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然解决方案示例中用花括号包裹动态内容，但在PHP中这不是必需的。简单变量可以直接在双引号字符串中写入并正确解析。然而，对于更复杂的序列，如果没有花括号，将会使读取变得困难。强烈推荐的最佳实践是始终用花括号括起要插入的任何值，以使字符串更易读。
- en: Unfortunately, string interpolation has its limits. The Solution example illustrates
    pulling data out of the superglobal `$_POST` array and inserting it directly into
    a string. This is potentially dangerous, as that content is generated directly
    by the user, and the string could be leveraged in a sensitive way. In fact, string
    interpolation like this is one of the largest vectors for injection attacks against
    applications.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，字符串插值也有其局限性。解决方案示例展示了从超全局`$_POST`数组中提取数据并直接插入字符串的操作。这是潜在危险的，因为该内容由用户直接生成，并且该字符串可能在敏感环境中被利用。事实上，这种类似插值的字符串操作是应用程序中最大的注入攻击向量之一。
- en: Note
  id: totrans-189
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In an injection attack, a third party can pass (or inject) executable or otherwise
    malicious input into your application and cause it to misbehave. More sophisticated
    ways to protect against this family of attacks are covered in [Chapter 9](ch09.html#chapter_encryption).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在注入攻击中，第三方可以传递（或注入）可执行或恶意输入到您的应用程序中，并导致其行为异常。更复杂的防护方法可以在[第9章](ch09.html#chapter_encryption)中找到。
- en: To protect your string use against potentially malicious user-generated input,
    it’s a good idea to instead use a format string via PHP’s `sprintf()` function
    to filter the content. [Example 4-18](#interpolation_sprintf) rewrites part of
    the Solution example to protect against malicious `$_POST` data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护您的字符串免受潜在恶意用户生成的输入的影响，最好使用PHP的`sprintf()`函数通过格式字符串来过滤内容。[示例4-18](#interpolation_sprintf)重写了解决方案示例的部分，以防止恶意的`$_POST`数据。
- en: Example 4-18\. Using format strings to produce an interpolated string
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-18\. 使用格式化字符串生成插值字符串
- en: '[PRE23]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Format strings are a basic form of input sanitization in PHP. In [Example 4-18](#interpolation_sprintf),
    you are explicitly assuming that the supplied `$_POST` data is numeric. The `%d`
    tokens within the format string will be replaced by the user-supplied data, but
    PHP will explicitly cast this data as integers during the replacement.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化字符串在PHP中是一种基本的输入清理形式。在[示例4-18](#interpolation_sprintf)中，您明确假定提供的`$_POST`数据是数字。格式字符串中的`%d`标记将被用户提供的数据替换，但PHP在替换期间将显式地将这些数据强制转换为整数。
- en: If, for example, this string were being inserted into a database, the formatting
    would protect against the potential of injection attacks against SQL interfaces.
    More complete methods of filtering and sanitizing user input are discussed in
    [Chapter 9](ch09.html#chapter_encryption).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果此字符串正在插入数据库，则格式化将保护免受针对SQL接口的注入攻击的威胁。更完整的用户输入过滤和清理方法在[第9章](ch09.html#chapter_encryption)中讨论。
- en: See Also
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [variable parsing](https://oreil.ly/CAj-J) in double quotes
    and Heredoc as well as documentation on the [`sprintf()` function](https://oreil.ly/DMAg6).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: PHP关于[双引号内变量解析](https://oreil.ly/CAj-J)和Heredoc以及[`sprintf()`函数](https://oreil.ly/DMAg6)的文档。
- en: 4.7 Concatenating Multiple Strings Together
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.7 合并多个字符串
- en: Problem
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You need to create a new string from two smaller strings.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从两个较小的字符串创建一个新的字符串。
- en: Solution
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use PHP’s string concatenation operator:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PHP的字符串连接运算符：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Discussion
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: PHP uses a single `.` character to join two strings together. This operator
    will also leverage type coercion to ensure that both values in the operation are
    strings before they’re concatenated, as shown in [Example 4-19](#string_concatenation_examples).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: PHP使用单个`.`字符来连接两个字符串。此运算符还会利用类型强制转换，确保操作中的两个值在串联之前都是字符串，如[示例4-19](#string_concatenation_examples)所示。
- en: Example 4-19\. String concatenation
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-19\. 字符串连接
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_strings_CO8-1)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_strings_CO8-1)'
- en: Prints `String 2`
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`String 2`
- en: '[![2](assets/2.png)](#co_strings_CO8-2)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_strings_CO8-2)'
- en: Prints `2 number`
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`2 number`
- en: '[![3](assets/3.png)](#co_strings_CO8-3)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_strings_CO8-3)'
- en: Prints `Boolean 1` because Boolean values are cast to integers and then to strings
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`Boolean 1`因为布尔值被转换为整数然后转换为字符串
- en: '[![4](assets/4.png)](#co_strings_CO8-4)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_strings_CO8-4)'
- en: Prints `23`
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 打印`23`
- en: The string concatenation operator is a quick way to combine simple strings,
    but it can become somewhat verbose if you use it to combine multiple strings with
    whitespace. Consider [Example 4-20](#string_concatenation_verbose), where you
    try to combine a list of words into a string, each separated by a space.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串连接运算符是将简单字符串快速组合的一种方式，但如果用它来组合多个带有空格的字符串，可能会显得有些冗长。考虑[示例4-20](#string_concatenation_verbose)，在这个示例中，您试图将一组单词组合成一个字符串，每个单词之间用空格分隔。
- en: Example 4-20\. Verbosity in concatenating large groups of strings
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-20\. 连接大量字符串时的冗长性
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[![1](assets/1.png)](#co_strings_CO9-1)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_strings_CO9-1)'
- en: One option is to individually concatenate each word in the collection with whitespace
    separators. As the word list grows, this quickly becomes unwieldy.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是逐个将集合中的每个单词与空格分隔符连接起来。随着单词列表的增长，这很快变得难以管理。
- en: '[![2](assets/2.png)](#co_strings_CO9-2)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_strings_CO9-2)'
- en: You can, instead, loop over the collection and build up a concatenated string
    without accessing each item in the collection individually.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以循环遍历集合并构建一个连接的字符串，而无需逐个访问集合中的每个项。
- en: '[![3](assets/3.png)](#co_strings_CO9-3)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_strings_CO9-3)'
- en: When using a loop, you might end up with unnecessary whitespace. You need to
    remember to trim extraneous spaces from the start of the string.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用循环时，可能会出现不必要的空白。您需要记住从字符串开头修剪多余的空格。
- en: Large, repetitive concatenation routines can be replaced by native PHP functions
    like `implode()`. This function in particular accepts an array of data to be joined
    and a definition of the character (or characters) to be used between data elements.
    It returns the final, concatenated string.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 大型重复的连接例程可以被本机PHP函数如`implode()`所取代。特别是此函数接受要连接的数据数组以及要在数据元素之间使用的字符（或字符）的定义。它返回最终的连接字符串。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Some developers prefer to use `join()` instead of `implode()` as it’s seen to
    be a more descriptive name for the operation. The fact is, `join()` is an alias
    of `implode()`, and the PHP compiler doesn’t care which you use.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有些开发者更喜欢使用`join()`而不是`implode()`，因为它被认为是操作的更描述性名称。事实上，`join()`是`implode()`的别名，PHP编译器不关心您使用哪个。
- en: Rewriting [Example 4-20](#string_concatenation_verbose) to use `implode()` makes
    the entire operation much simpler, as demonstrated by [Example 4-21](#string_concatenation_terse).
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写[示例4-20](#string_concatenation_verbose)以使用`implode()`使整个操作变得简单得多，正如[示例4-21](#string_concatenation_terse)所示。
- en: Example 4-21\. A concise approach to string concatenation
  id: totrans-229
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-21\. 字符串连接的简洁方法
- en: '[PRE27]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Take care to remember the parameter order for `implode()`. The string separator
    comes *first*, followed by the array over which you want to iterate. Earlier versions
    of PHP (prior to version 8.0) allowed the parameters to be specified in the opposite
    order. This behavior (specifying the array first and the separator second) was
    deprecated in PHP 7.4\. As of PHP 8.0, this will throw a `TypeError`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意记住`implode()`的参数顺序。字符串分隔符首先出现，然后是您想要迭代的数组。PHP的早期版本（PHP 8.0之前）允许参数以相反的顺序指定。在PHP
    7.4中，此行为（先指定数组，然后是分隔符）已弃用。从PHP 8.0开始，这将引发`TypeError`。
- en: If you’re using a library written prior to PHP 8.0, be sure you test that it’s
    not misusing either `implode()` or `join()` before you ship your project to production.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用PHP 8.0之前编写的库，请确保在将项目部署到生产环境之前测试它没有错误使用`implode()`或`join()`。
- en: See Also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`implode()`](https://oreil.ly/bGYt0).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档关于[`implode()`](https://oreil.ly/bGYt0)。
- en: 4.8 Managing Binary Data Stored in Strings
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.8 管理存储在字符串中的二进制数据
- en: Problem
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to encode data directly as binary rather than as an ASCII-formatted
    representation, or you want to read data into your application that was explicitly
    encoded as binary data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望直接将数据编码为二进制，而不是作为ASCII格式的表示，或者您希望读取作为二进制数据明确编码的数据到您的应用程序中。
- en: Solution
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use `unpack()` to extract binary data from a string:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unpack()`从字符串中提取二进制数据：
- en: '[PRE28]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use `pack()` to write binary data to a string:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pack()`将二进制数据写入字符串：
- en: '[PRE29]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Both `pack()` and `unpack()` empower you to operate on raw binary strings, assuming
    you know the format of the binary string you’re working with. The first parameter
    of each function is a format specification. This specification is determined by
    specific format codes, as defined in [Table 4-2](#binary_format_codes).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`pack()`和`unpack()`都使您能够操作原始二进制字符串，假设您知道您正在使用的二进制字符串的格式。每个函数的第一个参数是格式规范。此规范由特定的格式代码确定，如[表4-2](#binary_format_codes)中定义的。'
- en: Table 4-2\. Binary format string codes
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-2\. 二进制格式字符串代码
- en: '| Code | Description |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 代码 | 描述 |'
- en: '| --- | --- |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `a` | Null-padded string |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 以空字符填充的字符串 |'
- en: '| `A` | Space-padded string |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `A` | 以空格填充的字符串 |'
- en: '| `h` | Hex string, low nibble first |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 十六进制字符串，低半字节优先 |'
- en: '| `H` | Hex string, high nibble first |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 十六进制字符串，高半字节优先 |'
- en: '| `c` | Signed char |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 有符号字符 |'
- en: '| `C` | Unsigned char |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `C` | 无符号字符 |'
- en: '| `s` | Signed short (always 16-bit, machine byte order) |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 有符号短整型（始终为16位，机器字节顺序）'
- en: '| `S` | Unsigned short (always 16-bit, machine byte order) |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `S` | 无符号短整型（始终为16位，机器字节顺序）'
- en: '| `n` | Unsigned short (always 16-bit, big-endian byte order) |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 无符号短整型（始终为16位，大端字节顺序）'
- en: '| `v` | Unsigned short (always 16-bit, little-endian byte order) |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `v` | 无符号短整型（始终为16位，小端字节顺序）'
- en: '| `i` | Signed integer (machine-dependent size and byte order) |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `i` | 有符号整型（机器相关大小和字节顺序）'
- en: '| `I` | Unsigned integer (machine-dependent size and byte order) |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `I` | 无符号整型（机器相关大小和字节顺序）'
- en: '| `l` | Signed long (always 32-bit, machine byte order) |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 有符号长整型（始终为32位，机器字节顺序）'
- en: '| `L` | Unsigned long (always 32-bit, machine byte order) |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `L` | 无符号长整型（始终为32位，机器字节顺序）'
- en: '| `N` | Unsigned long (always 32-bit, big-endian byte order) |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 无符号长整型（始终为32位，大端字节顺序）'
- en: '| `V` | Unsigned long (always 32-bit, little-endian byte order) |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `V` | 无符号长整型（始终为32位，小端字节顺序）'
- en: '| `q` | Signed long long (always 64-bit, machine byte order) |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| `q` | 有符号长长整型（始终为64位，机器字节顺序）'
- en: '| `Q` | Unsigned long long (always 64-bit, machine byte order) |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| `Q` | 无符号长长整型（始终为64位，机器字节顺序）'
- en: '| `J` | Unsigned long long (always 64-bit, big-endian byte order) |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| `J` | 无符号长长整型（始终为64位，大端字节顺序）'
- en: '| `P` | Unsigned long long (always 64-bit, little-endian byte order) |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| `P` | 无符号长长整型（始终为64位，小端字节顺序）'
- en: '| `f` | Float (machine-dependent size and representation) |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 浮点数（机器相关大小和表示）'
- en: '| `g` | Float (machine-dependent size, little-endian byte order) |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 浮点数（机器相关大小，小端字节顺序）'
- en: '| `G` | Float (machine-dependent size, big-endian byte order) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `G` | 浮点数（机器相关大小，大端字节顺序）'
- en: '| `d` | Double (machine-dependent size and representation) |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 双精度浮点数（机器相关大小和表示）'
- en: '| `e` | Double (machine-dependent size, little-endian byte order) |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `e` | 双精度浮点数（机器相关大小，小端字节顺序）'
- en: '| `E` | Double (machine-dependent size, big-endian byte order) |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `E` | 双精度浮点数（机器相关大小，大端字节顺序）'
- en: '| `x` | Null byte |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 空字节'
- en: '| `X` | Back up one byte |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 向后移动一个字节'
- en: '| `Z` | Null-padded string |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| `Z` | 空字节填充字符串'
- en: '| `@` | Null-fill to absolute position |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `@` | 到绝对位置的空字节填充'
- en: 'When defining a format string, you can specify each byte type individually
    or leverage an optional repeating character. In the Solution examples, the number
    of bytes is explicitly specified with an integer. You could just as easily use
    an asterisk (`*`) to specify that a type of byte repeats through the end of the
    string as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义格式字符串时，可以单独指定每个字节类型，或者利用可选的重复字符。在解决方案示例中，通过整数明确指定字节数。您也可以轻松地使用星号（`*`）来指定字节类型重复到字符串末尾，如下所示：
- en: '[PRE30]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: PHP’s ability to convert between byte encoding types via `unpack()` also provides
    a simple method of converting ASCII characters to and from their binary equivalent.
    The `ord()` function will return the value of a specific character, but it requires
    looping over each character in a string if you want to unpack each in turn, as
    demonstrated in [Example 4-22](#character_encoding_with_ord).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: PHP通过`unpack()`能够简单地在不同的字节编码类型之间进行转换，也提供了一种将ASCII字符与它们的二进制等效物进行转换的简单方法。`ord()`函数将返回特定字符的值，但如果要依次解包每个字符，则需要循环遍历字符串，正如在[示例 4-22](#character_encoding_with_ord)中演示的那样。
- en: Example 4-22\. Retrieving character values with `ord()`
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例4-22\. 使用`ord()`检索字符值
- en: '[PRE31]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Thanks to `unpack()`, you don’t need to explicitly iterate over the characters
    in a string. The `c` format character references a signed character, and `C` a
    signed one. Rather than building a loop, you can leverage `unpack()` directly
    as follows to get an equivalent result:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`unpack()`的帮助，您不需要显式地迭代字符串中的每个字符。`c`格式字符引用有符号字符，`C`引用无符号字符。您可以直接利用`unpack()`来获得等效结果，而无需构建循环，如下所示：
- en: '[PRE32]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Both the preceding `unpack()` example and the original loop implementation
    in [Example 4-22](#character_encoding_with_ord) produce the following array:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 先前的`unpack()`示例以及[示例 4-22](#character_encoding_with_ord)中的原始循环实现都产生以下数组：
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: See Also
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: PHP documentation on [`pack()`](https://oreil.ly/0iieT) and [`unpack()`](https://oreil.ly/Un_aD).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: PHP文档关于[`pack()`](https://oreil.ly/0iieT)和[`unpack()`](https://oreil.ly/Un_aD)。
- en: ^([1](ch04.html#idm45875185433888-marker)) This string is a byte representation,
    formatted in octal notation, of “Hello World!”
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#idm45875185433888-marker)) 此字符串是“Hello World!”的八进制表示形式的字节表示。
- en: ^([2](ch04.html#idm45875190506912-marker)) Review [Table 4-1](#string_escape_sequences)
    for more on double-character escape sequences.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#idm45875190506912-marker)) 详见[表 4-1](#string_escape_sequences)了解更多双字符转义序列。
