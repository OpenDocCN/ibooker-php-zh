- en: Chapter 6\. PHP Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章\. PHP数组
- en: In [Chapter 3](ch03.xhtml#introduction_to_php), I gave a very brief introduction
    to PHP’s arrays—just enough for a little taste of their power. In this chapter,
    I’ll show you many more things that you can do with arrays, some of which—if you
    have ever used a strongly typed language such as C—may surprise you with their
    elegance and simplicity.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.xhtml#introduction_to_php)中，我对PHP数组进行了非常简要的介绍——仅仅足够让你略知一二它们的强大。在本章中，我将向你展示更多可以用数组做的事情，其中一些——如果你曾经使用过像C这样的强类型语言——可能会因其优雅和简洁而让你感到惊讶。
- en: Not only do arrays remove the tedium of writing code to deal with complicated
    data structures, but they also provide numerous ways to access data while remaining
    amazingly fast.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数组不仅消除了编写处理复杂数据结构的代码的枯燥感，而且提供了许多访问数据的方式，同时保持惊人的快速性。
- en: Basic Access
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本访问
- en: We’ve already looked at arrays as if they were clusters of matchboxes glued
    together. Another way to think of an array is like a string of beads, with the
    beads representing variables that can be numbers, strings, or even other arrays.
    They are like bead strings because each element has its own location and (with
    the exception of the first and last ones) each has other elements on either side.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过数组，就好像它们是粘在一起的火柴盒群。另一种思考数组的方法是把它看作是一串珠子，每个珠子代表一个可以是数字、字符串或甚至其他数组的变量。它们像珠串一样，因为每个元素都有自己的位置，并且（除了第一个和最后一个）每个元素两侧都有其他元素。
- en: Some arrays are referenced by numeric indexes; others allow alphanumeric identifiers.
    Built-in functions let you sort them, add or remove sections, and walk through
    them to handle each item through a special kind of loop. And by placing one or
    more arrays inside another, you can create arrays of two, three, or any number
    of dimensions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有些数组通过数字索引进行引用；其他允许使用字母数字标识符。内置函数允许你对它们进行排序、添加或移除部分，并通过一种特殊的循环来遍历它们处理每个项目。通过在另一个数组内放置一个或多个数组，你可以创建二维、三维或任意维数的数组。
- en: Numerically Indexed Arrays
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字索引数组
- en: Let’s assume that you’ve been tasked with creating a simple website for a local
    office supply company and you’re currently working on the section devoted to paper.
    One way to manage the various items of stock in this category would be to place
    them in a numeric array. You can see the simplest way of doing so in [Example 6-1](#adding_items_to_an_array).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你被委托为当地一家办公用品公司创建一个简单的网站，目前正在处理与纸张相关的部分。管理该类别库存中各种物品的一种方式是将它们放入一个数字数组中。你可以在[例子6-1](#adding_items_to_an_array)中看到最简单的做法。
- en: Example 6-1\. Adding items to an array
  id: totrans-8
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子6-1\. 向数组添加项目
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In this example, each time you assign a value to the array `$paper`, the first
    empty location within that array is used to store the value, and a pointer internal
    to PHP is incremented to point to the next free location, ready for future insertions.
    The familiar `print_r` function (which prints out the contents of a variable,
    array, or object) is used to verify that the array has been correctly populated.
    It prints out the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每当你给数组`$paper`赋值时，都会使用该数组内的第一个空位置来存储值，并且PHP内部的指针会递增指向下一个空位置，为将来的插入做准备。熟悉的`print_r`函数（用于打印变量、数组或对象的内容）用于验证数组是否已正确填充。它打印出以下内容：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous code could also have been written as shown in [Example 6-2](#adding_items_to_an_array_using_explicit),
    where the exact location of each item within the array is specified. But, as you
    can see, that approach requires extra typing and makes your code harder to maintain
    if you want to insert supplies into or remove them from the array. So, unless
    you wish to specify a different order, it’s usually better to simply let PHP handle
    the actual location numbers.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码也可以像在[例子6-2](#adding_items_to_an_array_using_explicit)中展示的那样书写，其中指定了数组中每个项目的确切位置。但是，正如你所看到的，这种方法需要额外的输入，并且如果你想要在数组中插入或删除项目，会使得你的代码更难维护。所以，除非你希望指定不同的顺序，通常最好让PHP处理实际的位置编号。
- en: Example 6-2\. Adding items to an array using explicit locations
  id: totrans-13
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子6-2\. 使用显式位置向数组添加项目
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The output from these examples is identical, but you are not likely to use `print_r`
    in a developed website, so [Example 6-3](#adding_items_to_an_array_and_retrieving)
    shows how you might print out the various types of paper the website offers using
    a `for` loop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些例子的输出是相同的，但在开发网站时你不太可能使用`print_r`，所以[例子6-3](#adding_items_to_an_array_and_retrieving)展示了如何使用`for`循环打印出网站提供的各种类型的纸张。
- en: Example 6-3\. Adding items to an array and retrieving them
  id: totrans-16
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 向数组添加项目并检索它们
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This example prints out the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例打印出以下内容：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So far, you’ve seen a couple of ways in which you can add items to an array
    and one way of referencing them. PHP offers many more, which I’ll get to shortly.
    But first, we’ll look at another type of array.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到了几种向数组添加项目和引用它们的方式。PHP还提供了更多方法，稍后会详细介绍。但首先，我们将看看另一种类型的数组。
- en: Associative Arrays
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联数组
- en: Keeping track of array elements by index works just fine but can require extra
    work in terms of remembering which number refers to which product. It can also
    make code hard for other programmers to follow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过索引跟踪数组元素可以很好地工作，但可能需要额外的工作来记住哪个数字指代哪个产品。这也可能使得其他程序员难以理解代码。
- en: This is where associative arrays come into their own. Using them, you can reference
    the items in an array by name rather than by number. [Example 6-4](#adding_items_to_an_associative_array_and)
    expands on the previous code by giving each element in the array an identifying
    name and a longer, more explanatory string value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关联数组发挥作用的地方。使用它们，您可以通过名称而不是数字引用数组中的项目。[示例 6-4](#adding_items_to_an_associative_array_and)扩展了先前的代码，为数组中的每个元素赋予了一个标识名称和一个更长、更详细的字符串值。
- en: Example 6-4\. Adding items to an associative array and retrieving them
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. 向关联数组添加项目并检索它们
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In place of a number (which doesn’t convey any useful information, aside from
    the position of the item in the array), each item now has a unique name that you
    can use to reference it elsewhere, as with the `echo` statement—which simply prints
    out `Laser Printer`. The names (`copier`, `inkjet`, and so on) are called *indexes*
    or *keys*, and the items assigned to them (such as `Laser Printer`) are called
    *values*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每个项目都有一个您可以在其他地方引用的唯一名称，例如 `echo` 语句—它仅仅打印出 `激光打印机`。这些名称（如 `复印机`、`喷墨打印机`
    等）称为*索引*或*键*，而分配给它们的项目（如 `激光打印机`）称为*值*。
- en: 'This very powerful feature of PHP is often used when you are extracting information
    from XML and HTML. For example, an HTML parser such as those used by a search
    engine could place all the elements of a web page into an associative array whose
    names reflect the page’s structure:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: PHP 的这一强大功能经常用于从 XML 和 HTML 中提取信息。例如，像搜索引擎使用的 HTML 解析器可以将网页的所有元素放入一个关联数组中，其名称反映了页面的结构：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The program would also probably break down all the links found within a page
    into another array, and all the headings and subheadings into another. When you
    use associative rather than numeric arrays, the code to refer to all of these
    items is easy to write and debug.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序还可能会将页面中找到的所有链接分解为另一个数组，并将所有标题和副标题分解为另一个数组。当您使用关联数组而不是数值数组时，引用所有这些项的代码变得易于编写和调试。
- en: Assignment Using the array Keyword
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `array` 关键字进行赋值
- en: So far, you’ve seen how to assign values to arrays by just adding new items
    one at a time. Whether you specify keys, specify numeric identifiers, or let PHP
    assign numeric identifiers implicitly, this is a long-winded approach. A more
    compact and faster assignment method uses the `array` keyword. [Example 6-5](#adding_items_to_an_array_using_the_array)
    shows both a numeric and an associative array assigned using this method.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何通过逐个添加新项目来向数组赋值。无论你指定键、指定数字标识符还是让 PHP 隐式分配数字标识符，这都是一种冗长的方法。使用
    `array` 关键字，有一种更紧凑和更快速的赋值方法。[示例 6-5](#adding_items_to_an_array_using_the_array)展示了使用这种方法分配的数字和关联数组。
- en: Example 6-5\. Adding items to an array using the `array` keyword
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. 使用 `array` 关键字向数组添加项目
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The first half of this snippet assigns the old, shortened product descriptions
    to the array `$p1`. There are four items, so they will occupy slots 0 through
    3\. Therefore, the `echo` statement prints out the following:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此片段的前半部分将旧的、简短的产品描述分配给数组 `$p1`。有四个项目，因此它们将占据0到3的位置。因此，`echo` 语句打印出以下内容：
- en: '**`    p1 element: Laser`**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    p1 元素：激光`**'
- en: 'The second half assigns associative identifiers and accompanying longer product
    descriptions to the array `$p2` using the format *`key`* `=>` *`value`*. The use
    of `=>` is similar to the regular `=` assignment operator, except that you are
    assigning a value to an *index* and not to a *variable*. The index is then inextricably
    linked with that value, unless it is assigned a new value. The `echo` command
    therefore prints out this:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分使用格式*`key`* `=>` *`value`* 将关联标识符和伴随的较长产品描述分配给数组`$p2`。`=>`的使用类似于常规的`=`赋值运算符，不同之处在于你正在为*索引*而不是*变量*赋值。索引因此与该值紧密联系，除非它被赋予新值。因此，`echo`命令打印出以下内容：
- en: '**`    p2 element: Inkjet Printer`**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    p2 元素: 墨水喷墨打印机`**'
- en: 'You can verify that `$p1` and `$p2` are different types of array, because both
    of the following commands, when appended to the code, will cause an `Undefined
    index` or `Undefined offset` error, as the array identifier for each is incorrect:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以验证`$p1`和`$p2`是不同类型的数组，因为将以下两个命令附加到代码后，都会导致`Undefined index`或`Undefined offset`错误，因为每个数组标识符都不正确：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The foreach...as Loop
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`foreach...as`循环'
- en: 'The creators of PHP have gone to great lengths to make the language easy to
    use. So, not content with the loop structures already provided, they added another
    one especially for arrays: the `foreach...as` loop. Using it, you can step through
    all the items in an array, one at a time, and do something with them.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: PHP的创建者为了使语言易于使用，做出了很大努力。因此，他们不满足于已经提供的循环结构，特别为数组添加了另一个循环：`foreach...as`循环。使用它，你可以逐个遍历数组中的所有项，并对它们进行操作。
- en: The process starts with the first item and ends with the last one, so you don’t
    even have to know how many items there are in an array. [Example 6-6](#walking_through_a_numeric_array_using_fo)
    shows how `foreach...as` can be used to rewrite [Example 6-3](#adding_items_to_an_array_and_retrieving).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程从第一项开始，直到最后一项结束，因此你甚至不需要知道数组中有多少项。[示例 6-6](#walking_through_a_numeric_array_using_fo)展示了如何使用`foreach...as`重写[示例
    6-3](#adding_items_to_an_array_and_retrieving)。
- en: Example 6-6\. Walking through a numeric array using `foreach...as`
  id: totrans-43
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 使用`foreach...as`遍历数值数组
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When PHP encounters a `foreach` statement, it takes the first item of the array
    and places it in the variable following the `as` keyword; and each time control
    flow returns to the `foreach`, the next array element is placed in the `as` keyword.
    In this case, the variable `$item` is set to each of the four values in turn in
    the array `$paper`. Once all values have been used, execution of the loop ends.
    The output from this code is exactly the same as in [Example 6-3](#adding_items_to_an_array_and_retrieving).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当PHP遇到`foreach`语句时，它将数组的第一个项放入跟随`as`关键字的变量中；每次控制流返回到`foreach`时，下一个数组元素将被放入`as`关键字中。在这种情况下，变量`$item`依次设置为数组`$paper`中的每个值。一旦所有值都被使用，循环的执行结束。这段代码的输出与[示例
    6-3](#adding_items_to_an_array_and_retrieving)完全相同。
- en: Now let’s see how `foreach` works with an associative array by taking a look
    at [Example 6-7](#walking_through_an_associative_array_usi), which is a rewrite
    of the second half of [Example 6-5](#adding_items_to_an_array_using_the_array).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何通过查看[示例 6-7](#walking_through_an_associative_array_usi)，了解`foreach`如何与关联数组一起使用，这是[示例
    6-5](#adding_items_to_an_array_using_the_array)的后半部分重写。
- en: Example 6-7\. Walking through an associative array using `foreach...a`s
  id: totrans-47
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-7\. 使用`foreach...a`s遍历关联数组
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Remember that associative arrays do not require numeric indexes, so the variable
    `$j` is not used in this example. Instead, each item of the array `$paper` is
    fed into the key/value pair of variables `$item` and `$description`, from which
    they are printed out. The displayed result of this code is as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，关联数组不需要数值索引，因此在此示例中未使用变量`$j`。相反，数组`$paper`的每个项被传递到变量`$item`和`$description`的键/值对中，从中打印出它们。该代码的显示结果如下：
- en: '**`    copier: Copier & Multipurpose     inkjet: Inkjet Printer     laser:
    Laser Printer     photo: Photographic Paper`**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    复印机: 复印机和多用途     墨水喷墨: 墨水喷墨打印机     激光: 激光打印机     照片: 摄影纸`**'
- en: Prior to version 7.2 of PHP, as an alternative syntax to `foreach...as`, you
    could use the `list` function in conjunction with the `each` function. However,
    `each` was then deprecated and therefore is not recommended for use because it
    may be removed in a future version. This is a bit of a nightmare for PHP programmers
    with legacy code to update, especially as the `each` function is extremely useful.
    Therefore, I have written a replacement for `each` called `myEach`, which works
    identically and will allow you to easily update old code, as in [Example 6-8](#walking_through_an_associative_a-id00016).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在PHP 7.2版本之前，作为`foreach...as`的替代语法，您可以将`list`函数与`each`函数结合使用。然而，`each`随后被弃用，因此不建议使用，因为它可能会在未来的版本中删除。对于需要更新的PHP程序员来说，这是一场噩梦，尤其是`each`函数非常有用。因此，我编写了一个名为`myEach`的替代品，它的功能与`each`完全相同，并且允许您轻松更新旧代码，如[示例 6-8](#walking_through_an_associative_a-id00016)。
- en: Example 6-8\. Walking through an associative array using `myEach` and `list`
  id: totrans-52
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-8\. 使用`myEach`和`list`遍历关联数组
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, a `while` loop is set up and will continue looping until the
    `myEach` function (equivalent to the old PHP `each` function) returns a value
    of `FALSE`. The `myEach` function acts like `foreach` in that it returns an array
    containing a key/value pair from the array `$paper` and then moves its built-in
    pointer to the next pair in that array. When there are no more pairs to return,
    `myEach` returns `FALSE`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，设置了一个`while`循环，并且将继续循环，直到`myEach`函数（等同于旧版PHP的`each`函数）返回`FALSE`为止。`myEach`函数类似于`foreach`，它返回一个包含数组`$paper`中的键/值对的数组，然后将其内置指针移动到该数组中的下一个对。当没有更多的对要返回时，`myEach`返回`FALSE`。
- en: The `list` function takes an array as its argument (in this case, the key/value
    pair returned by the function `myEach`) and then assigns the values of the array
    to the variables listed within parentheses.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`函数接受一个数组作为其参数（在本例中，是函数`myEach`返回的键/值对），然后将数组的值分配给括号内列出的变量。'
- en: You can see how `list` works a little more clearly in [Example 6-9](#using_the_list_function),
    where an array is created out of the two strings `Alice` and `Bob` and then passed
    to the `list` function, which assigns those strings as values to the variables
    `$a` and `$b`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 6-9](#using_the_list_function)中，您可以更清楚地看到`list`函数的工作原理，其中一个数组由两个字符串`Alice`和`Bob`创建，然后传递给`list`函数，该函数将这些字符串分配为变量`$a`和`$b`的值。
- en: Example 6-9\. Using the `list` function
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. 使用`list`函数
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output from this code is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的输出如下所示：
- en: '**`    a=Alice b=Bob`**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**`    a=Alice b=Bob`**'
- en: So, you can take your pick when walking through arrays. Use `foreach...as` to
    create a loop that extracts values to the variable following the `as`, or use
    the `myEach` function and create your own looping system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在处理数组时，您可以根据需要选择。使用`foreach...as`创建一个循环，将值提取到`as`后面的变量中，或者使用`myEach`函数创建自己的循环系统。
- en: Multidimensional Arrays
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维数组
- en: A simple design feature in PHP’s array syntax makes it possible to create arrays
    of more than one dimension. In fact, they can be as many dimensions as you like
    (although it’s a rare application that goes further than three).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: PHP数组语法中的一个简单设计特性使得可以创建多维数组。事实上，它们可以是任意多维（尽管很少有应用程序会超过三维）。
- en: 'That feature is the ability to include an entire array as a part of another
    one, and to be able to keep doing so, just like the old rhyme: “Big fleas have
    little fleas upon their backs to bite ’em. Little fleas have lesser fleas, add
    flea, ad infinitum.”'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性是将整个数组作为另一个数组的一部分包含进来，并且可以继续这样做，就像那首古老的韵文：“大跳蚤背上有小跳蚤来咬它们。小跳蚤有更小的跳蚤，继续蚤类，无穷尽。”
- en: Let’s look at how this works by taking the associative array in the previous
    example and extending it; see [Example 6-10](#creating_a_multidimensional_associative).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过扩展前面示例中的关联数组来看看它是如何工作的；参见[示例 6-10](#creating_a_multidimensional_associative)。
- en: Example 6-10\. Creating a multidimensional associative array
  id: totrans-66
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. 创建一个多维关联数组
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To make things clearer now that the code is starting to grow, I’ve renamed some
    of the elements. For example, because the previous array `$paper` is now just
    a subsection of a larger array, the main array is now called `$products`. Within
    this array, there are three items—`paper`, `pens`, and `misc`—each of which contains
    another array with key/value pairs.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码开始增长，为了使事情更清晰，我已经重新命名了一些元素。例如，因为前面的数组`$paper`现在只是更大数组的一个子部分，所以主数组现在称为`$products`。在这个数组内部，有三个条目——`paper`、`pens`和`misc`——每个条目都包含另一个带有键/值对的数组。
- en: If necessary, these subarrays could have contained even further arrays. For
    example, under `ball` there might be many different types and colors of ballpoint
    pens available in the online store. But for now, I’ve restricted the code to a
    depth of just two.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必要的话，这些子数组可能还包含更进一步的数组。例如，在 `ball` 下面可能有许多不同类型和颜色的圆珠笔可以在在线商店中获取。但是现在，我将代码限制在了只有两层的深度。
- en: Once the array data has been assigned, I use a pair of nested `foreach...as`
    loops to print out the various values. The outer loop extracts the main sections
    from the top level of the array, and the inner loop extracts the key/value pairs
    for the categories within each section.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数组数据被赋值，我使用一对嵌套的 `foreach...as` 循环来打印出各种值。外部循环从数组的顶层提取主要部分，内部循环提取每个部分内的键/值对。
- en: As long as you remember that each level of the array works the same way (it’s
    a key/value pair), you can easily write code to access any element at any level.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 只要记住每个数组级别都以相同方式工作（它是一个键/值对），你可以轻松编写代码来访问任何级别的任何元素。
- en: 'The `echo` statement makes use of the PHP escape character `\t`, which outputs
    a tab. Although tabs are not normally significant to the web browser, I let them
    be used for layout by using the `<pre>...</pre>` tags, which tell the web browser
    to format the text as preformatted and monospaced, and *not* to ignore whitespace
    characters such as tabs and line feeds. The output from this code looks like the
    following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`echo` 语句利用 PHP 转义字符 `\t` 输出制表符。尽管制表符通常对网页浏览器来说不重要，但我让它们被 `<pre>...</pre>`
    标签使用，这告诉浏览器将文本格式化为预格式化和等宽字体，并且 *不* 忽略空白字符如制表符和换行符。从这段代码的输出看起来，如下所示：'
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can directly access a particular element of the array by using square brackets:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用方括号直接访问数组的特定元素。
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This outputs the value `Adhesives`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这输出值为 `胶粘剂`。
- en: You can also create numeric multidimensional arrays that are accessed directly
    by indexes rather than by alphanumeric identifiers. [Example 6-11](#creating_a_multidimensional_numeric_arra)
    creates the board for a chess game with the pieces in their starting positions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建数值型多维数组，通过索引而不是通过字母数字标识符进行访问。[示例 6-11](#creating_a_multidimensional_numeric_arra)
    创建了一个象棋游戏的棋盘，其中各个棋子处于起始位置。
- en: Example 6-11\. Creating a multidimensional numeric array
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11\. 创建一个多维数值数组
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this example, the lowercase letters represent black pieces, and the uppercase
    white. The key is `r` = rook, `n` = knight, `b` = bishop, `k` = king, `q` = queen,
    and `p` = pawn. Again, a pair of nested `foreach...as` loops walks through the
    array and displays its contents. The outer loop processes each row into the variable
    `$row`, which itself is an array, because the `$chessboard` array uses a subarray
    for each row. This loop has two statements within it, so curly braces enclose
    them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，小写字母表示黑色棋子，大写字母表示白色棋子。键为 `r` = 车，`n` = 马，`b` = 象，`k` = 王，`q` = 后，`p`
    = 兵。同样，一对嵌套的 `foreach...as` 循环遍历数组并显示其内容。外部循环将每一行处理为变量 `$row`，它本身是一个数组，因为 `$chessboard`
    数组为每一行使用一个子数组。这个循环内有两条语句，所以用大括号将它们括起来。
- en: 'The inner loop then processes each square in a row, outputting the character
    (`$piece`) stored in it, followed by a space (to square up the printout). This
    loop has a single statement, so curly braces are not required to enclose it. The
    `<pre>` and `</pre>` tags ensure that the output displays correctly, like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后内部循环处理每行中的每个方块，输出存储在其中的字符（`$piece`），后跟一个空格（以使打印输出更加整齐）。这个循环只有一条语句，所以不需要用大括号将其括起来。`<pre>`
    和 `</pre>` 标签确保输出正确显示，如下所示：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also directly access any element within this array by using square
    brackets:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用方括号直接访问这个数组中的任何元素。
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This statement outputs the uppercase letter `Q`, the eighth element down and
    the fourth along (remember that array indexes start at 0, not 1).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句输出大写字母 `Q`，在第八行向下和第四列向右的位置（请记住数组索引从 0 开始，不是从 1 开始）。
- en: Using Array Functions
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组函数
- en: You’ve already seen the `list` and `each` functions, but PHP comes with numerous
    other functions for handling arrays. You can find the full list in the [documentation](https://tinyurl.com/arraysinphp).
    However, some of these functions are so fundamental that it’s worth taking the
    time to look at them here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 `list` 和 `each` 函数，但是 PHP 还配备了许多其他处理数组的函数。你可以在[文档](https://tinyurl.com/arraysinphp)中找到完整的列表。然而，其中一些函数非常基础，值得花时间在这里仔细研究它们。
- en: is_array
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: is_array
- en: 'Arrays and variables share the same namespace. This means that you cannot have
    a string variable called `$fred` and an array also called `$fred`. If you’re in
    doubt and your code needs to check whether a variable is an array, you can use
    the `is_array` function, like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 数组和变量共享相同的命名空间。这意味着你不能同时有一个名为 `$fred` 的字符串变量和一个名为 `$fred` 的数组。如果你不确定并且你的代码需要检查一个变量是否是数组，你可以使用
    `is_array` 函数，如下所示：
- en: '[PRE19]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that if `$fred` has not yet been assigned a value, an `Undefined variable`
    message will be generated.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果 `$fred` 还没有被赋值，将生成一个 `Undefined variable` 的消息。
- en: count
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: count
- en: 'Although the `each` function and `foreach...as` loop structure are excellent
    ways to walk through an array’s contents, sometimes you need to know exactly how
    many elements there are in your array, particularly if you will be referencing
    them directly. To count all the elements in the top level of an array, use a command
    such as this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `each` 函数和 `foreach...as` 循环结构是遍历数组内容的优秀方式，但有时你确实需要知道数组中有多少元素，特别是如果你将直接引用它们的话。要计算顶层数组中的所有元素数，使用如下命令：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Should you wish to know how many elements there are altogether in a multidimensional
    array, you can use a statement such as the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道多维数组中总共有多少元素，可以使用如下语句：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The second parameter is optional and sets the mode to use. It should be either
    `0` to limit counting to only the top level or `1` to force recursive counting
    of all subarray elements too.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是可选的，设置要使用的模式。它应该是 `0` 以限制仅计算顶层，或者 `1` 以强制递归计算所有子数组元素。
- en: sort
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序
- en: 'Sorting is so common that PHP provides a built-in function for it. In its simplest
    form, you would use it like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 排序是如此常见，PHP 为此提供了一个内置函数。在其最简单的形式中，你可以像这样使用它：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is important to remember that, unlike some other functions, `sort` will
    act directly on the supplied array rather than returning a new array of sorted
    elements. It returns `TRUE` on success and `FALSE` on error and also supports
    a few flags—the main two flags that you might wish to use force items to be sorted
    either numerically or as strings, like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的是，与其他一些函数不同，`sort` 会直接对提供的数组进行操作，而不是返回已排序元素的新数组。它在成功时返回 `TRUE`，在出错时返回 `FALSE`，并且还支持一些标志——你可能希望使用的主要两个标志，强制按数字或字符串对项目进行排序，如下所示：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can also sort an array in reverse order using the `rsort` function, like
    this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `rsort` 函数按照反向顺序对数组进行排序，如下所示：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: shuffle
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 洗牌
- en: 'There may be times when you need the elements of an array to be put in random
    order, such as when you’re creating a game of playing cards:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你可能需要将数组的元素随机排序，比如在创建一副扑克牌游戏时：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Like `sort`, `shuffle` acts directly on the supplied array and returns `TRUE`
    on success or `FALSE` on error.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `sort` 类似，`shuffle` 直接作用于提供的数组，并在成功时返回 `TRUE`，在出错时返回 `FALSE`。
- en: explode
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: explode
- en: '`explode` is a very useful function with which you can take a string containing
    several items separated by a single character (or string of characters) and then
    place each of these items into an array. One handy example is to split up a sentence
    into an array containing all its words, as in [Example 6-12](#exploding_a_string_into_an_array_using_s).'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`explode` 是一个非常有用的函数，你可以用它将包含多个由单个字符（或字符串）分隔的项目的字符串转换成一个数组。一个方便的例子是将句子拆分成一个包含所有单词的数组，如
    [示例 6-12](#exploding_a_string_into_an_array_using_s) 所示。'
- en: Example 6-12\. Exploding a string into an array using spaces
  id: totrans-111
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-12\. 使用空格将字符串分割成数组
- en: '[PRE26]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This example prints out the following (on a single line when viewed in a browser):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在浏览器中打印出以下内容（单行显示）：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first parameter, the delimiter, need not be a space or even a single character.
    [Example 6-13](#exploding_a_string_delimited_with_asteri) shows a slight variation.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数，分隔符，不一定是空格，甚至不一定是单个字符。[示例 6-13](#exploding_a_string_delimited_with_asteri)
    展示了一个略有不同的变体。
- en: Example 6-13\. Exploding a string delimited with `***` into an array
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-13\. 将用 `***` 分隔的字符串分割成数组
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The code in [Example 6-13](#exploding_a_string_delimited_with_asteri) prints
    out the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-13](#exploding_a_string_delimited_with_asteri) 中的代码将打印出以下内容：'
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: extract
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: extract
- en: Sometimes it can be convenient to turn the key/value pairs from an array into
    PHP variables. One such time might be when you are processing the `$_GET` or `$_POST`
    variables sent to a PHP script by a form.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候将数组中的键/值对转换为 PHP 变量可能会很方便。一个这样的时机可能是当你处理由表单发送到 PHP 脚本的 `$_GET` 或 `$_POST`
    变量时。
- en: When a form is submitted over the web, the web server unpacks the variables
    into a global array for the PHP script. If the variables were sent using the GET
    method, they will be placed in an associative array called `$_GET`; if they were
    sent using POST, they will be placed in an associative array called `$_POST`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过网络提交表单时，Web 服务器将变量解包到 PHP 脚本的全局数组中。如果使用 GET 方法发送变量，则会放入一个名为`$_GET`的关联数组；如果使用
    POST 发送，则会放入一个名为`$_POST`的关联数组。
- en: 'You could, of course, walk through such associative arrays in the manner shown
    in the examples so far. However, sometimes you just want to store the values sent
    into variables for later use. In this case, you can have PHP do the job automatically:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以按照迄今为止的示例中所示的方式遍历这样的关联数组。但是，有时您只想将发送的值存储到变量中以供以后使用。在这种情况下，您可以让 PHP 自动执行这项工作：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, if the query string parameter `q` is sent to a PHP script along with the
    associated value `Hi there`, a new variable called `$q` will be created and assigned
    that value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果将查询字符串参数`q`发送到 PHP 脚本以及相关联的值`Hi there`，将创建一个名为`$q`的新变量，并为其分配该值。
- en: 'Be careful with this approach, though, because if any extracted variables conflict
    with ones that you have already defined, your existing values will be overwritten.
    To avoid this possibility, you can use one of the many additional parameters available
    to this function, like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法很有用，但要小心，因为如果提取的任何变量与您已经定义的变量冲突，您现有的值将被覆盖。为了避免这种可能性，您可以使用该函数提供的许多附加参数之一，就像这样：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, all the new variables will begin with the given prefix string
    followed by an underscore, so `$q` will become `$fromget_q`. I strongly recommend
    that you use this version of the function when handling the `$_GET` and `$_POST`
    arrays, or any other array whose keys could be controlled by the user, because
    malicious users could submit keys chosen deliberately to overwrite commonly used
    variable names and compromise your website.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，所有新变量将以给定前缀字符串开始，后跟下划线，因此`$q`将变为`$fromget_q`。我强烈建议您在处理`$_GET`和`$_POST`数组或任何其他可能由用户控制键的数组时使用此函数版本，因为恶意用户可能会提交有意选择的键来覆盖常用变量名并危害您的网站。
- en: compact
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: compact
- en: At times you may want to use `compact`, the inverse of `extract`, to create
    an array from variables and their values. [Example 6-14](#using_the_compact_function)
    shows how you might use this function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能想要使用`compact`（`extract`的反向操作）来创建一个包含变量及其值的数组。[示例 6-14](#using_the_compact_function)展示了您可能如何使用此函数。
- en: Example 6-14\. Using the `compact` function
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-14\. 使用`compact`函数
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The result of running [Example 6-14](#using_the_compact_function) is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 运行[示例 6-14](#using_the_compact_function)的结果如下：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note how `compact` requires the variable names to be supplied in quotes, not
    preceded by a `$` symbol. This is because `compact` is looking for a list of variable
    names, not their values.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`compact`要求以引号提供变量名称，而不是以`$`符号开头。这是因为`compact`正在寻找变量名列表，而不是它们的值。
- en: Another use of this function is for debugging, when you wish to quickly view
    several variables and their values, as in [Example 6-15](#using_compact_to_help_with_debugging).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个使用该函数的情况是调试时，您希望快速查看几个变量及其值，例如[示例 6-15](#using_compact_to_help_with_debugging)。
- en: Example 6-15\. Using `compact` to help with debugging
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-15\. 使用`compact`函数进行调试
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This works by using the `explode` function to extract all the words from the
    string into an array, which is then passed to the `compact` function, which in
    turn returns an array to `print_r`, which finally shows its contents.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过使用`explode`函数从字符串中提取所有单词到数组中实现，然后将其传递给`compact`函数，后者再返回一个数组给`print_r`，最终显示其内容。
- en: 'If you copy and paste the `print_r` line of code, you only need to alter the
    variables named there for a quick printout of a group of variables’ values. In
    this example, the output is shown here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您复制并粘贴`print_r`代码行，则只需修改那里命名的变量即可快速打印一组变量的值。在本例中，输出如下所示：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: reset
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重置
- en: 'When the `foreach...as` construct or the `each` function walks through an array,
    it keeps an internal PHP pointer that makes a note of which element of the array
    it should return next. If your code ever needs to return to the start of an array,
    you can issue `reset`, which also returns the value of that element. Examples
    of how to use this function are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `foreach...as` 结构或 `each` 函数遍历数组时，它会保持一个内部的 PHP 指针，记录应该返回的数组元素。如果你的代码需要返回数组的开头，你可以使用
    `reset`，它也会返回那个元素的值。以下是如何使用此函数的示例：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: end
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: end
- en: 'As with `reset`, you can move PHP’s internal array pointer to the final element
    in an array using the `end` function, which also returns the value of the element
    and can be used as in these examples:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `reset` 类似，你可以使用 `end` 函数将 PHP 内部数组指针移动到数组的最后一个元素，并返回该元素的值。以下是一些示例：
- en: '[PRE37]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This chapter concludes your basic introduction to PHP, and you should now be
    able to write quite complex programs using the skills you have learned. In the
    next chapter, we’ll look at using PHP for common, practical tasks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了你对 PHP 的基础介绍，现在你应该能够使用所学的技能编写相当复杂的程序。在下一章中，我们将讨论使用 PHP 处理常见实际任务的方法。
- en: Questions
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a numeric and an associative array?
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数值数组和关联数组有什么区别？
- en: What is the main benefit of the `array` keyword?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`array` 关键字的主要优势是什么？'
- en: What is the difference between `foreach` and `each`?
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`foreach` 和 `each` 有什么区别？'
- en: How can you create a multidimensional array?
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何创建多维数组？
- en: How can you determine the number of elements in an array?
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何确定数组中元素的数量？
- en: What is the purpose of the `explode` function?
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`explode` 函数的目的是什么？'
- en: How can you set PHP’s internal pointer into an array back to the first element
    of the array?
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何将 PHP 内部指针设置回数组的第一个元素？
- en: See [“Chapter 6 Answers”](app01_split_005.xhtml#chapter_6_answers) in the [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions)
    for the answers to these questions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[“第 6 章答案”](app01_split_005.xhtml#chapter_6_answers)，位于[附录 A](app01_split_000.xhtml#solutions_to_the_chapter_questions)中，以获取这些问题的答案。
