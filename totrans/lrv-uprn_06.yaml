- en: Chapter 6\. Frontend Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Laravel is mainly known as a PHP framework, but it’s also *full stack*, meaning
    it has a series of components and conventions focused on generating frontend code.
    Some of these, like pagination and message bags, are PHP helpers that target the
    frontend, but Laravel also provides a Vite-based frontend build system, some conventions
    around non-PHP assets, and several starter kits.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel Starter Kits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Out of the box, Laravel provides an entire build system, which we’ll cover shortly,
    but it also includes easy-to-install starter kits that contain templates, auth,
    styles, JavaScript, and user registration and management workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel’s two starter kits are called Breeze and Jetstream.
  prefs: []
  type: TYPE_NORMAL
- en: Breeze is the simpler option; it provides all the needed routes, views, and
    styles for Laravel’s auth system, including registration, login, password reset,
    password confirmation, email confirmation, and an “edit profile” page. Breeze
    includes Tailwind styles, and you can choose either Blade templates or Inertia
    with React or Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Jetstream is more complex and robust; it provides everything Breeze does, but
    it also adds two-factor authentication, session management, API token management,
    and team management features. Jetstream includes Tailwind styles, and you can
    choose either Livewire or Inertia with Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Inertia is a frontend tool that allows you to build single-page apps in JavaScript,
    while using Laravel routes and controllers to provide the routing and data to
    each view, as if it were a traditional server-rendered app. Learn more at [*inertiajs.com*](https://inertiajs.com).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re just getting started with Laravel, Breeze is easier to understand
    and can be used with just Blade. Most Laravel apps work just fine with only Breeze.
  prefs: []
  type: TYPE_NORMAL
- en: Jetstream doesn’t have a Blade-only option, nor does it have a React option;
    you’ll need to work with some sort of frontend framework. Your choice is either
    Vue/Inertia or Livewire, which is a project that allows you to write mainly backend
    code but get frontend interactivity in your Laravel apps. However, Jetstream is
    more robust, so if you’re comfortable with Laravel and either Livewire or Inertia,
    and your project needs those extra features, Jetstream may be your best choice.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel Breeze
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel Breeze is a simple starter kit that provides everything you need for
    an average Laravel application to allow your users to sign up, log in, and manage
    their profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Breeze
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Breeze is intended to be installed on new apps, so it’s usually the first thing
    you’ll install when you spin up a new app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Breeze is added to your project, you’ll run its installer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you run the installer, you’ll be prompted to choose a stack: Blade, Inertia
    with React, Inertia with Vue, or API, which is meant to power a non-Inertia frontend
    like Next.js. These stacks are explained in the following section.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After Breeze is installed, make sure to run your migrations and build your
    frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What comes with Breeze
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Breeze automatically registers routes for registration, login, logout, password
    reset, email verification, and password confirmation pages. These routes live
    in a new *routes/auth.php* file.
  prefs: []
  type: TYPE_NORMAL
- en: The non-API form of Breeze also registers routes for a dashboard and an “edit
    profile” page for users, and adds these routes directly to the *routes/web.php*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The non-API form of Breeze also publishes controllers for the “edit profile”
    page, email verification, password resets, and several other authentication-related
    features. In addition, it adds Tailwind, Alpine.js, and PostCSS (for Tailwind).
    Beyond these shared files and dependencies, each stack adds its own, unique to
    its needs:'
  prefs: []
  type: TYPE_NORMAL
- en: Breeze Blade
  prefs: []
  type: TYPE_NORMAL
- en: Breeze Blade comes with a series of Blade templates for all the features mentioned
    above, which you can find in *resources/views/auth*, *resources/view/components*,
    *resources/views/profile*, and a few others sprinkled around.
  prefs: []
  type: TYPE_NORMAL
- en: Breeze Inertia
  prefs: []
  type: TYPE_NORMAL
- en: Both Inertia stacks bring in Inertia, Ziggy (a tool for generating URLs to Laravel
    routes in JavaScript), Tailwind’s “forms” component, and the necessary JavaScript
    packages to make their respective frontend frameworks function. They both also
    publish a basic Blade template that loads Inertia and a series of React/Vue components
    for all the published pages in the *resources/js* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Breeze API
  prefs: []
  type: TYPE_NORMAL
- en: The API stack for Breeze installs significantly less code and fewer packages
    than the other stacks, but it also removes the existing bootstrapped files that
    come with all new Laravel apps. The API stack is intended to prepare an app to
    be *only* an API backend for a separate Next.js app, so it removes *package.json*,
    all the JavaScript and CSS files, and all the frontend templates.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel Jetstream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jetstream builds on Breeze’s functionality and adds even more tooling for starting
    a new app; however, it’s a more complicated setup with fewer options for configuration,
    so you’ll want to know that you need it before you choose Jetstream over Breeze.
  prefs: []
  type: TYPE_NORMAL
- en: Jetstream, like Breeze, publishes routes, controllers, views, and configuration
    files. Like Breeze, Jetstream uses Tailwind, and comes in different tech “stacks.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike Breeze, however, Jetstream requires interactivity, so there’s no Blade-only
    stack. Instead, you have two choices: Livewire (which is Blade with some PHP-powered
    JavaScript interactivity) or Inertia/Vue (there’s no React form for Jetstream).'
  prefs: []
  type: TYPE_NORMAL
- en: Jetstream also expands Breeze’s offering by bringing in team management features,
    two-factor authentication, session management, and personal API token management.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jetstream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Jetstream is meant to be installed in a new Laravel app, and you can install
    it with Composer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Once Jetstream is added to your project, you’ll run its installer. Unlike Breeze,
    you won’t be prompted to pick your stack; instead, you need to pass in the stack
    (`livewire` or `inertia`) as the first parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to add team management to your Jetstream install, pass the `--teams`
    flag to the installation step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you’ve installed Jetstream, make sure to run your migrations and build
    your frontend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What comes with Jetstream
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Jetstream publishes an incredible amount of code; here’s a quick summary:'
  prefs: []
  type: TYPE_NORMAL
- en: Two-factor authentication and profile photo functionality added to the User
    model (and adding/modifying the required migrations)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dashboard for logged-in users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tailwind, Tailwind forms, Tailwind typography
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Laravel Fortify, the backend auth component Jetstream builds on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: “Actions” for Fortify and Jetstream in *app/Actions*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Markdown text for terms and policies pages in *resources/markdown*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A huge suite of tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fortify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fortify is a headless authentication system. It provides the routes and controllers
    for all the authentication features Laravel requires, from login and registration
    to password reset and more, to be consumed by whichever frontend you choose.
  prefs: []
  type: TYPE_NORMAL
- en: Jetstream builds on Fortify, so you can actually think of Jetstream as one of
    many possible frontends in front of Fortify. Jetstream does also add backend functionality,
    so it shows just how robust a Fortify-backed auth system can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jetstream’s Livewire and Inertia configurations each come with slightly different
    dependencies and locations for the templates:'
  prefs: []
  type: TYPE_NORMAL
- en: Jetstream Livewire
  prefs: []
  type: TYPE_NORMAL
- en: 'Jetstream’s Livewire template sets your app up for working with Livewire and
    Alpine, and it publishes Livewire components for the frontend. It provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Livewire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alpine.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Livewire components in *app/View/Components*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frontend templates in *resources/views*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jetstream Inertia
  prefs: []
  type: TYPE_NORMAL
- en: 'Jetstream’s Inertia template sets your app up for working with Inertia and
    Vue, and it publishes Vue components for the frontend. It provides:'
  prefs: []
  type: TYPE_NORMAL
- en: Inertia
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vue templates in *resources/js*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing your jetstream install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jetstream builds on Fortify, so customizing Jetstream sometimes will mean customizing
    Fortify. You can update any configuration settings in *config/fortify.php*, *config/jetstream.php*,
    the *FortifyServiceProvider*, and the *JetstreamServiceProvider*.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas Breeze publishes controllers for you to modify its behaviors, Jetstream
    publishes actions, each a one-off chunk of behavior with names like *ResetUserPassword.php*
    and *DeleteUser.php*.
  prefs: []
  type: TYPE_NORMAL
- en: Further Jetstream features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jetstream enables your application to manage teams, personal API tokens, two-factor
    authentication, and tracking and disconnecting all active sessions. You can also
    hook into some of Jetstream’s UI niceties in your own code, like custom flash
    banners.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about how this all works, take a look at the [Laravel docs for
    Jetstream](https://jetstream.laravel.com), which are exhaustive.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel’s Vite Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vite is a local frontend development environment that combines a dev server
    and Rollup-based build tooling chain. That might sound like a lot, but in Laravel,
    it’s primarily used to bundle CSS and JavaScript assets together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Laravel offers an NPM plug-in and a Blade directive to make it easy to work
    with Vite. Both are included in Laravel apps out of the box, along with a configuration
    file: *vite.config.js*.'
  prefs: []
  type: TYPE_NORMAL
- en: Take a look at [Example 6-1](#EX523) to see what the contents of the default
    *vite.config.js* file look like.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-1\. The default *vite.config.js*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We’re defining the files our plug-in should build from (`input`) and saying
    we do want the “refresh my page every time I save a view file” feature enabled
    (`refresh`).
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Vite pulls from the two files listed in [Example 6-1](#EX523),
    and will automatically refresh any time any file changes in these folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '*app/View/Components/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*lang/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*resources/lang/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*resources/views/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*routes/*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve got our Vite config pointed to our CSS and JavaScript entry files,
    we’ll want to reference those files using the `@vite` Blade directive, as you
    can see in [Example 6-2](#EX524).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-2\. Using the `@vite` Blade directive
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That’s it! Next, let’s take a look at how to bundle files with Vite.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If your local development domain is secured (HTTPS), you will need to modify
    your *vite.config.js* file to point to your credentials. If you’re using Valet,
    there’s a special configuration option for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Bundling Files with Vite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, it’s time to bundle our assets. There are two ways to bundle assets
    with Vite: “build” and “dev.”'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to build your files once, either for delivery to production or for
    local testing, run `npm run build` and Vite will bundle your assets. If you are
    developing locally, however, you may prefer to have Vite spin up a process that
    will watch your view files for changes, retrigger the build any time it detects
    changes to your view files, and push a refresh to the page in your browser. That’s
    what `npm run dev` does for you.
  prefs: []
  type: TYPE_NORMAL
- en: Your built files will end up in the *public/build/assets* folder of your app,
    with a file living at *public/build/manifest.json* that tells Laravel and Vite
    how to get to each built file from its nonbuilt path reference.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The *public/build* folder is ignored by default in Laravel’s *.gitignore*, so
    make sure to run `npm run build` as a part of your deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: The Vite Dev Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you run `npm run dev`, you’re spinning up an actual HTTP server, powered
    by Vite. The Vite Blade helper rewrites your asset URLs to point to the same locations
    on the dev server instead of on your local domain, which allows Vite to more quickly
    update and refresh your dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that if you write the following Blade call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It’ll look like this on your production application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'But it’ll look something like this locally if your Vite server is running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Working with Static Assets and Vite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far we’ve only covered loading JavaScript and CSS with Vite. But Laravel’s
    Vite configuration can process and version your static assets (like images), as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re working in JavaScript templates, Vite will grab the links to any *relative*
    static assets and process and version them. Any *absolute* static assets Vite
    will ignore.
  prefs: []
  type: TYPE_NORMAL
- en: This means the following images will receive different treatment, if they’re
    in JavaScript templates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re working in Blade templates, you’ll need to take two steps to have
    Vite handle your static assets. First, you’ll want to use the `Vite::asset` facade
    call to link your asset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And second, you’ll need to add a configuration step to your *resources/js/app.js*
    file that shows Vite which files or folders to import:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re running the Vite server with `npm run dev`, the server can load your
    static assets *without* you adding the `import.meta.glob` config. That means you
    may think it’s going to show up, but it will fail on your production build.
  prefs: []
  type: TYPE_NORMAL
- en: Working with JavaScript Frameworks and Vite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to work with Vue, React, Inertia, and/or a single-page application
    (SPA), you may need to bring in some specific plug-ins or set some specific configuration
    items. Here are the basics of what you need for the most common scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Vite and Vue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To work with Vite and Vue, first install Vite’s Vue plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to modify your *vite.config.js* file to call the Vue plug-in,
    passing two configuration settings to it. The first, `template.transformAssetUrls.base=null`,
    allows the Laravel plug-in instead of the Vue plug-in to handle rewriting URLs.
    The second, `template.transformAssetUrls.includeAbsolute=false`, allows URLs within
    Vue templates to reference files in the public directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Vite and React
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To work with Vite and React, first install Vite’s React plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to modify your *vite.config.js* file to call the React plug-in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add the `@viteReactRefresh` Blade directive in your template before
    you import your JavaScript files with `@vite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Vite and Inertia
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re setting up Inertia yourself, you’ll need Inertia to be able to resolve
    your page components.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a look at the code you’ll likely write in your *resources/js/app.js*
    file, but your best option is to install Inertia using Breeze, Jetstream, or the
    Inertia docs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Vite and SPAs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you’re building an SPA, remove *resources/css/app.css* from your *vite.config.js*
    file, which removes it as an entry point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, import your CSS into your JavaScript by adding this line to your *resources/js/app,js*
    file, directly below importing the bootstrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Using Environment Variables in Vite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to use environment variables in your JavaScript files, prefix the
    variable name with `VITE_`, as you can see in [Example 6-3](#EX525).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-3\. Referencing environment variables in vite.config.js
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Every time you run `npm run dev` or `npm run build`, it’ll load that environment
    variable from *.env* and inject it into your script.
  prefs: []
  type: TYPE_NORMAL
- en: Pagination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For something that is so common across web applications, pagination still can
    be wildly complicated to implement. Thankfully, Laravel has a built-in concept
    of pagination, which is also hooked into Eloquent results *and* the router by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: Paginating Database Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common place you’ll see pagination is when you are displaying the results
    of a database query and there are too many results for a single page. Eloquent
    and the query builder both read the `page` query parameter from the current page
    request and use it to provide a `paginate()` method on any result sets; the single
    parameter you should pass `paginate()` indicates how many results you want per
    page. Take a look at [Example 6-4](#EX512) to see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-4\. Paginating a query builder response
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 6-4](#EX512) specifies that this route should return 20 posts per
    page and will define which “page” of results the current user is on based on the
    URL’s `page` query parameter, if it has one. Eloquent models all have the same
    `paginate()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: When you display the results in your view, your collection will now have a `links()`
    method on it that will output the pagination controls. (See [Example 6-5](#EX513),
    which I’ve simplified for inclusion in this book.)
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-5\. Rendering pagination links in a template
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The paginator uses TailwindCSS for its default styling. If you want to use
    Bootstrap styles, call `Paginator::useBootstrap()` in your `AppServiceProvider`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Customizing the Number of Pagination Links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you’d like to control how many links display on either side of the current
    page, you can customize this number easily with the `onEachSide()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Manually Creating Paginators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re not working with Eloquent or the query builder, or if you’re working
    with a complex query (e.g., one using `groupBy`), you might find yourself needing
    to create a paginator manually. Thankfully, you can do that with the `Illuminate\Pagination\Paginator`
    or `Illuminate\Pagination\LengthAwarePaginator` classes.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between the two classes is that `Paginator` provides only previous
    and next buttons, but no links to each page; `LengthAwarePaginator` needs to know
    the length of the full result so that it can generate links for each individual
    page. You may find yourself wanting to use `Paginator` on large result sets so
    your paginator doesn’t have to be aware of a massive count of results that might
    be costly to run.
  prefs: []
  type: TYPE_NORMAL
- en: Both `Paginator` and `LengthAwarePaginator` require you to manually extract
    the subset of content that you want to pass to the view. Take a look at [Example 6-6](#EX514)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-6\. Manually creating a paginator
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Message Bags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another common-but-painful feature in web applications is passing messages
    between various components of the app, when the end goal is to share them with
    the user. Your controller, for example, might want to send a validation message:
    “The `email` field must be a valid email address.” However, that particular message
    doesn’t just need to make it to the view layer; it actually needs to survive a
    redirect and then end up in the view layer of a different page. How do you structure
    this messaging logic?'
  prefs: []
  type: TYPE_NORMAL
- en: The `Illuminate\Support\MessageBag` class is tasked with storing, categorizing,
    and returning messages that are intended for the end user. It groups all messages
    by key, where the keys are likely to be something like `errors` or `messages`,
    and it provides convenience methods for getting either all its stored messages
    or only those for a particular key, and outputting these messages in various formats.
  prefs: []
  type: TYPE_NORMAL
- en: You can spin up a new instance of `MessageBag` manually like in [Example 6-7](#EX515).
    To be honest, though, you likely won’t ever do this manually—​this is just a thought
    exercise to show how it works.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-7\. Manually creating and using a message bag
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Message bags are also closely connected to Laravel’s validators (you’ll learn
    more about these in [“Validation”](ch07.html#validation)): when validators return
    errors, they actually return an instance of `MessageBag`, which you can then pass
    to your view or attach to a redirect using `redirect(''route'')->withErrors($messagebag)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Laravel passes an empty instance of `MessageBag` to every view, assigned to
    the variable `$errors`; if you’ve flashed a message bag using `withErrors()` on
    a redirect, it will get assigned to that `$errors` variable instead. That means
    every view can always assume it has an `$errors` `MessageBag` that it can check
    wherever it handles validation, which leads to [Example 6-8](#EX516) as a common
    snippet developers place on every page.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-8\. Error bag snippet
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Missing $errors Variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have any routes that aren’t under the `web` middleware group, they won’t
    have the session middleware, which means they won’t have this `$errors` variable
    available.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes you need to differentiate message bags not just by key (`notices`
    versus `errors`) but also by component. Maybe you have a login form and a signup
    form on the same page; how do you differentiate them?
  prefs: []
  type: TYPE_NORMAL
- en: 'When you send errors along with a redirect using `withErrors()`, the second
    parameter is the name of the bag: `redirect(''dashboard'')->withErrors($validator,
    ''login'')`. Then, on the dashboard, you can use `$errors->login` to call all
    of the methods you saw before: `any()`, `count()`, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: String Helpers, Pluralization, and Localization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we tend to look at blocks of text as big placeholder divs, waiting
    for the client to put real content into them. Seldom are we involved in any logic
    inside these blocks.
  prefs: []
  type: TYPE_NORMAL
- en: But there are a few circumstances where you’ll be grateful for the tools Laravel
    provides for string manipulation.
  prefs: []
  type: TYPE_NORMAL
- en: The String Helpers and Pluralization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Laravel has a series of helpers for manipulating strings. They’re available
    as methods on the `Str` class (e.g., `Str::plural()`).
  prefs: []
  type: TYPE_NORMAL
- en: Laravel String and Array Global Helpers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Older versions of Laravel included global helpers that were aliases for the
    `Str` and `Arr` methods. These global `str_` and `array_` helpers were removed
    from Laravel in version 6 and exported to a separate package. If you’d like, you
    can install the `laravel/helpers` package via Composer: `composer require laravel/helpers`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Laravel [documentation](https://oreil.ly/vssfi) covers all of the string
    helpers in detail, but here are a few of the most commonly used ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '`e()`'
  prefs: []
  type: TYPE_NORMAL
- en: A shortcut for `html_entities()`; encodes all HTML entities for safety.
  prefs: []
  type: TYPE_NORMAL
- en: '`Str::startsWith()`, `Str::endsWith()`, `Str::contains()`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks a string (first parameter) to see if it starts with, ends with, or contains
    another string (second parameter).
  prefs: []
  type: TYPE_NORMAL
- en: '`Str::is()`'
  prefs: []
  type: TYPE_NORMAL
- en: Checks whether a string (second parameter) matches a particular pattern (first
    parameter)—for example, `foo*` will match `foobar` and `foobaz`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Str::slug()`'
  prefs: []
  type: TYPE_NORMAL
- en: Converts a string to a URL-type slug with hyphens.
  prefs: []
  type: TYPE_NORMAL
- en: '`Str::plural(*word*, *count*)`, `Str::singular()`'
  prefs: []
  type: TYPE_NORMAL
- en: Pluralizes or singularizes a word; English only (e.g., `Str::plural('dog')`
    returns `dogs`; `Str::plural('dog,' 1'))` returns `dog`).
  prefs: []
  type: TYPE_NORMAL
- en: '`Str::camel()`, `Str::kebab()`, `Str::snake()`, `Str::studly()`, `Str::title()`'
  prefs: []
  type: TYPE_NORMAL
- en: Converts a provided string to a different capitalization “case.”
  prefs: []
  type: TYPE_NORMAL
- en: '`Str::after()`, `Str::before()`, `Str::limit()`'
  prefs: []
  type: TYPE_NORMAL
- en: Trims a string and provides a substring. `Str::after()` returns everything after
    a given string, and `Str::before()` returns everything before a given string (both
    accept the full string as the first parameter and the string you’re using to cut
    as the second). `Str::limit()` truncates a string (first parameter) to a given
    number of characters (second parameter).
  prefs: []
  type: TYPE_NORMAL
- en: '`Str::markdown(*string*, *options*)`'
  prefs: []
  type: TYPE_NORMAL
- en: Converts Markdown into HTML. You can read more about the options you can pass
    on [the PHP league website](https://oreil.ly/3zOdm).
  prefs: []
  type: TYPE_NORMAL
- en: '`Str::replace(*search*, *replace*, *subject*, *caseSensitive*)`'
  prefs: []
  type: TYPE_NORMAL
- en: Looks in the subject string for the search string occurrence and replaces it
    with the replace string. If the case sensitivity parameter is true, only replace
    if the occurrence matches the search case (e.g., `Str::replace('Running', 'Going',
    'Laravel Up and Running', true)` returns `'Laravel Up and Going'`).
  prefs: []
  type: TYPE_NORMAL
- en: Localization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Localization enables you to define multiple languages and mark any strings as
    targets for translation. You can set a fallback language and even handle pluralization
    variations.
  prefs: []
  type: TYPE_NORMAL
- en: In Laravel, you’ll need to set an “application locale” at some point during
    the page load so the localization helpers know which bucket of translations to
    pull from. Each “locale” is usually connected to a translation and will often
    look like “en” (for English). You’ll do this with `App::setLocale($localeName)`,
    and you’ll likely put it in a service provider. For now, you can just put it in
    the `boot()` method of `AppServiceProvider`, but you may want to create a `LocaleServiceProvider`
    if you end up with more than just this one locale-related binding.
  prefs: []
  type: TYPE_NORMAL
- en: You can define your fallback locale in *config/app.php*, where you should find
    a `fallback_locale` key. This allows you to define a default language for your
    application, which Laravel will use if it can’t find a translation for the requested
    locale.
  prefs: []
  type: TYPE_NORMAL
- en: Basic localization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So, how do we call for a translated string? There’s a helper function, `__($key)`,
    that will pull the string for the current locale for the passed key or, if it
    doesn’t exist, grab it from the default locale. In Blade you can also use the
    `@lang()` directive. [Example 6-9](#EX517) demonstrates how a basic translation
    works. We’ll use the example of a “back to the dashboard” link at the top of a
    detail page.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-9\. Basic use of `__()`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume we are using the `es` locale right now. First, we’ll need to publish
    the `lang` files for modification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This command publishes the default Laravel `lang` files to the root of your
    application. You’ll want to create a file to define your navigation-related translations,
    *lang/en/navigation.php*, and have it return a PHP array with a key named `back`
    in it, as in [Example 6-10](#sample_navigation_en_file).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-10\. Example lang/en/navigation.php file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now, to make this translatable, let’s also create an *es* directory under *lang*,
    with its own *navigation.php* file, as you can see in [Example 6-11](#sample_navigation_es_file).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-11\. Example lang/es/navigation.php file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now let’s try using that translation key in our app, in [Example 6-12](#EX518).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-12\. Using a translation
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Parameters in localization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding example was relatively simple. Let’s dig into some that are more
    complex. What if we want to define *which* dashboard we’re returning to? Take
    a look at [Example 6-13](#EX519).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-13\. Parameters in translations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, prepending a word with a colon (`:section`) marks it as a placeholder
    that can be replaced. The second, optional, parameter of `__()` is an array of
    values to replace the placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Pluralization in localization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already covered pluralization, so now just imagine you’re defining your own
    pluralization rules. There are two ways to do it; we’ll start with the simplest,
    as shown in [Example 6-14](#EX520).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-14\. Defining a simple translation with an option for pluralization
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have a `trans_choice()` method, which takes the count of
    items affected as its second parameter; from this, it will determine which string
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use any translation definitions that are compatible with Symfony’s
    much more complex `Translation` component; see [Example 6-15](#EX521) for an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-15\. Using the Symfony `Translation` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Storing the default string as the key with JSON
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One common difficulty with localization is that it’s hard to ensure there’s
    a good system for defining key namespacing—​for example, remembering a key nested
    three or four levels deep or being unsure which key a phrase used twice in the
    site should use.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the slug key/string value pair system is to store your translations
    using your primary language string as the key, instead of a made-up slug. You
    can indicate to Laravel that you’re working this way by storing your translation
    files as JSON in the *lang* directory, with the filename reflecting the locale
    ([Example 6-16](#EX6a)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-16\. Using JSON translations and the `__()` helper
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is taking advantage of the fact that the `__()` translation helper, if
    it can’t find a matching key for the current language, will just display the key.
    If your key is the string in your app’s default language, that’s a much more reasonable
    fallback than, for example, `widgets.friends.title`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we focused primarily on Laravel’s frontend components. These
    are less likely the objects of unit tests, but they may at times be used in your
    integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Message and Error Bags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two primary ways of testing messages passed along with message and
    error bags. First, you can perform a behavior in your application tests that sets
    a message that will eventually be displayed somewhere, then redirect to that page
    and assert that the appropriate message is shown.
  prefs: []
  type: TYPE_NORMAL
- en: Second, for errors (which is the most common use case), you can assert the session
    has errors with `$this->assertSessionHasErrors($bindings = [])`. Take a look at
    [Example 6-17](#EX522) to see what this might look like.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-17\. Asserting the session has errors
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In order for [Example 6-17](#EX522) to pass, you’ll need to add input validation
    to that route. We’ll cover this in [Chapter 7](ch07.html#collecting_and_handling_user_data).
  prefs: []
  type: TYPE_NORMAL
- en: Translation and Localization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way to test localization is with application tests. Set the appropriate
    context (whether by URL or session), “visit” the page with `get()`, and assert
    that you see the appropriate content.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling Vite in Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’d like to disable Vite’s asset resolution during your tests, you can
    disable Vite entirely by calling the `withoutVite()` method at the top of a test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: TL;DR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a full stack framework, Laravel provides tools and components for the frontend
    as well as the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Vite is a build tool and dev server that Laravel builds on top of to help process,
    compress, and version your JavaScript, CSS, and static assets like images.
  prefs: []
  type: TYPE_NORMAL
- en: Laravel also offers other internal tools that target the frontend, including
    tools for implementing pagination, message and error bags, and localization.
  prefs: []
  type: TYPE_NORMAL
