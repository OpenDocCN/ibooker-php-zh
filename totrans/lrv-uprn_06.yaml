- en: Chapter 6\. Frontend Components
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。前端组件
- en: Laravel is mainly known as a PHP framework, but it’s also *full stack*, meaning
    it has a series of components and conventions focused on generating frontend code.
    Some of these, like pagination and message bags, are PHP helpers that target the
    frontend, but Laravel also provides a Vite-based frontend build system, some conventions
    around non-PHP assets, and several starter kits.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 主要被认为是一个 PHP 框架，但它也是 *全栈* 的，意味着它有一系列组件和约定，专注于生成前端代码。其中一些组件，如分页和消息包，是针对前端的
    PHP 帮助程序，但 Laravel 还提供基于 Vite 的前端构建系统，一些非 PHP 资产的约定以及几个起始套件。
- en: Laravel Starter Kits
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel 起始套件
- en: Out of the box, Laravel provides an entire build system, which we’ll cover shortly,
    but it also includes easy-to-install starter kits that contain templates, auth,
    styles, JavaScript, and user registration and management workflows.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开箱即用的情况下，Laravel 提供了一个完整的构建系统，我们很快就会介绍，但它还包括易于安装的起始套件，其中包含模板、认证、样式、JavaScript
    和用户注册及管理工作流程。
- en: Laravel’s two starter kits are called Breeze and Jetstream.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的两个起始套件称为 Breeze 和 Jetstream。
- en: Breeze is the simpler option; it provides all the needed routes, views, and
    styles for Laravel’s auth system, including registration, login, password reset,
    password confirmation, email confirmation, and an “edit profile” page. Breeze
    includes Tailwind styles, and you can choose either Blade templates or Inertia
    with React or Vue.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**Breeze** 是一个更简单的选择；它提供了Laravel认证系统所需的所有路由、视图和样式，包括注册、登录、密码重置、密码确认、电子邮件确认以及“编辑个人资料”页面。Breeze
    包含 Tailwind 样式，您可以选择使用 Blade 模板或者 Inertia 配合 React 或 Vue。'
- en: Jetstream is more complex and robust; it provides everything Breeze does, but
    it also adds two-factor authentication, session management, API token management,
    and team management features. Jetstream includes Tailwind styles, and you can
    choose either Livewire or Inertia with Vue.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jetstream** 更加复杂和强大；它提供了 Breeze 所有的功能，但还增加了双因素认证、会话管理、API 令牌管理和团队管理功能。Jetstream
    包含 Tailwind 样式，您可以选择 Livewire 或者 Inertia 配合 Vue。'
- en: Note
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Inertia is a frontend tool that allows you to build single-page apps in JavaScript,
    while using Laravel routes and controllers to provide the routing and data to
    each view, as if it were a traditional server-rendered app. Learn more at [*inertiajs.com*](https://inertiajs.com).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**Inertia** 是一个前端工具，允许您在 JavaScript 中构建单页面应用程序，同时使用 Laravel 路由和控制器为每个视图提供路由和数据，就像传统的服务器渲染应用程序一样。了解更多，请访问
    [*inertiajs.com*](https://inertiajs.com)。'
- en: If you’re just getting started with Laravel, Breeze is easier to understand
    and can be used with just Blade. Most Laravel apps work just fine with only Breeze.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您刚开始使用 Laravel，Breeze 更容易理解，并且可以仅使用 Blade。大多数 Laravel 应用程序仅使用 Breeze 就能正常工作。
- en: Jetstream doesn’t have a Blade-only option, nor does it have a React option;
    you’ll need to work with some sort of frontend framework. Your choice is either
    Vue/Inertia or Livewire, which is a project that allows you to write mainly backend
    code but get frontend interactivity in your Laravel apps. However, Jetstream is
    more robust, so if you’re comfortable with Laravel and either Livewire or Inertia,
    and your project needs those extra features, Jetstream may be your best choice.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jetstream** 没有仅限于 Blade 的选项，也没有 React 的选项；您需要使用某种前端框架。您的选择是 Vue/Inertia 或者
    Livewire，后者允许您主要编写后端代码，但在 Laravel 应用程序中获取前端交互性。然而，Jetstream 更为强大，因此如果您熟悉 Laravel
    并且了解 Livewire 或 Inertia，并且您的项目需要这些额外的功能，Jetstream 可能是您的最佳选择。'
- en: Laravel Breeze
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**Laravel Breeze**'
- en: Laravel Breeze is a simple starter kit that provides everything you need for
    an average Laravel application to allow your users to sign up, log in, and manage
    their profiles.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**Laravel Breeze** 是一个简单的起始套件，为普通的Laravel应用程序提供了一切所需，允许用户注册、登录和管理他们的个人资料。'
- en: Installing Breeze
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 **Breeze**
- en: 'Breeze is intended to be installed on new apps, so it’s usually the first thing
    you’ll install when you spin up a new app:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**Breeze** 旨在安装在新应用程序上，因此通常是您启动新应用程序时安装的第一个内容：'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once Breeze is added to your project, you’ll run its installer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将**Breeze**添加到您的项目中，您将运行其安装程序：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once you run the installer, you’ll be prompted to choose a stack: Blade, Inertia
    with React, Inertia with Vue, or API, which is meant to power a non-Inertia frontend
    like Next.js. These stacks are explained in the following section.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行安装程序，您将提示选择一个堆栈：Blade、Inertia 配合 React、Inertia 配合 Vue 或者 API，后者用于支持像 Next.js
    这样的非 Inertia 前端。这些堆栈在下一节中有详细解释。
- en: 'After Breeze is installed, make sure to run your migrations and build your
    frontend:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了 **Breeze** 后，请确保运行您的迁移并构建您的前端：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What comes with Breeze
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Breeze 所带来的内容
- en: Breeze automatically registers routes for registration, login, logout, password
    reset, email verification, and password confirmation pages. These routes live
    in a new *routes/auth.php* file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze 自动注册了用于注册、登录、注销、密码重置、电子邮件验证和密码确认页面的路由。这些路由位于新的 *routes/auth.php* 文件中。
- en: The non-API form of Breeze also registers routes for a dashboard and an “edit
    profile” page for users, and adds these routes directly to the *routes/web.php*
    file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze 的非 API 形式还为用户仪表板和“编辑个人资料”页面注册了路由，并直接添加到 *routes/web.php* 文件中。
- en: 'The non-API form of Breeze also publishes controllers for the “edit profile”
    page, email verification, password resets, and several other authentication-related
    features. In addition, it adds Tailwind, Alpine.js, and PostCSS (for Tailwind).
    Beyond these shared files and dependencies, each stack adds its own, unique to
    its needs:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze 的非 API 形式还发布了用于“编辑个人资料”页面、电子邮件验证、密码重置以及其他几个与身份验证相关的功能的控制器。此外，它还添加了 Tailwind、Alpine.js
    和 PostCSS（用于 Tailwind）。除了这些共享的文件和依赖项外，每个堆栈还根据自身需求添加了独特的文件：
- en: Breeze Blade
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze Blade
- en: Breeze Blade comes with a series of Blade templates for all the features mentioned
    above, which you can find in *resources/views/auth*, *resources/view/components*,
    *resources/views/profile*, and a few others sprinkled around.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze Blade 包含一系列 Blade 模板，涵盖了上述所有功能，你可以在 *resources/views/auth*、*resources/view/components*、*resources/views/profile*
    等位置找到它们。
- en: Breeze Inertia
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze Inertia
- en: Both Inertia stacks bring in Inertia, Ziggy (a tool for generating URLs to Laravel
    routes in JavaScript), Tailwind’s “forms” component, and the necessary JavaScript
    packages to make their respective frontend frameworks function. They both also
    publish a basic Blade template that loads Inertia and a series of React/Vue components
    for all the published pages in the *resources/js* directory.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 两种 Inertia 堆栈都引入了 Inertia、Ziggy（用于在 JavaScript 中生成到 Laravel 路由的 URL 的工具）、Tailwind
    的“forms”组件，以及使它们各自的前端框架功能正常运行所需的 JavaScript 包。它们还都发布了一个基本的 Blade 模板，该模板加载了 Inertia，以及在
    *resources/js* 目录中发布页面的一系列 React/Vue 组件。
- en: Breeze API
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze API
- en: The API stack for Breeze installs significantly less code and fewer packages
    than the other stacks, but it also removes the existing bootstrapped files that
    come with all new Laravel apps. The API stack is intended to prepare an app to
    be *only* an API backend for a separate Next.js app, so it removes *package.json*,
    all the JavaScript and CSS files, and all the frontend templates.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Breeze 的 API 堆栈安装的代码和包明显较少，但它也删除了所有新 Laravel 应用程序的现有引导文件。API 堆栈旨在准备一个应用程序仅作为独立的
    Next.js 应用程序的 API 后端，因此它删除了 *package.json*、所有 JavaScript 和 CSS 文件，以及所有前端模板。
- en: Laravel Jetstream
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Laravel Jetstream
- en: Jetstream builds on Breeze’s functionality and adds even more tooling for starting
    a new app; however, it’s a more complicated setup with fewer options for configuration,
    so you’ll want to know that you need it before you choose Jetstream over Breeze.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 延续了 Breeze 的功能，并增加了更多用于启动新应用的工具；但是，它的设置更复杂，配置选项更少，因此在选择 Jetstream
    而不是 Breeze 之前，您需要知道自己确实需要它。
- en: Jetstream, like Breeze, publishes routes, controllers, views, and configuration
    files. Like Breeze, Jetstream uses Tailwind, and comes in different tech “stacks.”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Breeze 类似，Jetstream 也发布路由、控制器、视图和配置文件。与 Breeze 一样，Jetstream 使用 Tailwind，并提供不同的技术“堆栈”选项。
- en: 'Unlike Breeze, however, Jetstream requires interactivity, so there’s no Blade-only
    stack. Instead, you have two choices: Livewire (which is Blade with some PHP-powered
    JavaScript interactivity) or Inertia/Vue (there’s no React form for Jetstream).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 Breeze 不同，Jetstream 需要互动性，因此没有仅限于 Blade 的堆栈。相反，您有两个选择：Livewire（这是带有一些由
    PHP 驱动的 JavaScript 互动功能的 Blade）或 Inertia/Vue（Jetstream 没有 React 形式）。
- en: Jetstream also expands Breeze’s offering by bringing in team management features,
    two-factor authentication, session management, and personal API token management.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 还通过引入团队管理功能、双因素认证、会话管理和个人 API 令牌管理扩展了 Breeze 的功能。
- en: Installing Jetstream
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 Jetstream
- en: 'Jetstream is meant to be installed in a new Laravel app, and you can install
    it with Composer:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 旨在安装到新的 Laravel 应用程序中，您可以使用 Composer 安装它：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once Jetstream is added to your project, you’ll run its installer. Unlike Breeze,
    you won’t be prompted to pick your stack; instead, you need to pass in the stack
    (`livewire` or `inertia`) as the first parameter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将 Jetstream 添加到您的项目中，您将运行其安装程序。与 Breeze 不同的是，您不会被要求选择堆栈；相反，您需要将堆栈 (`livewire`
    或 `inertia`) 作为第一个参数传入。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you want to add team management to your Jetstream install, pass the `--teams`
    flag to the installation step:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Jetstream 安装中添加团队管理功能，请在安装步骤中加入`--teams`标志：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once you’ve installed Jetstream, make sure to run your migrations and build
    your frontend:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 Jetstream 后，请确保运行你的迁移并构建你的前端：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What comes with Jetstream
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jetstream 包含了什么
- en: 'Jetstream publishes an incredible amount of code; here’s a quick summary:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 发布了大量的代码；以下是一个快速总结：
- en: Two-factor authentication and profile photo functionality added to the User
    model (and adding/modifying the required migrations)
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为用户模型添加双因素认证和个人资料照片功能（并添加/修改所需的迁移）
- en: A dashboard for logged-in users
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录用户的仪表板
- en: Tailwind, Tailwind forms, Tailwind typography
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tailwind, Tailwind forms, Tailwind typography
- en: Laravel Fortify, the backend auth component Jetstream builds on
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Laravel Fortify，Jetstream 构建在其上的后端身份验证组件
- en: “Actions” for Fortify and Jetstream in *app/Actions*
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*app/Actions* 中的 Fortify 和 Jetstream 的“操作”'
- en: Markdown text for terms and policies pages in *resources/markdown*
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*resources/markdown* 中的条款和政策页面的 Markdown 文本'
- en: A huge suite of tests
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个庞大的测试套件
- en: Fortify
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fortify
- en: Fortify is a headless authentication system. It provides the routes and controllers
    for all the authentication features Laravel requires, from login and registration
    to password reset and more, to be consumed by whichever frontend you choose.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Fortify 是一个无头身份验证系统。它为 Laravel 所需的所有身份验证功能提供路由和控制器，从登录和注册到密码重置等，供你选择的任何前端消费。
- en: Jetstream builds on Fortify, so you can actually think of Jetstream as one of
    many possible frontends in front of Fortify. Jetstream does also add backend functionality,
    so it shows just how robust a Fortify-backed auth system can be.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 建立在 Fortify 之上，因此你实际上可以将 Jetstream 视为 Fortify 的众多可能前端之一。Jetstream
    还添加了后端功能，因此显示了 Fortify 支持的身份验证系统可以有多强大。
- en: 'Jetstream’s Livewire and Inertia configurations each come with slightly different
    dependencies and locations for the templates:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 的 Livewire 和 Inertia 配置分别具有稍有不同的依赖项和模板位置：
- en: Jetstream Livewire
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream Livewire
- en: 'Jetstream’s Livewire template sets your app up for working with Livewire and
    Alpine, and it publishes Livewire components for the frontend. It provides:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 的 Livewire 模板为你的应用程序设置了与 Livewire 和 Alpine 协作的基础，并发布了前端的 Livewire
    组件。它提供了：
- en: Livewire
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Livewire
- en: Alpine.js
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alpine.js
- en: Livewire components in *app/View/Components*
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*app/View/Components* 中的 Livewire 组件'
- en: Frontend templates in *resources/views*
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*resources/views* 中的前端模板'
- en: Jetstream Inertia
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream Inertia
- en: 'Jetstream’s Inertia template sets your app up for working with Inertia and
    Vue, and it publishes Vue components for the frontend. It provides:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 的 Inertia 模板为你的应用程序设置了与 Inertia 和 Vue 协作的基础，并发布了前端的 Vue 组件。它提供了：
- en: Inertia
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Inertia
- en: Vue
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vue
- en: Vue templates in *resources/js*
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*resources/js* 中的 Vue 模板'
- en: Customizing your jetstream install
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义你的 Jetstream 安装
- en: Jetstream builds on Fortify, so customizing Jetstream sometimes will mean customizing
    Fortify. You can update any configuration settings in *config/fortify.php*, *config/jetstream.php*,
    the *FortifyServiceProvider*, and the *JetstreamServiceProvider*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 构建在 Fortify 基础之上，因此有时自定义 Jetstream 就意味着要自定义 Fortify。你可以在 *config/fortify.php*,
    *config/jetstream.php*, *FortifyServiceProvider* 和 *JetstreamServiceProvider*
    中更新任何配置设置。
- en: Whereas Breeze publishes controllers for you to modify its behaviors, Jetstream
    publishes actions, each a one-off chunk of behavior with names like *ResetUserPassword.php*
    and *DeleteUser.php*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Breeze 为你发布控制器以修改其行为，Jetstream 发布了动作，每个动作都是一个一次性的行为块，名称如 *ResetUserPassword.php*
    和 *DeleteUser.php*。
- en: Further Jetstream features
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多 Jetstream 特性
- en: Jetstream enables your application to manage teams, personal API tokens, two-factor
    authentication, and tracking and disconnecting all active sessions. You can also
    hook into some of Jetstream’s UI niceties in your own code, like custom flash
    banners.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Jetstream 使你的应用程序能够管理团队、个人 API 令牌、双因素认证以及跟踪和断开所有活动会话。你还可以在自己的代码中使用 Jetstream
    的一些 UI 精美功能，如自定义闪存横幅。
- en: To learn more about how this all works, take a look at the [Laravel docs for
    Jetstream](https://jetstream.laravel.com), which are exhaustive.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于这一切是如何工作的信息，请查看详尽的 [Laravel Jetstream 文档](https://jetstream.laravel.com)。
- en: Laravel’s Vite Configuration
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel 的 Vite 配置
- en: Vite is a local frontend development environment that combines a dev server
    and Rollup-based build tooling chain. That might sound like a lot, but in Laravel,
    it’s primarily used to bundle CSS and JavaScript assets together.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Vite 是一个本地前端开发环境，结合了开发服务器和基于 Rollup 的构建工具链。这听起来可能很多，但在 Laravel 中，主要用于将 CSS 和
    JavaScript 资源捆绑在一起。
- en: 'Laravel offers an NPM plug-in and a Blade directive to make it easy to work
    with Vite. Both are included in Laravel apps out of the box, along with a configuration
    file: *vite.config.js*.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 提供了一个 NPM 插件和一个 Blade 指令，使得与 Vite 协作变得容易。它们默认包含在 Laravel 应用程序中，还有一个配置文件：*vite.config.js*。
- en: Take a look at [Example 6-1](#EX523) to see what the contents of the default
    *vite.config.js* file look like.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 [Example 6-1](https://example.org/#EX523) 来查看默认 *vite.config.js* 文件的内容。
- en: Example 6-1\. The default *vite.config.js*
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. 默认的 *vite.config.js*
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’re defining the files our plug-in should build from (`input`) and saying
    we do want the “refresh my page every time I save a view file” feature enabled
    (`refresh`).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义插件应该从中构建的文件 (`input`)，并说我们希望启用 “每次保存视图文件时刷新我的页面” 的功能 (`refresh`)。
- en: 'By default, Vite pulls from the two files listed in [Example 6-1](#EX523),
    and will automatically refresh any time any file changes in these folders:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Vite 从 [Example 6-1](https://example.org/#EX523) 中列出的两个文件中拉取，并在这些文件夹中的任何文件更改时自动刷新：
- en: '*app/View/Components/*'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*app/View/Components/*'
- en: '*lang/*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*lang/*'
- en: '*resources/lang/*'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*resources/lang/*'
- en: '*resources/views/*'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*resources/views/*'
- en: '*routes/*'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*routes/*'
- en: Now that we’ve got our Vite config pointed to our CSS and JavaScript entry files,
    we’ll want to reference those files using the `@vite` Blade directive, as you
    can see in [Example 6-2](#EX524).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将 Vite 配置指向我们的 CSS 和 JavaScript 入口文件，我们将使用 `@vite` Blade 指令引用这些文件，正如你在
    [Example 6-2](https://example.org/#EX524) 中所看到的。
- en: Example 6-2\. Using the `@vite` Blade directive
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. 使用 `@vite` Blade 指令
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That’s it! Next, let’s take a look at how to bundle files with Vite.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！接下来，让我们看看如何使用 Vite 打包文件。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'If your local development domain is secured (HTTPS), you will need to modify
    your *vite.config.js* file to point to your credentials. If you’re using Valet,
    there’s a special configuration option for that:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的本地开发域名是安全的（HTTPS），你需要修改你的 *vite.config.js* 文件，指向你的凭据。如果你使用 Valet，这里有一个特殊的配置选项：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Bundling Files with Vite
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Vite 打包文件
- en: 'Finally, it’s time to bundle our assets. There are two ways to bundle assets
    with Vite: “build” and “dev.”'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候打包我们的资产了。使用 Vite 有两种打包资产的方式：“build” 和 “dev”。
- en: If you want to build your files once, either for delivery to production or for
    local testing, run `npm run build` and Vite will bundle your assets. If you are
    developing locally, however, you may prefer to have Vite spin up a process that
    will watch your view files for changes, retrigger the build any time it detects
    changes to your view files, and push a refresh to the page in your browser. That’s
    what `npm run dev` does for you.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想构建文件一次，无论是交付到生产环境还是进行本地测试，运行 `npm run build`，Vite 将会打包你的资产。然而，如果你在本地开发，可能更喜欢让
    Vite 启动一个进程，监视你的视图文件变化，每当检测到视图文件变化时重新触发构建，并在浏览器中刷新页面。这就是 `npm run dev` 为你做的事情。
- en: Your built files will end up in the *public/build/assets* folder of your app,
    with a file living at *public/build/manifest.json* that tells Laravel and Vite
    how to get to each built file from its nonbuilt path reference.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的构建文件将会存放在应用的 *public/build/assets* 文件夹中，同时还有一个位于 *public/build/manifest.json*
    的文件，它告诉 Laravel 和 Vite 如何从非构建路径引用到每一个构建文件。
- en: Note
  id: totrans-99
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The *public/build* folder is ignored by default in Laravel’s *.gitignore*, so
    make sure to run `npm run build` as a part of your deployment process.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Laravel 的 *.gitignore* 忽略 *public/build* 文件夹，所以确保在部署过程中运行 `npm run build`。
- en: The Vite Dev Server
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Vite 开发服务器
- en: When you run `npm run dev`, you’re spinning up an actual HTTP server, powered
    by Vite. The Vite Blade helper rewrites your asset URLs to point to the same locations
    on the dev server instead of on your local domain, which allows Vite to more quickly
    update and refresh your dependencies.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行 `npm run dev` 时，你会启动一个由 Vite 提供支持的实际 HTTP 服务器。Vite Blade 辅助程序会重写你的资产 URL，指向开发服务器上的相同位置，而不是你的本地域名，这使得
    Vite 能够更快地更新和刷新你的依赖。
- en: 'This means that if you write the following Blade call:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，如果你编写以下 Blade 调用：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It’ll look like this on your production application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的生产应用程序上看起来会是这样：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'But it’ll look something like this locally if your Vite server is running:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你的 Vite 服务器在本地运行，情况会是这样的：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Working with Static Assets and Vite
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用静态资产和 Vite
- en: So far we’ve only covered loading JavaScript and CSS with Vite. But Laravel’s
    Vite configuration can process and version your static assets (like images), as
    well.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只覆盖了使用 Vite 加载 JavaScript 和 CSS。但是 Laravel 的 Vite 配置可以处理和版本化你的静态资产（如图像）。
- en: If you’re working in JavaScript templates, Vite will grab the links to any *relative*
    static assets and process and version them. Any *absolute* static assets Vite
    will ignore.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在JavaScript模板中工作，Vite将会抓取任何*相对*静态资产的链接，并处理和版本化它们。任何*绝对*静态资产Vite都会忽略。
- en: This means the following images will receive different treatment, if they’re
    in JavaScript templates.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果它们在JavaScript模板中，以下图像将会接受不同的处理。
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you’re working in Blade templates, you’ll need to take two steps to have
    Vite handle your static assets. First, you’ll want to use the `Vite::asset` facade
    call to link your asset:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Blade模板中工作，你需要采取两步来让Vite处理你的静态资产。首先，你需要使用`Vite::asset`门面调用来链接你的资产：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And second, you’ll need to add a configuration step to your *resources/js/app.js*
    file that shows Vite which files or folders to import:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你需要在*resources/js/app.js*文件中添加配置步骤，向Vite展示要导入的文件或文件夹：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Warning
  id: totrans-118
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you’re running the Vite server with `npm run dev`, the server can load your
    static assets *without* you adding the `import.meta.glob` config. That means you
    may think it’s going to show up, but it will fail on your production build.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`npm run dev`运行Vite服务器，服务器可以加载你的静态资产，*无需*你添加`import.meta.glob`配置。这意味着你可能认为它会出现，但在你的生产构建中将会失败。
- en: Working with JavaScript Frameworks and Vite
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与JavaScript框架和Vite一起工作
- en: If you want to work with Vue, React, Inertia, and/or a single-page application
    (SPA), you may need to bring in some specific plug-ins or set some specific configuration
    items. Here are the basics of what you need for the most common scenarios.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要与Vue、React、Inertia和/或单页面应用程序（SPA）一起工作，你可能需要引入一些特定的插件或设置一些特定的配置项。这里是你在最常见场景下所需的基本内容。
- en: Vite and Vue
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vite 和 Vue
- en: 'To work with Vite and Vue, first install Vite’s Vue plug-in:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Vite和Vue一起工作，首先安装Vite的Vue插件：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then you need to modify your *vite.config.js* file to call the Vue plug-in,
    passing two configuration settings to it. The first, `template.transformAssetUrls.base=null`,
    allows the Laravel plug-in instead of the Vue plug-in to handle rewriting URLs.
    The second, `template.transformAssetUrls.includeAbsolute=false`, allows URLs within
    Vue templates to reference files in the public directory:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要修改你的*vite.config.js*文件来调用Vue插件，并向其传递两个配置设置。第一个，`template.transformAssetUrls.base=null`，允许Laravel插件而不是Vue插件处理重写URL。第二个，`template.transformAssetUrls.includeAbsolute=false`，允许Vue模板内的URL引用公共目录中的文件：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Vite and React
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vite 和 React
- en: 'To work with Vite and React, first install Vite’s React plug-in:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要与Vite和React一起工作，首先安装Vite的React插件：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then you need to modify your *vite.config.js* file to call the React plug-in:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要修改你的*vite.config.js*文件来调用React插件：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, add the `@viteReactRefresh` Blade directive in your template before
    you import your JavaScript files with `@vite`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在你导入JavaScript文件之前，在模板中添加`@viteReactRefresh` Blade指令：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Vite and Inertia
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vite 和 Inertia
- en: If you’re setting up Inertia yourself, you’ll need Inertia to be able to resolve
    your page components.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在自行设置Inertia，你需要Inertia能够解析你的页面组件。
- en: Here’s a look at the code you’ll likely write in your *resources/js/app.js*
    file, but your best option is to install Inertia using Breeze, Jetstream, or the
    Inertia docs.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你可能会在*resources/js/app.js*文件中编写的代码示例，但你最好的选择是使用Breeze、Jetstream或Inertia文档安装Inertia。
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Vite and SPAs
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Vite 和 SPAs
- en: If you’re building an SPA, remove *resources/css/app.css* from your *vite.config.js*
    file, which removes it as an entry point.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建SPA，请从你的*vite.config.js*文件中移除*resources/css/app.css*，这将它从入口点中移除。
- en: 'Instead, import your CSS into your JavaScript by adding this line to your *resources/js/app,js*
    file, directly below importing the bootstrap:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，通过在*resources/js/app.js*文件中在引入bootstrap之下添加这一行，将你的CSS导入到JavaScript中：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using Environment Variables in Vite
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Vite中使用环境变量
- en: If you want to use environment variables in your JavaScript files, prefix the
    variable name with `VITE_`, as you can see in [Example 6-3](#EX525).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的JavaScript文件中使用环境变量，请以`VITE_`为前缀变量名，就像你在[示例 6-3](#EX525)中看到的那样。
- en: Example 6-3\. Referencing environment variables in vite.config.js
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. 在vite.config.js中引用环境变量
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Every time you run `npm run dev` or `npm run build`, it’ll load that environment
    variable from *.env* and inject it into your script.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 每次运行`npm run dev`或`npm run build`时，它都会从*.env*中加载该环境变量，并将其注入到你的脚本中。
- en: Pagination
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分页
- en: For something that is so common across web applications, pagination still can
    be wildly complicated to implement. Thankfully, Laravel has a built-in concept
    of pagination, which is also hooked into Eloquent results *and* the router by
    default.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 Web 应用程序中分页是如此常见，但实现起来仍然可能非常复杂。幸运的是，Laravel 默认已经集成了分页的概念，并且默认已经与 Eloquent
    结果和路由器关联起来。
- en: Paginating Database Results
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分页数据库结果
- en: The most common place you’ll see pagination is when you are displaying the results
    of a database query and there are too many results for a single page. Eloquent
    and the query builder both read the `page` query parameter from the current page
    request and use it to provide a `paginate()` method on any result sets; the single
    parameter you should pass `paginate()` indicates how many results you want per
    page. Take a look at [Example 6-4](#EX512) to see how this works.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您最常见到分页的地方是当您显示数据库查询结果并且结果太多以至于无法在单个页面中显示时。Eloquent 和查询构建器都从当前页面请求的 `page` 查询参数中读取，并使用它在任何结果集上提供一个
    `paginate()` 方法；您应该传递给 `paginate()` 的单个参数指示您希望每页显示多少结果。查看[示例 6-4](#EX512)了解其工作原理。
- en: Example 6-4\. Paginating a query builder response
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. 对查询构建器响应进行分页
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Example 6-4](#EX512) specifies that this route should return 20 posts per
    page and will define which “page” of results the current user is on based on the
    URL’s `page` query parameter, if it has one. Eloquent models all have the same
    `paginate()` method.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-4](#EX512) 指定该路由应每页返回 20 篇文章，并根据 URL 的 `page` 查询参数定义当前用户所在的“页面”结果。所有
    Eloquent 模型都具有相同的 `paginate()` 方法。'
- en: When you display the results in your view, your collection will now have a `links()`
    method on it that will output the pagination controls. (See [Example 6-5](#EX513),
    which I’ve simplified for inclusion in this book.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在视图中显示结果时，您的集合现在将具有一个 `links()` 方法，该方法将输出分页控件。（参见[示例 6-5](#EX513)，我已将其简化以便包含在本书中。）
- en: Example 6-5\. Rendering pagination links in a template
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. 在模板中呈现分页链接
- en: '[PRE26]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The paginator uses TailwindCSS for its default styling. If you want to use
    Bootstrap styles, call `Paginator::useBootstrap()` in your `AppServiceProvider`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 分页器使用 TailwindCSS 进行默认样式设置。如果您想使用 Bootstrap 样式，请在 `AppServiceProvider` 中调用 `Paginator::useBootstrap()`：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Customizing the Number of Pagination Links
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义分页链接的数量
- en: 'If you’d like to control how many links display on either side of the current
    page, you can customize this number easily with the `onEachSide()` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望控制当前页面两侧显示多少链接，您可以使用 `onEachSide()` 方法轻松自定义此数字：
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Manually Creating Paginators
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动创建分页器
- en: If you’re not working with Eloquent or the query builder, or if you’re working
    with a complex query (e.g., one using `groupBy`), you might find yourself needing
    to create a paginator manually. Thankfully, you can do that with the `Illuminate\Pagination\Paginator`
    or `Illuminate\Pagination\LengthAwarePaginator` classes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不使用 Eloquent 或查询构建器，或者正在使用复杂的查询（例如使用 `groupBy` 的查询），您可能会发现自己需要手动创建分页器。幸运的是，您可以使用
    `Illuminate\Pagination\Paginator` 或 `Illuminate\Pagination\LengthAwarePaginator`
    类来实现这一点。
- en: The difference between the two classes is that `Paginator` provides only previous
    and next buttons, but no links to each page; `LengthAwarePaginator` needs to know
    the length of the full result so that it can generate links for each individual
    page. You may find yourself wanting to use `Paginator` on large result sets so
    your paginator doesn’t have to be aware of a massive count of results that might
    be costly to run.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个类的区别在于 `Paginator` 只提供上一页和下一页按钮，但没有每一页的链接；`LengthAwarePaginator` 需要知道完整结果的长度，以便可以为每个单独的页面生成链接。您可能会发现在大结果集上使用
    `Paginator` 是有用的，这样您的分页器不必了解可能昂贵运行的大量结果数量。
- en: Both `Paginator` and `LengthAwarePaginator` require you to manually extract
    the subset of content that you want to pass to the view. Take a look at [Example 6-6](#EX514)
    for an example.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Paginator` 和 `LengthAwarePaginator` 都要求您手动提取您希望传递给视图的内容子集。查看[示例 6-6](#EX514)了解示例。'
- en: Example 6-6\. Manually creating a paginator
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-6\. 手动创建分页器
- en: '[PRE29]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Message Bags
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息包
- en: 'Another common-but-painful feature in web applications is passing messages
    between various components of the app, when the end goal is to share them with
    the user. Your controller, for example, might want to send a validation message:
    “The `email` field must be a valid email address.” However, that particular message
    doesn’t just need to make it to the view layer; it actually needs to survive a
    redirect and then end up in the view layer of a different page. How do you structure
    this messaging logic?'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'Another common-but-painful feature in web applications is passing messages
    between various components of the app, when the end goal is to share them with
    the user. Your controller, for example, might want to send a validation message:
    “The `email` field must be a valid email address.” However, that particular message
    doesn’t just need to make it to the view layer; it actually needs to survive a
    redirect and then end up in the view layer of a different page. How do you structure
    this messaging logic?'
- en: The `Illuminate\Support\MessageBag` class is tasked with storing, categorizing,
    and returning messages that are intended for the end user. It groups all messages
    by key, where the keys are likely to be something like `errors` or `messages`,
    and it provides convenience methods for getting either all its stored messages
    or only those for a particular key, and outputting these messages in various formats.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: The `Illuminate\Support\MessageBag` class is tasked with storing, categorizing,
    and returning messages that are intended for the end user. It groups all messages
    by key, where the keys are likely to be something like `errors` or `messages`,
    and it provides convenience methods for getting either all its stored messages
    or only those for a particular key, and outputting these messages in various formats.
- en: You can spin up a new instance of `MessageBag` manually like in [Example 6-7](#EX515).
    To be honest, though, you likely won’t ever do this manually—​this is just a thought
    exercise to show how it works.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: You can spin up a new instance of `MessageBag` manually like in [Example 6-7](#EX515).
    To be honest, though, you likely won’t ever do this manually—​this is just a thought
    exercise to show how it works.
- en: Example 6-7\. Manually creating and using a message bag
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-7\. Manually creating and using a message bag
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Message bags are also closely connected to Laravel’s validators (you’ll learn
    more about these in [“Validation”](ch07.html#validation)): when validators return
    errors, they actually return an instance of `MessageBag`, which you can then pass
    to your view or attach to a redirect using `redirect(''route'')->withErrors($messagebag)`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'Message bags are also closely connected to Laravel’s validators (you’ll learn
    more about these in [“Validation”](ch07.html#validation)): when validators return
    errors, they actually return an instance of `MessageBag`, which you can then pass
    to your view or attach to a redirect using `redirect(''route'')->withErrors($messagebag)`.'
- en: Laravel passes an empty instance of `MessageBag` to every view, assigned to
    the variable `$errors`; if you’ve flashed a message bag using `withErrors()` on
    a redirect, it will get assigned to that `$errors` variable instead. That means
    every view can always assume it has an `$errors` `MessageBag` that it can check
    wherever it handles validation, which leads to [Example 6-8](#EX516) as a common
    snippet developers place on every page.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel passes an empty instance of `MessageBag` to every view, assigned to
    the variable `$errors`; if you’ve flashed a message bag using `withErrors()` on
    a redirect, it will get assigned to that `$errors` variable instead. That means
    every view can always assume it has an `$errors` `MessageBag` that it can check
    wherever it handles validation, which leads to [Example 6-8](#EX516) as a common
    snippet developers place on every page.
- en: Example 6-8\. Error bag snippet
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 6-8\. Error bag snippet
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Missing $errors Variable
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Missing $errors Variable
- en: If you have any routes that aren’t under the `web` middleware group, they won’t
    have the session middleware, which means they won’t have this `$errors` variable
    available.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: If you have any routes that aren’t under the `web` middleware group, they won’t
    have the session middleware, which means they won’t have this `$errors` variable
    available.
- en: Sometimes you need to differentiate message bags not just by key (`notices`
    versus `errors`) but also by component. Maybe you have a login form and a signup
    form on the same page; how do you differentiate them?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Sometimes you need to differentiate message bags not just by key (`notices`
    versus `errors`) but also by component. Maybe you have a login form and a signup
    form on the same page; how do you differentiate them?
- en: 'When you send errors along with a redirect using `withErrors()`, the second
    parameter is the name of the bag: `redirect(''dashboard'')->withErrors($validator,
    ''login'')`. Then, on the dashboard, you can use `$errors->login` to call all
    of the methods you saw before: `any()`, `count()`, and more.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'When you send errors along with a redirect using `withErrors()`, the second
    parameter is the name of the bag: `redirect(''dashboard'')->withErrors($validator,
    ''login'')`. Then, on the dashboard, you can use `$errors->login` to call all
    of the methods you saw before: `any()`, `count()`, and more.'
- en: String Helpers, Pluralization, and Localization
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: String Helpers, Pluralization, and Localization
- en: As developers, we tend to look at blocks of text as big placeholder divs, waiting
    for the client to put real content into them. Seldom are we involved in any logic
    inside these blocks.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: As developers, we tend to look at blocks of text as big placeholder divs, waiting
    for the client to put real content into them. Seldom are we involved in any logic
    inside these blocks.
- en: But there are a few circumstances where you’ll be grateful for the tools Laravel
    provides for string manipulation.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但在一些情况下，你会感谢 Laravel 提供的字符串操作工具。
- en: The String Helpers and Pluralization
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串助手和复数形式
- en: Laravel has a series of helpers for manipulating strings. They’re available
    as methods on the `Str` class (e.g., `Str::plural()`).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 提供了一系列用于操作字符串的助手。它们作为 `Str` 类的方法可用（例如，`Str::plural()`）。
- en: Laravel String and Array Global Helpers
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Laravel 字符串和数组全局助手
- en: 'Older versions of Laravel included global helpers that were aliases for the
    `Str` and `Arr` methods. These global `str_` and `array_` helpers were removed
    from Laravel in version 6 and exported to a separate package. If you’d like, you
    can install the `laravel/helpers` package via Composer: `composer require laravel/helpers`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的 Laravel 包括全局辅助函数，它们是 `Str` 和 `Arr` 方法的别名。这些全局的 `str_` 和 `array_` 辅助函数在
    Laravel 6 版本中被移除，并导出到一个单独的包中。如果你愿意，你可以通过 Composer 安装 `laravel/helpers` 包：`composer
    require laravel/helpers`。
- en: 'The Laravel [documentation](https://oreil.ly/vssfi) covers all of the string
    helpers in detail, but here are a few of the most commonly used ones:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel 的 [文档](https://oreil.ly/vssfi) 详细介绍了所有字符串助手，但以下是一些常用的助手：
- en: '`e()`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`e()`'
- en: A shortcut for `html_entities()`; encodes all HTML entities for safety.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`html_entities()` 的快捷方式；对所有 HTML 实体进行编码，以确保安全性。'
- en: '`Str::startsWith()`, `Str::endsWith()`, `Str::contains()`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`Str::startsWith()`, `Str::endsWith()`, `Str::contains()`'
- en: Checks a string (first parameter) to see if it starts with, ends with, or contains
    another string (second parameter).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串（第一个参数）是否以另一个字符串（第二个参数）开头、结尾或包含。
- en: '`Str::is()`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`Str::is()`'
- en: Checks whether a string (second parameter) matches a particular pattern (first
    parameter)—for example, `foo*` will match `foobar` and `foobaz`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字符串（第二个参数）是否与特定模式（第一个参数）匹配 —— 例如，`foo*` 将匹配 `foobar` 和 `foobaz`。
- en: '`Str::slug()`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Str::slug()`'
- en: Converts a string to a URL-type slug with hyphens.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 将字符串转换为带连字符的 URL 类型的 slug。
- en: '`Str::plural(*word*, *count*)`, `Str::singular()`'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Str::plural(*word*, *count*)`, `Str::singular()`'
- en: Pluralizes or singularizes a word; English only (e.g., `Str::plural('dog')`
    returns `dogs`; `Str::plural('dog,' 1'))` returns `dog`).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使单词变为复数或单数；仅支持英语（例如，`Str::plural('dog')` 返回 `dogs`； `Str::plural('dog,' 1'))`
    返回 `dog`）。
- en: '`Str::camel()`, `Str::kebab()`, `Str::snake()`, `Str::studly()`, `Str::title()`'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`Str::camel()`, `Str::kebab()`, `Str::snake()`, `Str::studly()`, `Str::title()`'
- en: Converts a provided string to a different capitalization “case.”
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 将提供的字符串转换为不同的大小写 "case"。
- en: '`Str::after()`, `Str::before()`, `Str::limit()`'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`Str::after()`, `Str::before()`, `Str::limit()`'
- en: Trims a string and provides a substring. `Str::after()` returns everything after
    a given string, and `Str::before()` returns everything before a given string (both
    accept the full string as the first parameter and the string you’re using to cut
    as the second). `Str::limit()` truncates a string (first parameter) to a given
    number of characters (second parameter).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 对字符串进行修剪并提供子字符串。`Str::after()` 返回给定字符串之后的所有内容，而 `Str::before()` 返回给定字符串之前的所有内容（两者都接受完整的字符串作为第一个参数，以及作为第二个参数用于切割的字符串）。`Str::limit()`
    将字符串（第一个参数）截断为指定数量的字符（第二个参数）。
- en: '`Str::markdown(*string*, *options*)`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Str::markdown(*string*, *options*)`'
- en: Converts Markdown into HTML. You can read more about the options you can pass
    on [the PHP league website](https://oreil.ly/3zOdm).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Markdown 转换为 HTML。您可以在 [PHP League 网站](https://oreil.ly/3zOdm) 上阅读有关您可以传递的选项的更多信息。
- en: '`Str::replace(*search*, *replace*, *subject*, *caseSensitive*)`'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`Str::replace(*search*, *replace*, *subject*, *caseSensitive*)`'
- en: Looks in the subject string for the search string occurrence and replaces it
    with the replace string. If the case sensitivity parameter is true, only replace
    if the occurrence matches the search case (e.g., `Str::replace('Running', 'Going',
    'Laravel Up and Running', true)` returns `'Laravel Up and Going'`).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在主题字符串中查找搜索字符串出现的位置，并用替换字符串替换它。如果 caseSensitive 参数为 true，则只有当出现与搜索案例匹配时才进行替换（例如，`Str::replace('Running',
    'Going', 'Laravel Up and Running', true)` 返回 `'Laravel Up and Going'`）。
- en: Localization
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地化
- en: Localization enables you to define multiple languages and mark any strings as
    targets for translation. You can set a fallback language and even handle pluralization
    variations.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化使您能够定义多种语言，并将任何字符串标记为翻译目标。您可以设置一个回退语言，甚至处理复数形式的变化。
- en: In Laravel, you’ll need to set an “application locale” at some point during
    the page load so the localization helpers know which bucket of translations to
    pull from. Each “locale” is usually connected to a translation and will often
    look like “en” (for English). You’ll do this with `App::setLocale($localeName)`,
    and you’ll likely put it in a service provider. For now, you can just put it in
    the `boot()` method of `AppServiceProvider`, but you may want to create a `LocaleServiceProvider`
    if you end up with more than just this one locale-related binding.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Laravel中，您需要在页面加载过程中的某个时刻设置“应用程序区域设置”，以便本地化助手知道从哪个翻译桶中获取翻译。每个“区域设置”通常与一个翻译相关联，通常看起来像“en”（英语）。您可以使用`App::setLocale($localeName)`来实现这一点，您可能会将其放在服务提供程序中。现在，您可以将其放在`AppServiceProvider`的`boot()`方法中，但如果您最终拥有多个与区域设置相关的绑定，可能需要创建一个`LocaleServiceProvider`。
- en: You can define your fallback locale in *config/app.php*, where you should find
    a `fallback_locale` key. This allows you to define a default language for your
    application, which Laravel will use if it can’t find a translation for the requested
    locale.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*config/app.php*中定义您的回退区域设置，那里应该有一个`fallback_locale`键。这允许您为应用程序定义一个默认语言，在无法找到请求的区域设置的翻译时，Laravel将使用它。
- en: Basic localization
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本本地化
- en: So, how do we call for a translated string? There’s a helper function, `__($key)`,
    that will pull the string for the current locale for the passed key or, if it
    doesn’t exist, grab it from the default locale. In Blade you can also use the
    `@lang()` directive. [Example 6-9](#EX517) demonstrates how a basic translation
    works. We’ll use the example of a “back to the dashboard” link at the top of a
    detail page.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何调用翻译字符串呢？有一个辅助函数，`__($key)`，它将为传递的键在当前区域设置中获取字符串，或者如果不存在，则从默认区域设置中获取。在Blade中，您还可以使用`@lang()`指令。[示例 6-9](#EX517)演示了基本翻译的工作方式。我们将使用“返回仪表板”链接的示例作为详细页面顶部的示例。
- en: Example 6-9\. Basic use of `__()`
  id: totrans-215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-9\. `__()` 的基本使用
- en: '[PRE32]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let’s assume we are using the `es` locale right now. First, we’ll need to publish
    the `lang` files for modification:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在正在使用`es`区域设置。首先，我们需要发布用于修改的`lang`文件：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This command publishes the default Laravel `lang` files to the root of your
    application. You’ll want to create a file to define your navigation-related translations,
    *lang/en/navigation.php*, and have it return a PHP array with a key named `back`
    in it, as in [Example 6-10](#sample_navigation_en_file).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会将默认的Laravel `lang`文件发布到应用程序的根目录。您需要创建一个文件来定义与导航相关的翻译，*lang/en/navigation.php*，并返回一个包含键名为`back`的PHP数组，如[示例 6-10](#sample_navigation_en_file)所示。
- en: Example 6-10\. Example lang/en/navigation.php file
  id: totrans-221
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-10\. 示例 lang/en/navigation.php 文件
- en: '[PRE35]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now, to make this translatable, let’s also create an *es* directory under *lang*,
    with its own *navigation.php* file, as you can see in [Example 6-11](#sample_navigation_es_file).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了使其可翻译，让我们在*lang*下创建一个*es*目录，并创建其自己的*navigation.php*文件，正如您在[示例 6-11](#sample_navigation_es_file)中所见。
- en: Example 6-11\. Example lang/es/navigation.php file
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-11\. 示例 lang/es/navigation.php 文件
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now let’s try using that translation key in our app, in [Example 6-12](#EX518).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试在我们的应用程序中使用该翻译键，在[示例 6-12](#EX518)中。
- en: Example 6-12\. Using a translation
  id: totrans-227
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-12\. 使用翻译
- en: '[PRE37]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Parameters in localization
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地化中的参数
- en: The preceding example was relatively simple. Let’s dig into some that are more
    complex. What if we want to define *which* dashboard we’re returning to? Take
    a look at [Example 6-13](#EX519).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例比较简单。让我们深入了解一些更复杂的内容。如果我们想要定义我们要返回的*哪一个*仪表板呢？看看[示例 6-13](#EX519)。
- en: Example 6-13\. Parameters in translations
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-13\. 翻译中的参数
- en: '[PRE38]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, prepending a word with a colon (`:section`) marks it as a placeholder
    that can be replaced. The second, optional, parameter of `__()` is an array of
    values to replace the placeholders.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，用冒号(`:section`)标记一个单词，将其视为可以替换的占位符。`__()`的第二个可选参数是一个替换占位符的值数组。
- en: Pluralization in localization
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地化中的复数形式
- en: We already covered pluralization, so now just imagine you’re defining your own
    pluralization rules. There are two ways to do it; we’ll start with the simplest,
    as shown in [Example 6-14](#EX520).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了复数形式，现在想象一下您正在定义自己的复数形式规则。有两种方法可以做到这一点；我们将从最简单的方法开始，如[示例 6-14](#EX520)所示。
- en: Example 6-14\. Defining a simple translation with an option for pluralization
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-14\. 定义具有复数形式选项的简单翻译
- en: '[PRE39]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As you can see, we have a `trans_choice()` method, which takes the count of
    items affected as its second parameter; from this, it will determine which string
    to use.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们有一个`trans_choice()`方法，它将受影响项目的计数作为其第二个参数；从中，它将确定要使用哪个字符串。
- en: You can also use any translation definitions that are compatible with Symfony’s
    much more complex `Translation` component; see [Example 6-15](#EX521) for an example.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用与Symfony的更复杂的`Translation`组件兼容的任何翻译定义；参见[示例 6-15](#EX521)作为示例。
- en: Example 6-15\. Using the Symfony `Translation` component
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-15\. 使用Symfony `Translation`组件
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Storing the default string as the key with JSON
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用JSON存储默认字符串作为键
- en: One common difficulty with localization is that it’s hard to ensure there’s
    a good system for defining key namespacing—​for example, remembering a key nested
    three or four levels deep or being unsure which key a phrase used twice in the
    site should use.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 本地化的一个常见难点是确保有一个良好的定义键命名空间的系统——例如，记住三四级嵌套的键或不确定站点中使用两次的短语应该使用哪个键。
- en: An alternative to the slug key/string value pair system is to store your translations
    using your primary language string as the key, instead of a made-up slug. You
    can indicate to Laravel that you’re working this way by storing your translation
    files as JSON in the *lang* directory, with the filename reflecting the locale
    ([Example 6-16](#EX6a)).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于slug键/字符串值对系统的另一种选择是使用主语言字符串作为键存储您的翻译，而不是使用虚构的slug。您可以通过在*lang*目录中以JSON格式存储翻译文件，并使用反映区域设置的文件名来指示Laravel，以表明您正在这样工作（参见[示例 6-16](#EX6a)）。
- en: Example 6-16\. Using JSON translations and the `__()` helper
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-16\. 使用JSON翻译和`__()`助手
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This is taking advantage of the fact that the `__()` translation helper, if
    it can’t find a matching key for the current language, will just display the key.
    If your key is the string in your app’s default language, that’s a much more reasonable
    fallback than, for example, `widgets.friends.title`.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这是利用了`__()`翻译助手的一个事实，如果它找不到当前语言的匹配键，它将只显示键。如果您的键是应用程序默认语言中的字符串，那么这比如`widgets.friends.title`之类的做法更合理。
- en: Testing
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: In this chapter we focused primarily on Laravel’s frontend components. These
    are less likely the objects of unit tests, but they may at times be used in your
    integration tests.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们主要关注了Laravel的前端组件。这些组件不太可能成为单元测试的对象，但有时可能会在集成测试中使用。
- en: Testing Message and Error Bags
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试消息和错误包
- en: There are two primary ways of testing messages passed along with message and
    error bags. First, you can perform a behavior in your application tests that sets
    a message that will eventually be displayed somewhere, then redirect to that page
    and assert that the appropriate message is shown.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 传递消息和错误包的消息的主要测试方法有两种。首先，您可以在应用程序测试中执行一个行为，设置最终将在某个地方显示的消息，然后重定向到该页面，并断言显示适当的消息。
- en: Second, for errors (which is the most common use case), you can assert the session
    has errors with `$this->assertSessionHasErrors($bindings = [])`. Take a look at
    [Example 6-17](#EX522) to see what this might look like.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，对于错误（这是最常见的用例），您可以使用`$this->assertSessionHasErrors($bindings = [])`断言会话存在错误。看一下[示例 6-17](#EX522)，看看可能的显示方式。
- en: Example 6-17\. Asserting the session has errors
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-17\. 断言会话存在错误
- en: '[PRE43]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In order for [Example 6-17](#EX522) to pass, you’ll need to add input validation
    to that route. We’ll cover this in [Chapter 7](ch07.html#collecting_and_handling_user_data).
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使[示例 6-17](#EX522)通过，您需要在该路由上添加输入验证。我们将在[第7章](ch07.html#collecting_and_handling_user_data)中介绍这个。
- en: Translation and Localization
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 翻译和本地化
- en: The simplest way to test localization is with application tests. Set the appropriate
    context (whether by URL or session), “visit” the page with `get()`, and assert
    that you see the appropriate content.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 测试本地化的最简单方法是使用应用程序测试。设置适当的上下文（无论是通过URL还是会话），使用`get()`“访问”页面，并断言您看到适当的内容。
- en: Disabling Vite in Testing
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在测试中禁用 Vite
- en: 'If you’d like to disable Vite’s asset resolution during your tests, you can
    disable Vite entirely by calling the `withoutVite()` method at the top of a test:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在测试期间禁用Vite的资产解析，可以通过在测试顶部调用`withoutVite()`方法完全禁用Vite：
- en: '[PRE44]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: TL;DR
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TL;DR
- en: As a full stack framework, Laravel provides tools and components for the frontend
    as well as the backend.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个全栈框架，Laravel提供了用于前端和后端的工具和组件。
- en: Vite is a build tool and dev server that Laravel builds on top of to help process,
    compress, and version your JavaScript, CSS, and static assets like images.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Vite是一个构建工具和开发服务器，Laravel在其上构建，帮助处理、压缩和版本化JavaScript、CSS和静态资源（如图像）。
- en: Laravel also offers other internal tools that target the frontend, including
    tools for implementing pagination, message and error bags, and localization.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Laravel还提供了针对前端的其他内部工具，包括用于实现分页、消息和错误包以及本地化的工具。
