- en: Chapter 6\. Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。对象
- en: In this chapter you’ll learn how to define, create, and use objects in PHP.
    Object-oriented programming (OOP) opens the door to cleaner designs, easier maintenance,
    and greater code reuse. OOP has proven so valuable that few today would dare to
    introduce a language that wasn’t object-oriented. PHP supports many useful features
    of OOP, and this chapter shows you how to use them, covering basic OOP concepts
    as well as advanced topics such as introspection and serialization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何在PHP中定义、创建和使用对象。面向对象编程（OOP）为更清晰的设计、更容易的维护和更大的代码重用打开了大门。OOP已被证明非常有价值，以至于今天很少有人敢引入非面向对象的语言。PHP支持OOP的许多有用功能，本章将向您展示如何使用它们，涵盖基本的OOP概念以及诸如内省和序列化等高级主题。
- en: Objects
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: Object-oriented programming acknowledges the fundamental connection between
    data and the code that works on it, and lets you design and implement programs
    around that connection. For example, a bulletin-board system usually keeps track
    of many users. In a procedural programming language, each user is represented
    by a data structure, and there would probably be a set of functions that work
    with those data structures (to create the new users, get their information, etc.).
    In an OOP language, each user is represented by an *object*—a data structure with
    attached code. The data and the code are still there, but they’re treated as an
    inseparable unit. The object, as a union of code and data, is the modular unit
    for application development and code reuse.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程承认数据与处理数据的代码之间的基本联系，并允许您围绕该联系设计和实现程序。例如，公告板系统通常跟踪许多用户。在过程式编程语言中，每个用户由一个数据结构表示，并且可能有一组函数用于处理这些数据结构（创建新用户、获取他们的信息等）。在面向对象的语言中，每个用户由一个*对象*表示—一个附带代码的数据结构。数据和代码仍然存在，但它们被视为一个不可分割的单元。对象作为代码和数据的结合体，是应用程序开发和代码重用的模块化单元。
- en: In this hypothetical bulletin-board design, objects can represent not just users
    but also messages and threads. A user object has a username and password for that
    user, and code to identify all the messages by that author. A message object knows
    which thread it belongs to and has code to post a new message, reply to an existing
    message, and display messages. A thread object is a collection of message objects,
    and it has code to display a thread index. This is only one way of dividing the
    necessary functionality into objects, though. For instance, in an alternate design,
    the code to post a new message lives in the user object, not the message object.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个假设的公告板设计中，对象不仅可以代表用户，还可以代表消息和主题。用户对象为该用户具有用户名和密码，并具有用于识别该作者的所有消息的代码。消息对象知道它属于哪个主题，并具有发布新消息、回复现有消息和显示消息的代码。主题对象是消息对象的集合，并具有显示主题索引的代码。然而，将必要功能划分为对象的方式只是其中一种。例如，在另一种设计中，发布新消息的代码存在于用户对象中，而不是消息对象中。
- en: Designing object-oriented systems is a complex topic, and many books have been
    written on it. The good news is that however you design your system, you can implement
    it in PHP. Let’s begin by introducing some of the key terms and concepts you’ll
    need to know before diving into this programming approach.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 设计面向对象系统是一个复杂的主题，已经有许多书籍写就。好消息是，无论您如何设计系统，都可以在PHP中实现它。让我们首先介绍一些在深入研究这种编程方法之前需要了解的关键术语和概念。
- en: Terminology
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 术语
- en: Every object-oriented language seems to have a different set of terms for the
    same old concepts. This section describes the terms that PHP uses, but be warned
    that in other languages these terms may have other meanings.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 每种面向对象语言似乎对相同的概念有不同的术语集。本节描述了PHP使用的术语，但请注意，在其他语言中，这些术语可能具有其他含义。
- en: Let’s return to the example of the users of a bulletin board. You need to keep
    track of the same information for each user, and the same functions can be called
    on each user’s data structure. When you design the program, you decide the fields
    for each user and come up with the functions. In OOP terms, you’re designing the
    user *class*. A class is a template for building objects.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到公告板用户的例子。您需要为每个用户跟踪相同的信息，并且可以在每个用户的数据结构上调用相同的函数。当您设计程序时，您决定每个用户的字段并提出函数。在面向对象编程术语中，您正在设计用户*类*。类是构建对象的模板。
- en: An *object* is an instance (or occurrence) of a class. In this case, it’s an
    actual user data structure with attached code. Objects and classes are a bit like
    values and data types. There’s only one integer data type, but there are many
    possible integers. Similarly, your program defines only one user class but can
    create many different (or identical) users from it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象*是类的一个实例（或发生）。在这种情况下，它是一个具有附加代码的实际用户数据结构。对象和类有点像值和数据类型。只有一个整数数据类型，但可能有许多可能的整数。类似地，您的程序仅定义一个用户类，但可以从中创建许多不同（或相同）的用户。'
- en: The data associated with an object are called its *properties*. The functions
    associated with an object are called its *methods*. When you define a class, you
    define the names of its properties and give the code for its methods.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与对象关联的数据称为其*属性*。与对象关联的函数称为其*方法*。当您定义一个类时，您定义其属性的名称并给出其方法的代码。
- en: Debugging and maintenance of programs is much easier if you use *encapsulation*.
    This is the idea that a class provides certain methods (the *interface*) to the
    code that uses its objects, so the outside code does not directly access the data
    structures of those objects. Debugging is thus easier because you know where to
    look for bugs—the only code that changes an object’s data structures is within
    the class—and maintenance is easier because you can swap out implementations of
    a class without changing the code that uses the class, as long as you maintain
    the same interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用*封装*，程序的调试和维护将变得更容易。这是一个类提供一定方法（*接口*）给使用其对象的代码的想法，因此外部代码不直接访问这些对象的数据结构。因此，调试更容易，因为您知道在哪里查找错误——只有更改对象数据结构的代码位于类内部——维护更容易，因为您可以在不更改使用类的代码的情况下交换类的实现，只要保持相同的接口。
- en: Any nontrivial object-oriented design probably involves *inheritance*. This
    is a way of defining a new class by saying that it’s like an existing class, but
    with certain new or changed properties and methods. The original class is called
    the *superclass* (or parent or base class), and the new class is called the *subclass*
    (or derived class). Inheritance is a form of code reuse—the superclass code is
    reused instead of being copied and pasted into the subclass. Any improvements
    or modifications to the superclass are automatically passed on to the subclass.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何非平凡的面向对象设计可能都涉及*继承*。这是通过指定一个新类说它像现有类一样，但具有某些新的或更改的属性和方法的一种方式。原始类称为*超类*（或父类或基类），新类称为*子类*（或派生类）。继承是代码重用的一种形式——超类代码被重用，而不是复制粘贴到子类中。对超类的任何改进或修改都会自动传递到子类。
- en: Creating an Object
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'It’s much easier to create (or *instantiate*) objects and use them than it
    is to define object classes, so before we discuss how to define classes, let’s
    look at creating objects. To create an object of a given class, use the `new`
    keyword:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 创建对象并使用它们比定义对象类要容易得多，因此在我们讨论如何定义类之前，让我们看看如何创建对象。要创建给定类的对象，请使用`new`关键字：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Assuming that a `Person` class has been defined, here’s how to create a `Person`
    object:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设已定义了一个`Person`类，以下是如何创建一个`Person`对象的方法：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Do not quote the class name, or you’ll get a compilation error:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不要引用类名，否则会导致编译错误：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Some classes permit you to pass arguments to the `new` call. The class’s documentation
    should say whether it accepts arguments. If it does, you’ll create objects like
    this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有些类允许您向`new`调用传递参数。类的文档应该说明它是否接受参数。如果接受，您将像这样创建对象：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The class name does not have to be hardcoded into your program. You can supply
    the class name through a variable:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 类名不必硬编码到您的程序中。您可以通过变量提供类名：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Specifying a class that doesn’t exist causes a runtime error.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 指定一个不存在的类会导致运行时错误。
- en: 'Variables containing object references are just normal variables—they can be
    used in the same ways as other variables. Note that variable variables work with
    objects, as shown here:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 包含对象引用的变量只是普通变量——它们可以像其他变量一样使用。注意，变量变量可以与对象一起使用，如下所示：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Accessing Properties and Methods
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问属性和方法
- en: 'Once you have an object, you can use the `->` notation to access methods and
    properties of the object:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有对象，您可以使用`->`符号访问对象的方法和属性：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Methods act the same as functions (only specifically to the object in question),
    so they can take arguments and return a value:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 方法与函数的行为相同（只针对所讨论的对象），因此它们可以接受参数并返回一个值：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Within a class’s definition, you can specify which methods and properties are
    publicly accessible and which are accessible only from within the class itself
    using the public and private access modifiers. You can use these to provide encapsulation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的定义中，你可以使用`public`和`private`访问修饰符来指定哪些方法和属性是公共可访问的，哪些是只能在类内部访问的。你可以使用这些修饰符来提供封装性。
- en: 'You can use variable variables with property names:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用带有属性名称的变量变量：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A static method is one that is called on a class, not on an object. Such methods
    cannot access properties. The name of a static method is the class name followed
    by two colons and the function name. For instance, this calls the `p()` static
    method in the HTML class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法是在类上调用而不是在对象上调用的方法。这样的方法无法访问属性。静态方法的名称是类名后跟两个冒号和函数名。例如，这在HTML类中调用`p()`静态方法：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When declaring a class, you define which properties and methods are static using
    the static access property.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明类时，使用静态访问属性定义哪些属性和方法是静态的。
- en: 'Once created, objects are passed by reference—that is, instead of copying around
    the entire object itself (a time- and memory-consuming endeavor), a reference
    to the object is passed around instead. For example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，对象通过引用传递——也就是说，不是复制整个对象本身（这是一项耗费时间和内存的工作），而是传递对象的引用。例如：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to create a true copy of an object, you use the clone operator:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个对象的真实副本，可以使用克隆运算符：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When you use the clone operator to create a copy of an object and that class
    declares the `__clone()` method, that method is called on the new object immediately
    after it’s cloned. You might use this in cases where an object holds external
    resources (such as file handles) to create new resources, rather than copying
    the existing ones.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用克隆运算符创建对象的副本，并且该类声明了`__clone()`方法时，该方法会在新对象被克隆后立即调用。在对象持有外部资源（如文件句柄）的情况下，你可以使用此方法创建新资源，而不是复制现有资源。
- en: Declaring a Class
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类声明
- en: 'To design your program or code library in an object-oriented fashion, you’ll
    need to define your own classes, using the `class` keyword. A class definition
    includes the class name and the properties and methods of the class. Class names
    are case-insensitive and must conform to the rules for PHP identifiers. Among
    others, the class name `stdClass` is reserved. Here’s the syntax for a class definition:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要以面向对象的方式设计你的程序或代码库，你需要使用`class`关键字定义自己的类。类定义包括类名以及类的属性和方法。类名不区分大小写，必须符合PHP标识符的规则。其中，类名`stdClass`是保留的。以下是类定义的语法：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Declaring Methods
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法声明
- en: A method is a function defined inside a class. Although PHP imposes no special
    restrictions, most methods act only on data within the object in which the method
    resides. Method names beginning with two underscores (`__`) may be used in the
    future by PHP (and are currently used for the object serialization methods `__sleep()`
    and `__wakeup()`, described later in this chapter, among others), so it’s recommended
    that you do not begin your method names with this sequence.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是定义在类内部的函数。虽然PHP没有施加特殊的限制，大多数方法只在方法所在的对象内部的数据上起作用。方法名称以两个下划线（`__`）开头的方法可能在未来由PHP使用（当前用于对象序列化方法`__sleep()`和`__wakeup()`，稍后在本章描述的其他方法），因此建议不要以这个序列开始方法名称。
- en: Within a method, the `$this` variable contains a reference to the object on
    which the method was called. For instance, if you call `$moana->birthday()`, inside
    the `birthday()` method, `$this` holds the same value as `$moana`. Methods use
    the `$this` variable to access the properties of the current object and to call
    other methods on that object.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法内部，`$this`变量包含对调用该方法的对象的引用。例如，如果你调用`$moana->birthday()`，在`birthday()`方法内部，`$this`持有与`$moana`相同的值。方法使用`$this`变量来访问当前对象的属性并调用该对象上的其他方法。
- en: 'Here’s a simple class definition of the `Person` class that shows the `$this`
    variable in action:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Person`类的简单类定义，展示了`$this`变量的使用方式：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the `getName()` and `setName()` methods use `$this` to access
    and set the `$name` property of the current object.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`getName()`和`setName()`方法使用`$this`访问和设置当前对象的`$name`属性。
- en: 'To declare a method as a static method, use the `static` keyword. Inside of
    static methods the variable `$this` is not defined. For example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要将方法声明为静态方法，请使用`static`关键字。在静态方法内部，变量`$this`未定义。例如：
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you declare a method using the `final` keyword, subclasses cannot override
    that method. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`final`关键字声明一个方法，子类将无法覆盖该方法。例如：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using access modifiers, you can change the visibility of methods. Methods that
    are accessible outside methods on the object should be declared `public`; methods
    on an instance that can be called only by methods within the same class should
    be declared `private`. Finally, methods declared as `protected` can be called
    only from within the object’s class methods and the class methods of classes inheriting
    from the class. Defining the visibility of class methods is optional; if a visibility
    is not specified, a method is public. For example, you might define:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问修饰符，你可以改变方法的可见性。在对象方法之外可访问的方法应该声明为`public`；只能被同一类内部方法调用的实例方法应该声明为`private`。最后，声明为`protected`的方法只能从对象的类方法和继承自该类的类方法调用。定义类方法的可见性是可选的；如果没有指定可见性，则方法是公共的。例如，你可以定义：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can use type hinting (described in [Chapter 3](ch03.xhtml#functions)) when
    declaring a method on an object:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明对象方法时，你可以使用类型提示（在[第三章](ch03.xhtml#functions)中描述）：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When a method returns a value, you can use type hinting to declare the method’s
    return value type:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当方法返回一个值时，你可以使用类型提示声明方法的返回值类型：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Declaring Properties
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明属性
- en: In the previous definition of the `Person` class, we explicitly declared the
    `$name` property. Property declarations are optional and are simply a courtesy
    to whomever maintains your program. It’s good PHP style to declare your properties,
    but you can add new properties at any time.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述`Person`类的定义中，我们明确声明了`$name`属性。属性声明是可选的，只是对维护你的程序的人的一种礼貌。声明属性是良好的PHP风格，但你可以随时添加新的属性。
- en: 'Here’s a version of the `Person` class that has an undeclared `$name` property:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`Person`类的版本，其中有一个未声明的`$name`属性：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can assign default values to properties, but those default values must
    be simple constants:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为属性分配默认值，但这些默认值必须是简单的常量：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using access modifiers, you can change the visibility of properties. Properties
    that are accessible outside the object’s scope should be declared `public`; properties
    on an instance that can be accessed only by methods within the same class should
    be declared `private`. Finally, properties declared as `protected` can be accessed
    only by the object’s class methods and the class methods of classes inheriting
    from the class. For example, you might declare a user class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问修饰符，你可以改变属性的可见性。在对象作用域之外可访问的属性应该声明为`public`；在同一类内部方法才能访问的实例属性应该声明为`private`。最后，声明为`protected`的属性只能被对象的类方法和继承自该类的类方法访问。例如，你可以声明一个用户类：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In addition to properties on instances of objects, PHP allows you to define
    static properties, which are variables on an object class, and can be accessed
    by referencing the property with the class name. For example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 除了对象实例的属性外，PHP还允许你定义静态属性，这些属性是对象类上的变量，可以通过类名引用该属性。例如：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inside an instance of the object class, you can also refer to the static property
    using the `self` keyword, like `echo self::$global;`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象类的实例内部，你也可以使用`self`关键字引用静态属性，例如`echo self::$global;`。
- en: If a property is accessed on an object that doesn’t exist, and if the `__get()`
    or `__set()` method is defined for the object’s class, that method is given an
    opportunity to either retrieve a value or set the value for that property.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在访问一个不存在的对象属性时，对象的类定义了`__get()`或`__set()`方法，那么该方法将有机会获取值或者为该属性设置值。
- en: 'For example, you might declare a class that represents data pulled from a database,
    but you might not want to pull in large data values—such as Binary Large Objects
    (BLOBs)—unless specifically requested. One way to implement that, of course, would
    be to create access methods for the property that read and write the data whenever
    requested. Another method might be to use these overloading methods:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以声明一个表示从数据库中拉取数据的类，但你可能不希望拉取大数据值（如二进制大对象（BLOBs）），除非专门请求。当然，实现这一点的一种方法是为该属性创建读取和写入数据的访问方法。另一种方法可能是使用这些重载方法：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Declaring Constants
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明常量
- en: 'As with global constants, assigned through the `define()` function, PHP provides
    a way to assign constants within a class. Like static properties, constants can
    be accessed directly through the class or within object methods using the `self`
    notation. Once a constant is defined, its value cannot be changed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 与通过`define()`函数分配的全局常量一样，PHP提供了在类内部分配常量的方法。类似于静态属性，常量可以直接通过类或在对象方法内部使用`self`表示法访问。一旦定义了常量，其值就不能更改：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As with global constants, it is common practice to define class constants with
    uppercase identifiers.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 与全局常量一样，通常使用大写标识符定义类常量。
- en: 'Using access modifiers, you can change the visibility of class constants. Class
    constants that are accessible outside methods on the object should be declared
    `public`; class constants on an instance that can be accessed only by methods
    within the same class should be declared `private`. Finally, constants declared
    as `protected` can be accessed only from within the object’s class methods and
    the class methods of classes inheriting from the class. Defining the visibility
    of class constants is optional; if a visibility is not specified, a method is
    `public`. For example, you might define:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用访问修饰符，可以更改类常量的可见性。可以从对象方法外部访问的类常量应声明为`public`；只能通过同一类内部方法访问的实例上的类常量应声明为`private`。最后，声明为`protected`的常量只能从对象的类方法和继承类的类方法中访问。定义类常量的可见性是可选的；如果没有指定可见性，则方法为`public`。例如，您可以定义：
- en: '[PRE26]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Inheritance
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'To inherit the properties and methods from another class, use the `extends`
    keyword in the class definition, followed by the name of the base class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要继承另一个类的属性和方法，使用类定义中的`extends`关键字，后跟基类的名称：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `Employee` class contains the `$position` and `$salary` properties, as well
    as the `$name`, `$address`, and `$age` properties inherited from the `Person`
    class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee`类包含`$position`和`$salary`属性，以及从`Person`类继承的`$name`，`$address`和`$age`属性。'
- en: If a derived class has a property or method with the same name as one in its
    parent class, the property or method in the derived class takes precedence over
    the property or method in the parent class. Referencing the property returns the
    value of the property on the child, while referencing the method calls the method
    on the child.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果派生类具有与其父类中同名的属性或方法，则派生类中的属性或方法优先于父类中的属性或方法。引用属性返回子类属性的值，引用方法调用子类的方法。
- en: 'Use the `parent::`*`method`*`()` notation to access an overridden method on
    an object’s parent class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`parent::`*`method`*`()`表示法来访问对象父类中被重写的方法：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'A common mistake is to hardcode the name of the parent class into calls to
    overridden methods:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的错误是在调用重写方法时将父类名称硬编码到中：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This is a mistake because it distributes knowledge of the parent class’s name
    throughout the derived class. Using `parent::` centralizes the knowledge of the
    parent class in the `extends` clause.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个错误，因为它将父类名称的知识分布到派生类中。使用`parent::`将父类的知识集中在`extends`子句中。
- en: 'If a method might be subclassed and you want to ensure that you’re calling
    it on the current class, use the `self::`*`method`*`()` notation:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法可能被子类继承，并且你希望确保在当前类上调用它，可以使用`self::`*`method`*`()`的表示法：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To check if an object is an instance of a particular class or if it implements
    a particular interface (see the section “Interfaces”), you can use the `instanceof`
    operator:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查一个对象是否是特定类的实例或是否实现了特定接口（参见“接口”部分），可以使用`instanceof`运算符：
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Interfaces
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: 'Interfaces provide a way for defining contracts to which a class adheres; the
    interface provides method prototypes and constants, and any class that implements
    the interface must provide implementations for all methods in the interface. Here’s
    the syntax for an interface definition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接口提供了一种定义类遵循的契约的方式；接口提供方法原型和常量，任何实现接口的类必须为接口中的所有方法提供实现。以下是接口定义的语法：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To declare that a class implements an interface, include the `implements` keyword
    and any number of interfaces, separated by commas:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个类实现一个接口，需要使用`implements`关键字，并且可以跟任意数量的接口，用逗号分隔：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: An interface may inherit from other interfaces (including multiple interfaces)
    as long as none of the interfaces it inherits from declare methods with the same
    name as those declared in the child interface.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以继承其他接口（包括多个接口），只要它从父接口继承的方法没有与子接口中声明的方法同名。
- en: Traits
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特征
- en: 'Traits provide a mechanism for reusing code outside of a class hierarchy. Traits
    allow you to share functionality across different classes that don’t (and shouldn’t)
    share a common ancestor in a class hierarchy. Here’s the syntax for a trait definition:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 特征提供了在类层次结构之外重用代码的机制。特征允许你在不共享公共祖先的不同类之间共享功能。以下是特征定义的语法：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To declare that a class should include a trait’s methods, include the `use`
    keyword and any number of traits, separated by commas:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个类应该包含特征的方法，请使用`use`关键字和任意数量的特征，用逗号分隔：
- en: '[PRE35]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The methods defined by the `Logger` trait are available to instances of the
    `UserGroup` class as if they were defined in that class.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由`Logger`特征定义的方法对`UserGroup`类的实例可用，就像这些方法在该类中定义一样。
- en: 'To declare that a trait should be composed of other traits, include the `use`
    statement in the trait’s declaration, followed by one or more trait names separated
    by commas, as shown here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个特征应该由其他特征组成，需在特征声明中使用`use`语句，后面跟上一个或多个用逗号分隔的特征名称，如下所示：
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Traits can declare abstract methods.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 特征可以声明抽象方法。
- en: 'If a class uses multiple traits defining the same method, PHP gives a fatal
    error. However, you can override this behavior by telling the compiler specifically
    which implementation of a given method you want to use. When defining which traits
    a class includes, use the `insteadof` keyword for each conflict:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类使用多个定义了相同方法的特征，PHP会给出致命错误。然而，你可以通过告诉编译器具体想要使用的给定方法的实现来覆盖这种行为。在定义一个类包含哪些特征时，对于每个冲突使用`insteadof`关键字：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Instead of picking just one method to include, you can use the `as` keyword
    to alias a trait’s method within the class including it to a different name. You
    must still explicitly resolve any conflicts in the included traits. For example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`as`关键字给一个特征的方法在包含它的类中起别名。你仍然必须明确解决包含特征中的任何冲突。例如：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Abstract Methods
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象方法
- en: 'PHP also provides a mechanism for declaring that certain methods on the class
    must be implemented by subclasses—the implementation of those methods is not defined
    in the parent class. In these cases, you provide an abstract method; in addition,
    if a class contains any methods defined as abstract, you must also declare the
    class as an abstract class:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: PHP还提供了一种机制来声明类上的某些方法必须由子类实现——这些方法的实现在父类中未定义。在这些情况下，你提供一个抽象方法；此外，如果一个类包含任何抽象方法定义，你还必须将该类声明为抽象类：
- en: '[PRE39]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Abstract classes cannot be instantiated. Also note that, unlike some languages,
    PHP does not allow you to provide a default implementation for abstract methods.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类不能被实例化。此外，请注意，与一些语言不同，PHP不允许为抽象方法提供默认实现。
- en: 'Traits can also declare abstract methods. Classes that include a trait that
    defines an abstract method must implement that method:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 特征也可以声明抽象方法。包含定义了抽象方法的特征的类必须实现该方法：
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When you implement an abstract method in a child class, the method signatures
    must match—that is, they must take in the same number of required parameters,
    and if any of the parameters have type hints, those type hints must match. In
    addition, the method must have the same or less restricted visibility.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在子类中实现一个抽象方法时，方法签名必须匹配——即，它们必须接收相同数量的必需参数，并且如果任何参数具有类型提示，则这些类型提示必须匹配。此外，方法的可见性必须相同或更少受限。
- en: Constructors
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'You may also provide a list of arguments following the class name when instantiating
    an object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化对象时，你可以在类名后提供一个参数列表：
- en: '[PRE41]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: These arguments are passed to the class’s *constructor*, a special function
    that initializes the properties of the class.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数传递给类的*构造函数*，一个特殊的函数，用于初始化类的属性。
- en: 'A constructor is a function in the class called `__construct()`. Here’s a constructor
    for the `Person` class:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是类中称为`__construct()`的函数。这是`Person`类的构造函数：
- en: '[PRE42]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'PHP does not provide for an automatic chain of constructors; that is, if you
    instantiate an object of a derived class, only the constructor in the derived
    class is automatically called. For the constructor of the parent class to be called,
    the constructor in the derived class must explicitly call the constructor. In
    this example, the `Employee` class constructor calls the `Person` constructor:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: PHP不提供自动构造函数链；也就是说，如果你实例化一个派生类的对象，只有派生类中的构造函数会自动调用。要调用父类的构造函数，派生类的构造函数必须显式调用父类的构造函数。在这个例子中，`Employee`类的构造函数调用了`Person`的构造函数：
- en: '[PRE43]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Destructors
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 析构函数
- en: 'When an object is destroyed, such as when the last reference to an object is
    removed or the end of the script is reached, its *destructor* is called. Because
    PHP automatically cleans up all resources when they fall out of scope and at the
    end of a script’s execution, their application is limited. The destructor is a
    method called `__destruct()`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被销毁时，比如当最后一个引用被移除或脚本结束时，它的*析构函数*会被调用。因为PHP在变量超出范围或脚本执行结束时自动清理所有资源，它们的应用是有限的。析构函数是一个名为`__destruct()`的方法：
- en: '[PRE44]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Anonymous Classes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名类
- en: 'While creating mock objects for testing, it’s useful to create anonymous classes.
    An anonymous class behaves the same as any other class, except that you do not
    provide a name (which means it cannot be directly instantiated):'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建用于测试的模拟对象时，创建匿名类非常有用。匿名类的行为与任何其他类相同，只是你不提供名称（这意味着不能直接实例化）：
- en: '[PRE45]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Unlike instances of named classes, instances of anonymous classes cannot be
    serialized. Attempting to serialize an instance of an anonymous class results
    in an error.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与具名类的实例不同，匿名类的实例无法被序列化。尝试序列化匿名类的实例会导致错误。
- en: Introspection
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自省
- en: '*Introspection* is the ability of a program to examine an object’s characteristics,
    such as its name, parent class (if any), properties, and methods. With introspection,
    you can write code that operates on any class or object. You don’t need to know
    which methods or properties are defined when you write your code; instead, you
    can discover that information at runtime, which makes it possible for you to write
    generic debuggers, serializers, profilers, and the like. In this section, we look
    at the introspective functions provided by PHP.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*自省*是程序检查对象特征（如其名称、父类（如果有）、属性和方法）的能力。使用自省，你可以编写操作任何类或对象的代码。在编写代码时，你无需知道定义了哪些方法或属性；相反，你可以在运行时发现这些信息，这使得编写通用调试器、序列化程序、分析器等成为可能。在本节中，我们将介绍PHP提供的自省函数。'
- en: Examining Classes
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查类
- en: 'To determine whether a class exists, use the `class_exists()` function, which
    takes in a string and returns a Boolean value. Alternately, you can use the `get_declared_classes()`
    function, which returns an array of defined classes and checks if the class name
    is in the returned array:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定一个类是否存在，可以使用`class_exists()`函数，它接受一个字符串并返回一个布尔值。或者，你可以使用`get_declared_classes()`函数，它返回一个已定义类的数组，并检查类名是否在返回的数组中：
- en: '[PRE46]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can get the methods and properties that exist in a class (including those
    that are inherited from superclasses) using the `get_class_methods()` and `get_class_vars()`
    functions. These functions take a class name and return an array:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get_class_methods()`和`get_class_vars()`函数可以获取类中存在的方法和属性（包括从超类继承的方法和属性）。这些函数接受一个类名并返回一个数组：
- en: '[PRE47]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The class name can be either a variable containing the class name, a bare word,
    or a quoted string:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 类名可以是包含类名的变量、裸单词或带引号的字符串：
- en: '[PRE48]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The array returned by `get_class_methods()` is a simple list of method names.
    The associative array returned by `get_class_vars()` maps property names to values
    and also includes inherited properties.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_class_methods()`返回的数组是一个简单的方法名称列表。`get_class_vars()`返回的关联数组将属性名称映射到值，并且还包括继承的属性。'
- en: One quirk of `get_class_vars()` is that it returns only properties that have
    default values and are visible in the current scope; there’s no way to discover
    uninitialized properties.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_class_vars()`的一个怪异之处在于它仅返回具有默认值并在当前作用域可见的属性；没有办法发现未初始化的属性。'
- en: 'Use `get_parent_class()` to find a class’s parent class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`get_parent_class()`来查找一个类的父类：
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[Example 6-1](#example_six_onedot_displaying_all_decla) lists the `displayClasses()`
    function, which displays all currently declared classes and the methods and properties
    for each.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-1](#example_six_onedot_displaying_all_decla)列出了`displayClasses()`函数，该函数显示了当前声明的所有类及其每个类的方法和属性。'
- en: Example 6-1\. Displaying all declared classes
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-1\. 显示所有已声明的类
- en: '[PRE50]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Examining an Object
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查一个对象
- en: 'To get the class to which an object belongs, first make sure it is an object
    using the `is_object()` function, and then get the class with the `get_class()`
    function:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取对象所属的类，首先确保它是一个对象，使用`is_object()`函数，然后用`get_class()`函数获取类：
- en: '[PRE51]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Before calling a method on an object, you can ensure that it exists using the
    `method_exists()` function:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用对象的方法之前，您可以使用`method_exists()`函数确保方法存在：
- en: '[PRE52]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Calling an undefined method triggers a runtime exception.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 调用未定义的方法会触发运行时异常。
- en: 'Just as `get_class_vars()` returns an array of properties for a class, `get_object_vars()`
    returns an array of properties set in an object:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`get_class_vars()`返回一个类的属性数组一样，`get_object_vars()`返回一个对象中设置的属性数组：
- en: '[PRE53]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And just as `get_class_vars()` returns only those properties with default values,
    `get_object_vars()` returns only those properties that are set:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如`get_class_vars()`只返回具有默认值的属性一样，`get_object_vars()`只返回已设置的属性：
- en: '[PRE54]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The `get_parent_class()` function accepts either an object or a class name.
    It returns the name of the parent class, or `FALSE` if there is no parent class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_parent_class()`函数接受一个对象或一个类名。它返回父类的名称，如果没有父类则返回`FALSE`：'
- en: '[PRE55]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Sample Introspection Program
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例内省程序
- en: '[Example 6-2](#example_six_twodot_object_introspection) shows a collection
    of functions that display a reference page of information about an object’s properties,
    methods, and inheritance tree.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-2](#example_six_twodot_object_introspection)展示了一组函数，显示了有关对象属性、方法和继承树的参考页面信息。'
- en: Example 6-2\. Object introspection functions
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-2\. 对象内省函数
- en: '[PRE56]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Here are some sample classes and objects that exercise the introspection functions
    from [Example 6-2](#example_six_twodot_object_introspection):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些示例类和对象，演示了来自[示例 6-2](#example_six_twodot_object_introspection)的内省函数：
- en: '[PRE57]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Serialization
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列化
- en: '*Serializing* an object means converting it to a bytestream representation
    that can be stored in a file. This is useful for persistent data; for example,
    PHP sessions automatically save and restore objects. Serialization in PHP is mostly
    automatic—it requires little extra work from you, beyond calling the `serialize()`
    and `unserialize()` functions:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列化*一个对象意味着将其转换为可以存储在文件中的字节流表示。这对于持久数据非常有用；例如，PHP会话会自动保存和恢复对象。PHP中的序列化大部分是自动的——除了调用`serialize()`和`unserialize()`函数外，你几乎不需要额外工作：'
- en: '[PRE58]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Serialization is most commonly used with PHP’s sessions, which handle the serialization
    for you. All you need to do is tell PHP which variables to keep track of, and
    they’re automatically preserved between visits to pages on your site. However,
    sessions are not the only use of serialization—if you want to implement your own
    form of persistent objects, `serialize()` and `unserialize()` are a natural choice.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化最常用于PHP的会话中，会话会处理对象的序列化。你只需告诉PHP要跟踪哪些变量，它们就会在您网站上的页面访问之间自动保存。然而，会话并不是序列化的唯一用途——如果您想实现自己的持久对象形式，`serialize()`和`unserialize()`是一个自然的选择。
- en: 'An object’s class must be defined before unserialization can occur. Attempting
    to unserialize an object whose class is not yet defined puts the object into `stdClass`,
    which renders it almost useless. One practical consequence of this is that if
    you use PHP sessions to automatically serialize and unserialize objects, you must
    include the file containing the object’s class definition in every page on your
    site. For example, your pages might start like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的类必须在反序列化之前定义。尝试反序列化一个尚未定义类的对象会将对象放入`stdClass`，这几乎使其无用。这的一个实际后果是，如果您使用PHP会话自动序列化和反序列化对象，则必须在您网站的每个页面中包含包含对象类定义的文件。例如，您的页面可能如下所示：
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'PHP has two hooks for objects during the serialization and unserialization
    process: `__sleep()` and `__wakeup()`. These methods are used to notify objects
    that they’re being serialized or unserialized. Objects can be serialized if they
    do not have these methods; however, they won’t be notified about the process.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: PHP在序列化和反序列化过程中为对象提供了两个钩子：`__sleep()`和`__wakeup()`。这些方法用于通知对象它们正在被序列化或反序列化。如果对象没有这些方法，它们可以被序列化，但是它们不会被通知该过程。
- en: The `__sleep()` method is called on an object just before serialization; it
    can perform any cleanup necessary to preserve the object’s state, such as closing
    database connections, writing out unsaved persistent data, and so on. It should
    return an array containing the names of the data members that need to be written
    into the bytestream. If you return an empty array, no data is written.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`__sleep()`方法在对象序列化之前调用；它可以执行任何必要的清理操作以保留对象的状态，如关闭数据库连接、写入未保存的持久数据等。它应返回一个包含需要写入字节流的数据成员名称的数组。如果返回一个空数组，则不会写入任何数据。'
- en: Conversely, the `__wakeup()` method is called on an object immediately after
    an object is created from a bytestream. The method can take any action it requires,
    such as reopening database connections and other initialization tasks.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`__wakeup()`方法在从字节流创建对象后立即调用。该方法可以执行任何所需的操作，如重新打开数据库连接和其他初始化任务。
- en: '[Example 6-3](#example_six_threedot_the_logdotphp_file) is an object class,
    `Log`, that provides two useful methods: `write()` to append a message to the
    logfile, and `read()` to fetch the current contents of the logfile. It uses `__wakeup()`
    to reopen the logfile and `__sleep()` to close the logfile.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-3](#example_six_threedot_the_logdotphp_file)是一个对象类，`Log`，提供两个有用的方法：`write()`用于将消息追加到日志文件中，`read()`用于获取日志文件的当前内容。它使用`__wakeup()`重新打开日志文件和`__sleep()`关闭日志文件。'
- en: Example 6-3\. The Log.php file
  id: totrans-183
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-3\. Log.php文件
- en: '[PRE60]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Store the `Log` class definition in a file called *Log.php*. The HTML front
    page in [Example 6-4](#example_six_fourdot_frontdotphp) uses the `Log` class and
    PHP sessions to create a persistent log variable, `$logger`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Log`类的定义存储在名为*Log.php*的文件中。[示例 6-4](#example_six_fourdot_frontdotphp)的HTML首页使用`Log`类和PHP会话来创建一个持久的日志变量`$logger`。
- en: Example 6-4\. front.php
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-4\. front.php
- en: '[PRE61]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[Example 6-5](#example_six_fivedot_nextdotphp) shows the file *next.php*, an
    HTML page. Following the link from the front page to this page triggers the loading
    of the persistent object `$logger`. The `__wakeup()` call reopens the logfile
    so the object is ready to be used.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例 6-5](#example_six_fivedot_nextdotphp)展示了文件*next.php*，一个HTML页面。从首页到该页面的链接触发了持久对象`$logger`的加载。`__wakeup()`调用重新打开日志文件，以便对象准备好使用。'
- en: Example 6-5\. next.php
  id: totrans-189
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 6-5\. next.php
- en: '[PRE62]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: What’s Next
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: Learning how to use objects in your own scripts is an enormous task. In the
    next chapter, we transition from language semantics to practice and show you one
    of PHP’s most commonly used set of object-oriented classes—the date and time classes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何在您自己的脚本中使用对象是一项巨大的任务。在下一章中，我们将从语言语义转向实践，并向您展示PHP中最常用的一组面向对象类之一——日期和时间类。
