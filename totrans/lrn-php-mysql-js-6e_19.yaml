- en: Chapter 16\. JavaScript Functions, Objects, and Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like PHP, JavaScript offers access to functions and objects. In fact, JavaScript
    is actually based on objects, because—as you’ve seen—it has to access the DOM,
    which makes every element of an HTML document available to manipulate as an object.
  prefs: []
  type: TYPE_NORMAL
- en: The usage and syntax are also quite similar to those of PHP, so you should feel
    right at home as I take you through using functions and objects in JavaScript,
    as well as through an in-depth exploration of array handling.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to having access to dozens of built-in functions (or methods), such
    as `write`, which you have already seen being used in `document.write`, you can
    easily create your own functions. Whenever you have a relatively complex piece
    of code that is likely to be reused, you have a candidate for a function.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The general syntax for a function is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line of the syntax indicates the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A definition starts with the word `function`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A name follows that must start with a letter or underscore, followed by any
    number of letters, digits, dollar signs, or underscores.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The parentheses are required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more parameters, separated by commas, are optional (indicated by the
    square brackets, which are not part of the function syntax).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Function names are case-sensitive, so all of the following strings refer to
    different functions: `getInput`, `GETINPUT`, and `getinput`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript there is a general naming convention for functions: the first
    letter of each word in a name is capitalized, except for the very first letter,
    which is lowercase. Therefore, of the previous examples, `getInput` would be the
    preferred name used by most programmers. This convention is commonly referred
    to as *bumpyCaps*, *bumpyCase*, or (most frequently) *camelCase*.'
  prefs: []
  type: TYPE_NORMAL
- en: The opening curly brace starts the statements that will execute when you call
    the function; a matching curly brace must close it. These statements may include
    one or more `return` statements, which force the function to cease execution and
    return to the calling code. If a value is attached to the `return` statement,
    the calling code can retrieve it.
  prefs: []
  type: TYPE_NORMAL
- en: The `arguments` array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `arguments` array is a member of every function. With it, you can determine
    the number of variables passed to a function and what they are. Take the example
    of a function called `displayItems`. [Example 16-1](#defining_a_function-id00087)
    shows one way of writing it.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-1\. Defining a function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you call up this script in your browser, it will display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All of this is fine, but what if you wanted to pass more than five items to
    the function? Also, reusing the `document.write` call multiple times instead of
    employing a loop is wasteful programming. Luckily, the `arguments` array gives
    you the flexibility to handle a variable number of arguments. [Example 16-2](#modifying_the_function_to_use_the_argume)
    shows how you can use it to rewrite the previous example in a much more efficient
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-2\. Modifying the function to use the `arguments` array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of the `length` property, which you already encountered in the
    previous chapter, and also that I reference the array `displayItems.arguments`
    using the variable `j` as an offset into it. I also chose to keep the function
    short and sweet by not surrounding the contents of the `for` loop in curly braces,
    as it contains only a single statement. Remember that the loop must stop when
    `j` is one less than `length`, not equal to `length`.
  prefs: []
  type: TYPE_NORMAL
- en: Using this technique, you now have a function that can take as many (or as few)
    arguments as you like and act on each argument as you desire.
  prefs: []
  type: TYPE_NORMAL
- en: Returning a Value
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions are not used just to display things. In fact, they are mostly used
    to perform calculations or data manipulations and then return a result. The function
    `fixNames` in [Example 16-3](#cleaning_up_a_full_name-id00089) uses the `arguments`
    array (discussed in the previous section) to take a series of strings passed to
    it and return them as a single string. The “fix” it performs is to convert every
    character in the arguments to lowercase except for the first character of each
    argument, which is set to a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-3\. Cleaning up a full name
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When called with the parameters `the`, `DALLAS`, and `CowBoys`, for example,
    the function returns the string `The Dallas Cowboys`. Let’s walk through the function.
  prefs: []
  type: TYPE_NORMAL
- en: It first initializes the temporary (and local) variable `s` to the empty string.
    Then a `for` loop iterates through each of the passed parameters, isolating the
    parameter’s first character using the `charAt` method and converting it to uppercase
    with the `toUpperCase` method. The various methods shown in this example are all
    built into JavaScript and available by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then the `substr` method is used to fetch the rest of each string, which is
    converted to lowercase via the `toLowerCase` method. A fuller version of the `substr`
    method here would specify how many characters are part of the substring as a second
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In other words, this `substr` method says, “Start with the character at position
    1 (the second character) and return the rest of the string (the length minus one).”
    As a nice touch, though, the `substr` method assumes that you want the rest of
    the string if you omit the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: After the whole argument is converted to our desired case, a space character
    is added to the end, and the result is appended to the temporary variable `s`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `substr` method is used again to return the contents of the variable
    `s`, except for the final space—which is unwanted. We remove this by using `substr`
    to return the string up to, but not including, the final character.
  prefs: []
  type: TYPE_NORMAL
- en: 'This example is particularly interesting in that it illustrates the use of
    multiple properties and methods in a single expression, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You have to interpret the statement by mentally dividing it into parts at the
    periods. JavaScript evaluates these elements of the statement from left to right
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the name of the function itself: `fixNames`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract element `j` from the array `arguments` representing `fixNames` arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke `substr` with a parameter of `1` to the extracted element. This passes
    all but the first character to the next section of the expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the method `toLowerCase` to the string that has been passed thus far.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This practice is often referred to as *method chaining*. So, for example, if
    the string `mixedCASE` is passed to the example expression, it will go through
    the following transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In other words, `fixNames.arguments[j]` produces “mixedCASE”, then `substr(1)`
    takes “mixedCASE” and produces “ixedCASE”, and finally `toLowerCase()` takes “ixedCASE”
    and produces “ixedcase”.
  prefs: []
  type: TYPE_NORMAL
- en: 'One final reminder: the `s` variable created inside the function is local and
    therefore cannot be accessed outside the function. By returning `s` in the `return`
    statement, we made its value available to the caller, which could store or use
    it any way it wanted. But `s` itself disappears at the end of the function. Although
    we could make a function operate on global variables (and sometimes that’s necessary),
    it’s much better to just return the values you want to preserve and let JavaScript
    clean up all the other variables used by the function.'
  prefs: []
  type: TYPE_NORMAL
- en: Returning an Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Example 16-3](#cleaning_up_a_full_name-id00089), the function returned only
    one parameter—but what if you need to return multiple parameters? You can do this
    by returning an array, as in [Example 16-4](#returning_an_array_of_values).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-4\. Returning an array of values
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here the variable `words` is automatically defined as an array and populated
    with the returned result of a call to the function `fixNames`. Then a `for` loop
    iterates through the array and displays each member.
  prefs: []
  type: TYPE_NORMAL
- en: As for the `fixNames` function, it’s almost identical to [Example 16-3](#cleaning_up_a_full_name-id00089),
    except that the variable `s` is now an array; after each word has been processed,
    it is stored as an element of this array, which is returned by the `return` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function enables the extraction of individual parameters from its returned
    values, like the following (the output from which is simply `The Cowboys`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A JavaScript object is a step up from a variable, which can contain only one
    value at a time. In contrast, objects can contain multiple values and even functions.
    An object groups data together with the functions needed to manipulate it.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a script to use objects, you need to design a composite of data
    and code called a *class*. Each new object based on this class is called an *instance*
    (or *occurrence*) of that class. As you’ve already seen, the data associated with
    an object is called its *properties*, while the functions it uses are called *methods*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at how to declare the class for an object called `User` that will
    contain details about the current user. To create the class, just write a function
    named after the class. This function can accept arguments (I’ll show later how
    it’s invoked) and can create properties and methods for objects in that class.
    The function is called a *constructor*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 16-5](#declaring_the_user_class_and_its_method) shows a constructor
    for the class `User` with three properties: `forename`, `username`, and `password`.
    The class also defines the method `showUser`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-5\. Declaring the `User` class and its method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The function is different from other functions we’ve seen so far in several
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Each time the function is called, it creates a new object. Thus, you can call
    the same function over and over with different arguments to create users with
    different forenames, for example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function refers to an object named `this`, which refers to the instance
    being created. As the example shows, the object uses the name `this` to set its
    own properties, which will be different from one `User` to another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new function named `showUser` is created within the function. The syntax shown
    here is new and rather complicated, but its purpose is to tie `showUser` to the
    `User` class. Thus, `showUser` comes into being as a method of the `User` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The naming convention I have used is to keep all properties in lowercase and
    to use at least one uppercase character in method names, following the camelCase
    convention mentioned earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 16-5](#declaring_the_user_class_and_its_method) follows the recommended
    way to write a class constructor, which is to include methods in the constructor
    function. However, you can also refer to functions defined outside the constructor,
    as in [Example 16-6](#separately_defining_a_class_and_method).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-6\. Separately defining a class and method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: I show you this form because you are certain to encounter it when perusing other
    programmers’ code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create an instance of the class `User`, you can use a statement such as
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can create an empty object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'and then populate it later, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add new properties to an object, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that adding such new properties works with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Accessing Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To access an object, you can refer to its properties, as in the following two
    unrelated example statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So, to access the `showUser` method of an object of class `User`, you would
    use the following syntax, in which the object `details` has already been created
    and populated with data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming the data supplied earlier, this code would display the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The prototype Keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `prototype` keyword can save you a lot of memory. In the `User` class,
    every instance will contain the three properties and the method. Therefore, if
    you have one thousand of these objects in memory, the method `showUser` will also
    be replicated one thousand times. However, because the method is identical in
    every case, you can specify that new objects should refer to a single instance
    of the method instead of creating a copy of it. So, instead of using the following
    in a class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'you could replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 16-7](#declaring_a_class_using_the_prototype_ke) shows what the new
    constructor would look like.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-7\. Declaring a class using the `prototype` keyword for a method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This works because all functions have a `prototype` property, designed to hold
    properties and methods that are not replicated in any objects created from a class.
    Instead, they are passed to its objects by reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you can add a `prototype` property or method at any time and
    all objects (even those already created) will inherit it, as the following statements
    illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The first statement adds the `prototype` property of `greeting` with a value
    of `Hello` to the class `User`. In the second line, the object `details`, which
    has already been created, correctly displays this new property.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add to or modify methods in a class, as the following statements
    illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You might add these lines to your script in a conditional statement (such as
    `if`), so they run if user activities cause you to decide you need a different
    `showUser` method. After these lines run, even if the object `details` has been
    created already, further calls to `details.showUser` will run the new function.
    The old definition of `showUser` has been erased.
  prefs: []
  type: TYPE_NORMAL
- en: Static methods and properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When reading about PHP objects, you learned that classes can have static properties
    and methods as well as properties and methods associated with a particular instance
    of a class. JavaScript also supports static properties and methods, which you
    can conveniently store and retrieve from the class’s `prototype`. Thus, the following
    statements set and read a static string from `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Extending JavaScript objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `prototype` keyword even lets you add functionality to a built-in object.
    For example, suppose that you would like to add the ability to replace all spaces
    in a string with nonbreaking spaces in order to prevent it from wrapping around.
    You can do this by adding a prototype method to JavaScript’s default `String`
    object definition, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here the `replace` method is used with a regular expression to find and replace
    all single spaces with the string `&nbsp;`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you are not already familiar with regular expressions, they are a handy means
    of extracting information from or manipulating strings and are fully explained
    in [Chapter 17](ch17_split_000.xhtml#javascript_and_php_validation_and_error).
    Suffice it to say that for now, you can copy and paste the preceding examples
    and they will work as described, illustrating the power of extending JavaScript
    `String` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you then enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'it will output the string `The&nbsp;quick&nbsp;brown&nbsp;fox`. Or here’s a
    method you can add that will trim leading and trailing spaces from a string (once
    again using a regular expression):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you issue the following statement, the output will be the string `Please
    trim me` (with the leading and trailing spaces removed):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If we break down the expression into its component parts, the two `/` characters
    mark the start and end of the expression, and the final `g` specifies a global
    search. Inside the expression, the `^\s+` part searches for one or more whitespace
    characters appearing at the start of the search string, while the `\s+$` part
    searches for one or more whitespace characters at the end of the search string.
    The `|` character in the middle acts to separate the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: The result is that when either of these expressions matches, the match is replaced
    with the empty string, thus returning a trimmed version of the string without
    any leading or trailing whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There is debate about whether extending objects is good or bad practice. Some
    programmers say that should an object later be extended to officially offer the
    functionality you have added, it could be implemented another way, or do something
    quite different to your extension, which could then cause a conflict. However,
    other programmers, such as the inventor of JavaScript, Brendan Eich, say that
    this is a perfectly acceptable practice. My take is to agree with the latter but
    in production code to choose extension names that are most unlikely to ever be
    officially used. So, for example, the `trim` extension could be renamed as `mytrim`,
    and the supporting code might more safely be written as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Array handling in JavaScript is very similar to PHP, although the syntax is
    a little different. Nevertheless, given all you have already learned about arrays,
    this section should be relatively straightforward for you.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new array, use the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Or you can use the shorthand form, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Assigning element values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In PHP, you could add a new element to an array by simply assigning it without
    specifying the element offset, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'But in JavaScript you use the `push` method to achieve the same thing, like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to keep adding items to an array without having to keep track
    of the number of items. When you need to know how many elements are in an array,
    you can use the `length` property, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, if you wish to keep track of the element locations yourself
    and place them in specific locations, you can use syntax such as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 16-8](#creatingcomma_buildingcomma_and_printing) shows a simple script
    that creates an array, loads it with some values, and then displays them.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-8\. Creating, building, and printing an array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Assignment using the Array keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also create an array together with some initial elements by using the
    `Array` keyword, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There is nothing stopping you from adding more elements afterward as well.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now seen a couple of ways you can add items to an array, and one way
    of referencing them. JavaScript offers many more, which I’ll get to shortly—but
    first, we’ll look at another type of array.
  prefs: []
  type: TYPE_NORMAL
- en: Associative Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *associative array* is one in which the elements are referenced by name rather
    than by an integer offset. However, JavaScript doesn’t support such things. Instead,
    we can achieve the same result by creating an object with properties that will
    act the same way.
  prefs: []
  type: TYPE_NORMAL
- en: So, to create an “associative array,” define a block of elements within curly
    braces. For each element, place the key on the left and the contents on the right
    of a colon (`:`). [Example 16-9](#creating_and_displaying_an_associative_a) shows
    how you might create an associative array to hold the contents of the “balls”
    section of an online sports equipment retailer.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-9\. Creating and displaying an associative array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: To verify that the array has been correctly created and populated, I have used
    another kind of `for` loop using the `in` keyword. This creates a new variable
    to use only within the array (`ball`, in this example) and iterates through all
    elements of the array to the right of the `in` keyword (`balls`, in this example).
    The loop acts on each element of `balls`, placing the key value into `ball`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this key value stored in `ball`, you can also get the value of the current
    element of `balls`. The result of calling up the example script in a browser is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a specific element of an associative array, you can specify a key explicitly,
    in the following manner (in this case, outputting the value `Soccer ball, 1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Multidimensional Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a multidimensional array in JavaScript, just place arrays inside other
    arrays. For example, to create an array to hold the details of a two-dimensional
    checkerboard (8 × 8 squares), you could use the code in [Example 16-10](#creating_a_multidimensional_nume-id00097).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-10\. Creating a multidimensional numeric array
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the lowercase letters represent black pieces, and the uppercase
    white. A pair of nested `for` loops walks through the array and displays its contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The outer loop contains two statements, so curly braces enclose them. The inner
    loop then processes each square in a row, outputting the character at location
    `[j][k]`, followed by a space (to square up the printout). This loop contains
    a single statement, so curly braces are not required to enclose it. The `<pre>`
    and `</pre>` tags ensure that the output displays correctly, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also directly access any element within this array by using square
    brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This statement outputs the uppercase letter `O`, the eighth element down and
    the third along—remember that array indexes start at 0, not 1.
  prefs: []
  type: TYPE_NORMAL
- en: Using Array Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Given the power of arrays, JavaScript comes ready-made with a number of methods
    for manipulating them and their data. Here is a selection of the most useful ones.
  prefs: []
  type: TYPE_NORMAL
- en: some
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you need to know whether at least one array element matches a certain
    criterion, you can use the `some` function, which will test all the elements and
    automatically stop and return the required value as soon as one matches. This
    saves you from having to write your own code to perform such searches, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: indexOf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find out where an element can be found in an array, you can call the `indexOf`
    function on the array, which will return the offset of the located element (starting
    from 0), or `-1` if it is not found. For example, the following gives `offset`
    the value `2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: concat
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `concat` method concatenates two arrays, or a series of values within an
    array. For example, the following code outputs `Banana,Grape,Carrot,Cabbage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: You can specify multiple arrays as arguments, in which case `concat` adds all
    their elements in the order that the arrays are specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s another way to use `concat`. This time, plain values are concatenated
    with the array `pets`, which outputs `Cat,Dog,Fish,Rabbit,Hamster`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: forEach
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `forEach` method in JavaScript is another way of achieving functionality
    similar to the PHP `foreach` keyword. To use it, you pass it the name of a function,
    which will be called for each element within the array. [Example 16-11](#using_the_foreach_method)
    shows how.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-11\. Using the `forEach` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the function passed to `forEach` is called `output`. It takes
    three parameters: the `element`, its `index`, and the `array`. These can be used
    as required by your function. This example displays just the `element` and `index`
    values using the function `document.write`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once an array has been populated, the method is called like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: join
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the `join` method, you can convert all the values in an array to strings
    and then join them together into one large string, placing an optional separator
    between them. [Example 16-12](#using_the_join_method) shows three ways of using
    this method.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-12\. Using the `join` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Without a parameter, `join` uses a comma to separate the elements; otherwise,
    the string passed to `join` is inserted between each element. The output of [Example 16-12](#using_the_join_method)
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: push and pop
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You already saw how the `push` method can be used to insert a value into an
    array. The inverse method is `pop`. It deletes the most recently inserted element
    from an array and returns it. [Example 16-13](#using_the_push_and_pop_methods)
    shows an example of its use.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-13\. Using the `push` and `pop` methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The three main statements of this script are shown in bold type. First, the
    script creates an array called `sports` with three elements and then `push`es
    a fourth element into the array. After that, it `pop`s that element back off.
    In the process, the various current values are displayed via `document.write`.
    The script outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `push` and `pop` functions are useful in situations where you need to divert
    from some activity to do another, and then return. For example, let’s suppose
    you want to put off some activities until later, while you get on with something
    more important now. This often happens in real life when we’re going through “to-do”
    lists, so let’s emulate that in code, with tasks number 2 and 5 in a list of six
    items being granted priority status, as in [Example 16-14](#using_push_and_pop_inside_and_outside_of).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-14\. Using `push` and `pop` inside and outside of a loop
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, nothing is actually getting processed here, just text being output
    to the browser, but you get the idea. The output from this example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Using reverse
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `reverse` method simply reverses the order of all elements in an array.
    [Example 16-15](#using_the_reverse_method) shows this in action.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-15\. Using the `reverse` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The original array is modified, and the output from this script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: sort
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the `sort` method, you can place all the elements of an array in alphabetical
    order, depending on the parameters used. [Example 16-16](#using_the_sort_method)
    shows four types of sort.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-16\. Using the `sort` method
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The first of the four example sections uses the default `sort` method to perform
    an *alphabetical sort*, while the second uses the default `sort` and then applies
    the `reverse` method to get a *reverse alphabetical sort*.
  prefs: []
  type: TYPE_NORMAL
- en: The third and fourth sections are a little more complicated; they use a function
    to compare the relationships between `a` and `b`. The function doesn’t have a
    name, because it’s used only in the sort. You have already seen the function named
    `function` used to create an anonymous function; we used it to define a method
    in a class (the `showUser` method).
  prefs: []
  type: TYPE_NORMAL
- en: Here, `function` creates an anonymous function meeting the needs of the `sort`
    method. If the function returns a value greater than zero, the sort assumes that
    `b` comes before `a`. If the function returns a value less than zero, the sort
    assumes that `a` comes before `b`. The sort runs this function across all the
    values in the array to determine their order. (Of course, if `a` and `b` have
    the same value, the function returns zero and it doesn’t matter which value is
    first.)
  prefs: []
  type: TYPE_NORMAL
- en: By manipulating the value returned (`a – b` in contrast to `b - a`), the third
    and fourth sections of [Example 16-16](#using_the_sort_method) choose between
    an *ascending numerical sort* and a *descending numerical sort*.
  prefs: []
  type: TYPE_NORMAL
- en: And, believe it or not, this represents the end of your introduction to JavaScript.
    You should now have a core knowledge of the three main technologies covered in
    this book. The next chapter will look at some advanced techniques used across
    these technologies, such as pattern matching and input validation.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Are JavaScript functions and variable names case-sensitive or case-insensitive?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you write a function that accepts and processes an unlimited number
    of parameters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name a way to return multiple values from a function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you’re defining a class, what keyword do you use to refer to the current
    object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do all the methods of a class have to be defined within the class definition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What keyword is used to create an object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you make a property or method available to all objects in a class without
    replicating the property or method within the object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you create a multidimensional array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What syntax is used to create an associative array?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write a statement to sort an array of numbers in descending numerical order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See [“Chapter 16 Answers”](app01_split_015.xhtml#chapter_16_answers) in the
    [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions) for the
    answers to these questions.
  prefs: []
  type: TYPE_NORMAL
