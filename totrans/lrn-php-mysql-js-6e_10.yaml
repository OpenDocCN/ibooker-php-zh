- en: Chapter 7\. Practical PHP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章\. PHP 实用指南
- en: The previous chapters went over the elements of the PHP language. This chapter
    builds on your new programming skills to teach you how to perform some common
    but important practical tasks. You will learn the best ways to handle strings
    in order to achieve clear and concise code that displays in web browsers exactly
    how you want it to, including advanced date and time management. You’ll also find
    out how to create and otherwise modify files, including those uploaded by users.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节介绍了 PHP 语言的各个元素。本章将基于你的新编程技能，教你如何执行一些常见但重要的实际任务。你将学习如何处理字符串，以实现清晰简洁的代码，并在网页浏览器中显示你想要的效果，包括高级的日期和时间管理。你还将了解如何创建和修改文件，包括用户上传的文件。
- en: Using printf
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 printf
- en: 'You’ve already seen the `print` and `echo` functions, which simply output text
    to the browser. But a much more powerful function, `printf`, controls the format
    of the output by letting you put special formatting characters in a string. For
    each formatting character, `printf` expects you to pass an argument that it will
    display using that format. For instance, the following example uses the `%d` conversion
    specifier to display the value `3` in decimal:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了 `print` 和 `echo` 函数，它们仅仅是将文本输出到浏览器。但是一个更强大的函数 `printf` 可以通过在字符串中添加特殊的格式化字符来控制输出的格式。对于每个格式化字符，`printf`
    都希望你传递一个参数，它将使用该格式显示。例如，以下示例使用 `%d` 转换说明符来显示值 `3` 的十进制表示：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you replace the `%d` with `%b`, the value `3` will be displayed in binary
    (`11`). [Table 7-1](#printf_conversion_specifiers) shows the conversion specifiers
    supported.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你用 `%b` 替换 `%d`，那么值 `3` 将以二进制 (`11`) 形式显示。[表 7-1](#printf_conversion_specifiers)
    显示了支持的转换说明符。
- en: Table 7-1\. The `printf` conversion specifiers
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-1\. `printf` 转换说明符
- en: '| Specifier | Conversion action on argument arg | Example (for an arg of 123)
    |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 指示符 | 对参数`arg`的转换操作 | 示例（对于参数为123） |'
- en: '| --- | --- | --- |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `%` | Display a % character (no `arg` required) | `%` |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `%` | 显示 `%` 字符（不需要`arg`） | `%` |'
- en: '| `b` | Display `arg` as a binary integer | `1111011` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `b` | 以二进制整数显示`arg` | `1111011` |'
- en: '| `c` | Display ASCII character for `arg` | `{` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `c` | 显示`arg`的ASCII字符 | `{` |'
- en: '| `d` | Display `arg` as a signed decimal integer | `123` |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 以有符号十进制整数显示`arg` | `123` |'
- en: '| `e` | Display `arg` using scientific notation | `1.23000e+2` |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| `e` | 使用科学计数法显示`arg` | `1.23000e+2` |'
- en: '| `f` | Display `arg` as floating point | `123.000000` |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| `f` | 以浮点数显示`arg` | `123.000000` |'
- en: '| `o` | Display `arg` as an octal integer | `173` |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `o` | 以八进制整数显示`arg` | `173` |'
- en: '| `s` | Display `arg` as a string | `123` |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 以字符串形式显示`arg` | `123` |'
- en: '| `u` | Display `arg` as an unsigned decimal | `123` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `u` | 以无符号十进制显示`arg` | `123` |'
- en: '| `x` | Display `arg` in lowercase hexadecimal | `7b` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 以小写十六进制显示`arg` | `7b` |'
- en: '| `X` | Display `arg` in uppercase hexadecimal | `7B` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `X` | 以大写十六进制显示`arg` | `7B` |'
- en: 'You can have as many specifiers as you like in a `printf` function, as long
    as you pass a matching number of arguments and as long as each specifier is prefaced
    by a `%` symbol. Therefore, the following code is valid and will output `"My name
    is Simon. I''m 33 years old, which is 21 in hexadecimal"`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `printf` 函数中，你可以使用任意数量的转换说明符，只要你传递相匹配的参数，并且每个说明符前面都有 `%` 符号。因此，以下代码是有效的，并将输出
    `"我的名字是Simon。我今年33岁，这在十六进制中是21"`：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you leave out any arguments, you will receive a parse error informing you
    that a right bracket, `)`, was unexpectedly encountered or that there are too
    few arguments.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略任何参数，你将收到一个解析错误，提示意外遇到右括号 `)` 或参数不足。
- en: 'A more practical example of `printf` sets colors in HTML using decimal values.
    For example, suppose you know you want a color that has a triplet value of 65
    red, 127 green, and 245 blue but don’t want to convert this to hexadecimal yourself.
    Here’s an easy solution:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更实际的 `printf` 示例是使用十进制值在 HTML 中设置颜色。例如，假设你想要一个颜色，其中红色为65、绿色为127、蓝色为245，但不想自己将其转换为十六进制。这里有一个简单的解决方案：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Check the format of the color specification between the apostrophes (`''''`)
    carefully. First comes the pound, or hash, sign (`#`) expected by the color specification.
    Then come three `%X` format specifiers, one for each of your numbers. The resulting
    output from this command is as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细检查撇号(`''`)之间的颜色规范格式。颜色规范首先是井号 (`#`)。然后是三个 `%X` 格式说明符，分别对应你的数字。这个命令的输出如下所示：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Usually, you’ll find it convenient to use variables or expressions as arguments
    to `printf`. For instance, if you stored values for your colors in the three variables
    `$r`, `$g`, and `$b`, you could create a darker color with this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用变量或表达式作为 `printf` 的参数会更方便。例如，如果您将颜色值存储在三个变量 `$r`、`$g` 和 `$b` 中，可以通过以下方式创建更深的颜色：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Precision Setting
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 精度设置
- en: 'Not only can you specify a conversion type, but you can also set the precision
    of the displayed result. For example, amounts of currency are usually displayed
    with only two digits of precision. However, after a calculation, a value may have
    a greater precision than this, such as 123.42 / 12, which results in 10.285\.
    To ensure that such values are correctly stored internally, but displayed with
    only two digits of precision, you can insert the string `".2"` between the `%`
    symbol and the conversion specifier:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不仅可以指定转换类型，还可以设置显示结果的精度。例如，通常货币金额只显示两位小数。但是，在计算后，值可能具有更高的精度，例如 123.42 / 12，得到
    10.285\. 为确保这些值在内部正确存储但仅显示两位小数，可以在 `%` 符号和转换说明符之间插入字符串 `".2"`：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output from this command is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出如下：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: But you actually have even more control than that, because you can also specify
    whether to pad output with either zeros or spaces by prefacing the specifier with
    certain values. [Example 7-1](#precision_setting-id00018) shows four possible
    combinations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你拥有比这更多的控制权，因为你还可以指定输出是用零还是空格填充，通过在转换说明符前面加上特定的值。[示例 7-1](#precision_setting-id00018)
    展示了四种可能的组合。
- en: Example 7-1\. Precision setting
  id: totrans-35
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-1\. 精度设置
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output from this example looks like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的输出如下：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The way it works is simple if you go from right to left (see [Table 7-2](#conversion_specifier_components)).
    Notice that:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式很简单，如果你从右到左看（见 [表 7-2](#conversion_specifier_components)）。请注意：
- en: 'The rightmost character is the conversion specifier: in this case, `f` for
    floating point.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最右边的字符是转换说明符：在本例中为浮点数 `f`。
- en: Just before the conversion specifier, if there is a period and a number together,
    then the precision of the output is specified as the value of the number.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在转换说明符之前有一个句点和一个数字在一起，则输出的精度被指定为该数字的值。
- en: Regardless of whether there’s a precision specifier, if there is a number, then
    that represents the number of characters to which the output should be padded.
    In the previous example, this is 15 characters. If the output is already equal
    to or greater than the padding length, then this argument is ignored.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无论是否有精度说明符，如果有数字，则表示输出应填充到该字符数。在前面的示例中，这是 15 个字符。如果输出已等于或大于填充长度，则忽略此参数。
- en: 'The leftmost parameter allowed after the `%` symbol is a `0`, which is ignored
    unless a padding value has been set, in which case the output is padded with zeros
    instead of spaces. If a pad character other than zero or a space is required,
    you can use any one of your choice as long as you preface it with a single quotation
    mark, like this: `''#`.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `%` 符号之后允许的最左边的参数是 `0`，除非设置了填充值，否则会被忽略，如果需要的是除零或空格之外的填充字符，则可以使用任意你选择的一个，并在其前面加上一个单引号，例如
    `'#`。
- en: On the left is the `%` symbol, which starts the conversion.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左边是 `%` 符号，表示开始转换。
- en: Table 7-2\. Conversion specifier components
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-2\. 转换说明符组件
- en: '| Start conversion | Pad character | Number of pad characters | Display precision
    | Conversion specifier | Example |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 开始转换 | 填充字符 | 填充字符数 | 显示精度 | 转换说明符 | 示例 |'
- en: '| --- | --- | --- | --- | --- | --- |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- en: '| `%` |   | `15` |   | `f` | `10.285000` |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| `%` |   | `15` |   | `f` | `10.285000` |'
- en: '| `%` | `0` | `15` | `.2` | `f` | `000000000010.29` |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| `%` | `0` | `15` | `.2` | `f` | `000000000010.29` |'
- en: '| `%` | `''#` | `15` | `.4` | `f` | `########10.2850` |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| `%` | `''#` | `15` | `.4` | `f` | `########10.2850` |'
- en: String Padding
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串填充
- en: You can also pad strings to required lengths (as you can with numbers), select
    different padding characters, and even choose between left and right justification.
    [Example 7-2](#string_padding-id00019) shows various examples.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以像处理数字一样，将字符串填充到所需的长度，选择不同的填充字符，甚至可以选择左对齐或右对齐。[示例 7-2](#string_padding-id00019)
    展示了各种示例。
- en: Example 7-2\. String padding
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-2\. 字符串填充
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note how for purposes of layout in a web page, I’ve used the `<pre>` HTML tag
    to preserve all the spaces and the `\n` newline character after each of the lines
    to be displayed. The output from this example is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在Web页面布局方面，我使用了 `<pre>` HTML 标签来保留所有空格和每行后的 `\n` 换行字符。该示例的输出如下所示：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you specify a padding value, strings of a length equal to or greater than
    that value will be ignored, *unless* a cutoff value is given that shortens the
    strings back to less than the padding value.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定填充值时，长度等于或大于该值的字符串将被忽略，*除非*提供了截断值，将字符串缩短至小于填充值。
- en: '[Table 7-3](#string_conversion_specifier_components) shows the components available
    to string conversion specifiers.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 7-3](#string_conversion_specifier_components) 显示了可用于字符串转换说明符的组件。'
- en: Table 7-3\. String conversion specifier components
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-3\. 字符串转换说明符组件
- en: '| Start conversion | Left/right justify | Padding character | Number of pad
    characters | Cutoff | Conversion specifier | Example (using “Rasmus”) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 开始转换 | 左/右对齐 | 填充字符 | 填充字符数 | 截断 | 转换说明符 | 示例（使用“Rasmus”） |'
- en: '| --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- |'
- en: '| `%` |   |   |   |   | `s` | `[Rasmus]` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `%` |   |   |   |   | `s` | `[Rasmus]` |'
- en: '| `%` | `-` |   | `10` |   | `s` | `[Rasmus ]` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `%` | `-` |   | `10` |   | `s` | `[Rasmus ]` |'
- en: '| `%` |   | `''#` | `8` | `.4` | `s` | `[####Rasm]` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `%` |   | `''#` | `8` | `.4` | `s` | `[####Rasm]` |'
- en: Using sprintf
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 sprintf
- en: Often, you don’t want to output the result of a conversion but need it to use
    elsewhere in your code. This is where the `sprintf` function comes in. With it,
    you can send the output to another variable rather than to the browser.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，您不希望输出转换的结果，但需要将其用于代码中的其他地方。这就是 sprintf 函数的用武之地。使用它，您可以将输出发送到另一个变量，而不是直接发送到浏览器。
- en: 'You might use it to make a conversion, as in the following example, which returns
    the hexadecimal string value for the RGB color group 65, 127, 245 in `$hexstring`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用它进行转换，就像以下示例中为RGB颜色组65, 127, 245返回十六进制字符串值 `$hexstring` 一样：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or you may wish to store output in a variable for other use or display:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您可能希望将输出存储在变量中以供其他用途或显示：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Date and Time Functions
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期和时间函数
- en: 'To keep track of the date and time, PHP uses standard Unix timestamps, which
    are simply the number of seconds since the start of January 1, 1970\. To determine
    the current timestamp, you can use the `time` function:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: PHP使用标准的Unix时间戳来跟踪日期和时间，即从1970年1月1日开始的秒数。要确定当前时间戳，可以使用 `time` 函数：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Because the value is stored as seconds, to obtain the timestamp for this time
    next week, you would use the following, which adds 7 days × 24 hours × 60 minutes
    × 60 seconds to the returned value:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因为值以秒为单位存储，要获得下周此时刻的时间戳，您可以使用以下方法，将7天× 24小时× 60分钟× 60秒添加到返回值中：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If you wish to create a timestamp for a given date, you can use the `mktime`
    function. Its output is the timestamp `1669852800` for the first second of the
    first minute of the first hour of the first day of December in the year 2022:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望为给定日期创建时间戳，可以使用 `mktime` 函数。对于2022年12月1日的第一秒的时间戳是 `1669852800`：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The parameters to pass are, in order from left to right:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的参数从左到右依次为：
- en: The number of the hour (0–23)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小时数（0–23）
- en: The number of the minute (0–59)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分钟数（0–59）
- en: The number of seconds (0–59)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秒数（0–59）
- en: The number of the month (1–12)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 月份数（1–12）
- en: The number of the day (1–31)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日数（1–31）
- en: The year (1970–2038, or 1901–2038 with PHP 5.1.0+ on 32-bit signed systems)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年份（1970–2038，或者在32位有符号系统上的PHP 5.1.0+中为1901–2038）
- en: Note
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You may ask why you are limited to the years 1970 through 2038\. Well, it’s
    because the original developers of Unix chose the start of the year 1970 as the
    base date that no programmer should need to go before!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会问为什么要将年份限制在1970到2038年之间。这是因为Unix的原始开发者选择了1970年作为基准日期，没有程序员需要在此之前使用！
- en: Luckily, as of version 5.1.0, PHP supports systems using a signed 32-bit integer
    for the timestamp, and dates from 1901 to 2038 are allowed on them. However, that
    introduces a problem even worse than the original one, because the Unix designers
    also decided that nobody would still be using Unix after about 70 years or so
    and therefore believed they could get away with storing the timestamp as a 32-bit
    value—which will run out on January 19, 2038!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，从版本5.1.0开始，PHP支持使用有符号32位整数的系统进行时间戳，支持1901年到2038年的日期。然而，这引入了一个比原问题更严重的问题，因为Unix的设计者还决定，在大约70年后没有人会继续使用Unix，因此他们认为可以用32位值存储时间戳，而这将在2038年1月19日耗尽！
- en: This will create what has come to be known as the Y2K38 bug (much like the millennium
    bug, which was caused by storing years as two-digit values, and which also had
    to be fixed). PHP introduced the `DateTime` class in version 5.2 to overcome this
    issue, but it will work only on 64-bit architecture, which most computers will
    be these days (but do check before you use it).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生所谓的Y2K38问题（类似于千年虫问题，由于将年份存储为两位数值引起，也必须解决）。PHP在5.2版本中引入了`DateTime`类以解决这个问题，但仅适用于64位架构，这在今天的大多数计算机上都是（但使用前请检查）。
- en: 'To display the date, use the `date` function, which supports a plethora of
    formatting options enabling you to display the date any way you wish. The format
    is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示日期，请使用`date`函数，它支持众多格式选项，使您能够按任意方式显示日期。格式如下：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The parameter `$format` should be a string containing formatting specifiers
    as detailed in [Table 7-4](#major_date_function_format_specifier), and `$timestamp`
    should be a Unix timestamp. For the complete list of specifiers, please see the
    [documentation](https://tinyurl.com/phpdate). The following command will output
    the current date and time in the format `"Monday February 17th, 2025 - 1:38pm"`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`$format`应为包含格式说明符的字符串，如[表7-4](#major_date_function_format_specifier)所详述，并且`$timestamp`应为Unix时间戳。有关所有说明符的完整列表，请参阅[文档](https://tinyurl.com/phpdate)。以下命令将以格式`"Monday
    February 17th, 2025 - 1:38pm"`输出当前日期和时间：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Table 7-4\. The major date function format specifiers
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Table 7-4\. 主要日期函数格式说明符
- en: '| Format | Description | Returned value |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 格式 | 描述 | 返回值 |'
- en: '| --- | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Day specifiers** |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| **日期说明符** |'
- en: '| `d` | Day of month, two digits, with leading zeros | `01` to `31` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `d` | 日期，两位数，前导零 | `01` 到 `31` |'
- en: '| `D` | Day of the week, three letters | `Mon` to `Sun` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `D` | 星期几，三个字母 | `Mon` 到 `Sun` |'
- en: '| `j` | Day of month, no leading zeros | `1` to `31` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `j` | 日期，无前导零 | `1` 到 `31` |'
- en: '| `l` | Day of week, full names | `Sunday` to `Saturday` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `l` | 星期几，全称 | `Sunday` 到 `Saturday` |'
- en: '| `N` | Day of week, numeric, Monday to Sunday | `1` to `7` |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `N` | 星期几，数字形式，星期一至星期日 | `1` 到 `7` |'
- en: '| `S` | Suffix for day of month (useful with specifier `j`) | `st`, `nd`, `rd`,
    or `th` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `S` | 日期后缀（与`j`说明符一起使用） | `st`、`nd`、`rd` 或 `th` |'
- en: '| `w` | Day of week, numeric, Sunday to Saturday | `0` to `6` |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `w` | 星期几，数字形式，星期日至星期六 | `0` 到 `6` |'
- en: '| `z` | Day of year | `0` to `365` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `z` | 年内的第几天 | `0` 到 `365` |'
- en: '| **Week specifier** |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| **周说明符** |'
- en: '| `W` | Week number of year | `01` to `52` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `W` | 年的周数 | `01` 到 `52` |'
- en: '| **Month specifiers** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **月份说明符** |'
- en: '| `F` | Month name | `January` to `December` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `F` | 月份名称 | `January` 到 `December` |'
- en: '| `m` | Month number with leading zeros | `01` to `12` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `m` | 月份，带前导零 | `01` 到 `12` |'
- en: '| `M` | Month name, three letters | `Jan` to `Dec` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `M` | 月份名称，三个字母 | `Jan` 到 `Dec` |'
- en: '| `n` | Month number, no leading zeros | `1` to `12` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `n` | 月份，无前导零 | `1` 到 `12` |'
- en: '| `t` | Number of days in given month | `28` to `31` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `t` | 给定月份的天数 | `28` 到 `31` |'
- en: '| **Year specifiers** |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| **年份说明符** |'
- en: '| `L` | Leap year | `1` = Yes, `0` = No |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `L` | 闰年 | `1` = 是，`0` = 否 |'
- en: '| `y` | Year, 2 digits | `00` to `99` |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `y` | 年份，2位数 | `00` 到 `99` |'
- en: '| `Y` | Year, 4 digits | `0000` to `9999` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `Y` | 年份，4位数 | `0000` 到 `9999` |'
- en: '| **Time specifiers** |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| **时间格式说明符** |'
- en: '| `a` | Before or after midday, lowercase | `am` or `pm` |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 上午或下午，小写 | `am` 或 `pm` |'
- en: '| `A` | Before or after midday, uppercase | `AM` or `PM` |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `A` | 上午或下午，大写 | `AM` 或 `PM` |'
- en: '| `g` | Hour of day, 12-hour format, no leading zeros | `1` to `12` |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `g` | 小时，12小时制，无前导零 | `1` 到 `12` |'
- en: '| `G` | Hour of day, 24-hour format, no leading zeros | `0` to `23` |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `G` | 小时，24小时制，无前导零 | `0` 到 `23` |'
- en: '| `h` | Hour of day, 12-hour format, with leading zeros | `01` to `12` |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `h` | 小时，12小时制，前导零 | `01` 到 `12` |'
- en: '| `H` | Hour of day, 24-hour format, with leading zeros | `00` to `23` |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `H` | 小时，24小时制，前导零 | `00` 到 `23` |'
- en: '| `i` | Minutes, with leading zeros | `00` to `59` |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `i` | 分钟，前导零 | `00` 到 `59` |'
- en: '| `s` | Seconds, with leading zeros | `00` to `59` |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `s` | 秒，前导零 | `00` 到 `59` |'
- en: Date Constants
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期常量
- en: 'There are a number of useful constants that you can use with the `date` command
    to return the date in specific formats. For example, `date(DATE_RSS)` returns
    the current date and time in the valid format for an RSS feed. Some of the more
    commonly used constants are as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多有用的常量可以与 `date` 命令一起使用，以返回特定格式的日期。例如，`date(DATE_RSS)` 返回符合 RSS 订阅格式的当前日期和时间。一些常用的常量如下：
- en: <dfn class="keep-together">`DATE_ATOM`</dfn>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`DATE_ATOM`</dfn>
- en: This is the format for Atom feeds. The PHP format is `"Y-m-d\TH:i:sP"`, and
    example output is `"2025-05-15T12:00:00+00:00"`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Atom 订阅的格式。PHP 的格式是`"Y-m-d\TH:i:sP"`，示例输出是`"2025-05-15T12:00:00+00:00"`。
- en: <dfn class="keep-together">`DATE_COOKIE`</dfn>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`DATE_COOKIE`</dfn>
- en: This is the format for cookies set from a web server or JavaScript. The PHP
    format is `"l, d-M-y H:i:s T"`, and example output is `"Thursday, 15-May-25 12:00:00
    UTC"`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 Web 服务器或 JavaScript 设置的 cookie 的格式。PHP 的格式是`"l, d-M-y H:i:s T"`，示例输出是`"Thursday,
    15-May-25 12:00:00 UTC"`。
- en: <dfn class="keep-together">`DATE_RSS`</dfn>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`DATE_RSS`</dfn>
- en: This is the format for RSS feeds. The PHP format is `"D, d M Y H:i:s O"`, and
    example output is `"Thu, 15 May 2025 12:00:00 UTC"`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于 RSS 订阅的格式。PHP 的格式是`"D, d M Y H:i:s O"`，示例输出是`"Thu, 15 May 2025 12:00:00
    UTC"`。
- en: <dfn class="keep-together">`DATE_W3C`</dfn>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <dfn class="keep-together">`DATE_W3C`</dfn>
- en: This is the format for the World Wide Web Consortium. The PHP format is `"Y-m-d\TH:i:sP"`,
    and example output is `"2025-05-15T12:00:00+00:00"`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于万维网联盟的格式。PHP 的格式是`"Y-m-d\TH:i:sP"`，示例输出是`"2025-05-15T12:00:00+00:00"`。
- en: The complete list can be found in the [documentation](https://tinyurl.com/phpdatetime).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[文档](https://tinyurl.com/phpdatetime)中找到完整的列表。
- en: Using checkdate
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 checkdate
- en: You’ve seen how to display a valid date in a variety of formats. But how can
    you check whether a user has submitted a valid date to your program? The answer
    is to pass the month, day, and year to the `checkdate` function, which returns
    a value of `TRUE` if the date is valid or `FALSE` if it is not.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到如何以多种格式显示有效日期。但是如何检查用户是否向程序提交了有效日期？答案是将月、日和年传递给 `checkdate` 函数，如果日期有效则返回`TRUE`，否则返回`FALSE`。
- en: For example, if September 31 of any year is input, it will always be an invalid
    date. [Example 7-3](#checking_for_the_validity_of_a_date) shows code that you
    could use for this. As it stands, it will find the given date invalid.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果输入任意年份的 9 月 31 日，将始终是一个无效日期。[示例 7-3](#checking_for_the_validity_of_a_date)
    显示了您可以用于此目的的代码。目前，它会发现给定日期无效。
- en: Example 7-3\. Checking for the validity of a date
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-3\. 检查日期的有效性
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: File Handling
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件处理
- en: Powerful as it is, MySQL is not the only (or necessarily the best) way to store
    all data on a web server. Sometimes it can be quicker and more convenient to directly
    access files on the hard disk. Cases in which you might need to do this are when
    modifying images such as uploaded user avatars or with logfile that you wish to
    process.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 MySQL 强大，但并非在 Web 服务器上存储所有数据的唯一（或者说是最佳）方法。有时，直接访问硬盘上的文件可能更快、更便捷。这种情况包括修改用户上传头像或处理日志文件。
- en: 'First, though, a note about file naming: if you are writing code that may be
    used on various PHP installations, there is no way of knowing whether these systems
    are case-sensitive. For example, Windows and macOS filenames are not case-sensitive,
    but Linux and Unix filenames are. Therefore, you should always assume that the
    system is case-sensitive and stick to a convention such as all-lowercase filenames.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，首先要注意文件命名：如果您在编写可能在不同 PHP 安装中使用的代码，就无法确定这些系统是否区分大小写。例如，Windows 和 macOS 的文件名不区分大小写，但
    Linux 和 Unix 的文件名区分大小写。因此，您应始终假定系统区分大小写，并坚持使用全小写文件名等约定。
- en: Checking Whether a File Exists
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查文件是否存在
- en: 'To determine whether a file already exists, you can use the `file_exists` function,
    which returns either `TRUE` or `FALSE` and is used like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定文件是否已存在，可以使用 `file_exists` 函数。该函数返回`TRUE`或`FALSE`，用法如下：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating a File
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文件
- en: At this point, *testfile.txt* doesn’t exist, so let’s create it and write a
    few lines to it. Type [Example 7-4](#creating_a_simple_text_file) and save it
    as *testfile.php*.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，*testfile.txt* 不存在，让我们创建它并向其中写入几行内容。键入 [示例 7-4](#creating_a_simple_text_file)
    并将其保存为 *testfile.php*。
- en: Example 7-4\. Creating a simple text file
  id: totrans-150
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-4\. 创建一个简单的文本文件
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Should a program call the `die` function, the open file will be automatically
    closed as part of terminating the program.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果程序调用`die`函数，打开的文件将作为终止程序的一部分自动关闭。
- en: 'When you run this in a browser, all being well, you will receive the message
    `File ''testfile.txt'' written successfully`. If you receive an error message,
    your hard disk may be full or, more likely, you may not have permission to create
    or write to the file, in which case you should modify the attributes of the destination
    folder according to your operating system. Otherwise, the file *testfile.txt*
    should now be residing in the same folder in which you saved the *testfile.php*
    program. Try opening the file in a text or program editor—the contents will look
    like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在浏览器中运行这个程序时，如果一切顺利，你将会收到消息`File 'testfile.txt' written successfully`。如果你收到错误消息，可能是你的硬盘已满，或者更可能的是你没有权限创建或写入文件，这时你应该根据你的操作系统修改目标文件夹的属性。否则，文件*testfile.txt*现在应该存储在你保存*testfile.php*程序的相同文件夹中。尝试用文本编辑器或程序打开文件——内容将会像这样：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This simple example shows the sequence that all file handling takes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了所有文件处理所需的顺序：
- en: Always start by opening the file. You do this through a call to `fopen`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 总是通过调用`fopen`来开始打开文件。通过调用`fopen`函数来实现这一点。
- en: Then you can call other functions; here we write to the file (`fwrite`), but
    you can also read from an existing file (`fread` or `fgets`) and do other things.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后你可以调用其他函数；这里我们向文件写入（`fwrite`），但你也可以从现有文件中读取（`fread`或`fgets`）以及执行其他操作。
- en: Finish by closing the file (`fclose`). Although the program does this for you
    when it ends, you should clean up by closing the file when you’re finished.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后通过关闭文件(`fclose`)来完成。尽管程序在结束时会自动关闭文件，但在你完成后手动关闭文件也是必要的。
- en: Every open file requires a file resource so that PHP can access and manage it.
    The preceding example sets the variable `$fh` (which I chose to stand for *file
    handle*) to the value returned by the `fopen` function. Thereafter, each file-handling
    function that accesses the opened file, such as `fwrite` or `fclose`, must be
    passed `$fh` as a parameter to identify the file being accessed. Don’t worry about
    the content of the `$fh` variable; it’s a number PHP uses to refer to internal
    information about the file—you just pass the variable to other functions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每个打开的文件都需要一个文件资源，以便 PHP 可以访问和管理它。前面的例子将变量`$fh`（我选择用来表示*文件句柄*的变量名）设置为`fopen`函数返回的值。此后，每个访问已打开文件的文件处理函数，如`fwrite`或`fclose`，都必须将`$fh`作为参数传递，以标识正在访问的文件。不用担心`$fh`变量的内容；它是
    PHP 用来引用有关文件的内部信息的数字——你只需将该变量传递给其他函数。
- en: 'Upon failure, `FALSE` will be returned by `fopen`. The previous example shows
    a simple way to capture and respond to the failure: it calls the `die` function
    to end the program and give the user an error message. A web application would
    never abort in this crude way (you would create a web page with an error message
    instead), but this is fine for our testing purposes.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 失败时，`fopen`会返回`FALSE`。前面的例子展示了捕获并响应失败的简单方法：调用`die`函数来结束程序并向用户显示错误消息。Web 应用程序绝不会以这种粗暴的方式中止（你应该创建一个带有错误消息的网页），但这对于我们的测试目的来说是可以接受的。
- en: 'Notice the second parameter to the `fopen` call. It is simply the character
    `w`, which tells the function to open the file for writing. The function creates
    the file if it doesn’t already exist. Be careful when playing around with these
    functions: if the file already exists, the `w` mode parameter causes the `fopen`
    call to delete the old contents (even if you don’t write anything new!).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`fopen`调用的第二个参数。它只是字符`w`，告诉函数以写入模式打开文件。如果文件不存在，函数会创建该文件。在使用这些函数时要小心：如果文件已经存在，`w`模式参数会导致`fopen`调用删除旧内容（即使你没有写入任何新内容！）。
- en: There are several different mode parameters that can be used here, as detailed
    in [Table 7-5](#supported_fopen_modes). The modes that include a `+` symbol are
    further explained in the section [“Updating Files”](#updating_files).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里可以使用几种不同的模式参数，详细说明见[表 7-5](#supported_fopen_modes)。包含`+`符号的模式在“更新文件”部分有进一步解释。
- en: Table 7-5\. The supported `fopen` modes
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-5\. 支持的`fopen`模式
- en: '| Mode | Action | Description |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 模式 | 动作 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `''r''` | Read from file’s beginning | Open for reading only; place the file
    pointer at the beginning of the file. Return `FALSE` if the file doesn’t already
    exist. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `''r''` | 从文件开头读取 | 只读模式打开；将文件指针放在文件开头。如果文件不存在，则返回`FALSE`。 |'
- en: '| --- | --- | --- |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `''r+''` | Read from file’s beginning and allow writing | Open for reading
    and writing; place the file pointer at the beginning of the file. Return `FALSE`
    if the file doesn’t already exist. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `''r+''` | 从文件开头读取并允许写入 | 可读写打开；将文件指针放在文件开头。如果文件不存在，则返回`FALSE`。 |'
- en: '| --- | --- | --- |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `''w''` | Write from file’s beginning and truncate file | Open for writing
    only; place the file pointer at the beginning of the file and truncate the file
    to zero length. If the file doesn’t exist, attempt to create it. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `''w''` | 从文件开头写入并截断文件 | 只写打开；将文件指针放在文件开头并截断文件为零长度。如果文件不存在，则尝试创建。 |'
- en: '| --- | --- | --- |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `''w+''` | Write from file’s beginning, truncate file, and allow reading
    | Open for reading and writing; place the file pointer at the beginning of the
    file and truncate the file to zero length. If the file doesn’t exist, attempt
    to create it. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `''w+''` | 从文件开头写入、截断文件并允许读取 | 可读写打开；将文件指针放在文件开头并截断文件为零长度。如果文件不存在，则尝试创建。
    |'
- en: '| --- | --- | --- |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `''a''` | Append to file’s end | Open for writing only; place the file pointer
    at the end of the file. If the file doesn’t exist, attempt to create it. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `''a''` | 追加到文件末尾 | 只写打开；将文件指针放在文件末尾。如果文件不存在，则尝试创建。 |'
- en: '| --- | --- | --- |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `''a+''` | Append to file’s end and allow reading | Open for reading and
    writing; place the file pointer at the end of the file. If the file doesn’t exist,
    attempt to create it. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `''a+''` | 追加到文件末尾并允许读取 | 可读写打开；将文件指针放在文件末尾。如果文件不存在，则尝试创建。 |'
- en: '| --- | --- | --- |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: Reading from Files
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: The easiest way to read from a text file is to grab a whole line through `fgets`
    (think of the final `s` as standing for *string*), as in [Example 7-5](#reading_a_file_with_fgets).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 从文本文件中读取的最简单方法是通过`fgets`获取整行（最后的`s`可以理解为*string*），如[示例 7-5](#reading_a_file_with_fgets)。
- en: Example 7-5\. Reading a file with `fgets`
  id: totrans-180
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-5\. 使用`fgets`读取文件
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you created the file as shown in [Example 7-4](#creating_a_simple_text_file),
    you’ll get the first line:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你按照[示例 7-4](#creating_a_simple_text_file)创建文件，你会得到第一行：
- en: '[PRE23]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can retrieve multiple lines or portions of lines through the `fread` function,
    as in [Example 7-6](#reading_a_file_with_fread).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过`fread`函数检索多行或行的部分，如[示例 7-6](#reading_a_file_with_fread)。
- en: Example 7-6\. Reading a file with `fread`
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-6\. 使用`fread`读取文件
- en: '[PRE24]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I’ve requested three characters in the `fread` call, so the program displays
    this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我在`fread`调用中请求了三个字符，因此程序显示如下内容：
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `fread` function is commonly used with binary data. If you use it on text
    data that spans more than one line, remember to count newline characters.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`fread`函数通常用于二进制数据。如果在跨越多行的文本数据上使用它，请记得计算换行符。'
- en: Copying Files
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制文件
- en: Let’s try out the PHP `copy` function to create a clone of *testfile.txt*. Type
    [Example 7-7](#copying_a_file), save it as *copyfile.php*, and then call up the
    program in your browser.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试 PHP `copy` 函数来创建*testfile.txt*的克隆。将其保存为*copyfile.php*，然后在浏览器中调用该程序，如[示例 7-7](#copying_a_file)。
- en: Example 7-7\. Copying a file
  id: totrans-192
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-7\. 复制文件
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you check your folder again, you’ll see that you now have the new file *testfile2.txt*
    in it. By the way, if you don’t want your programs to exit on a failed copy attempt,
    you could try the alternate syntax in [Example 7-8](#alternate_syntax_for_copying_a_file).
    This uses the `!` (`NOT`) operator as a quick-and-easy shorthand. Placed in front
    of an expression, it applies the `NOT` operator to it, so the equivalent statement
    here in English would begin “If not able to copy...”.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果再次检查你的文件夹，你会看到现在有了新文件*testfile2.txt*。顺便说一句，如果不希望程序在复制失败时退出，你可以尝试[示例 7-8](#alternate_syntax_for_copying_a_file)中的替代语法。它使用`!`（`NOT`）运算符作为一个快捷简便的缩写。放在表达式前面，它会对其应用`NOT`运算符，所以这里的等效语句在英语中会以“如果无法复制...”开头。
- en: Example 7-8\. Alternate syntax for copying a file
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-8\. 复制文件的替代语法
- en: '[PRE27]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Moving a File
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动文件
- en: To move a file, rename it with the `rename` function, as in [Example 7-9](#moving_a_file-id00020).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要移动文件，请使用`rename`函数重命名，如[示例 7-9](#moving_a_file-id00020)。
- en: Example 7-9\. Moving a file
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-9\. 移动文件
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You can use the `rename` function on directories, too. To avoid any warning
    messages if the original file doesn’t exist, you can call the `file_exists` function
    first to check.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在目录上使用`rename`函数。为了避免在原始文件不存在时出现任何警告消息，可以先调用`file_exists`函数进行检查。
- en: Deleting a File
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除文件
- en: Deleting a file is just a matter of using the `unlink` function to remove it
    from the filesystem, as in [Example 7-10](#deleting_a_file-id00021).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 删除文件只需使用`unlink`函数从文件系统中删除，如[示例 7-10](#deleting_a_file-id00021)中所示。
- en: Example 7-10\. Deleting a file
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-10\. 删除文件
- en: '[PRE29]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Warning
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Whenever you access files on your hard disk directly, you must also always ensure
    that it is impossible for your filesystem to be compromised. For example, if you
    are deleting a file based on user input, you must make absolutely certain it is
    a file that can be safely deleted and that the user is allowed to delete it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 每当直接访问硬盘上的文件时，您必须始终确保文件系统不会被破坏。例如，如果根据用户输入删除文件，则必须确保它是可以安全删除的文件，并且用户被允许删除它。
- en: As with moving a file, a warning message will be displayed if the file doesn’t
    exist, which you can avoid by using `file_exists` to first check for its existence
    before calling `unlink`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 与移动文件一样，如果文件不存在，将显示警告消息，您可以通过首先使用`file_exists`检查其是否存在，然后再调用`unlink`来避免这种情况。
- en: Updating Files
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新文件
- en: Often, you will want to add more data to a saved file, which you can do in many
    ways. You can use one of the append write modes (see [Table 7-5](#supported_fopen_modes)),
    or you can simply open a file for reading and writing with one of the other modes
    that supports writing, and move the file pointer to the correct place within the
    file that you wish to write to or read from.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能希望向已保存的文件添加更多数据，有多种方法可以实现。您可以使用追加写模式之一（参见[表 7-5](#supported_fopen_modes)），或者您可以简单地使用支持写入的其他模式之一打开文件进行读写，并将文件指针移动到希望写入或读取的文件中的正确位置。
- en: The *file pointer* is the position within a file at which the next file access
    will take place, whether it’s a read or a write. It is not the same as the *file
    handle* (as stored in the variable `$fh` in [Example 7-4](#creating_a_simple_text_file)),
    which contains details about the file being accessed.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件指针*是文件中下一个文件访问将发生的位置，无论是读取还是写入。它与*文件句柄*（在[示例 7-4](#creating_a_simple_text_file)中存储在变量`$fh`中）不同，后者包含有关正在访问的文件的详细信息。'
- en: You can see this in action by typing [Example 7-11](#updating_a_file) and saving
    it as *update.php*. Then call it up in your browser.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入[示例 7-11](#updating_a_file)并将其保存为*update.php*来查看其操作。然后在浏览器中调用它。
- en: Example 7-11\. Updating a file
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-11\. 更新文件
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This program opens *testfile.txt* for both reading and writing by setting the
    mode with `''r+''`, which puts the file pointer right at the start. It then uses
    the `fgets` function to read in a single line from the file (up to the first line
    feed). After that, the `fseek` function is called to move the file pointer right
    to the file end, at which point the line of text that was extracted from the start
    of the file (stored in `$text`) is then appended to the file’s end (preceded by
    a `\n` line feed) and the file is closed. The resulting file now looks like this:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此程序通过使用`'r+'`设置模式同时打开*testfile.txt*进行读取和写入，将文件指针置于开头。然后使用`fgets`函数从文件中读取一行（直到第一个换行符）。之后，调用`fseek`函数将文件指针直接移动到文件末尾，在此时，从文件开头提取的文本行（存储在`$text`中）将以`\n`换行符开头附加到文件末尾，然后关闭文件。结果文件现在如下所示：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The first line has successfully been copied and then appended to the file’s
    end.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行已成功复制并附加到文件的末尾。
- en: As used here, in addition to the `$fh` file handle, the `fseek` function was
    passed two other parameters, `0` and `SEEK_END`. `SEEK_END` tells the function
    to move the file pointer to the end of the file, and `0` tells it how many positions
    it should then be moved backward from that point. In the case of [Example 7-11](#updating_a_file),
    a value of `0` is used because the pointer is required to remain at the file’s
    end.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此处使用的`$fh`文件句柄外，还向`fseek`函数传递了另外两个参数，`0`和`SEEK_END`。`SEEK_END`告诉函数将文件指针移动到文件末尾，`0`告诉它从那一点开始向后移动多少位置。在[示例 7-11](#updating_a_file)的情况下，使用`0`是因为需要保持指针在文件的末尾。
- en: 'There are two other seek options available to the `fseek` function: `SEEK_SET`
    and `SEEK_CUR`. The `SEEK_SET` option tells the function to set the file pointer
    to the exact position given by the preceding parameter. Thus, the following example
    moves the file pointer to position 18:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`fseek`函数还有两个其他的寻址选项：`SEEK_SET`和`SEEK_CUR`。`SEEK_SET`选项告诉函数将文件指针设置为前面参数给出的确切位置。因此，以下示例将文件指针移动到位置18：'
- en: '[PRE32]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`SEEK_CUR` sets the file pointer to the current position *plus* the value of
    the given offset. Therefore, if the file pointer is currently at position 18,
    the following call will move it to position 23:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`SEEK_CUR`将文件指针设置为当前位置*加上*给定偏移量的值。因此，如果文件指针当前位于位置18，则以下调用将其移动到位置23：'
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Locking Files for Multiple Accesses
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为多次访问锁定文件
- en: Web programs are often called by many users at the same time. If more than one
    person tries to write to a file simultaneously, it can become corrupted. And if
    one person writes to it while another is reading from it, the file is all right,
    but the person reading it can get odd results. To handle simultaneous users, you
    must use the file-locking `flock` function. This function queues up all other
    requests to access a file until your program releases the lock. So, whenever your
    programs use write access on files that may be accessed concurrently by multiple
    users, you should also add file locking to them, as in [Example 7-12](#updating_a_file_with_file_locking),
    which is an updated version of [Example 7-11](#updating_a_file).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Web程序经常被许多用户同时调用。如果多个人尝试同时写入文件，可能会导致文件损坏。如果一个人在读取文件时另一个人在写入它，文件是没问题的，但读取它的人可能会得到奇怪的结果。为了处理同时使用者，你必须使用文件锁定`flock`函数。这个函数将所有其他访问文件的请求排队，直到你的程序释放锁。因此，每当你的程序对可能被多个用户同时访问的文件执行写入访问时，你还应该为它们添加文件锁定，如[示例 7-12](#updating_a_file_with_file_locking)中所示，这是[示例 7-11](#updating_a_file)的更新版本。
- en: Example 7-12\. Updating a file with file locking
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-12\. 使用文件锁更新文件
- en: '[PRE34]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'There is a trick to file locking to preserve the best possible response time
    for your website visitors: perform it directly before a change you make to a file,
    and then unlock it immediately afterward. Having a file locked for any longer
    than this will slow down your application unnecessarily. This is why the calls
    to `flock` in [Example 7-12](#updating_a_file_with_file_locking) are directly
    before and after the `fwrite` call.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件锁定有一个技巧，以保持网站访问者最佳的响应时间：在对文件进行更改之前直接执行锁定操作，然后立即解锁。将文件锁定时间超过此时间将不必要地减慢应用程序。这就是为什么在[示例 7-12](#updating_a_file_with_file_locking)中的`flock`调用直接在`fwrite`调用之前和之后的原因。
- en: 'The first call to `flock` sets an exclusive file lock on the file referred
    to by `$fh` using the `LOCK_EX` parameter:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`flock`使用`LOCK_EX`参数在由`$fh`引用的文件上设置独占文件锁：
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'From this point onward, no other processes can write to (or even read from)
    the file until you release the lock by using the `LOCK_UN` parameter, like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 从此时起，直到使用`LOCK_UN`参数释放锁为止，没有其他进程可以写入（甚至读取）该文件，如下所示：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As soon as the lock is released, other processes are again allowed access to
    the file. This is one reason why you should reseek to the point you wish to access
    in a file each time you need to read or write data—another process could have
    changed the file since the last access.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦释放锁定，其他进程就可以再次访问文件。这也是为什么每次需要读取或写入数据时都应重新定位到文件中希望访问的位置的原因之一——另一个进程可能在上次访问后更改了文件。
- en: However, did you notice that the call to request an exclusive lock is nested
    as part of an `if` statement? This is because `flock` is not supported on all
    systems; thus, it is wise to check whether you successfully secured a lock, just
    in case one could not be obtained.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你是否注意到请求独占锁的调用嵌套在一个`if`语句中？这是因为并非所有系统都支持`flock`；因此，明智的做法是检查是否成功获取了锁，以防无法获取锁。
- en: Something else you must consider is that `flock` is what is known as an *advisory*
    lock. This means that it locks out only other processes that call the function.
    If you have any code that goes right in and modifies files without implementing
    `flock` file locking, it will always override the locking and could wreak havoc
    on your files.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件你必须考虑的事情是，`flock`被称为*建议性*锁定。这意味着它只锁定调用该函数的其他进程。如果你有任何直接修改文件而没有实现`flock`文件锁定的代码，它将始终覆盖锁定，并可能对你的文件造成严重破坏。
- en: By the way, implementing file locking and then accidentally leaving it out in
    one section of code can lead to an extremely hard-to-locate bug.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，实现文件锁定然后意外地在某个代码部分中留下它可能会导致一个极其难以定位的错误。
- en: Warning
  id: totrans-236
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: '`flock` will not work on NFS and many other networked filesystems. Also, when
    using a multithreaded server like ISAPI, you may not be able to rely on `flock`
    to protect files against other PHP scripts running in parallel threads of the
    same server instance. Additionally, `flock` is not supported on any system using
    the old FAT filesystem, such as older versions of Windows, although you are unlikely
    to come across such systems (hopefully).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`flock` 在 NFS 和许多其他网络文件系统上无法工作。 此外，当使用像 ISAPI 这样的多线程服务器时，您可能无法依赖 `flock` 来保护文件免受同一服务器实例的并行线程中运行的其他
    PHP 脚本的影响。 另外，`flock` 不支持使用旧的 FAT 文件系统的任何系统，例如较旧版本的 Windows，尽管您不太可能遇到这些系统（希望如此）。'
- en: If in doubt, you can try making a quick lock on a test file at the start of
    a program to see whether you can obtain a lock on the file. Don’t forget to unlock
    it (and maybe delete it if not needed) after checking.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不确定，可以尝试在程序开始时快速锁定一个测试文件，看看是否可以锁定该文件。 检查后不要忘记解锁它（如果不需要，可能还要删除它）。
- en: Also remember that any call to the `die` function automatically unlocks a lock
    and closes the file as part of ending the program.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，任何对 `die` 函数的调用都会自动解锁锁定并关闭文件，作为结束程序的一部分。
- en: Reading an Entire File
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取整个文件
- en: A handy function for reading in an entire file without having to use file handles
    is `file_get_contents`. It’s very easy to use, as you can see in [Example 7-13](#using_file_get_contents).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方便的函数用于读取整个文件，而无需使用文件句柄是 `file_get_contents`。 它非常容易使用，就像您可以在 [Example 7-13](#using_file_get_contents)
    中看到的那样。
- en: Example 7-13\. Using `file_get_contents`
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-13\. 使用 `file_get_contents`
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: But the function is actually a lot more useful than that, because you can also
    use it to fetch a file from a server across the internet, as in [Example 7-14](#grabbing_the_oapostrophereilly_home_page),
    which requests the HTML from the O’Reilly home page and then displays it as if
    the user had surfed to the page itself. The result will be similar to [Figure 7-1](#oreillyhome).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这个函数实际上比这更有用，因为您还可以使用它从 Internet 上的服务器获取文件，就像 [Example 7-14](#grabbing_the_oapostrophereilly_home_page)
    中请求 O’Reilly 主页的 HTML 并将其显示为用户已经浏览到页面本身一样。 结果类似于 [Figure 7-1](#oreillyhome)。
- en: Example 7-14\. Grabbing the O’Reilly home page
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-14\. 抓取 O’Reilly 主页
- en: '[PRE38]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![](Images/pmj6_0701.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/pmj6_0701.png)'
- en: Figure 7-1\. The O’Reilly home page grabbed with `file_get_contents`
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 7-1\. 使用 `file_get_contents` 抓取的 O’Reilly 主页
- en: Uploading Files
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件上传
- en: Uploading files to a web server is a subject that seems daunting to many people,
    but it actually couldn’t be much easier. All you need to do to upload a file from
    a form is choose a special type of encoding called `multipart/form-data`, and
    your browser will handle the rest. To see how this works, type the program in
    [Example 7-15](#image_uploader_uploaddotphp) and save it as *upload.php*. When
    you run it, you’ll see a form in your browser that lets you upload a file of your
    choice.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件上传到 Web 服务器是许多人看起来令人生畏的主题，但实际上却没有那么困难。 要从表单中上传文件，您需要选择一种特殊的编码类型称为 `multipart/form-data`，您的浏览器会处理其余部分。
    要查看其工作原理，请输入 [Example 7-15](#image_uploader_uploaddotphp) 中的程序并将其保存为 *upload.php*。
    运行时，您将在浏览器中看到一个表单，让您上传您选择的文件。
- en: Example 7-15\. Image uploader upload.php
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 7-15\. 图像上传程序 upload.php
- en: '[PRE39]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Let’s examine this program a section at a time. The first line of the multiline
    `echo` statement starts an HTML document, displays the title, and then starts
    the document’s body.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐段检查这个程序。 多行 `echo` 语句的第一行开始一个 HTML 文档，显示标题，然后开始文档的主体。
- en: Next we come to the form, which selects the POST method of form submission,
    sets the target for posted data to the program *upload.php* (the program itself),
    and tells the web browser that the data posted should be encoded via the content
    type of `multipart/form-data`, the mime type used for file uploads.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们来到表单，它选择表单提交的 POST 方法，将发布数据的目标设置为程序 *upload.php*（程序本身），并告诉 Web 浏览器应使用 `multipart/form-data`
    的内容类型来编码发布的数据，这是文件上传的 MIME 类型。
- en: With the form set up, the next lines display the prompt `Select File:` and then
    request two inputs. The first request is for a file; it uses an input type of
    `file`, a name of `filename`, and an input field with a width of 10 characters.
    The second requested input is just a submit button that is given the label `Upload`
    (which replaces the default button text of Submit Query). And then the form is
    closed.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好表单后，下一行显示提示 `Select File:`，然后请求两个输入。 第一个请求是文件，它使用 `file` 类型的输入，名称为 `filename`，并且输入字段宽度为
    10 个字符。 第二个请求的输入只是一个提交按钮，标签为 `Upload`（取代默认的提交按钮文本 Submit Query）。 然后关闭表单。
- en: 'This short program shows a common technique in web programming in which a single
    program is called twice: once when the user first visits a page and again when
    the user clicks the submit button.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的程序展示了Web编程中的一个常见技术，即一个程序被调用两次：用户首次访问页面时和用户点击提交按钮时。
- en: The PHP code to receive the uploaded data is fairly simple, because all uploaded
    files are placed into the associative system array `$_FILES`. Therefore, a quick
    check to see whether `$_FILES` contains anything is sufficient to determine whether
    the user has uploaded a file. This is done with the statement `if ($_FILES)`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接收上传数据的PHP代码非常简单，因为所有上传的文件都放置在关联数组`$_FILES`中。因此，仅需快速检查`$_FILES`是否包含任何内容即可确定用户是否已上传文件。这通过语句`if
    ($_FILES)`完成。
- en: The first time the user visits the page, before uploading a file, `$_FILES`
    is empty, so the program skips this block of code. When the user uploads a file,
    the program runs again and discovers an element in the `$_FILES` array.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 用户首次访问页面时，在上传文件之前，`$_FILES`是空的，所以程序会跳过此代码块。当用户上传文件时，程序再次运行，并在`$_FILES`数组中发现一个元素。
- en: Once the program realizes that a file was uploaded, the actual name, as read
    from the uploading computer, is retrieved and placed into the variable `$name`.
    Now all that’s necessary is to move the uploaded file from the temporary location
    in which PHP stored it to a more permanent one. We do this using the `move_uploaded_file`
    function, passing it the original name of the file, with which it is saved to
    the current directory.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序意识到文件已上传，就会从PHP存储它的临时位置检索并将实际名称读取到变量`$name`中。现在只需要使用`move_uploaded_file`函数将上传的文件从PHP存储的临时位置移动到更永久的位置即可。我们通过将文件的原始名称传递给它来执行此操作，文件将保存到当前目录中。
- en: Finally, the uploaded image is displayed within an `IMG` tag, and the result
    should look like [Figure 7-2](#uploading_an_image_as_form_data).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，上传的图像将显示在一个`IMG`标签中，结果应该看起来像[图 7-2](#uploading_an_image_as_form_data)。
- en: Warning
  id: totrans-261
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: If you run this program and receive a warning message such as `Permission denied`
    for the `move_uploaded_file` function call, then you may not have the correct
    permissions set for the folder in which the program is running.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行此程序并收到类似`move_uploaded_file`函数调用时`Permission denied`的警告消息，那么您可能没有为程序运行的文件夹设置正确的权限。
- en: '![Uploading an image as form data](Images/pmj6_0702.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![以表单数据形式上传图像](Images/pmj6_0702.png)'
- en: Figure 7-2\. Uploading an image as form data
  id: totrans-264
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 7-2\. 以表单数据形式上传图像
- en: Using $_FILES
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `$_FILES`
- en: Five things are stored in the `$_FILES` array when a file is uploaded, as shown
    in [Table 7-6](#contents_of_the_dollar_files_array) (where *`file`* is the file
    upload field name supplied by the submitting form).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当上传文件时，`$_FILES` 数组中存储了五个东西，如[表 7-6](#contents_of_the_dollar_files_array)所示（其中*`file`*是提交表单提供的文件上传字段名）。
- en: Table 7-6\. The contents of the `$_FILES` array
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-6\. `$_FILES`数组的内容
- en: '| Array element | Contents |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 数组元素 | 内容 |'
- en: '| --- | --- |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `$_FILES[''*file*''][''*name*'']` | The name of the uploaded file (e.g.,
    *smiley.jpg*) |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `$_FILES[''*file*''][''*name*'']` | 上传文件的名称（例如，*smiley.jpg*） |'
- en: '| `$_FILES[''*file*''][''*type*'']` | The content type of the file (e.g., *image/jpeg*)
    |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `$_FILES[''*file*''][''*type*'']` | 文件的内容类型（例如，*image/jpeg*） |'
- en: '| `$_FILES[''*file*''][''*size*'']` | The file’s size in bytes |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| `$_FILES[''*file*''][''*size*'']` | 文件的字节大小 |'
- en: '| `$_FILES[''*file*''][''*tmp_name*'']` | The name of the temporary file stored
    on the server |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| `$_FILES[''*file*''][''*tmp_name*'']` | 服务器上存储的临时文件名 |'
- en: '| `$_FILES[''*file*''][''*error*'']` | The error code resulting from the file
    upload |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| `$_FILES[''*file*''][''*error*'']` | 文件上传引起的错误代码 |'
- en: Content types used to be known as *MIME* (Multipurpose Internet Mail Extension)
    types, but because their use later expanded to the whole internet, now they are
    often called *internet media types*. [Table 7-7](#some_common_internet_media_content_types)
    shows some of the more frequently used types that turn up in `$_FILES['`*`file`*`']['`*`type`*`']`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 以前称为*MIME*（多用途互联网邮件扩展）类型的内容类型，但由于它们后来的使用扩展到整个互联网，现在通常称为*互联网媒体类型*。[表 7-7](#some_common_internet_media_content_types)展示了在`$_FILES['`*`file`*`']['`*`type`*`']`中经常出现的一些类型。
- en: Table 7-7\. Some common internet media content types
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7-7\. 一些常见的互联网媒体内容类型
- en: '| `application/pdf` | `image/gif` | `multipart/form-data` | `text/xml` |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| `application/pdf` | `image/gif` | `multipart/form-data` | `text/xml` |'
- en: '| `application/zip` | `image/jpeg` | `text/css` | `video/mpeg` |'
  id: totrans-278
  prefs: []
  type: TYPE_TB
  zh: '| `application/zip` | `image/jpeg` | `text/css` | `video/mpeg` |'
- en: '| `audio/mpeg` | `image/png` | `text/html` | `video/mp4` |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '| `audio/mpeg` | `image/png` | `text/html` | `video/mp4` |'
- en: '| `audio/x-wav` | `application/json` | `text/plain` | `audio/webm` |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| `audio/x-wav` | `application/json` | `text/plain` | `audio/webm` |'
- en: Validation
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证
- en: I hope it now goes without saying (although I’ll do so anyway) that form data
    validation is of the utmost importance, due to the possibility of users attempting
    to hack into your server.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望现在毋庸置疑（尽管我还是会这么说），表单数据验证是非常重要的，因为用户可能试图入侵你的服务器。
- en: In addition to maliciously formed input data, some of the things you also have
    to check are whether a file was actually received and, if so, whether the right
    type of data was sent.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 除了恶意构造的输入数据之外，你还需要检查一些其他事情，例如是否实际接收到了文件，以及如果有的话，是否发送了正确类型的数据。
- en: Taking all these things into account, [Example 7-16](#more_secure_version_of_uploaddotphp),
    *upload2.php*, is a more secure rewrite of *upload.php*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些因素，[示例 7-16](#more_secure_version_of_uploaddotphp)，*upload2.php*，是*upload.php*的更安全的重写。
- en: Example 7-16\. A more secure version of upload.php
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-16\. `upload.php`的更安全版本
- en: '[PRE40]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The non-HTML section of code has been expanded from the half-dozen lines of
    [Example 7-15](#image_uploader_uploaddotphp) to more than 20 lines, starting at
    `if ($_FILES)`.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 非HTML代码部分从[示例 7-15](#image_uploader_uploaddotphp)的半打行扩展到超过20行，从`if ($_FILES)`开始。
- en: As with the previous version, this `if` line checks whether any data was actually
    posted, but there is now a matching `else` near the bottom of the program that
    echoes a message to the screen when nothing has been uploaded.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的版本一样，这个`if`行检查是否实际上有任何数据被发布，但是现在在程序底部附近有一个匹配的`else`，当没有上传任何内容时向屏幕输出一条消息。
- en: Within the `if` statement, the variable `$name` is assigned the value of the
    filename as retrieved from the uploading computer (just as before), but this time
    we won’t rely on the user having sent us valid data. Instead, a `switch` statement
    checks the uploaded content type against the four types of image this program
    supports. If a match is made, the variable `$ext` is set to the three-letter file
    extension for that type. Should no match be found, the file uploaded was not of
    an accepted type and the variable `$ext` is set to the empty string `""`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句内部，变量`$name`被赋予从上传计算机检索到的文件名的值（就像以前一样），但是这一次我们不依赖于用户发送给我们有效数据。相反，`switch`语句根据此程序支持的四种图像类型检查上传的内容类型。如果找到匹配项，则变量`$ext`设置为该类型的三字母文件扩展名。如果没有找到匹配项，则上传的文件不属于接受的类型，变量`$ext`设置为空字符串`""`。
- en: Note
  id: totrans-290
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In this example the file type still comes from the browser and can be modified
    or changed by the user uploading the file. In this instance such user manipulation
    is not of concern as the files are only being treated as images. But if the file
    could ever be executable, you should not rely on information you have not ascertained
    to be absolutely correct.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，文件类型仍然来自浏览器，并且可以被上传文件的用户修改或更改。在这种情况下，此类用户操作并不令人担忧，因为这些文件只被视为图像。但是，如果文件可能是可执行的，你不应依赖于你未确认绝对正确的信息。
- en: The next section of code then checks the variable `$ext` to see whether it contains
    a string and, if so, creates a new filename called `$n` with the base name *image*
    and the extension stored in `$ext`. This means that the program has full control
    over the file type of the file to be created, as it can be only one of *image.jpg*,
    *image.gif*, *image.png*, or *image.tif*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的下一部分然后检查变量`$ext`是否包含一个字符串，并且如果是这样的话，创建一个新的文件名叫做`$n`，基本名称为*image*，扩展名存储在`$ext`中。这意味着程序对要创建的文件类型有完全的控制，因为它只能是其中之一：*image.jpg*、*image.gif*、*image.png*或*image.tif*。
- en: Safe in the knowledge that the program has not been compromised, the rest of
    the PHP code is much the same as in the previous version. It moves the uploaded
    temporary image to its new location and then displays it while also displaying
    the old and new image names.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 有了程序未被破坏的保证，PHP代码的其余部分与之前的版本大致相同。它将上传的临时图像移动到新位置，然后显示它，同时显示旧图像和新图像的名称。
- en: Note
  id: totrans-294
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Don’t worry about having to delete the temporary file that PHP creates during
    the upload process, because if the file has not been moved or renamed, it will
    be automatically removed when the program exits.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心必须删除PHP在上传过程中创建的临时文件，因为如果文件没有被移动或重命名，当程序退出时它会自动删除。
- en: After the `if` statement, there is a matching `else`, which is executed only
    if an unsupported image type was uploaded (in which case it displays an appropriate
    error message).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在`if`语句之后，有一个匹配的`else`语句，只有在上传了不受支持的图像类型时才会执行（此时显示适当的错误消息）。
- en: When you write your own file-uploading routines, I strongly advise you to use
    a similar approach and have prechosen names and locations for uploaded files.
    That way, no attempts to add pathnames and other malicious data to the variables
    you use can get through. If this means that more than one user could end up having
    a file uploaded with the same name, you could prefix such files with their user’s
    usernames, or save them to individually created folders for each user.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写自己的文件上传例程时，我强烈建议您使用类似的方法，并为上传的文件预先选择名称和位置。这样，无法通过您使用的变量尝试添加路径名和其他恶意数据。如果这意味着多个用户可能使用相同的名称上传文件，则可以在这些文件前加上其用户的用户名前缀，或将它们保存到为每个用户单独创建的文件夹中。
- en: 'But if you must use a supplied filename, you should sanitize it by allowing
    only alphanumeric characters and the period, which you can do with the following
    command, using a regular expression (see [Chapter 18](ch18.xhtml#using_ajax))
    to perform a search and replace on `$name`:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您必须使用提供的文件名，您应该通过允许仅包含字母数字字符和句点的方式进行清理，可以使用以下命令使用正则表达式（参见[第18章](ch18.xhtml#using_ajax)）对`$name`进行搜索和替换：
- en: '[PRE41]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This leaves only the characters A–Z, a–z, 0–9 and periods in the string `$name`,
    and strips out everything else.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，字符串`$name`中仅留下A-Z、a-z、0-9和句点，并删除所有其他内容。
- en: 'Even better, to ensure that your program will work on all systems, regardless
    of whether they are case-sensitive or case-insensitive, you should probably use
    the following command instead, which changes all uppercase characters to lowercase
    at the same time:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，为了确保您的程序在所有系统上都能正常工作，无论它们是区分大小写还是不区分大小写，您可能应该改用以下命令，同时将所有大写字母改为小写字母：
- en: '[PRE42]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-303
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Sometimes you may encounter the media type of `image/pjpeg`, which indicates
    a progressive JPEG, but you can safely add this to your code as an alias of `image/jpeg`,
    like this:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能会遇到`image/pjpeg`的媒体类型，表示渐进式JPEG，但您可以安全地将其添加到代码中作为`image/jpeg`的别名，如下所示：
- en: '[PRE43]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: System Calls
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 系统调用
- en: Sometimes PHP will not have the function you need to perform a certain action,
    but the operating system it is running on may. In such cases, you can use the
    `exec` system call to do the job.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 有时PHP可能没有您执行某个操作所需的函数，但运行它的操作系统可能会有。在这种情况下，您可以使用`exec`系统调用来完成工作。
- en: For example, to quickly view the contents of the current directory, you can
    use a program such as [Example 7-17](#executing_a_system_command). If you are
    on a Windows system, it will run as is using the Windows `dir` command. On Linux,
    Unix, or macOS, comment out or remove the first line and uncomment the second
    to use the `ls` system command. You may wish to type this program, save it as
    *exec.php*, and call it up in your browser.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要快速查看当前目录的内容，您可以使用诸如[示例 7-17](#executing_a_system_command)的程序。如果您使用的是Windows系统，它将直接使用Windows
    `dir`命令运行。在Linux、Unix或macOS上，请注释或删除第一行，并取消注释第二行以使用`ls`系统命令。您可能希望键入此程序，将其保存为*exec.php*，并在浏览器中调用它。
- en: Example 7-17\. Executing a system command
  id: totrans-309
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 7-17\. 执行系统命令
- en: '[PRE44]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The `htmlspecialchars` function is called to turn any special characters returned
    by the system into ones that HTML can understand and properly display, neatening
    the output. Depending on the system you are using, the result of running this
    program will look something like this (from a Windows `dir` command):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`htmlspecialchars`函数用于将系统返回的任何特殊字符转换为HTML可以理解和正确显示的字符，整理输出。根据您使用的系统，运行此程序的结果将类似于以下内容（来自Windows
    `dir`命令）：
- en: '[PRE45]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`exec` takes three arguments:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`exec`接受三个参数：'
- en: The command itself (in the previous case, `$cmd`)
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令本身（在前一种情况下为`$cmd`）
- en: An array in which the system will put the output from the command (in the previous
    case, `$output`)
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统将从命令中获取输出的数组（在前一种情况下为`$output`）
- en: A variable to contain the returned status of the call (which, in the previous
    case, is `$status`)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个变量，用于包含调用的返回状态（在前一种情况下是`$status`）
- en: If you wish, you can omit the `$output` and `$status` parameters, but you will
    not know the output created by the call or even whether it completed successfully.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如果愿意，可以省略`$output`和`$status`参数，但将无法知道调用生成的输出，甚至不知道是否成功完成。
- en: You should also note the use of the `escapeshellcmd` function. It is a good
    habit to always use this when issuing an `exec` call, because it sanitizes the
    command string, preventing the execution of arbitrary commands, should you supply
    user input to the call.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应注意`escapeshellcmd`函数的使用。在发出`exec`调用时，始终使用此函数是一个好习惯，因为它清理命令字符串，防止执行任意命令，如果您向调用提供用户输入。
- en: Warning
  id: totrans-319
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The system call functions are typically disabled on shared web hosts, as they
    pose a security risk. You should always try to solve your problems within PHP
    if you can, and go to the system directly only if it is really necessary. Also,
    going to the system is relatively slow, and you need to code two implementations
    if your application is expected to run on both Windows and Linux/Unix systems.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 共享网络主机通常会禁用系统调用功能，因为它们存在安全风险。如果可能的话，你应该始终尝试在 PHP 内部解决问题，只有在确实必要时才直接访问系统。此外，访问系统相对较慢，如果你的应用程序预计在
    Windows 和 Linux/Unix 系统上运行，你需要编写两种实现。
- en: XHTML or HTML5?
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: XHTML 还是 HTML5？
- en: Because XHTML documents need to be well formed, you can parse them using standard
    XML parsers—unlike HTML, which requires a lenient HTML-specific parser. For this
    reason, XHTML never really caught on, and when the time came to devise a new standard,
    the World Wide Web Consortium chose to support HTML5 rather than the newer XHTML2
    standard.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 XHTML 文档需要良好的格式，你可以使用标准的 XML 解析器解析它们——与 HTML 不同，后者需要宽松的专用 HTML 解析器。因此，XHTML
    从未真正流行起来，当制定新标准时，万维网联盟选择支持 HTML5 而不是较新的 XHTML2 标准。
- en: 'HTML5 has some of the features of both HTML4 and XHTML but is much simpler
    to use and less strict to validate—and, happily, there is now just a single document
    type you need to place at the head of an HTML5 document (instead of the variety
    of strict, transitional, and frameset types previously required):'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: HTML5 同时具有 HTML4 和 XHTML 的一些特性，但使用起来更简单，验证时更宽松。幸运的是，现在你只需要在 HTML5 文档的头部放置一个单一的文档类型声明（而不是之前需要的多种
    strict、transitional 和 frameset 类型）：
- en: '[PRE46]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Just the simple word `html` is sufficient to tell the browser that your web
    page is designed for HTML5, and, because all the latest versions of the most popular
    browsers have been supporting most of the HTML5 specification since 2011 or so,
    this document type is generally the only one you need, unless you choose to cater
    to older browsers.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 只需简单的单词`html`即可告诉浏览器你的网页是为 HTML5 设计的，因为自 2011 年左右，大多数流行浏览器的最新版本都支持大部分 HTML5
    规范，所以这种文档类型通常是你唯一需要的，除非你选择支持旧版浏览器。
- en: For all intents and purposes, when writing HTML documents, web developers can
    safely ignore the old XHTML document types and syntax (such as using `<br />`
    instead of the simpler `<br>` tag). But if you find yourself having to cater to
    a very old browser or an unusual application that relies on XHTML, then you can
    get more information on how to do that at [*http://xhtml.com*](http://xhtml.com).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 就 HTML 文档编写而言，Web 开发人员可以安全地忽略旧的 XHTML 文档类型和语法（例如使用`<br />`而不是更简单的`<br>`标签）。但如果你发现自己需要支持非常旧的浏览器或依赖于
    XHTML 的特殊应用程序，你可以在[*http://xhtml.com*](http://xhtml.com)获取更多信息。
- en: Questions
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which `printf` conversion specifier would you use to display a floating-point
    number?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个`printf`转换说明符用于显示浮点数？
- en: What `printf` statement could be used to take the input string `"Happy Birthday"`
    and output the string `"**Happy"`?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么`printf`语句可用于将输入字符串`"Happy Birthday"`输出为字符串`"**Happy"`？
- en: To send the output from `printf` to a variable instead of to a browser, what
    alternative function would you use?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将`printf`的输出发送到变量而不是浏览器，你会使用哪个替代函数？
- en: How would you create a Unix timestamp for 7:11 a.m. on May 2, 2025?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何为 2025 年 5 月 2 日上午 7:11 创建 Unix 时间戳？
- en: Which file access mode would you use with `fopen` to open a file in write and
    read mode, with the file truncated and the file pointer at the start?
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`fopen`以写入和读取模式打开文件，并将文件截断，并将文件指针置于起始位置时，会使用哪种文件访问模式？
- en: What is the PHP command for deleting the file *file.txt*?
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除文件*file.txt*的 PHP 命令是什么？
- en: Which PHP function is used to read in an entire file in one go, even from across
    the web?
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 PHP 函数用于一次性从网络上读取整个文件？
- en: Which PHP superglobal variable holds the details on uploaded files?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 PHP 超全局变量包含有关上传文件的详细信息？
- en: Which PHP function enables the running of system commands?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个 PHP 函数启用运行系统命令？
- en: 'Which of the following tag styles is preferred in HTML5: `<hr>` or `<hr />`?'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTML5 中更倾向于使用以下哪种标签风格：`<hr>`还是`<hr />`？
- en: See [“Chapter 7 Answers”](app01_split_006.xhtml#chapter_7_answers) in the [Appendix A](app01_split_000.xhtml#solutions_to_the_chapter_questions)
    for the answers to these questions.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[“第7章答案”](app01_split_006.xhtml#chapter_7_answers)，位于[附录 A](app01_split_000.xhtml#solutions_to_the_chapter_questions)中，以获取这些问题的答案。
