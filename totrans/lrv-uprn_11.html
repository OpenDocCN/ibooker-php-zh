<html><head></head><body><section data-pdf-bookmark="Chapter 11. The Container" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_container">&#13;
<h1><span class="label">Chapter 11. </span>The Container</h1>&#13;
&#13;
&#13;
<p>Laravel’s<a data-primary="containers" data-secondary="purpose of" data-type="indexterm" id="id1434"/> service container, or dependency injection container, sits at the core of almost every other feature. The container is a simple tool you can use to bind and resolve concrete instances of classes and interfaces, and at the same time, it’s a powerful and nuanced manager of a network of interrelated dependencies. In this chapter, you’ll learn more about what it is, how it works, and how you can use it.</p>&#13;
<div data-type="note" epub:type="note"><h1>Naming and the Container</h1>&#13;
<p>You’ll<a data-primary="containers" data-secondary="alternate names for" data-type="indexterm" id="id1435"/><a data-primary="names and naming" data-secondary="service containers" data-type="indexterm" id="id1436"/> notice in this book, in the documentation, and in other educational sources that there are quite a few names folks use for the container. These include:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Application container</p>&#13;
</li>&#13;
<li>&#13;
<p>IoC (inversion of control) container</p>&#13;
</li>&#13;
<li>&#13;
<p>Service container</p>&#13;
</li>&#13;
<li>&#13;
<p>DI (dependency injection) container</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>All are useful and valid, but just know they’re all talking about the same thing. They’re all referring to the service container.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Quick Introduction to Dependency Injection" data-type="sect1"><div class="sect1" id="id219">&#13;
<h1>A Quick Introduction to Dependency Injection</h1>&#13;
&#13;
<p>Dependency injection<a data-primary="containers" data-secondary="dependency injection overview" data-type="indexterm" id="id1437"/><a data-primary="dependency injection" data-secondary="introduction to" data-type="indexterm" id="id1438"/> means that, rather than being instantiated (“newed up”) within a class, each class’s dependencies will be <em>injected</em> in from the outside. This<a data-primary="constructor injection" data-type="indexterm" id="id1439"/> most commonly occurs with <em>constructor injection</em>, which means an object’s dependencies are injected when it’s created. But there’s<a data-primary="setter injection" data-type="indexterm" id="id1440"/> also <em>setter injection</em>, where the class exposes a method specifically for injecting a given dependency, and<a data-primary="method injection" data-type="indexterm" id="id1441"/> <em>method injection</em>, where one or more methods expect their dependencies to be injected when they’re called.</p>&#13;
&#13;
<p>Take a look at <a data-type="xref" href="#EX1101">Example 11-1</a> for a quick example of constructor injection, the most common type of dependency injection.</p>&#13;
<div data-type="example" id="EX1101">&#13;
<h5><span class="label">Example 11-1. </span>Basic dependency injection</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="o">&lt;?</code><code class="nx">php</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">UserMailer</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">protected</code> <code class="nv">$mailer</code><code class="p">;</code>&#13;
&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="fm">__construct</code><code class="p">(</code><code class="nx">Mailer</code> <code class="nv">$mailer</code><code class="p">)</code>&#13;
    <code class="p">{</code>&#13;
        <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">mailer</code> <code class="o">=</code> <code class="nv">$mailer</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">welcome</code><code class="p">(</code><code class="nv">$user</code><code class="p">)</code>&#13;
    <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">mailer</code><code class="o">-&gt;</code><code class="na">mail</code><code class="p">(</code><code class="nv">$user</code><code class="o">-&gt;</code><code class="na">email</code><code class="p">,</code> <code class="s1">'Welcome!'</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>As you can see, this <code>UserMailer</code> class expects an object of type <code>Mailer</code> to be injected when it’s instantiated, and its methods then refer to that instance.</p>&#13;
&#13;
<p>The primary benefits of dependency injection are that it gives us the freedom to change what we’re injecting, to mock dependencies for testing, and to instantiate shared dependencies just once for shared use.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id1442">&#13;
<h1>Inversion of Control</h1>&#13;
<p>You<a data-primary="inversion of control" data-type="indexterm" id="id1443"/><a data-primary="IoC containers" data-type="indexterm" id="id1444"/><a data-primary="containers" data-secondary="IoC containers" data-type="indexterm" id="id1445"/> may have heard the phrase “inversion of control” used in conjunction with “dependency injection,” and sometimes Laravel’s container is called the IoC container.</p>&#13;
&#13;
<p>The two concepts are very similar. Inversion of control references the idea that, in traditional programming, the lowest-level code—​specific classes, instances, and procedural code—“controls” that instance of a particular pattern or interface to use. For example, if you’re instantiating your mailer in each class that needs it, each class gets to decide whether to use Mailgun or Mandrill or Sendgrid.</p>&#13;
&#13;
<p>The idea of inversion of control refers to flipping that “control” to the opposite end of your application. Now the definition of which mailer to use lives at the highest, most abstract level of the application, often in configuration. Every instance, every piece of low-level code, looks up to the high-level configuration to essentially “ask”: “Can you give me a mailer?” They don’t “know” which mailer they’re getting, just that they’re getting one.</p>&#13;
&#13;
<p>Dependency injection and especially DI containers provide a great opportunity for inversion of control because, for example, you can define once which concrete instance of the <code>Mailer</code> interface to provide when injecting mailers into any class that needs them.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dependency Injection and Laravel" data-type="sect1"><div class="sect1" id="id460">&#13;
<h1>Dependency Injection and Laravel</h1>&#13;
&#13;
<p>As<a data-primary="containers" data-secondary="dependency injection and Laravel" data-type="indexterm" id="id1446"/><a data-primary="dependency injection" data-secondary="and Laravel" data-secondary-sortas="Laravel" data-type="indexterm" id="id1447"/> you saw in <a data-type="xref" href="#EX1101">Example 11-1</a>, the most common pattern for dependency injection <span class="keep-together">is constructor</span> injection, or injecting the dependencies of an object when it’s instantiated (“constructed”).</p>&#13;
&#13;
<p>Let’s take our <code>UserMailer</code> class from <a data-type="xref" href="#EX1101">Example 11-1</a>. <a data-type="xref" href="#EX1102">Example 11-2</a> shows what it might look like to create and use an instance of it.</p>&#13;
<div data-type="example" id="EX1102">&#13;
<h5><span class="label">Example 11-2. </span>Simple manual dependency injection</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="nv">$mailer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MailgunMailer</code><code class="p">(</code><code class="nv">$mailgunKey</code><code class="p">,</code> <code class="nv">$mailgunSecret</code><code class="p">,</code> <code class="nv">$mailgunOptions</code><code class="p">);</code>&#13;
<code class="nv">$userMailer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">UserMailer</code><code class="p">(</code><code class="nv">$mailer</code><code class="p">);</code>&#13;
&#13;
<code class="nv">$userMailer</code><code class="o">-&gt;</code><code class="na">welcome</code><code class="p">(</code><code class="nv">$user</code><code class="p">);</code></pre></div>&#13;
&#13;
<p>Now let’s imagine we want our <code>UserMailer</code> class to be able to log messages, as well as send a notification to a Slack channel every time it sends a message. <a data-type="xref" href="#EX1103">Example 11-3</a> shows what this would look like. As you can see, it would start to get pretty unwieldy if we had to do all this work every time we wanted to create a new instance—​especially when you consider that we’ll have to get all these parameters from somewhere.</p>&#13;
<div data-type="example" id="EX1103">&#13;
<h5><span class="label">Example 11-3. </span>More complex manual dependency injection</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="nv">$mailer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MailgunMailer</code><code class="p">(</code><code class="nv">$mailgunKey</code><code class="p">,</code> <code class="nv">$mailgunSecret</code><code class="p">,</code> <code class="nv">$mailgunOptions</code><code class="p">);</code>&#13;
<code class="nv">$logger</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Logger</code><code class="p">(</code><code class="nv">$logPath</code><code class="p">,</code> <code class="nv">$minimumLogLevel</code><code class="p">);</code>&#13;
<code class="nv">$slack</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Slack</code><code class="p">(</code><code class="nv">$slackKey</code><code class="p">,</code> <code class="nv">$slackSecret</code><code class="p">,</code> <code class="nv">$channelName</code><code class="p">,</code> <code class="nv">$channelIcon</code><code class="p">);</code>&#13;
<code class="nv">$userMailer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">UserMailer</code><code class="p">(</code><code class="nv">$mailer</code><code class="p">,</code> <code class="nv">$logger</code><code class="p">,</code> <code class="nv">$slack</code><code class="p">);</code>&#13;
&#13;
<code class="nv">$userMailer</code><code class="o">-&gt;</code><code class="na">welcome</code><code class="p">(</code><code class="nv">$user</code><code class="p">);</code></pre></div>&#13;
&#13;
<p>Imagine having to write that code every time you wanted a <code>UserMailer</code>. Dependency injection is great, but this is a mess.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The app() Global Helper" data-type="sect1"><div class="sect1" id="id220">&#13;
<h1>The app() Global Helper</h1>&#13;
&#13;
<p>Before<a data-primary="containers" data-secondary="getting objects out of containers" data-type="indexterm" id="id1448"/><a data-primary="helpers" data-secondary="app() global helper" data-type="indexterm" id="id1449"/><a data-primary="app() global helper" data-type="indexterm" id="id1450"/> we go too far into how the container actually works, let’s take a quick look at the simplest way to get an object out of the container: the <code>app()</code> helper.</p>&#13;
&#13;
<p>Pass any string to that helper, whether it’s a fully qualified class name (FQCN, like <code><em>App\ThingDoer</em></code>) or a Laravel shortcut (we’ll talk about those more in a second), and it’ll return an instance of that class:</p>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="nv">$logger</code> <code class="o">=</code> <code class="nx">app</code><code class="p">(</code><code class="nx">Logger</code><code class="o">::</code><code class="na">class</code><code class="p">);</code></pre>&#13;
&#13;
<p>This is the absolute simplest way to interact with the container. It creates an instance of this class and returns it for you, nice and easy. It’s like <code>new Logger</code> but, as you’ll see shortly, much better.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id1451">&#13;
<h1>Different Syntaxes for Making a Concrete Instance</h1>&#13;
<p>The<a data-primary="concrete instances" data-type="indexterm" id="id1452"/><a data-primary="make() method" data-type="indexterm" id="id1453"/> simplest way to “make” a concrete instance of any class or interface is to use the global helper and pass the class or interface name directly to the helper, using <code>app('<em>FQCN</em>')</code>.</p>&#13;
&#13;
<p>However, if you have an instance of the container—​whether it was injected somewhere, or you’re in a service provider and using <code>$this-&gt;app</code>, or (a lesser-known trick) you get one just by running <code>$container = app()</code>—there are a few ways to make an instance from there.</p>&#13;
&#13;
<p>The most common way is to run the <code>make()</code> method. <code>$app-&gt;make('<em>FQCN</em>')</code> works well. However, you may also see other developers and the documentation use this syntax sometimes: <code>$app['<em>FQCN</em>']</code>. Don’t worry. That’s doing the same thing; it’s just a different way of writing it.</p>&#13;
</div></aside>&#13;
&#13;
<p>Creating the <code>Logger</code> instance as shown here seems simple enough, but you might’ve noticed that our <code>$logger</code> class in <a data-type="xref" href="#EX1103">Example 11-3</a> has two parameters: <code>$logPath</code> and <code>$minimumLogLevel</code>. How does the container know what to pass here?</p>&#13;
&#13;
<p>Short answer: it doesn’t. You can use the <code>app()</code> global helper to create an instance of a class that has no parameters in its constructor, but at that point you could’ve just run <code>new Logger</code> yourself. The container shines when there’s some complexity in the constructor, and that’s when we need to look at how exactly the container can figure out how to construct classes with constructor parameters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How the Container Is Wired" data-type="sect1"><div class="sect1" id="id221">&#13;
<h1>How the Container Is Wired</h1>&#13;
&#13;
<p>Before<a data-primary="containers" data-secondary="autowiring of" data-type="indexterm" id="id1454"/><a data-primary="autowiring" data-type="indexterm" id="id1455"/> we dig further into the <code>Logger</code> class, take a look at <a data-type="xref" href="#EX1104">Example 11-4</a>.</p>&#13;
<div data-type="example" id="EX1104">&#13;
<h5><span class="label">Example 11-4. </span>Laravel autowiring</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="k">class</code> <code class="nc">Bar</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="fm">__construct</code><code class="p">()</code> <code class="p">{}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">Baz</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="fm">__construct</code><code class="p">()</code> <code class="p">{}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">Foo</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="fm">__construct</code><code class="p">(</code><code class="nx">Bar</code> <code class="nv">$bar</code><code class="p">,</code> <code class="nx">Baz</code> <code class="nv">$baz</code><code class="p">)</code> <code class="p">{}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nv">$foo</code> <code class="o">=</code> <code class="nx">app</code><code class="p">(</code><code class="nx">Foo</code><code class="o">::</code><code class="na">class</code><code class="p">);</code></pre></div>&#13;
&#13;
<p>This looks similar to our mailer example in <a data-type="xref" href="#EX1103">Example 11-3</a>. What’s different is that these dependencies (<code>Bar</code> and <code>Baz</code>) are both so simple that the container can resolve them without any further information. The container reads the typehints in the <code>Foo</code> constructor, resolves an instance of both <code>Bar</code> and <code>Baz</code>, and then injects them into the new <code>Foo</code> instance when it’s creating it. This is called <em>autowiring</em>: resolving instances based on typehints without the developer needing to explicitly bind those classes in the container.</p>&#13;
&#13;
<p>Autowiring means that, if a class has not been explicitly bound to the container (like <code>Foo</code>, <code>Bar</code>, or <code>Baz</code> in this context) but the container can figure out how to resolve it anyway, the container will resolve it. This means any class with no constructor dependencies (like <code>Bar</code> and <code>Baz</code>) and any class with constructor dependencies that the container can resolve (like <code>Foo</code>) can be resolved out of the container.</p>&#13;
&#13;
<p>That leaves us needing to bind only classes that have unresolvable constructor parameters—​for example, our <code>$logger</code> class in <a data-type="xref" href="#EX1103">Example 11-3</a>, which has parameters related to our log path and log level.</p>&#13;
&#13;
<p>For those, we’ll need to learn how to explicitly bind something to the container.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Binding Classes to the Container" data-type="sect1"><div class="sect1" id="id461">&#13;
<h1>Binding Classes to the Container</h1>&#13;
&#13;
<p>Binding<a data-primary="containers" data-secondary="binding classes to" data-type="indexterm" id="Cbind11"/> a class to Laravel’s container is essentially telling the container, “If a developer asks for an instance of <code>Logger</code>, here’s the code to run to instantiate one with the correct parameters and dependencies and then return it correctly.”</p>&#13;
&#13;
<p>We’re teaching the container that, when someone asks for this particular string (which is usually the FQCN of a class), it should resolve it this way.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Binding to a Closure" data-type="sect2"><div class="sect2" id="id222">&#13;
<h2>Binding to a Closure</h2>&#13;
&#13;
<p>So, let’s<a data-primary="closures" data-type="indexterm" id="id1456"/> look at how to bind to the container. Note that the appropriate place to bind to the container is in a service provider’s <code>register()</code> method (see <a data-type="xref" href="#EX1105">Example 11-5</a>).</p>&#13;
<div data-type="example" id="EX1105">&#13;
<h5><span class="label">Example 11-5. </span>Basic container binding</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// In any service provider (maybe LoggerServiceProvider)</code>&#13;
<code class="k">public</code> <code class="k">function</code> <code class="nf">register</code><code class="p">()</code><code class="o">:</code> <code class="nx">void</code>&#13;
<code class="p">{</code>&#13;
    <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">bind</code><code class="p">(</code><code class="nx">Logger</code><code class="o">::</code><code class="na">class</code><code class="p">,</code> <code class="k">function</code> <code class="p">(</code><code class="nv">$app</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="k">new</code> <code class="nx">Logger</code><code class="p">(</code><code class="s1">'\log\path\here'</code><code class="p">,</code> <code class="s1">'error'</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>There are a few important things to note in this example. First, we’re running <code>$this</code><code class="keep-together">-&gt;app-&gt;bind()</code>. <code>$this-&gt;app</code> is an instance of the container that’s always available on every service provider. The container’s <code>bind()</code> method is what we use to bind to the container.</p>&#13;
&#13;
<p>The first parameter of <code>bind()</code> is the “key” we’re binding to. Here, we’ve used the FQCN of the class. The second parameter differs depending on what you’re doing, but essentially, it should be <em>something</em> that shows the container what to do to resolve an instance of that bound key.</p>&#13;
&#13;
<p>So, in this example, we’re passing a closure. And now, any time someone runs <code>app(Logger::class)</code>, they’ll get the result of this closure. The closure is passed an instance of the container itself (<code>$app</code>), so if the class you’re resolving has a dependency you want resolved out of the container, you can use it in your definition as seen in <a data-type="xref" href="#EX11a">Example 11-6</a>.</p>&#13;
<div data-type="example" id="EX11a">&#13;
<h5><span class="label">Example 11-6. </span>Using the passed <code>$app</code> instance in a container binding</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// Note that this binding is not doing anything technically useful, since this</code>&#13;
<code class="c1">// could all be provided by the container's autowiring already.</code>&#13;
<code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">bind</code><code class="p">(</code><code class="nx">UserMailer</code><code class="o">::</code><code class="na">class</code><code class="p">,</code> <code class="k">function</code> <code class="p">(</code><code class="nv">$app</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nx">UserMailer</code><code class="p">(</code>&#13;
        <code class="nv">$app</code><code class="o">-&gt;</code><code class="na">make</code><code class="p">(</code><code class="nx">Mailer</code><code class="o">::</code><code class="na">class</code><code class="p">),</code>&#13;
        <code class="nv">$app</code><code class="o">-&gt;</code><code class="na">make</code><code class="p">(</code><code class="nx">Logger</code><code class="o">::</code><code class="na">class</code><code class="p">),</code>&#13;
        <code class="nv">$app</code><code class="o">-&gt;</code><code class="na">make</code><code class="p">(</code><code class="nx">Slack</code><code class="o">::</code><code class="na">class</code><code class="p">)</code>&#13;
    <code class="p">);</code>&#13;
<code class="p">});</code></pre></div>&#13;
&#13;
<p>Note that every time you ask for a new instance of your class, this closure will be run again and the new output returned.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Binding to Singletons, Aliases, and Instances" data-type="sect2"><div class="sect2" id="id223">&#13;
<h2>Binding to Singletons, Aliases, and Instances</h2>&#13;
&#13;
<p>If you want<a data-primary="singletons, binding to" data-type="indexterm" id="id1457"/><a data-primary="aliases, binding to" data-type="indexterm" id="id1458"/><a data-primary="instances, binding to" data-type="indexterm" id="id1459"/> the output of the binding closure to be cached so that this closure isn’t re-run every time you ask for an instance, that’s the singleton pattern, and you can run <code>$this-&gt;app-&gt;singleton()</code> to do that. <a data-type="xref" href="#EX11b">Example 11-7</a> shows what this looks like.</p>&#13;
<div data-type="example" id="EX11b">&#13;
<h5><span class="label">Example 11-7. </span>Binding a singleton to the container</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="k">public</code> <code class="k">function</code> <code class="nf">register</code><code class="p">()</code><code class="o">:</code> <code class="nx">void</code>&#13;
<code class="p">{</code>&#13;
    <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">singleton</code><code class="p">(</code><code class="nx">Logger</code><code class="o">::</code><code class="na">class</code><code class="p">,</code> <code class="k">function</code> <code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="k">new</code> <code class="nx">Logger</code><code class="p">(</code><code class="s1">'\log\path\here'</code><code class="p">,</code> <code class="s1">'error'</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>You can also get similar behavior if you already have an instance of the object you want the singleton to return, as seen in <a data-type="xref" href="#EX11c">Example 11-8</a>.</p>&#13;
<div data-type="example" id="EX11c">&#13;
<h5><span class="label">Example 11-8. </span>Binding an existing class instance to the container</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="k">public</code> <code class="k">function</code> <code class="nf">register</code><code class="p">()</code><code class="o">:</code> <code class="nx">void</code>&#13;
<code class="p">{</code>&#13;
    <code class="nv">$logger</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Logger</code><code class="p">(</code><code class="s1">'\log\path\here'</code><code class="p">,</code> <code class="s1">'error'</code><code class="p">);</code>&#13;
    <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">instance</code><code class="p">(</code><code class="nx">Logger</code><code class="o">::</code><code class="na">class</code><code class="p">,</code> <code class="nv">$logger</code><code class="p">);</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Finally, if you want to alias one class to another, bind a class to a shortcut, or bind a shortcut to a class, you can just pass two strings, as shown in <a data-type="xref" href="#EX11d">Example 11-9</a>.</p>&#13;
<div data-type="example" id="EX11d">&#13;
<h5><span class="label">Example 11-9. </span>Aliasing classes and strings</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// Asked for Logger, give FirstLogger</code>&#13;
<code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">bind</code><code class="p">(</code><code class="nx">Logger</code><code class="o">::</code><code class="na">class</code><code class="p">,</code> <code class="nx">FirstLogger</code><code class="o">::</code><code class="na">class</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Asked for log, give FirstLogger</code>&#13;
<code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">bind</code><code class="p">(</code><code class="s1">'log'</code><code class="p">,</code> <code class="nx">FirstLogger</code><code class="o">::</code><code class="na">class</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Asked for log, give FirstLogger</code>&#13;
<code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">alias</code><code class="p">(</code><code class="nx">FirstLogger</code><code class="o">::</code><code class="na">class</code><code class="p">,</code> <code class="s1">'log'</code><code class="p">);</code></pre></div>&#13;
&#13;
<p>Note that these shortcuts are common in Laravel’s core; it provides a system of shortcuts to classes that provide core functionality, using easy-to-remember keys like <code>log</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Binding a Concrete Instance to an Interface" data-type="sect2"><div class="sect2" id="id224">&#13;
<h2>Binding a Concrete Instance to an Interface</h2>&#13;
&#13;
<p>Just<a data-primary="concrete instances" data-type="indexterm" id="id1460"/> like we can bind a class to another class, or a class to a shortcut, we can also bind to an interface. This is extremely powerful, because we can now typehint interfaces instead of class names, like in <a data-type="xref" href="#EX1106">Example 11-10</a>.</p>&#13;
<div data-type="example" id="EX1106">&#13;
<h5><span class="label">Example 11-10. </span>Typehinting and binding to an interface</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="o">...</code>&#13;
<code class="k">use</code> <code class="nx">Interfaces\Mailer</code> <code class="k">as</code> <code class="nx">MailerInterface</code><code class="p">;</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">UserMailer</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">protected</code> <code class="nv">$mailer</code><code class="p">;</code>&#13;
&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="fm">__construct</code><code class="p">(</code><code class="nx">MailerInterface</code> <code class="nv">$mailer</code><code class="p">)</code>&#13;
    <code class="p">{</code>&#13;
        <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">mailer</code> <code class="o">=</code> <code class="nv">$mailer</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// Service provider</code>&#13;
<code class="k">public</code> <code class="k">function</code> <code class="nf">register</code><code class="p">()</code><code class="o">:</code> <code class="nx">void</code>&#13;
<code class="p">{</code>&#13;
    <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">bind</code><code class="p">(</code><code class="nx">\Interfaces\Mailer</code><code class="o">::</code><code class="na">class</code><code class="p">,</code> <code class="k">function</code> <code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="k">new</code> <code class="nx">MailgunMailer</code><code class="p">(</code><code class="o">...</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>You can now typehint <code>Mailer</code> or <code>Logger</code> interfaces all across your code, and then choose once in a service provider which specific mailer or logger you want to use everywhere. That’s inversion of control.</p>&#13;
&#13;
<p>One of the key benefits you get from using this pattern is that later, if you choose to use a different mail provider than Mailgun, as long as you have a mailer class for that new provider that implements the <code>Mailer</code> interface, you can swap it once in your service provider and everything in the rest of your code will just work.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Contextual Binding" data-type="sect2"><div class="sect2" id="id225">&#13;
<h2>Contextual Binding</h2>&#13;
&#13;
<p>Sometimes<a data-primary="contextual binding" data-type="indexterm" id="id1461"/> you need to change how to resolve an interface depending on the context. You might want to log events from one place to a local syslog and from others out <span class="keep-together">to an</span> external service. So, let’s tell the container to differentiate—check out <a data-type="xref" href="#EX1107">Example 11-11</a>.<a data-primary="" data-startref="Cbind11" data-type="indexterm" id="id1462"/></p>&#13;
<div data-type="example" id="EX1107">&#13;
<h5><span class="label">Example 11-11. </span>Contextual binding</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// In a service provider</code>&#13;
<code class="k">public</code> <code class="k">function</code> <code class="nf">register</code><code class="p">()</code><code class="o">:</code> <code class="nx">void</code>&#13;
<code class="p">{</code>&#13;
    <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">when</code><code class="p">(</code><code class="nx">FileWrangler</code><code class="o">::</code><code class="na">class</code><code class="p">)</code>&#13;
        <code class="o">-&gt;</code><code class="na">needs</code><code class="p">(</code><code class="nx">Interfaces\Logger</code><code class="o">::</code><code class="na">class</code><code class="p">)</code>&#13;
        <code class="o">-&gt;</code><code class="na">give</code><code class="p">(</code><code class="nx">Loggers\Syslog</code><code class="o">::</code><code class="na">class</code><code class="p">);</code>&#13;
&#13;
    <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">when</code><code class="p">(</code><code class="nx">Jobs\SendWelcomeEmail</code><code class="o">::</code><code class="na">class</code><code class="p">)</code>&#13;
        <code class="o">-&gt;</code><code class="na">needs</code><code class="p">(</code><code class="nx">Interfaces\Logger</code><code class="o">::</code><code class="na">class</code><code class="p">)</code>&#13;
        <code class="o">-&gt;</code><code class="na">give</code><code class="p">(</code><code class="nx">Loggers\PaperTrail</code><code class="o">::</code><code class="na">class</code><code class="p">);</code>&#13;
<code class="p">}</code></pre></div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Constructor Injection in Laravel Framework Files" data-type="sect1"><div class="sect1" id="id226">&#13;
<h1>Constructor Injection in Laravel Framework Files</h1>&#13;
&#13;
<p>We’ve<a data-primary="containers" data-secondary="constructor injection in Laravel framework files" data-type="indexterm" id="id1463"/><a data-primary="files" data-secondary="constructor injection in Laravel framework files" data-type="indexterm" id="id1464"/><a data-primary="constructor injection" data-type="indexterm" id="id1465"/> covered the concept of constructor injection, and we’ve looked at how the container makes it easy to resolve instances of a class or interface out of the container. You saw how easy it is to use the <code>app()</code> helper to make instances, and also how the container will resolve the constructor dependencies of a class when it’s creating it.</p>&#13;
&#13;
<p>What we haven’t covered yet is how the container is also responsible for resolving many of the core operating classes of your application. For example, every controller is instantiated by the container. That means if you want an instance of a logger in your controller, you can simply typehint the logger class in your controller’s constructor, and when Laravel creates the controller, it will resolve it out of the container and that logger instance will be available to your controller. Take a look at <a data-type="xref" href="#EX1108">Example 11-12</a>.</p>&#13;
<div data-type="example" id="EX1108">&#13;
<h5><span class="label">Example 11-12. </span>Injecting dependencies into a controller</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="o">...</code>&#13;
<code class="k">class</code> <code class="nc">MyController</code> <code class="k">extends</code> <code class="nx">Controller</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">protected</code> <code class="nv">$logger</code><code class="p">;</code>&#13;
&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="fm">__construct</code><code class="p">(</code><code class="nx">Logger</code> <code class="nv">$logger</code><code class="p">)</code>&#13;
    <code class="p">{</code>&#13;
        <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">logger</code> <code class="o">=</code> <code class="nv">$logger</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">index</code><code class="p">()</code>&#13;
    <code class="p">{</code>&#13;
        <code class="c1">// Do something</code>&#13;
        <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">logger</code><code class="o">-&gt;</code><code class="na">error</code><code class="p">(</code><code class="s1">'Something happened'</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>The container is responsible for resolving controllers, middleware, queue jobs, event listeners, and any other classes that are automatically generated by Laravel in the process of your application’s lifecycle—​so any of those classes can typehint dependencies in their constructors and expect them to be automatically injected.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Method Injection" data-type="sect1"><div class="sect1" id="id227">&#13;
<h1>Method Injection</h1>&#13;
&#13;
<p>There<a data-primary="containers" data-secondary="method injection" data-type="indexterm" id="id1466"/><a data-primary="method injection" data-type="indexterm" id="id1467"/> are a few places in your application where Laravel doesn’t just read the constructor signature: it also reads the <em>method</em> signature and will inject dependencies for you there as well.</p>&#13;
&#13;
<p>The most common place to use method injection is in controller methods. If you have a dependency you only want to use for a single controller method, you can inject it into just that method like in <a data-type="xref" href="#EX1109">Example 11-13</a>.</p>&#13;
<div data-type="example" id="EX1109">&#13;
<h5><span class="label">Example 11-13. </span>Injecting dependencies into a controller method</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="o">...</code>&#13;
<code class="k">class</code> <code class="nc">MyController</code> <code class="k">extends</code> <code class="nx">Controller</code>&#13;
<code class="p">{</code>&#13;
    <code class="c1">// Method dependencies can come after or before route parameters.</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">show</code><code class="p">(</code><code class="nx">Logger</code> <code class="nv">$logger</code><code class="p">,</code> <code class="nv">$id</code><code class="p">)</code>&#13;
    <code class="p">{</code>&#13;
        <code class="c1">// Do something</code>&#13;
        <code class="nv">$logger</code><code class="o">-&gt;</code><code class="na">error</code><code class="p">(</code><code class="s1">'Something happened'</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="id1468">&#13;
<h1>Passing Unresolvable Constructor Parameters Using makeWith()</h1>&#13;
<p>All<a data-primary="makeWith() method" data-type="indexterm" id="id1469"/><a data-primary="parameters" data-secondary="passing unresolvable constructor parameters" data-type="indexterm" id="id1470"/> of the primary tools for resolving a concrete instance of a class—<code>app()</code>, <code>$container-&gt;make()</code>, etc.—assume that all of the class’s dependencies can be resolved without passing anything in. But what if your class accepts a value in its constructor, instead of a dependency the container can resolve for you? Use the <code>makeWith()</code> method:</p>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="k">class</code> <code class="nc">Foo</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="fm">__construct</code><code class="p">(</code><code class="nv">$bar</code><code class="p">)</code>&#13;
    <code class="p">{</code>&#13;
        <code class="c1">// ...</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nv">$foo</code> <code class="o">=</code> <code class="nv">$this</code><code class="o">-&gt;</code><code class="na">app</code><code class="o">-&gt;</code><code class="na">makeWith</code><code class="p">(</code>&#13;
    <code class="nx">Foo</code><code class="o">::</code><code class="na">class</code><code class="p">,</code>&#13;
    <code class="p">[</code><code class="s1">'bar'</code> <code class="o">=&gt;</code> <code class="s1">'value'</code><code class="p">]</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>This is a bit of an edge case. Most classes that you’ll be resolving out of the container should <em>only</em> have dependencies injected into their constructors.</p>&#13;
</div></aside>&#13;
&#13;
<p>You<a data-primary="boot() method" data-type="indexterm" id="id1471"/> can do the same in the <code>boot()</code> method of service providers, and you can also arbitrarily call a method on any class using the container, which will allow for method injection there (see <a data-type="xref" href="#EX1110">Example 11-14</a>).</p>&#13;
<div data-type="example" id="EX1110">&#13;
<h5><span class="label">Example 11-14. </span>Manually calling a class method using the container’s <code>call()</code> method</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="k">class</code> <code class="nc">Foo</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">bar</code><code class="p">(</code><code class="nv">$parameter1</code><code class="p">)</code> <code class="p">{}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Calls the 'bar' method on 'Foo' with a first parameter of 'value'</code>&#13;
<code class="nx">app</code><code class="p">()</code><code class="o">-&gt;</code><code class="na">call</code><code class="p">(</code><code class="s1">'Foo@bar'</code><code class="p">,</code> <code class="p">[</code><code class="s1">'parameter1'</code> <code class="o">=&gt;</code> <code class="s1">'value'</code><code class="p">]);</code></pre></div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Facades and the Container" data-type="sect1"><div class="sect1" id="id462">&#13;
<h1>Facades and the Container</h1>&#13;
&#13;
<p>We’ve<a data-primary="containers" data-secondary="facades and" data-type="indexterm" id="Cfacades11"/><a data-primary="facades" data-secondary="and containers" data-secondary-sortas="containers" data-type="indexterm" id="id1472"/> covered facades quite a bit so far in the book, but we haven’t actually talked about how they work.</p>&#13;
&#13;
<p>Laravel’s facades are classes that provide simple access to core pieces of Laravel’s functionality. There are two trademark features of facades: first, they’re all available in the global namespace (<code>\Log</code> is an alias to <code>\Illuminate\Support\Facades\Log</code>); and second, they use static methods to access nonstatic resources.</p>&#13;
&#13;
<p>Let’s take a look at the <code>Log</code> facade, since we’ve been looking at logging already in this chapter. In your controller or views, you could use this call:</p>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="nx">Log</code><code class="o">::</code><code class="na">alert</code><code class="p">(</code><code class="s1">'Something has gone wrong!'</code><code class="p">);</code></pre>&#13;
&#13;
<p>Here’s what it would look like to make that same call without the facade:</p>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="nv">$logger</code> <code class="o">=</code> <code class="nx">app</code><code class="p">(</code><code class="s1">'log'</code><code class="p">);</code>&#13;
<code class="nv">$logger</code><code class="o">-&gt;</code><code class="na">alert</code><code class="p">(</code><code class="s1">'Something has gone wrong!'</code><code class="p">);</code></pre>&#13;
&#13;
<p>As you can see, facades translate static calls (any method call that you make on a class itself, using <code>::</code>, instead of on an instance) to normal method calls on instances.</p>&#13;
<div data-type="tip"><h1>Importing Facade Namespaces</h1>&#13;
<p>If<a data-primary="facades" data-secondary="importing facade namespaces" data-type="indexterm" id="id1473"/> you’re in a namespaced class, you’ll want to be sure to import the facade at the top:</p>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="o">...</code>&#13;
<code class="k">use</code> <code class="nx">Illuminate\Support\Facades\Log</code><code class="p">;</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">Controller</code> <code class="k">extends</code> <code class="nx">Controller</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">index</code><code class="p">()</code>&#13;
    <code class="p">{</code>&#13;
        <code class="c1">// ...</code>&#13;
        <code class="nx">Log</code><code class="o">::</code><code class="na">error</code><code class="p">(</code><code class="s1">'Something went wrong!'</code><code class="p">);</code>&#13;
    <code class="p">}</code></pre>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Facades Work" data-type="sect2"><div class="sect2" id="id463">&#13;
<h2>How Facades Work</h2>&#13;
&#13;
<p>Let’s<a data-primary="facades" data-secondary="how they work" data-type="indexterm" id="id1474"/> take a look at the <code>Cache</code> facade and see how it actually works.</p>&#13;
&#13;
<p>First, open up the class <code>Illuminate\Support\Facades\Cache</code>. You’ll see something like <a data-type="xref" href="#EX1111">Example 11-15</a>.</p>&#13;
<div data-type="example" id="EX1111">&#13;
<h5><span class="label">Example 11-15. </span>The <code>Cache</code> facade class</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="o">&lt;?</code><code class="nx">php</code>&#13;
&#13;
<code class="k">namespace</code> <code class="nx">Illuminate\Support\Facades</code><code class="p">;</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">Cache</code> <code class="k">extends</code> <code class="nx">Facade</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">protected</code> <code class="k">static</code> <code class="k">function</code> <code class="nf">getFacadeAccessor</code><code class="p">()</code>&#13;
    <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="s1">'cache'</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Every facade has a single method: <code>getFacadeAccessor()</code>. This defines the key that Laravel should use to look up this facade’s backing instance from the container.</p>&#13;
&#13;
<p>In this instance, we can see that every call to the <code>Cache</code> facade is proxied to be a call to an instance of the <code>cache</code> shortcut from the container. Of course, that’s not a real class or interface name, so we know it’s one of those shortcuts I mentioned earlier.</p>&#13;
&#13;
<p>So, here’s what’s really happening:</p>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="nx">Cache</code><code class="o">::</code><code class="na">get</code><code class="p">(</code><code class="s1">'key'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Is the same as...</code>&#13;
&#13;
<code class="nx">app</code><code class="p">(</code><code class="s1">'cache'</code><code class="p">)</code><code class="o">-&gt;</code><code class="na">get</code><code class="p">(</code><code class="s1">'key'</code><code class="p">);</code></pre>&#13;
&#13;
<p>There are a few ways to look up exactly what class each facade accessor points to, but checking the documentation is the easiest. There’s a table on the <a href="https://oreil.ly/IRsgc">facades documentation page</a> that shows, for each facade, which container binding (shortcut, like <code>cache</code>) it’s connected to, and which class that returns. It looks like this:</p>&#13;
<table>&#13;
&#13;
<thead>&#13;
<tr>&#13;
<th>Facade</th>&#13;
<th>Class</th>&#13;
<th>Service container binding</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>App</code></p></td>&#13;
<td><p><code>Illuminate\Foundation\Application</code></p></td>&#13;
<td><p><code>app</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>…​</p></td>&#13;
<td><p>…​</p></td>&#13;
<td><p>…​</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>Cache</code></p></td>&#13;
<td><p><code>Illuminate\Cache\CacheManager</code></p></td>&#13;
<td><p><code>cache</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>…​</p></td>&#13;
<td><p>…​</p></td>&#13;
<td><p>…​</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Now that you have this reference, you can do three things.</p>&#13;
&#13;
<p>First, you can figure out what methods are available on a facade. Just find its backing class and look at the definition of that class, and you’ll know that any of its public methods are callable on the facade.</p>&#13;
&#13;
<p>Second, you can figure out how to inject a facade’s backing class using dependency injection. If you ever want the functionality of a facade but prefer to use dependency injection, just typehint the facade’s backing class or get an instance of it with <code>app()</code> and call the same methods you would’ve called on the facade.</p>&#13;
&#13;
<p>Third, you can see how to create your own facades. Create a class for the facade that extends <code>Illuminate\Support\Facades\Facade</code>, and give it a <code>getFacadeAccessor()</code> method, which returns a string. Make that string something that can be used to resolve your backing class out of the container—​maybe just the FQCN of the class. Finally, you have to register the facade by adding it to the <code>aliases</code> array in <em>config/app.php</em>. Done! You just made your own facade.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Real-Time Facades" data-type="sect2"><div class="sect2" id="id228">&#13;
<h2>Real-Time Facades</h2>&#13;
&#13;
<p>Rather<a data-primary="facades" data-secondary="real-time facades" data-type="indexterm" id="id1475"/><a data-primary="real-time facades" data-type="indexterm" id="id1476"/> than creating a new class to make your class’s instance methods available as static methods, with <em>real-time facades</em> you can simply prefix your class’s FQCN with <code>Facades\</code> and use it <em>as if it were a facade</em>. <a data-type="xref" href="#EX1114">Example 11-16</a> illustrates how this works.</p>&#13;
<div data-type="example" id="EX1114">&#13;
<h5><span class="label">Example 11-16. </span>Using real-time facades</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="k">namespace</code> <code class="nx">App</code><code class="p">;</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">Charts</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">burndown</code><code class="p">()</code>&#13;
    <code class="p">{</code>&#13;
        <code class="c1">// ...</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">h2</code><code class="p">&gt;</code>Burndown Chart<code class="p">&lt;/</code><code class="nt">h2</code><code class="p">&gt;</code>&#13;
{{ Facades\App\Charts::burndown() }}</pre></div>&#13;
&#13;
<p>As you can see here, the nonstatic method <code>burndown()</code> becomes accessible as a static method on the real-time facade, which we create by prepending the class’s full name with <code>Facades\</code>.<a data-primary="" data-startref="Cfacades11" data-type="indexterm" id="id1477"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Service Providers" data-type="sect1"><div class="sect1" id="service_providers2">&#13;
<h1>Service Providers</h1>&#13;
&#13;
<p>We<a data-primary="containers" data-secondary="service providers and" data-type="indexterm" id="id1478"/><a data-primary="service providers" data-type="indexterm" id="id1479"/> covered the basics of service providers in the previous chapter (see <a data-type="xref" href="#service_providers2">“Service Providers”</a>). What’s most important with regard to the container is that you remember to register your bindings in the <code>register()</code> method of some service <span class="keep-together">provider</span> somewhere.</p>&#13;
&#13;
<p>You can just dump loose bindings into <code>App\Providers\AppServiceProvider</code>, which is a bit of a catchall, but it’s generally better practice to create a unique service provider for each group of functionality you’re developing and bind its classes in its unique<a data-primary="register() method" data-type="indexterm" id="id1480"/> <code>register()</code> method.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing" data-type="sect1"><div class="sect1" id="id464">&#13;
<h1>Testing</h1>&#13;
&#13;
<p>The<a data-primary="containers" data-secondary="testing" data-type="indexterm" id="id1481"/><a data-primary="testing" data-secondary="containers" data-type="indexterm" id="id1482"/> ability to use inversion of control and dependency injection makes testing in Laravel extremely versatile. You can bind a different logger, for instance, depending on whether the app is live or under testing. Or you can change the transactional email service from Mailgun to a local email logger for easy inspection. Both of these swaps are actually so common that it’s even easier to make them using Laravel’s <em>.env</em> configuration files, but you can make similar swaps with any interfaces or classes you’d like.</p>&#13;
&#13;
<p>The easiest way to do this is to explicitly rebind classes and interfaces when you need them rebound, directly in the test.  <a data-type="xref" href="#EX1112">Example 11-17</a> shows how.</p>&#13;
<div data-type="example" id="EX1112">&#13;
<h5><span class="label">Example 11-17. </span>Overriding a binding in tests</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="k">public</code> <code class="k">function</code> <code class="nf">test_it_does_something</code><code class="p">()</code>&#13;
<code class="p">{</code>&#13;
    <code class="nx">app</code><code class="p">()</code><code class="o">-&gt;</code><code class="na">bind</code><code class="p">(</code><code class="nx">Interfaces\Logger</code><code class="p">,</code> <code class="k">function</code> <code class="p">()</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="k">new</code> <code class="nx">DevNullLogger</code><code class="p">;</code>&#13;
    <code class="p">});</code>&#13;
&#13;
    <code class="c1">// Do stuff</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>If you need certain classes or interfaces rebound globally for your tests (which is not a particularly common occurrence), you can do this in either the <code>setUp()</code> method in the test class or in the <code>setUp()</code> method in Laravel’s <code>TestCase</code> base test, as shown in <a data-type="xref" href="#EX1113">Example 11-18</a>.</p>&#13;
<div data-type="example" id="EX1113">&#13;
<h5><span class="label">Example 11-18. </span>Overriding a binding for all tests</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="k">class</code> <code class="nc">TestCase</code> <code class="k">extends</code> <code class="nx">\Illuminate\Foundation\Testing\TestCase</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">setUp</code><code class="p">()</code>&#13;
    <code class="p">{</code>&#13;
        <code class="k">parent</code><code class="o">::</code><code class="na">setUp</code><code class="p">();</code>&#13;
&#13;
        <code class="nx">app</code><code class="p">()</code><code class="o">-&gt;</code><code class="na">bind</code><code class="p">(</code><code class="s1">'whatever'</code><code class="p">,</code> <code class="s1">'whatever else'</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>When using something like Mockery, it’s common to create a mock or spy or stub of a class and then rebind that to the container in place of its referent.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="TL;DR" data-type="sect1"><div class="sect1" id="id465">&#13;
<h1>TL;DR</h1>&#13;
&#13;
<p>Laravel’s service container<a data-primary="containers" data-secondary="overview of" data-type="indexterm" id="id1483"/> has many names, but regardless of what you call it, in the end its goal is to make it easy to define how to resolve certain string names as concrete instances. These string names are going to be the fully qualified class names of classes or interfaces, or shortcuts like <code>log</code>.</p>&#13;
&#13;
<p>Each binding teaches the application, given a string key (e.g., <code>app('log')</code>), how to resolve a concrete instance.</p>&#13;
&#13;
<p>The container is smart enough to do recursive dependency resolution, so if you try to resolve an instance of something that has constructor dependencies, the container will try to resolve those dependencies based on their typehints, then pass them into your class, and finally return an instance.</p>&#13;
&#13;
<p>There are several ways to bind to the container, but in the end, they all define what to return, given a particular string.</p>&#13;
&#13;
<p>Facades are simple shortcuts that make it easy to use static calls on a root namespace–aliased class to call nonstatic methods on classes resolved out of the container. Real-time facades allow you to treat any class like a facade by prepending its fully qualified class name with <code>Facades\</code>.</p>&#13;
</div></section>&#13;
</div></section></body></html>