<html><head></head><body><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Why Laravel?" data-type="chapter" epub:type="chapter"><div class="chapter" id="why_laravel">&#13;
<h1><span class="label">Chapter 1. </span>Why Laravel?</h1>&#13;
&#13;
&#13;
<p>In the early days of the dynamic web, writing a web application looked a lot different than it does today. Developers then were responsible for writing the code for not just the unique business logic of our applications but also each of the components that are so common across sites—​user authentication, input validation, database access, templating, and more.</p>&#13;
&#13;
<p>Today, programmers have dozens of application development frameworks and thousands of components and libraries easily accessible. It’s a common refrain among programmers that, by the time you learn one framework, three newer (and purportedly better) frameworks have popped up intending to replace it.</p>&#13;
&#13;
<p>“Just because it’s there” might be a valid justification for climbing a mountain, but there are better reasons to choose to use a specific framework—​or to use a framework at all. It’s worth asking the question, why frameworks? More specifically, why Laravel?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why Use a Framework?" data-type="sect1"><div class="sect1" id="id369">&#13;
<h1>Why Use a Framework?</h1>&#13;
&#13;
<p>It’s<a data-primary="Laravel" data-secondary="reasons to adopt" data-type="indexterm" id="id744"/> easy to see why it’s beneficial to use the individual components, or packages, that are available to PHP developers. With packages, someone else is responsible for developing and maintaining an isolated piece of code that has a well-defined job, and, in theory, that person has a deeper understanding of this single component than you have time to have.</p>&#13;
&#13;
<p>Frameworks like Laravel—​and Symfony, Lumen, and Slim—​prepackage a collection of third-party components together with custom framework “glue” like configuration files, service providers, prescribed directory structures, and application bootstraps. So, the benefit of using a framework in general is that someone has made decisions not just about individual components for you but also about <em>how those components should fit together.</em></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="“I’ll Just Build It Myself”" data-type="sect2"><div class="sect2" id="id624">&#13;
<h2>“I’ll Just Build It Myself”</h2>&#13;
&#13;
<p>Let’s say you start a new web app without the benefit of a framework. Where do you begin? Well, it should probably route HTTP requests, so you now need to evaluate all of the HTTP request and response libraries available and pick one. Then you’ll have to pick a router. Oh, and you’ll probably need to set up some form of routes configuration file. What syntax should it use? Where should it go? What about controllers? Where do they live, and how are they loaded? Well, you probably need a dependency injection container to resolve the controllers and their dependencies. But which one?</p>&#13;
&#13;
<p>Furthermore, if you do take the time to answer all those questions and successfully create your application, what’s the impact on the next developer? What about when you have four such custom framework–based applications, or a dozen, and you have to remember where the controllers live in each or what the routing syntax is?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Consistency and Flexibility" data-type="sect2"><div class="sect2" id="id625">&#13;
<h2>Consistency and Flexibility</h2>&#13;
&#13;
<p>Frameworks address this issue by providing a carefully considered answer to the question “Which component should we use here?” and ensuring that the particular components chosen work well together. Additionally, frameworks provide conventions that reduce the amount of code a developer new to the project has to understand—​if you understand how routing works in one Laravel project, for example, you understand how it works in all Laravel projects.</p>&#13;
&#13;
<p>When someone prescribes rolling your own framework for each new project, what they’re really advocating is the ability to <em>control</em> what does and doesn’t go into your application’s foundation. That means the best frameworks will not only provide you with a solid foundation but also give you the freedom to customize to your heart’s content. And this, as I’ll show you in the rest of this book, is part of what makes Laravel so special.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Short History of Web and PHP Frameworks" data-type="sect1"><div class="sect1" id="id2">&#13;
<h1>A Short History of Web and PHP Frameworks</h1>&#13;
&#13;
<p>An<a data-primary="Laravel" data-secondary="history of" data-type="indexterm" id="Lhistory01"/><a data-primary="PHP frameworks, history of" data-type="indexterm" id="phphistory01"/> important part of being able to answer the question “Why Laravel?” is understanding Laravel’s history—​and understanding what came before it. Prior to Laravel’s rise in popularity, there were a variety of frameworks and other movements in PHP and other web development spaces.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Ruby on Rails" data-type="sect2"><div class="sect2" id="id3">&#13;
<h2>Ruby on Rails</h2>&#13;
&#13;
<p>David Heinemeier Hansson released the first version of<a data-primary="Ruby on Rails" data-type="indexterm" id="id745"/> Ruby on Rails in 2004, and it’s been hard to find a web application framework since then that hasn’t been influenced by Rails in some way.</p>&#13;
&#13;
<p>Rails popularized MVC, RESTful JSON APIs, convention over configuration, ActiveRecord, and many more tools and conventions that had a profound influence on the way web developers approached their applications—​especially with regard to rapid application development.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Influx of PHP Frameworks" data-type="sect2"><div class="sect2" id="id626">&#13;
<h2>The Influx of PHP Frameworks</h2>&#13;
&#13;
<p>It was clear to most developers that Rails and similar web application frameworks were the wave of the future, and PHP frameworks, including those admittedly imitating Rails, started popping up quickly.</p>&#13;
&#13;
<p>CakePHP was the first in 2005, and it was soon followed by Symfony, CodeIgniter, Zend Framework, and Kohana (a CodeIgniter fork). Yii arrived in 2008, and Aura and Slim in 2010. The year 2011 brought FuelPHP and Laravel, both of which were not quite CodeIgniter offshoots, but instead proposed as alternatives.</p>&#13;
&#13;
<p>Some of these frameworks were more Rails-y, focusing on database object-relational mappers (ORMs), MVC structures, and other tools targeting rapid development. Others, like Symfony and Zend, focused more on enterprise design patterns and ecommerce.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Good and the Bad of CodeIgniter" data-type="sect2"><div class="sect2" id="id4">&#13;
<h2>The Good and the Bad of CodeIgniter</h2>&#13;
&#13;
<p>CakePHP and CodeIgniter<a data-primary="CodeIgniter" data-type="indexterm" id="id746"/> were the two early PHP frameworks that were most <span class="keep-together">open about</span> how much their inspiration was drawn from Rails. CodeIgniter quickly rose to fame and by 2010 was arguably the most popular of the independent PHP frameworks.</p>&#13;
&#13;
<p>CodeIgniter was simple, easy to use, and boasted amazing documentation and a strong community. But its use of modern technology and patterns advanced slowly; and as the framework world grew and PHP’s tooling advanced, CodeIgniter started falling behind in terms of both technological advances and out-of-the-box features. Unlike many other frameworks, CodeIgniter was managed by a company, and it was slow to catch up with PHP 5.3’s newer features, like namespaces and the moves to GitHub and later Composer. It was in 2010 that Taylor Otwell, Laravel’s creator, became dissatisfied enough with CodeIgniter that he set off to write his own &#13;
<span class="keep-together">framework</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel 1, 2, and 3" data-type="sect2"><div class="sect2" id="id627">&#13;
<h2>Laravel 1, 2, and 3</h2>&#13;
&#13;
<p>The first beta of Laravel 1 was released in June 2011, and it was written completely from scratch. It featured a custom ORM (Eloquent); closure-based routing (inspired by Ruby Sinatra); a module system for extension; and helpers for forms, validation, authentication, and more.</p>&#13;
&#13;
<p>Early Laravel development moved quickly, and Laravel 2 and 3 were released in November 2011 and February 2012, respectively. They introduced controllers, unit testing, a command-line tool, an inversion of control (IoC) container, Eloquent relationships, and migrations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel 4" data-type="sect2"><div class="sect2" id="id628">&#13;
<h2>Laravel 4</h2>&#13;
&#13;
<p>With Laravel 4, Taylor rewrote the entire framework from the ground up. By this point Composer, PHP’s now-ubiquitous package manager, was showing signs of becoming an industry standard, and Taylor saw the value of rewriting the framework as a collection of components, distributed and bundled together by Composer.</p>&#13;
&#13;
<p>Taylor developed a set of components under the code name <em>Illuminate</em> and, in May 2013, released Laravel 4 with an entirely new structure. Instead of bundling the majority of its code as a download, Laravel now pulled in the majority of its components from Symfony (another framework that released its components for use by others) and the Illuminate components through Composer.</p>&#13;
&#13;
<p>Laravel 4 also introduced queues, a mail component, facades, and database seeding. And because Laravel was now relying on Symfony components, it was announced that Laravel would be mirroring (not exactly, but soon after) the six-month release schedule Symfony follows.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel 5" data-type="sect2"><div class="sect2" id="id629">&#13;
<h2>Laravel 5</h2>&#13;
&#13;
<p>Laravel 4.3 was scheduled to be released in November 2014, but as development progressed it became clear that the significance of its changes merited a major release, and Laravel 5 was released in February 2015.</p>&#13;
&#13;
<p>Laravel 5 featured a revamped directory structure, removal of the form and HTML helpers, the introduction of the contract interfaces, a spate of new views, Socialite for social media authentication, Elixir for asset compilation, Scheduler to simplify cron, dotenv for simplified environment management, form requests, and a brand-new REPL (read–evaluate–print loop). Since then, it’s grown in features and maturity, but there have been no major changes like in previous versions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel 6" data-type="sect2"><div class="sect2" id="id630">&#13;
<h2>Laravel 6</h2>&#13;
&#13;
<p>In September 2019, Laravel 6 was introduced with two primary changes: first, removal of the string and array global helpers Laravel offers (in favor of facades); and second, moving to SemVer (semantic versioning) for version numbering. The practical effect of this change means that, for all versions of Laravel after 5, both major (6, 7, etc.) and minor (6.1, 6.2, etc.) versions are released much more frequently.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Laravel Versions in the New SemVer World (6+)" data-type="sect2"><div class="sect2" id="id5">&#13;
<h2>Laravel Versions in the New SemVer World (6+)</h2>&#13;
&#13;
<p>Starting with version 6, Laravel releases are less monumental than in the past because of the new SemVer release schedule. So going forward, releases will be more about how much time has passed and less about very specific big new features.<a data-primary="" data-startref="phphistory01" data-type="indexterm" id="id747"/><a data-primary="" data-startref="Lhistory01" data-type="indexterm" id="id748"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What’s So Special About Laravel?" data-type="sect1"><div class="sect1" id="id370">&#13;
<h1>What’s So Special About Laravel?</h1>&#13;
&#13;
<p>So<a data-primary="Laravel" data-secondary="philosophy of" data-type="indexterm" id="id749"/>, what is it that sets Laravel apart? Why is it worth having more than one PHP framework at any time? They all use components from Symfony anyway, right? Let’s talk a bit about what makes Laravel “tick.”</p>&#13;
<section data-pdf-bookmark="The Philosophy of Laravel" data-type="sect2"><div class="sect2" id="the-philosophy-of-laravel-52sMH3t2">&#13;
<h2>The Philosophy of Laravel</h2>&#13;
&#13;
<p>You only need to read through the Laravel marketing materials and READMEs to start seeing its values. Taylor uses light-related words like “Illuminate” and “Spark.” And then there are these: “Artisans.” “Elegant.” Also, these: “Breath of fresh air.” “Fresh start.” And finally: “Rapid.” “Warp speed.”</p>&#13;
&#13;
<p>The two most strongly communicated values of the framework are to increase developer speed and developer happiness. Taylor has described the “Artisan” language as intentionally contrasting against more utilitarian values. You can see the genesis of this sort of thinking in <a href="https://oreil.ly/q0tgM">his 2011 question on StackExchange</a> in which he stated, “Sometimes I spend ridiculous amounts of time (hours) agonizing over making code ‘look pretty’” just for the sake of a better experience of looking at the code itself. And he’s often talked about the value of making it easier and quicker for developers to take their ideas to fruition, getting rid of unnecessary barriers to creating great products.</p>&#13;
&#13;
<p>Laravel is, at its core, about equipping and enabling developers. Its goal is to provide clear, simple, and beautiful code and features that help developers quickly learn, start, develop, and write code that’s simple, clear, and lasting.</p>&#13;
&#13;
<p>The concept of targeting developers is clear across Laravel materials. “Happy developers make the best code” is written in the documentation. “Developer happiness from download to deploy” was the unofficial slogan for a while. Of course, any tool or framework will say it wants developers to be happy. But having developer happiness as a <em>primary</em> concern, rather than secondary, has had a huge impact on Laravel’s style and decision-making progress. Where other frameworks may target architectural purity as their primary goal, or compatibility with the goals and values of enterprise development teams, Laravel’s primary focus is on serving the individual developer. That doesn’t mean you can’t write architecturally pure or enterprise-ready applications in Laravel, but it won’t have to be at the expense of the readability and comprehensibility of your codebase.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Laravel Achieves Developer Happiness" data-type="sect2"><div class="sect2" id="id371">&#13;
<h2>How Laravel Achieves Developer Happiness</h2>&#13;
&#13;
<p>Just<a data-primary="Laravel" data-secondary="benefits of" data-type="indexterm" id="id750"/> saying you want to make developers happy is one thing. Doing it is another, and it requires you to question what in a framework is most likely to make developers unhappy and what is most likely to make them happy. There are a number of ways Laravel tries to make developers’ lives easier.</p>&#13;
&#13;
<p>First, Laravel is a rapid application development framework. This means it focuses on a shallow (easy) learning curve and on minimizing the steps between starting a new app and publishing it. All of the most common tasks in building web applications, from database interactions to authentication to queues to email to caching, are made simpler by the components Laravel provides. But Laravel’s components aren’t just great on their own; they provide a consistent API and predictable structures across the entire framework. That means that, when you’re trying something new in Laravel, you’re more than likely going to end up saying, “…​and it just works.”</p>&#13;
&#13;
<p>This doesn’t end with the framework itself, either. Laravel provides an entire ecosystem of tools for building and launching applications. You have Sail and Valet and Homestead for local development, Forge for server management, and Envoyer and Vapor for advanced deployment. And there’s a suite of add-on packages: Cashier for payments and subscriptions, Echo for WebSockets, Scout for search, Sanctum and Passport for API authentication, Dusk for frontend testing, Socialite for social login, Horizon for monitoring queues, Nova for building admin panels, and Spark to bootstrap your SaaS. Laravel is trying to take the repetitive work out of developers’ jobs so they can do something unique.</p>&#13;
&#13;
<p>Next, Laravel focuses on “convention over configuration”—meaning that if you’re willing to use Laravel’s defaults, you’ll have to do much less work than with other frameworks that require you to declare all of your settings even if you’re using the recommended configuration. Projects built on Laravel take less time than those built on most other PHP frameworks.</p>&#13;
&#13;
<p>Laravel also focuses deeply on simplicity. It’s possible to use dependency injection and mocking and the Data Mapper pattern and repositories and command query responsibility segregation and all sorts of other more complex architectural patterns with Laravel, if you want. But while other frameworks might suggest using those tools and structures on every project, Laravel and its documentation and community lean toward starting with the simplest possible implementation—​a global function here, a facade there, ActiveRecord over there. This allows developers to create the simplest possible application to solve for their needs, without limiting its usefulness in complex environments.</p>&#13;
&#13;
<p>An interesting source of how Laravel is different from other PHP frameworks is that its creator and its community are more connected to and inspired by Ruby and Rails and functional programming languages than by Java. There’s a strong current in modern PHP to lean toward verbosity and complexity, embracing the more Java-esque aspects of PHP. But Laravel tends to be on the other side, embracing expressive, dynamic, and simple coding practices and language features.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Laravel Community" data-type="sect2"><div class="sect2" id="id6">&#13;
<h2>The Laravel Community</h2>&#13;
&#13;
<p>If<a data-primary="Laravel community" data-type="indexterm" id="id751"/><a data-primary="Laravel" data-secondary="resources for learning" data-type="indexterm" id="id752"/><a data-primary="resources for learning" data-secondary="Laravel community" data-type="indexterm" id="id753"/> this book is your first exposure to the Laravel community, you have something special to look forward to. One of the distinguishing elements of Laravel, which has contributed to its growth and success, is the welcoming, teaching community that surrounds it. From Jeffrey Way’s <a href="https://laracasts.com">Laracasts video tutorials</a> to <a href="https://laravel-news.com">Laravel News</a> to Slack and IRC and Discord channels, from Twitter friends to bloggers to podcasts to the Laracon conferences, Laravel has a rich and vibrant community full of folks who’ve been around since day one and folks who are just starting their own “day one.” And this isn’t an accident:</p>&#13;
<blockquote>&#13;
<p>From the very beginning of Laravel, I’ve had this idea that all people want to feel like they are part of something. It’s a natural human instinct to want to belong and be accepted into a group of other like-minded people. So, by injecting personality into a web framework and being really active with the community, that type of feeling can grow in the community.</p>&#13;
<p data-type="attribution">Taylor Otwell, <cite>Product and Support interview</cite></p>&#13;
</blockquote>&#13;
&#13;
<p>Taylor understood from the early days of Laravel that a successful open source project needed two things: good documentation and a welcoming community. And those two things are now hallmarks of Laravel.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How It Works" data-type="sect1"><div class="sect1" id="id7">&#13;
<h1>How It Works</h1>&#13;
&#13;
<p>Up<a data-primary="Laravel" data-secondary="how it works" data-type="indexterm" id="Lwork01"/> until now, everything I’ve shared here has been entirely abstract. What about the code, you ask? Let’s dig into a simple application (<a data-type="xref" href="#EX1">Example 1-1</a>)  so you can see what working with Laravel day-to-day is actually like.</p>&#13;
<div data-type="example" id="EX1">&#13;
<h5><span class="label">Example 1-1. </span>“Hello, World” in routes/web.php</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="o">&lt;?</code><code class="nx">php</code>&#13;
&#13;
<code class="nx">Route</code><code class="o">::</code><code class="na">get</code><code class="p">(</code><code class="s1">'/'</code><code class="p">,</code> <code class="k">function</code> <code class="p">()</code> <code class="p">{</code>&#13;
   <code class="k">return</code> <code class="s1">'Hello, World!'</code><code class="p">;</code>&#13;
<code class="p">});</code></pre></div>&#13;
&#13;
<p>The simplest possible action you can take in a Laravel application is to define a route and return a result any time someone visits that route. If you initialize a brand-new Laravel application on your machine, define the route in <a data-type="xref" href="#EX1">Example 1-1</a>, and then serve the site from the <em>public</em> directory, you’ll have a fully functioning “Hello, World” example (see <a data-type="xref" href="#FIG101">Figure 1-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="FIG101">&#13;
<img alt="The words 'Hello, World' on a white screen" src="assets/lur3_0101.png"/>&#13;
<h6><span class="label">Figure 1-1. </span>Returning “Hello, World!” with Laravel</h6>&#13;
</div></figure>&#13;
&#13;
<p>It looks very similar with controllers, as you can see in <a data-type="xref" href="#EX2">Example 1-2</a> (which, if you’d like to test right away, requires you to run <code>php artisan make:controller WelcomeController</code> first to create the controller).</p>&#13;
<div data-type="example" id="EX2">&#13;
<h5><span class="label">Example 1-2. </span>“Hello, World” with controllers</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// File: routes/web.php</code>&#13;
<code class="o">&lt;?</code><code class="nx">php</code>&#13;
&#13;
<code class="k">use</code> <code class="nx">App\Http\Controllers\WelcomeController</code><code class="p">;</code>&#13;
&#13;
<code class="nx">Route</code><code class="o">::</code><code class="na">get</code><code class="p">(</code><code class="s1">'/'</code><code class="p">,</code> <code class="p">[</code><code class="nx">WelcomeController</code><code class="o">::</code><code class="na">class</code><code class="p">,</code> <code class="s1">'index'</code><code class="p">]);</code></pre>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// File: app/Http/Controllers/WelcomeController.php</code>&#13;
<code class="o">&lt;?</code><code class="nx">php</code>&#13;
&#13;
<code class="k">namespace</code> <code class="nx">App\Http\Controllers</code><code class="p">;</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">WelcomeController</code> <code class="k">extends</code> <code class="nx">Controller</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">index</code><code class="p">()</code>&#13;
    <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="s1">'Hello, World!'</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>And if you’re storing your greetings in a database, it’ll also look pretty similar (see <a data-type="xref" href="#EX3">Example 1-3</a>).</p>&#13;
<div data-type="example" id="EX3">&#13;
<h5><span class="label">Example 1-3. </span>Multigreeting “Hello, World” with database access</h5>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// File: routes/web.php</code>&#13;
<code class="o">&lt;?</code><code class="nx">php</code>&#13;
&#13;
<code class="k">use</code> <code class="nx">App\Greeting</code><code class="p">;</code>&#13;
&#13;
<code class="nx">Route</code><code class="o">::</code><code class="na">get</code><code class="p">(</code><code class="s1">'create-greeting'</code><code class="p">,</code> <code class="k">function</code> <code class="p">()</code> <code class="p">{</code>&#13;
    <code class="nv">$greeting</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Greeting</code><code class="p">;</code>&#13;
    <code class="nv">$greeting</code><code class="o">-&gt;</code><code class="na">body</code> <code class="o">=</code> <code class="s1">'Hello, World!'</code><code class="p">;</code>&#13;
    <code class="nv">$greeting</code><code class="o">-&gt;</code><code class="na">save</code><code class="p">();</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">Route</code><code class="o">::</code><code class="na">get</code><code class="p">(</code><code class="s1">'first-greeting'</code><code class="p">,</code> <code class="k">function</code> <code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">Greeting</code><code class="o">::</code><code class="na">first</code><code class="p">()</code><code class="o">-&gt;</code><code class="na">body</code><code class="p">;</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// File: app/Models/Greeting.php</code>&#13;
<code class="o">&lt;?</code><code class="nx">php</code>&#13;
&#13;
<code class="k">namespace</code> <code class="nx">App\Models</code><code class="p">;</code>&#13;
&#13;
<code class="k">use</code> <code class="nx">Illuminate\Database\Eloquent\Factories\HasFactory</code><code class="p">;</code>&#13;
<code class="k">use</code> <code class="nx">Illuminate\Database\Eloquent\Model</code><code class="p">;</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">Greeting</code> <code class="k">extends</code> <code class="nx">Model</code>&#13;
<code class="p">{</code>&#13;
    <code class="k">use</code> <code class="nx">HasFactory</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="php" data-type="programlisting"><code class="c1">// File: database/migrations/2023_03_12_192110_create_greetings_table.php</code>&#13;
<code class="o">&lt;?</code><code class="nx">php</code>&#13;
&#13;
<code class="k">use</code> <code class="nx">Illuminate\Database\Migrations\Migration</code><code class="p">;</code>&#13;
<code class="k">use</code> <code class="nx">Illuminate\Database\Schema\Blueprint</code><code class="p">;</code>&#13;
<code class="k">use</code> <code class="nx">Illuminate\Support\Facades\Schema</code><code class="p">;</code>&#13;
&#13;
<code class="k">return</code> <code class="k">new</code> <code class="k">class</code> <code class="nc">extends</code> <code class="nx">Migration</code>&#13;
<code class="p">{</code>&#13;
    <code class="sd">/**</code>&#13;
<code class="sd">     * Run the migrations.</code>&#13;
<code class="sd">     */</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">up</code><code class="p">()</code><code class="o">:</code> <code class="nx">void</code>&#13;
    <code class="p">{</code>&#13;
        <code class="nx">Schema</code><code class="o">::</code><code class="na">create</code><code class="p">(</code><code class="s1">'greetings'</code><code class="p">,</code> <code class="k">function</code> <code class="p">(</code><code class="nx">Blueprint</code> <code class="nv">$table</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="nv">$table</code><code class="o">-&gt;</code><code class="na">id</code><code class="p">();</code>&#13;
            <code class="nv">$table</code><code class="o">-&gt;</code><code class="na">string</code><code class="p">(</code><code class="s1">'body'</code><code class="p">);</code>&#13;
            <code class="nv">$table</code><code class="o">-&gt;</code><code class="na">timestamps</code><code class="p">();</code>&#13;
        <code class="p">});</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="sd">/**</code>&#13;
<code class="sd">     * Reverse the migrations.</code>&#13;
<code class="sd">     */</code>&#13;
    <code class="k">public</code> <code class="k">function</code> <code class="nf">down</code><code class="p">()</code><code class="o">:</code> <code class="nx">void</code>&#13;
    <code class="p">{</code>&#13;
        <code class="nx">Schema</code><code class="o">::</code><code class="na">dropIfExists</code><code class="p">(</code><code class="s1">'greetings'</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">};</code></pre></div>&#13;
&#13;
<p><a data-type="xref" href="#EX3">Example 1-3</a> might be a bit overwhelming, and if so, just skip over it. You’ll learn about everything that’s happening here in later chapters, but you can already see that with just a few lines of code, you can set up database migrations and models and pull records out. It’s just that simple.<a data-primary="" data-startref="Lwork01" data-type="indexterm" id="id754"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Why Laravel?" data-type="sect1"><div class="sect1" id="id372">&#13;
<h1>Why Laravel?</h1>&#13;
&#13;
<p>So—​why<a data-primary="Laravel" data-secondary="benefits of" data-type="indexterm" id="id755"/> Laravel?</p>&#13;
&#13;
<p>Because Laravel helps you bring your ideas to reality with no wasted code, using modern coding standards, surrounded by a vibrant community, with an empowering ecosystem of tools.</p>&#13;
&#13;
<p>And because you, dear developer, deserve to be happy.</p>&#13;
</div></section>&#13;
</div></section></body></html>