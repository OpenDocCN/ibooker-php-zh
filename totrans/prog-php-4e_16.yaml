- en: Chapter 15\. Application Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should have a solid understanding of the details of the PHP language
    and its use in a variety of common situations. Now we’re going to show you some
    techniques you may find useful in your PHP applications, such as code libraries,
    templating systems, efficient output handling, error handling, and performance
    tuning.
  prefs: []
  type: TYPE_NORMAL
- en: Code Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve seen, PHP ships with numerous extension libraries that combine useful
    functionality into distinct packages that you can access from your scripts. We
    covered using the GD, FPDF, and Libxslt extension libraries in Chapters [10](ch10.xhtml#graphic),
    [11](ch11.xhtml#pdf), and [12](ch12.xhtml#xml), respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using the extensions that ship with PHP, you can create libraries
    of your own code that you can use in more than one part of your website. The general
    technique is to store a collection of related functions in a PHP file. Then, when
    you need to use that functionality in a page, you can use `require_once()` to
    insert the contents of the file into your current script.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that there are three other inclusion type functions that can also be employed.
    They are `require()`, `include_once()`, and `include()`. [Chapter 2](ch02.xhtml#language_basics)
    discusses these functions in detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say you have a collection of functions that help create HTML form
    elements in valid HTML: one function in your collection creates a text field or
    a `text​area` (depending on how many characters you set as the maximum), another
    creates a series of pop ups from which to set a date and time, and so on. Rather
    than copying the code into many pages—which is tedious, leads to errors, and makes
    it difficult to fix any bugs found in the functions—creating a function library
    is the sensible choice.'
  prefs: []
  type: TYPE_NORMAL
- en: When you are combining functions into a code library, be careful to maintain
    a balance between grouping related functions and including functions that are
    not often used. When you include a code library in a page, all of the functions
    in that library are parsed, whether you use them all or not. PHP’s parser is quick,
    but not parsing a function is even faster. At the same time, you don’t want to
    split your functions across too many libraries, causing you to have to include
    lots of files in each page, because file access is slow.
  prefs: []
  type: TYPE_NORMAL
- en: Templating Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *templating system* provides a way of separating the code in a web page from
    the layout of that page. In larger projects, templates can be used to allow designers
    to deal exclusively with designing web pages and programmers to deal (more or
    less) exclusively with programming. The basic idea of a templating system is that
    the web page itself contains special markers that are replaced with dynamic content.
    A web designer can create the HTML for a page and simply worry about the layout,
    using the appropriate markers for different kinds of dynamic content that are
    needed. The programmer, on the other hand, is responsible for creating the code
    that generates the dynamic content for the markers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this more concrete, let’s look at a simple example. Consider the following
    web page, which asks the user to supply a name and then, if a name is provided,
    thanks the user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The placement of the different PHP elements within various layout tags, such
    as the `font` and `table` elements, is better left to a designer, especially as
    the page gets more complex. Using a templating system, we can split this page
    into separate files, some containing PHP code and some containing the layout.
    The HTML pages will then contain special markers where dynamic content should
    be placed. [Example 15-1](#example_onefive_onedot_html_template_fo) shows the
    new HTML template page for our simple form, which is stored in the file *user.template*.
    It uses the `{DESTINATION}` marker to indicate the script that should process
    the form.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-1\. HTML template for user input form
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15-2](#example_onefive_twodot_html_template_fo) shows the template
    for the thank-you page, called *thankyou.template*, which is displayed after the
    user has filled out the form. This page uses the `{NAME}` marker to include the
    value of the user’s name.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-2\. HTML template for thank-you page
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we need a script that can process these template pages, filling in the appropriate
    information for the various markers. [Example 15-3](#example_onefive_threedot_template_scrip)
    shows the PHP script that uses these templates (one for before the user has given
    us information and one for after). The PHP code uses the `fillTemplate()` function
    to join our values and the template files. This file is called *form_template.php*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-3\. Template script
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 15-4](#example_onefive_fourdot_the_filltemplat) shows the `fillTemplate()`
    function used by the script in [Example 15-3](#example_onefive_threedot_template_scrip).
    The function takes a template filename (relative to a directory named *templates*
    located in the document root), an array of values, and an optional instruction
    denoting what to do if a marker is found for which no value is given. The possible
    values are `delete`, which deletes the marker; `comment`, which replaces the marker
    with a comment noting that the value is missing; or anything else, which just
    leaves the marker alone. This file is called *func_template.php.*'
  prefs: []
  type: TYPE_NORMAL
- en: Example 15-4\. The fillTemplate() function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Clearly, this example of a templating system is somewhat contrived. But if you
    think of a large PHP application that displays hundreds of news articles, you
    can imagine how a templating system that used markers such as `{HEADLINE}`, `{BYLINE}`,
    and `{ARTICLE}` might be useful, as it would allow designers to create the layout
    for article pages without needing to worry about the actual content.
  prefs: []
  type: TYPE_NORMAL
- en: While templates may reduce the amount of PHP code that designers have to see,
    there is a performance trade-off, as every request incurs the cost of building
    a page from the template. Performing pattern matches on every outgoing page can
    really slow down a popular site. Andrei Zmievski’s [Smarty](http://www.smarty.net)
    is an efficient templating system that neatly side-steps much of this performance
    hit by turning the template into straight PHP code and caching it. Instead of
    doing the template replacement on every request, it does it only when the template
    file is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PHP is all about displaying output in the web browser. Accordingly, there are
    a few different techniques that you can use to handle output more efficiently
    or conveniently.
  prefs: []
  type: TYPE_NORMAL
- en: Output Buffering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, PHP sends the results of `echo` and similar commands to the browser
    after each command is executed. Alternately, you can use PHP’s output buffering
    functions to gather the information that would normally be sent to the browser
    into a buffer and send it later (or kill it entirely). This allows you to specify
    the content length of your output after it is generated, capture the output of
    a function, or discard the output of a built-in function.
  prefs: []
  type: TYPE_NORMAL
- en: 'You turn on output buffering with the `ob_start()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The optional *`callback`* parameter is the name of a function that postprocesses
    the output. If specified, this function is passed the collected output when the
    buffer is flushed, and it should return a string of output to send to the browser.
    You can use this, for instance, to turn all occurrences of *http://www.yoursite.com*
    to *http://www.mysite.com*.
  prefs: []
  type: TYPE_NORMAL
- en: 'While output buffering is enabled, all output is stored in an internal buffer.
    To get the current length and contents of the buffer, use `ob_get_length()` and
    `ob_get_``contents()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If buffering isn’t enabled, these functions return `false`.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to throw away the data in the buffer. The `ob_clean()` function
    erases the output buffer but does not turn off buffering for subsequent output.
    The `ob_end_clean()` function erases the output buffer and ends output buffering.
  prefs: []
  type: TYPE_NORMAL
- en: There are three ways to send the collected output to the browser (this action
    is known as *flushing* the buffer). The `ob_flush()` function sends the output
    data to the web server and clears the buffer, but doesn’t terminate output buffering.
    The `flush()` function not only flushes and clears the output buffer, but also
    tries to make the web server send the data to the browser immediately. The `ob_end_flush()`
    function sends the output data to the web server and ends output buffering. In
    all cases, if you specified a callback with `ob_start()`, that function is called
    to decide exactly what gets sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: If your script ends with output buffering still enabled—that is, if you haven’t
    called `ob_end_flush()` or `ob_end_clean()`—PHP calls `ob_end_flush()` for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code collects the output of the `phpinfo()` function and uses
    it to determine whether you have the GD graphics module installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, a quicker and simpler approach to check if a certain extension is
    available is to pick a function that you know the extension provides and check
    if it exists. For the GD extension, you might do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To change all references in a document from *http://www.yoursite.com* to *http://www.mysite.com*,
    simply wrap the page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Another way to do this is with a callback. Here, the `rewrite()` callback changes
    the text of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Output Compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recent browsers support compressing the text of web pages; the server sends
    compressed text and the browser decompresses it. To automatically compress your
    web page, wrap it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The built-in `ob_gzhandler()` function can be used as the callback for a call
    to `ob_start()`. It compresses the buffered page according to the `Accept-Encoding`
    header sent by the browser. Possible compression techniques are *gzip*, *deflate*,
    or none.
  prefs: []
  type: TYPE_NORMAL
- en: It rarely makes sense to compress short pages, as the time for compression and
    decompression exceeds the time it would take to simply send the uncompressed text.
    It does make sense to compress large (greater than 5 KB) web pages, however.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of adding the `ob_start()` call to the top of every page, you can set
    the `output_handler` option in your *php.ini* file to a callback to be made on
    every page. For compression, this is `ob_gzhandler`.
  prefs: []
  type: TYPE_NORMAL
- en: Performance Tuning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before thinking much about performance tuning, take the time to get your code
    working properly. Once you have sound working code, you can locate the slower
    sections, or *bottlenecks*. If you try to optimize your code while writing it,
    you’ll discover that optimized code tends to be more difficult to read and generally
    takes more time to write. If you spend that time on a section of code that isn’t
    actually causing a problem, that’s time wasted, especially down the road when
    you need to maintain that code and you can no longer read it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you get your code working, you may find that it needs some optimization.
    Optimizing code tends to fall within one of two areas: shortening execution times
    and reducing memory requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: Before you begin optimization, ask yourself whether you need to optimize at
    all. Too many programmers have wasted hours wondering whether a complex series
    of string function calls are faster or slower than a single Perl regular expression,
    when the page where this code is located is viewed once every five minutes. Optimization
    is necessary only when a page takes so long to load that the user perceives it
    as slow. Often this is a symptom of a very popular site—if requests for a page
    come in fast enough, the time it takes to generate that page can mean the difference
    between prompt delivery and server overload. With a possible long wait on your
    site, you can bet that your web visitors won’t take long to decide to look elsewhere
    for their information.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve decided that your page needs optimization (this can best be done
    with some end user testing and observation), you can move on to working out exactly
    what is slow. You can use the techniques in the section “Profiling” to time the
    various subroutines or logical units of your page. This will give you an idea
    of which parts of your page are taking the longest time to produce—these parts
    are where you should focus your optimization efforts. If a page is taking 5 seconds
    to produce, you’ll never get it down to 2 seconds by optimizing a function that
    accounts for only 0.25 seconds of the total time. Identify the biggest time-wasting
    blocks of code and focus on them. Time the page and the pieces you’re optimizing
    to make sure your changes are having a positive, and not a negative, effect.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, know when to quit. Sometimes there is an absolute limit for the speed
    at which you can get something to run. In these circumstances, the only way to
    get better performance is to throw new hardware at the problem. The solution might
    turn out to be faster machines or more web servers with a reverse-proxy cache
    in front of them.
  prefs: []
  type: TYPE_NORMAL
- en: Benchmarking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re using Apache, you can use the Apache benchmarking utility, `ab`,
    to do high-level performance testing. To use it, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This command tests the speed of the PHP script *info.php* 1,000 times, with
    10 concurrent requests running at any given time. The benchmarking tool returns
    various information about the test, including the slowest, fastest, and average
    load times. You can compare those values to a static HTML page to see how quickly
    your script performs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, here’s the output from 1,000 fetches of a page that simply calls
    `phpinfo()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If your PHP script uses sessions, the results you get from `ab` will not be
    representative of the real-world performance of the scripts. Since a session is
    locked across a request, results from the concurrent requests run by `ab` will
    be extremely poor. However, in normal usage, a session is typically associated
    with a single user, who isn’t likely to make concurrent requests.
  prefs: []
  type: TYPE_NORMAL
- en: Using `ab` tells you the overall speed of your page but gives you no information
    on the speed of individual functions of blocks of code within the page. Use `ab`
    to test changes you make to your code as you attempt to improve its speed. We
    show you how to time individual portions of a page in the next section, but ultimately
    these microbenchmarks don’t matter if the overall page is still slow to load and
    run. The ultimate proof that your performance optimizations have been successful
    comes from the numbers that `ab` reports.
  prefs: []
  type: TYPE_NORMAL
- en: Profiling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PHP does not have a built-in profiler, but there are some techniques you can
    use to investigate code that you think has performance issues. One technique is
    to call the `microtime()` function to get an accurate representation of the amount
    of time that elapses. You can surround the code you’re profiling with calls to
    `microtime()` and use the values it returns to calculate how long the code took.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, here’s some code you can use to find out just how long it takes
    to produce the `phpinfo()` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Reload this page several times, and you’ll see the number fluctuate slightly.
    Reload it often enough, and you’ll see it fluctuate quite a lot. The danger of
    timing a single run of a piece of code is that you may not get a representative
    machine load—the server might be paging as a user starts *emacs*, or it may have
    removed the source file from its cache. The best way to get an accurate representation
    of the time it takes to do something is to time repeated runs and look at the
    average of those times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Benchmark` class available in PEAR makes it easy to repeatedly time sections
    of your script. Here is a simple example that shows how you can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from this program is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: That is, it took 1.0006979703903 seconds to get to Marker 1, which is set right
    after our `sleep(1)` call, so it is what you would expect. It took just over two
    seconds to get from Marker 1 to the end, and the entire script took just over
    three seconds to run. You can add as many markers as you like and thereby time
    various parts of your script.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing Execution Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some tips for shortening the execution times of your scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid `printf()` when `echo` is all you need.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Avoid recomputing values inside a loop, as PHP’s parser does not remove loop
    invariants. For example, don’t do this if the size of $array doesn’t change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instead, do this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Include only files that you need. Split included files to include only functions
    that you are sure will be used together. Although the code may be a bit more difficult
    to maintain, parsing code you don’t use is expensive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using a database, use persistent database connections—setting up
    and tearing down database connections can be slow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t use a regular expression when a simple string-manipulation function will
    do the job. For example, to turn one character into another in a string, use `str_replace()`,
    not `preg_replace()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing Memory Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some techniques for reducing the memory requirements of your scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use numbers instead of strings whenever possible:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you’re done with a large string, set the variable holding the string to
    an empty string. This frees up the memory to be reused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only include or require files that you need. Use `include_once()` and `require_once()`
    instead of `include()` and `require()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release MySQL or other database result sets as soon as you are done with them.
    There is no benefit to keeping result sets in memory beyond their use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse Proxies and Replication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding hardware is often the quickest route to better performance. It’s better
    to benchmark your software first, though, as it’s generally cheaper to fix software
    than to buy new hardware. Three common solutions to the problem of scaling traffic
    are reverse-proxy caches, load-balancing servers, and database replication.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse-proxy caches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A *reverse proxy* is a program that sits in front of your web server and handles
    all connections from client browsers. Proxies are optimized to serve up static
    files quickly, and despite appearances and implementation, most dynamic sites
    can be cached for short periods of time without loss of service. Normally, you’ll
    run the proxy on a separate machine from your web server.
  prefs: []
  type: TYPE_NORMAL
- en: Take, for example, a busy site whose front page is hit 50 times per second.
    If this first page is built from two database queries and the database changes
    as often as twice a minute, you can avoid 5,994 database queries per minute by
    using a `Cache-Control` header to tell the reverse proxy to cache the page for
    30 seconds. The worst-case scenario is that there will be a 30-second delay from
    database update to a user seeing this new data. For most applications that’s not
    a very long delay, and it gives significant performance benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy caches can even intelligently cache content that is personalized or tailored
    to the browser type, accepted language, or similar feature. The typical solution
    is to send a `Vary` header telling the cache exactly which request parameters
    affect the caching.
  prefs: []
  type: TYPE_NORMAL
- en: There are hardware proxy caches available, but there are also very good software
    implementations. For a high-quality and extremely flexible open source proxy cache,
    have a look at [Squid](http://www.squid-cache.org). See the book [*Web Caching*](http://oreil.ly/Web_Caching)
    (O’Reilly) by Duane Wessels for more information on proxy caches and how to tune
    a website to work with one.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing and redirection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One way to boost performance is to spread the load over a number of machines.
    A *load-balancing system* does this by either evenly distributing the load or
    sending incoming requests to the least-loaded machine. A *redirector* is a program
    that rewrites incoming URLs, allowing fine-grained control over the distribution
    of requests to individual server machines.
  prefs: []
  type: TYPE_NORMAL
- en: Again, there are hardware HTTP redirectors and load balancers, but redirection
    and load balancing can also be done effectively in software. By adding redirection
    logic to Squid through a tool like [SquidGuard](http://www.squidguard.org), you
    can improve performance in a number of ways.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL replication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes the database server is the bottleneck—many simultaneous queries can
    bog down a database server, resulting in sluggish performance. Replication is
    one of the best solutions. Take everything that happens to one database and quickly
    bring one or more other databases in sync, so you end up with multiple identical
    databases. This lets you spread your queries across many database servers instead
    of loading down only one.
  prefs: []
  type: TYPE_NORMAL
- en: The most effective model is to use one-way replication, where you have a single
    master database that gets replicated to a number of slave databases. Database
    writes go to the master server, and database reads are load-balanced across multiple
    slave databases. This technique is aimed at architectures that do a lot more reads
    than writes. Most web applications fit this scenario nicely.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 15-1](#database_replication_relationship) shows the relationship between
    the master and slave databases during replication.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Database replication relationship](Images/php4_1502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-1\. Database replication relationship
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Many databases support replication, including MySQL, PostgreSQL, and Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a really high-powered architecture, pull all these concepts together into
    a configuration like the one shown in [Figure 15-2](#putting_it_all_together).
  prefs: []
  type: TYPE_NORMAL
- en: Using five separate machines—one for the reverse proxy and redirector, three
    web servers, and one master database server—this architecture can handle a huge
    number of requests. The exact number depends only on the two bottlenecks—the single
    Squid proxy and the single master database server. With a bit of creativity, either
    or both of these could be split across multiple servers as well, but as it is,
    if your application is somewhat cacheable and heavy on database reads, this is
    a nice approach.
  prefs: []
  type: TYPE_NORMAL
- en: '![Putting it all together](Images/php4_1503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15-2\. Putting it all together
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each Apache server gets its own read-only MySQL database, so all read requests
    from your PHP scripts go over a Unix-domain local socket to a dedicated MySQL
    instance. You can add as many of these Apache/PHP/MySQL servers as you need under
    this framework. Any database writes from your PHP applications will go over a
    Transmission Control Protocol (TCP) socket to the master MySQL server.
  prefs: []
  type: TYPE_NORMAL
- en: What’s Next
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next chapter, we’ll dive deeper into using PHP to develop and deploy
    web services.
  prefs: []
  type: TYPE_NORMAL
